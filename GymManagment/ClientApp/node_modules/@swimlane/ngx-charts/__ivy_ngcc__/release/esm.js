import { ApplicationRef, ComponentFactoryResolver, Injectable, Injector, Input, Component, ElementRef, ViewEncapsulation, HostListener, ViewChild, HostBinding, Renderer2, Directive, Output, EventEmitter, ViewContainerRef, NgModule, ChangeDetectionStrategy, ChangeDetectorRef, NgZone, TemplateRef, ContentChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { trigger, style, animate, transition } from '@angular/animations';
import { DomSanitizer } from '@angular/platform-browser';
import { rgb } from 'd3-color';
import { fromEvent } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { range, min, max } from 'd3-array';
import { scaleBand, scaleLinear, scaleOrdinal, scaleQuantile, scaleTime, scalePoint } from 'd3-scale';
import { brushX } from 'd3-brush';
import { select, event } from 'd3-selection';
import { curveLinear, area, line, curveCardinalClosed, lineRadial, arc, pie } from 'd3-shape';
import { forceCollide, forceLink, forceManyBody, forceSimulation, forceX, forceY } from 'd3-force';
import { interpolate } from 'd3-interpolate';
import { format } from 'd3-format';
import { treemap, stratify } from 'd3-hierarchy';
import { timeFormat } from 'd3-time-format';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

var _c0 = ["caretElm"];
function TooltipContentComponent_span_4_ng_template_1_Template(rf, ctx) { }
var _c1 = function (a0) { return { model: a0 }; };
function TooltipContentComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, TooltipContentComponent_span_4_ng_template_1_Template, 0, 0, "ng-template", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c1, ctx_r1.context));
} }
function TooltipContentComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 6);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r2.title, ɵngcc0.ɵɵsanitizeHtml);
} }
function ChartComponent_ngx_charts_scale_legend_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelement(0, "ngx-charts-scale-legend", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("horizontal", ctx_r0.legendOptions && ctx_r0.legendOptions.position === "below")("valueRange", ctx_r0.legendOptions.domain)("colors", ctx_r0.legendOptions.colors)("height", ctx_r0.view[1])("width", ctx_r0.legendWidth);
} }
function ChartComponent_ngx_charts_legend_4_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "ngx-charts-legend", 5);
    ɵngcc0.ɵɵlistener("labelClick", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.legendLabelClick.emit($event); })("labelActivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelActivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.legendLabelActivate.emit($event); })("labelDeactivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelDeactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.legendLabelDeactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("horizontal", ctx_r1.legendOptions && ctx_r1.legendOptions.position === "below")("data", ctx_r1.legendOptions.domain)("title", ctx_r1.legendOptions.title)("colors", ctx_r1.legendOptions.colors)("height", ctx_r1.view[1])("width", ctx_r1.legendWidth)("activeEntries", ctx_r1.activeEntries);
} }
var _c2 = ["*"];
function LegendComponent_header_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "header", 4);
    ɵngcc0.ɵɵelementStart(1, "span", 5);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);
} }
function LegendComponent_li_4_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 6);
    ɵngcc0.ɵɵelementStart(1, "ngx-charts-legend-entry", 7);
    ɵngcc0.ɵɵlistener("select", function LegendComponent_li_4_Template_ngx_charts_legend_entry_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.labelClick.emit($event); })("activate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate($event); })("deactivate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var entry_r2 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("label", entry_r2.label)("formattedLabel", entry_r2.formattedLabel)("color", entry_r2.color)("isActive", ctx_r1.isActive(entry_r2));
} }
function AdvancedLegendComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 7);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", ctx_r0.roundedTotal)("valueFormatting", ctx_r0.valueFormatting);
} }
function AdvancedLegendComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.valueFormatting ? ctx_r1.valueFormatting(ctx_r1.roundedTotal) : ctx_r1.defaultValueFormatting(ctx_r1.roundedTotal), " ");
} }
function AdvancedLegendComponent_div_7_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 16);
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", legendItem_r3._value)("valueFormatting", ctx_r4.valueFormatting);
} }
function AdvancedLegendComponent_div_7_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.valueFormatting ? ctx_r5.valueFormatting(legendItem_r3.value) : ctx_r5.defaultValueFormatting(legendItem_r3.value), " ");
} }
function AdvancedLegendComponent_div_7_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 18);
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("countTo", legendItem_r3.percentage)("countSuffix", "%");
} }
function AdvancedLegendComponent_div_7_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 19);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", legendItem_r3.percentage.toLocaleString(), "%");
} }
function AdvancedLegendComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵlistener("mouseenter", function AdvancedLegendComponent_div_7_Template_div_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.activate.emit(legendItem_r3.data); })("mouseleave", function AdvancedLegendComponent_div_7_Template_div_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = ctx.$implicit; var ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.deactivate.emit(legendItem_r3.data); })("click", function AdvancedLegendComponent_div_7_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = ctx.$implicit; var ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.select.emit(legendItem_r3.data); });
    ɵngcc0.ɵɵelement(1, "div", 10);
    ɵngcc0.ɵɵtemplate(2, AdvancedLegendComponent_div_7_div_2_Template, 1, 2, "div", 11);
    ɵngcc0.ɵɵtemplate(3, AdvancedLegendComponent_div_7_div_3_Template, 2, 1, "div", 12);
    ɵngcc0.ɵɵelementStart(4, "div", 13);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, AdvancedLegendComponent_div_7_div_6_Template, 1, 2, "div", 14);
    ɵngcc0.ɵɵtemplate(7, AdvancedLegendComponent_div_7_div_7_Template, 2, 1, "div", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("border-left-color", legendItem_r3.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.animations);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(legendItem_r3.displayLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.animations);
} }
var _c3 = ["ngx-charts-axis-label", ""];
var _c4 = ["ticksel"];
var _c5 = ["ngx-charts-x-axis-ticks", ""];
function XAxisTicksComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 4);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r3 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.tickTransform(tick_r3));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.tickFormat(tick_r3));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("font-size", "12px");
    ɵngcc0.ɵɵattribute("text-anchor", ctx_r1.textAnchor)("transform", ctx_r1.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.tickTrim(ctx_r1.tickFormat(tick_r3)), " ");
} }
function XAxisTicksComponent__svg_g_3__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "line", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("transform", ctx_r5.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("y1", 0 - ctx_r5.gridLineHeight);
} }
function XAxisTicksComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, XAxisTicksComponent__svg_g_3__svg_g_1_Template, 2, 2, "g", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r4 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r2.tickTransform(tick_r4));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.showGridLines);
} }
var _c6 = ["ngx-charts-x-axis", ""];
function XAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function XAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.emitTicksHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r0.trimTicks)("rotateTicks", ctx_r0.rotateTicks)("maxTickLength", ctx_r0.maxTickLength)("tickFormatting", ctx_r0.tickFormatting)("tickArguments", ctx_r0.tickArguments)("tickStroke", ctx_r0.tickStroke)("scale", ctx_r0.xScale)("orient", ctx_r0.xOrient)("showGridLines", ctx_r0.showGridLines)("gridLineHeight", ctx_r0.dims.height)("width", ctx_r0.dims.width)("tickValues", ctx_r0.ticks);
} }
function XAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", "bottom")("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
} }
var _c7 = ["ngx-charts-y-axis-ticks", ""];
function YAxisTicksComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 5);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r5 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.transform(tick_r5));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.tickFormat(tick_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("font-size", "12px");
    ɵngcc0.ɵɵattribute("dy", ctx_r1.dy)("x", ctx_r1.x1)("y", ctx_r1.y1)("text-anchor", ctx_r1.textAnchor);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.tickTrim(ctx_r1.tickFormat(tick_r5)), " ");
} }
function YAxisTicksComponent__svg_path_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "path", 6);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("d", ctx_r2.referenceAreaPath)("transform", ctx_r2.gridLineTransform());
} }
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 9);
} if (rf & 2) {
    var ctx_r8 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵattribute("x2", ctx_r8.gridLineWidth);
} }
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 9);
} if (rf & 2) {
    var ctx_r9 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵattribute("x2", 0 - ctx_r9.gridLineWidth);
} }
function YAxisTicksComponent__svg_g_4__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template, 1, 1, "line", 8);
    ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template, 1, 1, "line", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("transform", ctx_r7.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.orient === "left");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.orient === "right");
} }
function YAxisTicksComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_4__svg_g_1_Template, 3, 3, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r6 = ctx.$implicit;
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r3.transform(tick_r6));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.showGridLines);
} }
function YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 11);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var refLine_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
    var ctx_r12 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r12.tickTrim(ctx_r12.tickFormat(refLine_r10.value)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("dy", ctx_r12.dy)("y", 0 - 6)("x", ctx_r12.gridLineWidth)("text-anchor", ctx_r12.textAnchor);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", refLine_r10.name, " ");
} }
function YAxisTicksComponent__svg_g_5__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "line", 10);
    ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template, 5, 6, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var refLine_r10 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r11 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r11.transform(refLine_r10.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("x2", ctx_r11.gridLineWidth)("transform", ctx_r11.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r11.showRefLabels);
} }
function YAxisTicksComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_5__svg_g_1_Template, 3, 4, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.showRefLines);
} }
var _c8 = ["ngx-charts-y-axis", ""];
function YAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function YAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.emitTicksWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r0.trimTicks)("maxTickLength", ctx_r0.maxTickLength)("tickFormatting", ctx_r0.tickFormatting)("tickArguments", ctx_r0.tickArguments)("tickValues", ctx_r0.ticks)("tickStroke", ctx_r0.tickStroke)("scale", ctx_r0.yScale)("orient", ctx_r0.yOrient)("showGridLines", ctx_r0.showGridLines)("gridLineWidth", ctx_r0.dims.width)("referenceLines", ctx_r0.referenceLines)("showRefLines", ctx_r0.showRefLines)("showRefLabels", ctx_r0.showRefLabels)("height", ctx_r0.dims.height);
} }
function YAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", ctx_r1.yOrient)("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
} }
var _c9 = ["ngx-charts-circle-series", ""];
function CircleSeriesComponent__svg_g_0__svg_rect_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect", 4);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("x", ctx_r1.circle.cx - ctx_r1.circle.radius)("y", ctx_r1.circle.cy)("width", ctx_r1.circle.radius * 2)("height", ctx_r1.circle.height)("fill", ctx_r1.gradientFill);
} }
var _c10 = function (a0) { return { name: a0 }; };
function CircleSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "defs");
    ɵngcc0.ɵɵelement(2, "g", 1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, CircleSeriesComponent__svg_g_0__svg_rect_3_Template, 1, 6, "rect", 2);
    ɵngcc0.ɵɵelementStart(4, "g", 3);
    ɵngcc0.ɵɵlistener("select", function CircleSeriesComponent__svg_g_0_Template__svg_g_select_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(ctx_r2.circle.data); })("activate", function CircleSeriesComponent__svg_g_0_Template__svg_g_activate_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activateCircle(); })("deactivate", function CircleSeriesComponent__svg_g_0_Template__svg_g_deactivate_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivateCircle(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.circle.gradientStops);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.barVisible && ctx_r0.type === "standard");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("active", ctx_r0.isActive(ɵngcc0.ɵɵpureFunction1(18, _c10, ctx_r0.circle.seriesName)));
    ɵngcc0.ɵɵproperty("cx", ctx_r0.circle.cx)("cy", ctx_r0.circle.cy)("r", ctx_r0.circle.radius)("fill", ctx_r0.circle.color)("pointerEvents", ctx_r0.circle.value === 0 ? "none" : "all")("data", ctx_r0.circle.value)("classNames", ctx_r0.circle.classNames)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(ctx_r0.circle))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", ctx_r0.circle.data);
} }
var _c11 = ["ngx-charts-circle", ""];
var _c12 = ["ngx-charts-grid-panel", ""];
var _c13 = ["ngx-charts-grid-panel-series", ""];
function GridPanelSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 1);
} if (rf & 2) {
    var gridPanel_r1 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("grid-panel", true)("odd", gridPanel_r1.class === "odd")("even", gridPanel_r1.class === "even");
    ɵngcc0.ɵɵproperty("height", gridPanel_r1.height)("width", gridPanel_r1.width)("x", gridPanel_r1.x)("y", gridPanel_r1.y);
} }
var _c14 = ["ngx-charts-svg-linear-gradient", ""];
function SvgLinearGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    var stop_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r1.offset + "%");
} }
var _c15 = ["ngx-charts-svg-radial-gradient", ""];
function SvgRadialGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    var stop_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r1.offset + "%");
} }
var _c16 = ["ngx-charts-timeline", ""];
var _c17 = ["ngx-charts-area", ""];
function AreaComponent__svg_defs_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
var _c18 = ["tooltipAnchor"];
var _c19 = ["ngx-charts-tooltip-area", ""];
function TooltipArea__xhtml_ng_template_2__xhtml_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵelement(1, "span", 7);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tooltipItem_r5 = ctx.$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("background-color", tooltipItem_r5.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r4.getToolTipText(tooltipItem_r5), " ");
} }
function TooltipArea__xhtml_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵtemplate(1, TooltipArea__xhtml_ng_template_2__xhtml_div_1_Template, 3, 3, "div", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var model_r3 = ctx.model;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", model_r3);
} }
var _c20 = ["ngx-charts-count-up", ""];
var _c21 = ["tooltipTemplate"];
var _c22 = ["seriesTooltipTemplate"];
function AreaChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("baseValue", ctx_r2.baseValue)("colors", ctx_r2.colors)("data", series_r9)("activeEntries", ctx_r2.activeEntries)("scaleType", ctx_r2.scaleType)("gradient", ctx_r2.gradient)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function AreaChartComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("baseValue", ctx_r19.baseValue)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
var _c23 = function (a0, a1) { return [a0, a1]; };
function AreaChartComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartComponent__svg_g_10__svg_g_1_Template, 2, 9, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
function AreaChartNormalizedComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartNormalizedComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartNormalizedComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("scaleType", ctx_r2.scaleType)("activeEntries", ctx_r2.activeEntries)("gradient", ctx_r2.gradient)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartNormalizedComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartNormalizedComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartNormalizedComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("showPercentage", true)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
function AreaChartNormalizedComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartNormalizedComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
function AreaChartStackedComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartStackedComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartStackedComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartStackedComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartStackedComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("scaleType", ctx_r2.scaleType)("gradient", ctx_r2.gradient)("activeEntries", ctx_r2.activeEntries)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartStackedComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 12);
    ɵngcc0.ɵɵlistener("select", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartStackedComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartStackedComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartStackedComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartStackedComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results)("ngForTrackBy", ctx_r3.trackBy);
} }
function AreaChartStackedComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
function AreaChartStackedComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 13);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartStackedComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartStackedComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
var _c24 = ["ngx-charts-area-series", ""];
var _c25 = ["ngx-charts-bar", ""];
function BarComponent__svg_defs_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("orientation", ctx_r0.orientation)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function BarHorizontalComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontal2DComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.valueScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontal2DComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_4_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.groupScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontal2DComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelWidthChanged", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_dataLabelWidthChanged_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxWidthChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.valueScale)("activeEntries", ctx_r2.activeEntries)("yScale", ctx_r2.innerScale)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("roundEdges", ctx_r2.roundEdges)("animations", ctx_r2.animations)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarHorizontalNormalizedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalNormalizedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarHorizontalNormalizedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, group_r7); })("activate", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event, group_r7); })("deactivate", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event, group_r7); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarHorizontalStackedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalStackedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontalStackedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelWidthChanged", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_dataLabelWidthChanged_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxWidthChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("series", group_r7.series)("activeEntries", ctx_r2.activeEntries)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarVerticalComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVerticalComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVertical2DComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVertical2DComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.groupScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVertical2DComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVertical2DComponent__svg_g_4_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.valueScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVertical2DComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BarVertical2DComponent__svg_g_5_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarVertical2DComponent__svg_g_5_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarVertical2DComponent__svg_g_5_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelHeightChanged", function BarVertical2DComponent__svg_g_5_Template__svg_g_dataLabelHeightChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxHeightChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("activeEntries", ctx_r2.activeEntries)("xScale", ctx_r2.innerScale)("yScale", ctx_r2.valueScale)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("seriesName", group_r7.name)("roundEdges", ctx_r2.roundEdges)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
} }
function BarVerticalNormalizedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarVerticalNormalizedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVerticalNormalizedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, group_r7); })("activate", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event, group_r7); })("deactivate", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event, group_r7); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarVerticalStackedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVerticalStackedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVerticalStackedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelHeightChanged", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_dataLabelHeightChanged_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxHeightChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
var _c26 = ["ngx-charts-series-vertical", ""];
function SeriesVerticalComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function SeriesVerticalComponent__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onClick($event); })("activate", function SeriesVerticalComponent__svg_g_0_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit($event); })("deactivate", function SeriesVerticalComponent__svg_g_0_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var bar_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("@.disabled", !ctx_r0.animations)("width", bar_r2.width)("height", bar_r2.height)("x", bar_r2.x)("y", bar_r2.y)("fill", bar_r2.color)("stops", bar_r2.gradientStops)("data", bar_r2.data)("orientation", "vertical")("roundEdges", bar_r2.roundEdges)("gradient", ctx_r0.gradient)("ariaLabel", bar_r2.ariaLabel)("isActive", ctx_r0.isActive(bar_r2.data))("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", ctx_r0.tooltipPlacement)("tooltipType", ctx_r0.tooltipType)("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : bar_r2.tooltipText)("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", bar_r2.data)("noBarWhenZero", ctx_r0.noBarWhenZero)("animations", ctx_r0.animations);
} }
function SeriesVerticalComponent__svg_g_1__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function SeriesVerticalComponent__svg_g_1__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var i_r9 = ctx.index; var ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.dataLabelHeightChanged.emit({ size: $event, index: i_r9 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var b_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("barX", b_r8.x)("barY", b_r8.y)("barWidth", b_r8.width)("barHeight", b_r8.height)("value", b_r8.total)("valueFormatting", ctx_r7.dataLabelFormatting)("orientation", "vertical");
} }
function SeriesVerticalComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, SeriesVerticalComponent__svg_g_1__svg_g_1_Template, 1, 7, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
} }
var _c27 = ["ngx-charts-series-horizontal", ""];
function SeriesHorizontal__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function SeriesHorizontal__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.click($event); })("activate", function SeriesHorizontal__svg_g_0_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit($event); })("deactivate", function SeriesHorizontal__svg_g_0_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var bar_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("width", bar_r2.width)("height", bar_r2.height)("x", bar_r2.x)("y", bar_r2.y)("fill", bar_r2.color)("stops", bar_r2.gradientStops)("data", bar_r2.data)("orientation", "horizontal")("roundEdges", bar_r2.roundEdges)("gradient", ctx_r0.gradient)("isActive", ctx_r0.isActive(bar_r2.data))("ariaLabel", bar_r2.ariaLabel)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", ctx_r0.tooltipPlacement)("tooltipType", ctx_r0.tooltipType)("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : bar_r2.tooltipText)("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", bar_r2.data)("noBarWhenZero", ctx_r0.noBarWhenZero);
} }
function SeriesHorizontal__svg_g_1__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function SeriesHorizontal__svg_g_1__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var i_r9 = ctx.index; var ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.dataLabelWidthChanged.emit({ size: $event, index: i_r9 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var b_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("barX", b_r8.x)("barY", b_r8.y)("barWidth", b_r8.width)("barHeight", b_r8.height)("value", b_r8.total)("valueFormatting", ctx_r7.dataLabelFormatting)("orientation", "horizontal");
} }
function SeriesHorizontal__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, SeriesHorizontal__svg_g_1__svg_g_1_Template, 1, 7, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
} }
var _c28 = ["ngx-charts-bar-label", ""];
function BubbleChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BubbleChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("showGridLines", ctx_r0.showGridLines)("dims", ctx_r0.dims)("xScale", ctx_r0.xScale)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BubbleChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BubbleChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("showGridLines", ctx_r1.showGridLines)("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BubbleChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BubbleChartComponent__svg_g_9_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var series_r7 = ctx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, series_r7); })("activate", function BubbleChartComponent__svg_g_9_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event); })("deactivate", function BubbleChartComponent__svg_g_9_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("rScale", ctx_r2.rScale)("xScaleType", ctx_r2.xScaleType)("yScaleType", ctx_r2.yScaleType)("xAxisLabel", ctx_r2.xAxisLabel)("yAxisLabel", ctx_r2.yAxisLabel)("colors", ctx_r2.colors)("data", series_r7)("activeEntries", ctx_r2.activeEntries)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate);
} }
var _c29 = ["ngx-charts-bubble-series", ""];
function BubbleSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g");
    ɵngcc0.ɵɵelementStart(2, "g", 1);
    ɵngcc0.ɵɵlistener("select", function BubbleSeriesComponent__svg_g_0_Template__svg_g_select_2_listener() { ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = ctx.$implicit; var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(circle_r1.data); })("activate", function BubbleSeriesComponent__svg_g_0_Template__svg_g_activate_2_listener() { ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = ctx.$implicit; var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activateCircle(circle_r1); })("deactivate", function BubbleSeriesComponent__svg_g_0_Template__svg_g_deactivate_2_listener() { ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = ctx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivateCircle(circle_r1); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var circle_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("transform", circle_r1.transform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("opacity", circle_r1.opacity);
    ɵngcc0.ɵɵclassProp("active", circle_r1.isActive);
    ɵngcc0.ɵɵproperty("@animationState", "active")("cx", 0)("cy", 0)("r", circle_r1.radius)("fill", circle_r1.color)("pointerEvents", "all")("data", circle_r1.value)("classNames", circle_r1.classNames)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(circle_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", circle_r1.data);
} }
var _c30 = ["linkTemplate"];
var _c31 = ["nodeTemplate"];
function ForceDirectedGraphComponent__svg_g_3_1__svg_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
} }
function ForceDirectedGraphComponent__svg_g_3_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵtemplate(0, ForceDirectedGraphComponent__svg_g_3_1__svg_ng_template_0_Template, 0, 0, "ng-template", 8);
} }
function ForceDirectedGraphComponent__svg_g_3__svg_line_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 9);
} if (rf & 2) {
    var link_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵattribute("x1", link_r2.source.x)("y1", link_r2.source.y)("x2", link_r2.target.x)("y2", link_r2.target.y);
} }
function ForceDirectedGraphComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, ForceDirectedGraphComponent__svg_g_3_1_Template, 1, 0, undefined, 6);
    ɵngcc0.ɵɵtemplate(2, ForceDirectedGraphComponent__svg_g_3__svg_line_2_Template, 1, 4, "line", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.linkTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.linkTemplate);
} }
function ForceDirectedGraphComponent__svg_g_5_1__svg_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
} }
function ForceDirectedGraphComponent__svg_g_5_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵtemplate(0, ForceDirectedGraphComponent__svg_g_5_1__svg_ng_template_0_Template, 0, 0, "ng-template", 8);
} }
function ForceDirectedGraphComponent__svg_g_5__svg_circle_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 12);
} }
function ForceDirectedGraphComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mousedown", function ForceDirectedGraphComponent__svg_g_5_Template__svg_g_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); var node_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDragStart(node_r7, $event); })("click", function ForceDirectedGraphComponent__svg_g_5_Template__svg_g_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); var node_r7 = ctx.$implicit; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onClick({ name: node_r7.value }); });
    ɵngcc0.ɵɵtemplate(1, ForceDirectedGraphComponent__svg_g_5_1_Template, 1, 0, undefined, 6);
    ɵngcc0.ɵɵtemplate(2, ForceDirectedGraphComponent__svg_g_5__svg_circle_2_Template, 1, 0, "circle", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var node_r7 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r1.tooltipTemplate ? undefined : node_r7.value)("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", node_r7);
    ɵngcc0.ɵɵattribute("transform", "translate(" + node_r7.x + "," + node_r7.y + ")")("fill", ctx_r1.colors.getColor(ctx_r1.groupResultsBy(node_r7)))("stroke", ctx_r1.colors.getColor(ctx_r1.groupResultsBy(node_r7)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.nodeTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.nodeTemplate);
} }
var _c32 = ["ngx-charts-heat-map-cell", ""];
function HeatMapCellComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
var _c33 = ["ngx-charts-heat-map-cell-series", ""];
var _c34 = function (a0, a1, a2) { return { series: a0, name: a1, value: a2 }; };
function HeatCellSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 1);
    ɵngcc0.ɵɵlistener("select", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_select_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = ctx.$implicit; var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(c_r1.cell); })("activate", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_activate_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = ctx.$implicit; var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activate.emit(c_r1.cell); })("deactivate", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_deactivate_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = ctx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivate.emit(c_r1.cell); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("x", c_r1.x)("y", c_r1.y)("width", c_r1.width)("height", c_r1.height)("fill", c_r1.fill)("data", c_r1.data)("gradient", ctx_r0.gradient)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.tooltipText(c_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", ɵngcc0.ɵɵpureFunction3(14, _c34, c_r1.series, c_r1.label, c_r1.data));
} }
function HeatMapComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function HeatMapComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function HeatMapComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function HeatMapComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function HeatMapComponent__svg_rect_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect");
} if (rf & 2) {
    var rect_r7 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("x", rect_r7.x)("y", rect_r7.y)("rx", rect_r7.rx)("width", rect_r7.width)("height", rect_r7.height)("fill", rect_r7.fill);
} }
var _c35 = ["ngx-charts-line", ""];
function LineChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function LineChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function LineChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function LineChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("referenceLines", ctx_r1.referenceLines)("showRefLines", ctx_r1.showRefLines)("showRefLabels", ctx_r1.showRefLabels);
} }
function LineChartComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("activeEntries", ctx_r2.activeEntries)("scaleType", ctx_r2.scaleType)("curve", ctx_r2.curve)("rangeFillOpacity", ctx_r2.rangeFillOpacity)("hasRange", ctx_r2.hasRange)("animations", ctx_r2.animations);
} }
function LineChartComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event); })("activate", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("activeEntries", ctx_r10.activeEntries)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function LineChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function LineChartComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function LineChartComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, LineChartComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function LineChartComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("curve", ctx_r19.curve)("hasRange", ctx_r19.hasRange)("animations", ctx_r19.animations);
} }
function LineChartComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function LineChartComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, LineChartComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("scaleType", ctx_r4.scaleType)("legend", ctx_r4.legend);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
var _c36 = ["ngx-charts-line-series", ""];
function LineSeriesComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function LineSeriesComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 5);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r1.isActive(ctx_r1.data))("inactive", ctx_r1.isInactive(ctx_r1.data));
    ɵngcc0.ɵɵproperty("data", ctx_r1.data)("path", ctx_r1.outerPath)("fill", ctx_r1.hasGradient ? ctx_r1.gradientUrl : ctx_r1.colors.getColor(ctx_r1.data.name))("opacity", ctx_r1.rangeFillOpacity)("animations", ctx_r1.animations);
} }
function PolarChartComponent__svg_g_4__svg_circle_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 8);
} if (rf & 2) {
    var r_r6 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("r", r_r6);
} }
function PolarChartComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PolarChartComponent__svg_g_4__svg_circle_1_Template, 1, 1, "circle", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.radiusTicks);
} }
function PolarChartComponent__svg_g_5__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 10);
} if (rf & 2) {
    var tick_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("data", tick_r8)("radius", ctx_r7.outerRadius)("label", tick_r8.label)("max", ctx_r7.outerRadius)("value", ctx_r7.showGridLines ? 1 : ctx_r7.outerRadius)("explodeSlices", true)("animations", ctx_r7.animations)("labelTrim", ctx_r7.labelTrim)("labelTrimSize", ctx_r7.labelTrimSize);
} }
function PolarChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PolarChartComponent__svg_g_5__svg_g_1_Template, 1, 9, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.thetaTicks);
} }
function PolarChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 11);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function PolarChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r2.yAxisScale)("dims", ctx_r2.yAxisDims)("showGridLines", ctx_r2.showGridLines)("showLabel", ctx_r2.showYAxisLabel)("labelText", ctx_r2.yAxisLabel)("trimTicks", ctx_r2.trimYAxisTicks)("maxTickLength", ctx_r2.maxYAxisTickLength)("tickFormatting", ctx_r2.yAxisTickFormatting);
    ɵngcc0.ɵɵattribute("transform", ctx_r2.transformYAxis);
} }
function PolarChartComponent__svg_g_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 12);
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r3.xAxisLabel)("offset", ctx_r3.labelOffset)("orient", "bottom")("height", ctx_r3.dims.height)("width", ctx_r3.dims.width);
} }
function PolarChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function PolarChartComponent__svg_g_9_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onClick($event); })("activate", function PolarChartComponent__svg_g_9_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.onActivate($event); })("deactivate", function PolarChartComponent__svg_g_9_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("gradient", ctx_r4.gradient)("xScale", ctx_r4.xScale)("yScale", ctx_r4.yScale)("colors", ctx_r4.colors)("data", series_r11)("activeEntries", ctx_r4.activeEntries)("scaleType", ctx_r4.scaleType)("curve", ctx_r4.curve)("rangeFillOpacity", ctx_r4.rangeFillOpacity)("animations", ctx_r4.animations)("tooltipDisabled", ctx_r4.tooltipDisabled)("tooltipTemplate", ctx_r4.tooltipTemplate);
} }
var _c37 = ["ngx-charts-polar-series", ""];
function PolarSeriesComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("color", ctx_r0.seriesColor)("name", ctx_r0.gradientId)("startOpacity", 0.25)("endOpacity", 1)("stops", ctx_r0.gradientStops);
} }
function PolarSeriesComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("select", function PolarSeriesComponent__svg_g_4_Template__svg_g_select_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = ctx.$implicit; var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.select.emit(circle_r2.data); })("activate", function PolarSeriesComponent__svg_g_4_Template__svg_g_activate_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = ctx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit({ name: circle_r2.data.series }); })("deactivate", function PolarSeriesComponent__svg_g_4_Template__svg_g_deactivate_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = ctx.$implicit; var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit({ name: circle_r2.data.series }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var circle_r2 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("opacity", ctx_r1.inactive ? 0.2 : 1);
    ɵngcc0.ɵɵproperty("cx", circle_r2.cx)("cy", circle_r2.cy)("r", ctx_r1.circleRadius)("fill", circle_r2.color)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", "top")("tooltipTitle", ctx_r1.tooltipTemplate ? undefined : ctx_r1.tooltipText(circle_r2))("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", circle_r2.data);
} }
var _c38 = ["ngx-charts-pie-label", ""];
var _c39 = ["ngx-charts-pie-arc", ""];
function PieArcComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("color", ctx_r0.fill)("name", ctx_r0.radialGradientId)("startOpacity", ctx_r0.startOpacity);
} }
function PieGridComponent__svg_g_2__svg_text_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "text", 10);
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("countTo", series_r1.percent)("countSuffix", "%");
} }
function PieGridComponent__svg_g_2__svg_text_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", series_r1.percent.toLocaleString(), " ");
} }
function PieGridComponent__svg_g_2__svg_text_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "text", 12);
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", series_r1.total)("countPrefix", ctx_r4.label + ": ");
    ɵngcc0.ɵɵattribute("y", series_r1.outerRadius);
} }
function PieGridComponent__svg_g_2__svg_text_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("y", series_r1.outerRadius);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate2(" ", ctx_r5.label, ": ", series_r1.total.toLocaleString(), " ");
} }
var _c40 = function (a0) { return { data: a0 }; };
function PieGridComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵelementStart(1, "g", 4);
    ɵngcc0.ɵɵlistener("select", function PieGridComponent__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onClick($event); })("activate", function PieGridComponent__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onActivate($event); })("deactivate", function PieGridComponent__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, PieGridComponent__svg_g_2__svg_text_2_Template, 1, 2, "text", 5);
    ɵngcc0.ɵɵtemplate(3, PieGridComponent__svg_g_2__svg_text_3_Template, 2, 1, "text", 6);
    ɵngcc0.ɵɵelementStart(4, "text", 7);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, PieGridComponent__svg_g_2__svg_text_6_Template, 1, 3, "text", 8);
    ɵngcc0.ɵɵtemplate(7, PieGridComponent__svg_g_2__svg_text_7_Template, 2, 3, "text", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", series_r1.transform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("colors", series_r1.colors)("data", series_r1.data)("innerRadius", series_r1.innerRadius)("outerRadius", series_r1.outerRadius)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.tooltipText(ɵngcc0.ɵɵpureFunction1(17, _c40, series_r1)))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", series_r1.data[0].data);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.animations);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", series_r1.label, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.animations);
} }
var _c41 = ["ngx-charts-pie-grid-series", ""];
function PieGridSeriesComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function PieGridSeriesComponent__svg_g_1_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick($event); })("activate", function PieGridSeriesComponent__svg_g_1_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activate.emit($event); })("deactivate", function PieGridSeriesComponent__svg_g_1_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("startAngle", arc_r1.startAngle)("endAngle", arc_r1.endAngle)("innerRadius", ctx_r0.innerRadius)("outerRadius", ctx_r0.outerRadius)("fill", ctx_r0.color(arc_r1))("value", arc_r1.data.value)("data", arc_r1.data)("gradient", false)("pointerEvents", arc_r1.pointerEvents)("animate", arc_r1.animate);
    ɵngcc0.ɵɵattribute("class", arc_r1.class);
} }
var _c42 = ["ngx-charts-pie-series", ""];
function PieSeriesComponent__svg_g_0__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var arc_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", arc_r1)("radius", ctx_r2.outerRadius)("color", ctx_r2.color(arc_r1))("label", ctx_r2.labelText(arc_r1))("labelTrim", ctx_r2.trimLabels)("labelTrimSize", ctx_r2.maxLabelLength)("max", ctx_r2.max)("value", arc_r1.value)("explodeSlices", ctx_r2.explodeSlices)("animations", ctx_r2.animations);
} }
function PieSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PieSeriesComponent__svg_g_0__svg_g_1_Template, 1, 10, "g", 1);
    ɵngcc0.ɵɵelementStart(2, "g", 2);
    ɵngcc0.ɵɵlistener("select", function PieSeriesComponent__svg_g_0_Template__svg_g_select_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); })("activate", function PieSeriesComponent__svg_g_0_Template__svg_g_activate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.activate.emit($event); })("deactivate", function PieSeriesComponent__svg_g_0_Template__svg_g_deactivate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.deactivate.emit($event); })("dblclick", function PieSeriesComponent__svg_g_0_Template__svg_g_dblclick_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.dblclick.emit($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.labelVisible(arc_r1));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("startAngle", arc_r1.startAngle)("endAngle", arc_r1.endAngle)("innerRadius", ctx_r0.innerRadius)("outerRadius", ctx_r0.outerRadius)("fill", ctx_r0.color(arc_r1))("value", arc_r1.data.value)("gradient", ctx_r0.gradient)("data", arc_r1.data)("max", ctx_r0.max)("explodeSlices", ctx_r0.explodeSlices)("isActive", ctx_r0.isActive(arc_r1.data))("animate", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.getTooltipTitle(arc_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", arc_r1.data);
} }
var _c43 = ["textEl"];
var _c44 = ["ngx-charts-card", ""];
function CardComponent__svg_path_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "path", 7);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("fill", ctx_r0.bandColor)("transform", ctx_r0.transformBand)("d", ctx_r0.bandPath);
} }
var _c45 = ["ngx-charts-card-series", ""];
function CardSeriesComponent__svg_rect_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect", 2);
} if (rf & 2) {
    var c_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("fill", ctx_r0.emptyColor);
    ɵngcc0.ɵɵattribute("x", c_r2.x)("y", c_r2.y)("width", c_r2.width)("height", c_r2.height);
} }
function CardSeriesComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵlistener("select", function CardSeriesComponent__svg_g_1_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r3 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("x", c_r3.x)("y", c_r3.y)("width", c_r3.width)("height", c_r3.height)("color", c_r3.color)("bandColor", c_r3.bandColor)("textColor", c_r3.textColor)("data", c_r3.data)("label", c_r3.label)("medianSize", ctx_r1.medianSize)("valueFormatting", ctx_r1.valueFormatting)("labelFormatting", ctx_r1.labelFormatting)("animations", ctx_r1.animations);
} }
var _c46 = ["ngx-charts-tree-map-cell", ""];
function TreeMapCellComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function TreeMapCellComponent__svg_foreignObject_3__xhtml_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 8);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("countTo", ctx_r2.value)("valueFormatting", ctx_r2.valueFormatting);
} }
function TreeMapCellComponent__svg_foreignObject_3__xhtml_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.formattedValue, " ");
} }
function TreeMapCellComponent__svg_foreignObject_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "foreignObject", 4);
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(1, "p");
    ɵngcc0.ɵɵelement(2, "span", 5);
    ɵngcc0.ɵɵelement(3, "br");
    ɵngcc0.ɵɵtemplate(4, TreeMapCellComponent__svg_foreignObject_3__xhtml_span_4_Template, 1, 2, "span", 6);
    ɵngcc0.ɵɵtemplate(5, TreeMapCellComponent__svg_foreignObject_3__xhtml_span_5_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("pointer-events", "none");
    ɵngcc0.ɵɵattribute("x", ctx_r1.x)("y", ctx_r1.y)("width", ctx_r1.width)("height", ctx_r1.height);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("color", ctx_r1.getTextColor())("height", ctx_r1.height + "px")("width", ctx_r1.width + "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r1.formattedLabel, ɵngcc0.ɵɵsanitizeHtml);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.animations);
} }
var _c47 = ["ngx-charts-tree-map-cell-series", ""];
function TreeMapCellSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 1);
    ɵngcc0.ɵɵlistener("select", function TreeMapCellSeriesComponent__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", c_r1.data)("x", c_r1.x)("y", c_r1.y)("width", c_r1.width)("height", c_r1.height)("fill", c_r1.fill)("label", c_r1.label)("value", c_r1.value)("valueType", c_r1.valueType)("valueFormatting", ctx_r0.valueFormatting)("labelFormatting", ctx_r0.labelFormatting)("gradient", ctx_r0.gradient)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(c_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", c_r1.data);
} }
var _c48 = ["valueTextEl"];
var _c49 = ["unitsTextEl"];
function LinearGaugeComponent__svg_line_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 10);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r0.transformLine)("stroke", ctx_r0.colors.getColor(ctx_r0.units));
} }
function LinearGaugeComponent__svg_line_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 11);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.transformLine)("stroke", ctx_r1.colors.getColor(ctx_r1.units));
} }
var _c50 = function () { return {}; };
function GaugeComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 5);
    ɵngcc0.ɵɵlistener("select", function GaugeComponent__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); })("activate", function GaugeComponent__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.onActivate($event); })("deactivate", function GaugeComponent__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r3 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r0.rotation);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("backgroundArc", arc_r3.backgroundArc)("valueArc", arc_r3.valueArc)("cornerRadius", ctx_r0.cornerRadius)("colors", ctx_r0.colors)("isActive", ctx_r0.isActive(arc_r3.valueArc.data))("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipTemplate", ctx_r0.tooltipTemplate)("valueFormatting", ctx_r0.valueFormatting)("animations", ctx_r0.animations);
} }
function GaugeComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 6);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("bigSegments", ctx_r1.bigSegments)("smallSegments", ctx_r1.smallSegments)("min", ctx_r1.min)("max", ctx_r1.max)("radius", ctx_r1.outerRadius)("angleSpan", ctx_r1.angleSpan)("valueScale", ctx_r1.valueScale)("startAngle", ctx_r1.startAngle)("tickFormatting", ctx_r1.axisTickFormatting);
} }
function GaugeComponent__svg_text_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 7, 8);
    ɵngcc0.ɵɵelementStart(2, "tspan", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "tspan", 10);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.textTransform);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.displayValue);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.units);
} }
var _c51 = ["ngx-charts-gauge-arc", ""];
var _c52 = ["ngx-charts-gauge-axis", ""];
function GaugeAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r3.line);
} }
function GaugeAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelementStart(1, "text", 3);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r4 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("text-anchor", tick_r4.textAnchor);
    ɵngcc0.ɵɵattribute("transform", tick_r4.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", tick_r4.text, " ");
} }
function GaugeAxisComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r5 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r5.line);
} }
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

// The export is needed here to generate a valid polyfills.metadata.json file
function ngxChartsPolyfills() {
    // IE11 fix
    // Ref: https://github.com/swimlane/ngx-charts/issues/386
    if (typeof (SVGElement) !== 'undefined' && typeof SVGElement.prototype.contains === 'undefined') {
        SVGElement.prototype.contains = HTMLDivElement.prototype.contains;
    }
}
ngxChartsPolyfills();

var PlacementTypes;
(function (PlacementTypes) {
    PlacementTypes[PlacementTypes["top"] = 'top'] = "top";
    PlacementTypes[PlacementTypes["bottom"] = 'bottom'] = "bottom";
    PlacementTypes[PlacementTypes["left"] = 'left'] = "left";
    PlacementTypes[PlacementTypes["right"] = 'right'] = "right";
})(PlacementTypes || (PlacementTypes = {}));

var caretOffset = 7;
function verticalPosition(elDimensions, popoverDimensions, alignment) {
    if (alignment === 'top') {
        return elDimensions.top - caretOffset;
    }
    if (alignment === 'bottom') {
        return elDimensions.top + elDimensions.height - popoverDimensions.height + caretOffset;
    }
    if (alignment === 'center') {
        return elDimensions.top + elDimensions.height / 2 - popoverDimensions.height / 2;
    }
    return undefined;
}
function horizontalPosition(elDimensions, popoverDimensions, alignment) {
    if (alignment === 'left') {
        return elDimensions.left - caretOffset;
    }
    if (alignment === 'right') {
        return elDimensions.left + elDimensions.width - popoverDimensions.width + caretOffset;
    }
    if (alignment === 'center') {
        return elDimensions.left + elDimensions.width / 2 - popoverDimensions.width / 2;
    }
    return undefined;
}
/**
 * Position helper for the popover directive.
 *
 * @export
 * @class PositionHelper
 */
var PositionHelper = /** @class */ (function () {
    function PositionHelper() {
    }
    /**
     * Calculate vertical alignment position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateVerticalAlignment = function (elDimensions, popoverDimensions, alignment) {
        var result = verticalPosition(elDimensions, popoverDimensions, alignment);
        if (result + popoverDimensions.height > window.innerHeight) {
            result = window.innerHeight - popoverDimensions.height;
        }
        return result;
    };
    /**
     * Calculate vertical caret position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} caretDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateVerticalCaret = function (elDimensions, popoverDimensions, caretDimensions, alignment) {
        var result;
        if (alignment === 'top') {
            result = elDimensions.height / 2 - caretDimensions.height / 2 + caretOffset;
        }
        if (alignment === 'bottom') {
            result = popoverDimensions.height - elDimensions.height / 2 - caretDimensions.height / 2 - caretOffset;
        }
        if (alignment === 'center') {
            result = popoverDimensions.height / 2 - caretDimensions.height / 2;
        }
        var popoverPosition = verticalPosition(elDimensions, popoverDimensions, alignment);
        if (popoverPosition + popoverDimensions.height > window.innerHeight) {
            result += (popoverPosition + popoverDimensions.height - window.innerHeight);
        }
        return result;
    };
    /**
     * Calculate horz alignment position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateHorizontalAlignment = function (elDimensions, popoverDimensions, alignment) {
        var result = horizontalPosition(elDimensions, popoverDimensions, alignment);
        if (result + popoverDimensions.width > window.innerWidth) {
            result = window.innerWidth - popoverDimensions.width;
        }
        return result;
    };
    /**
     * Calculate horz caret position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} caretDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateHorizontalCaret = function (elDimensions, popoverDimensions, caretDimensions, alignment) {
        var result;
        if (alignment === 'left') {
            result = elDimensions.width / 2 - caretDimensions.width / 2 + caretOffset;
        }
        if (alignment === 'right') {
            result = popoverDimensions.width - elDimensions.width / 2 - caretDimensions.width / 2 - caretOffset;
        }
        if (alignment === 'center') {
            result = popoverDimensions.width / 2 - caretDimensions.width / 2;
        }
        var popoverPosition = horizontalPosition(elDimensions, popoverDimensions, alignment);
        if (popoverPosition + popoverDimensions.width > window.innerWidth) {
            result += (popoverPosition + popoverDimensions.width - window.innerWidth);
        }
        return result;
    };
    /**
     * Checks if the element's position should be flipped
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} placement
     * @param {any} spacing
     * @returns {boolean}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.shouldFlip = function (elDimensions, popoverDimensions, placement, spacing) {
        var flip = false;
        if (placement === 'right') {
            if (elDimensions.left + elDimensions.width + popoverDimensions.width + spacing > window.innerWidth) {
                flip = true;
            }
        }
        if (placement === 'left') {
            if (elDimensions.left - popoverDimensions.width - spacing < 0) {
                flip = true;
            }
        }
        if (placement === 'top') {
            if (elDimensions.top - popoverDimensions.height - spacing < 0) {
                flip = true;
            }
        }
        if (placement === 'bottom') {
            if (elDimensions.top + elDimensions.height + popoverDimensions.height + spacing > window.innerHeight) {
                flip = true;
            }
        }
        return flip;
    };
    /**
     * Position caret
     *
     * @static
     * @param {any} placement
     * @param {any} elmDim
     * @param {any} hostDim
     * @param {any} caretDimensions
     * @param {any} alignment
     * @returns {*}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.positionCaret = function (placement, elmDim, hostDim, caretDimensions, alignment) {
        var top = 0;
        var left = 0;
        if (placement === PlacementTypes.right) {
            left = -7;
            top = PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.left) {
            left = elmDim.width;
            top = PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.top) {
            top = elmDim.height;
            left = PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.bottom) {
            top = -7;
            left = PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        return { top: top, left: left };
    };
    /**
     * Position content
     *
     * @static
     * @param {any} placement
     * @param {any} elmDim
     * @param {any} hostDim
     * @param {any} spacing
     * @param {any} alignment
     * @returns {*}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.positionContent = function (placement, elmDim, hostDim, spacing, alignment) {
        var top = 0;
        var left = 0;
        if (placement === PlacementTypes.right) {
            left = hostDim.left + hostDim.width + spacing;
            top = PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.left) {
            left = hostDim.left - elmDim.width - spacing;
            top = PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.top) {
            top = hostDim.top - elmDim.height - spacing;
            left = PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.bottom) {
            top = hostDim.top + hostDim.height + spacing;
            left = PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
        }
        return { top: top, left: left };
    };
    /**
     * Determine placement based on flip
     *
     * @static
     * @param {any} placement
     * @param {any} elmDim
     * @param {any} hostDim
     * @param {any} spacing
     * @returns {*}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.determinePlacement = function (placement, elmDim, hostDim, spacing) {
        var shouldFlip = PositionHelper.shouldFlip(hostDim, elmDim, placement, spacing);
        if (shouldFlip) {
            if (placement === PlacementTypes.right) {
                return PlacementTypes.left;
            }
            else if (placement === PlacementTypes.left) {
                return PlacementTypes.right;
            }
            else if (placement === PlacementTypes.top) {
                return PlacementTypes.bottom;
            }
            else if (placement === PlacementTypes.bottom) {
                return PlacementTypes.top;
            }
        }
        return placement;
    };
    return PositionHelper;
}());

var StyleTypes;
(function (StyleTypes) {
    StyleTypes[StyleTypes["popover"] = 'popover'] = "popover";
    StyleTypes[StyleTypes["tooltip"] = 'tooltip'] = "tooltip";
})(StyleTypes || (StyleTypes = {}));

var AlignmentTypes;
(function (AlignmentTypes) {
    AlignmentTypes[AlignmentTypes["left"] = 'left'] = "left";
    AlignmentTypes[AlignmentTypes["center"] = 'center'] = "center";
    AlignmentTypes[AlignmentTypes["right"] = 'right'] = "right";
})(AlignmentTypes || (AlignmentTypes = {}));

var ShowTypes;
(function (ShowTypes) {
    ShowTypes[ShowTypes["all"] = 'all'] = "all";
    ShowTypes[ShowTypes["focus"] = 'focus'] = "focus";
    ShowTypes[ShowTypes["mouseover"] = 'mouseover'] = "mouseover";
})(ShowTypes || (ShowTypes = {}));

/**
 * Injection service is a helper to append components
 * dynamically to a known location in the DOM, most
 * noteably for dialogs/tooltips appending to body.
 *
 * @export
 * @class InjectionService
 */
var InjectionService = /** @class */ (function () {
    function InjectionService(applicationRef, componentFactoryResolver, injector) {
        this.applicationRef = applicationRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
    }
    InjectionService_1 = InjectionService;
    /**
     * Sets a default global root view container. This is useful for
     * things like ngUpgrade that doesn't have a ApplicationRef root.
     *
     * @param container
     */
    InjectionService.setGlobalRootViewContainer = function (container) {
        InjectionService_1.globalRootViewContainer = container;
    };
    /**
     * Gets the root view container to inject the component to.
     *
     * @returns {ComponentRef<any>}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.getRootViewContainer = function () {
        var rootComponents = this.applicationRef.components;
        // fix cannot read length of undefined
        if (rootComponents) {
            if (rootComponents.length)
                return rootComponents[0];
        }
        if (this._container)
            return this._container;
        if (InjectionService_1.globalRootViewContainer)
            return InjectionService_1.globalRootViewContainer;
        throw new Error('View Container not found! ngUpgrade needs to manually set this via setRootViewContainer.');
    };
    /**
     * Overrides the default root view container. This is useful for
     * things like ngUpgrade that doesn't have a ApplicationRef root.
     *
     * @param {any} container
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.setRootViewContainer = function (container) {
        this._container = container;
    };
    /**
     * Gets the html element for a component ref.
     *
     * @param {ComponentRef<any>} componentRef
     * @returns {HTMLElement}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.getComponentRootNode = function (componentRef) {
        // the top most component root node has no `hostView`
        if (!componentRef.hostView)
            return componentRef.element.nativeElement;
        return componentRef.hostView.rootNodes[0];
    };
    /**
     * Gets the root component container html element.
     *
     * @returns {HTMLElement}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.getRootViewContainerNode = function () {
        return this.getComponentRootNode(this.getRootViewContainer());
    };
    /**
     * Projects the bindings onto the component
     *
     * @param {ComponentRef<any>} component
     * @param {*} options
     * @returns {ComponentRef<any>}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.projectComponentBindings = function (component, bindings) {
        if (bindings) {
            if (bindings.inputs !== undefined) {
                var bindingKeys = Object.getOwnPropertyNames(bindings.inputs);
                for (var _i = 0, bindingKeys_1 = bindingKeys; _i < bindingKeys_1.length; _i++) {
                    var bindingName = bindingKeys_1[_i];
                    component.instance[bindingName] = bindings.inputs[bindingName];
                }
            }
            if (bindings.outputs !== undefined) {
                var eventKeys = Object.getOwnPropertyNames(bindings.outputs);
                for (var _a = 0, eventKeys_1 = eventKeys; _a < eventKeys_1.length; _a++) {
                    var eventName = eventKeys_1[_a];
                    component.instance[eventName] = bindings.outputs[eventName];
                }
            }
        }
        return component;
    };
    /**
     * Appends a component to a adjacent location
     *
     * @template T
     * @param {Type<T>} componentClass
     * @param {*} [options={}]
     * @param {Element} [location=this.getRootViewContainerNode()]
     * @returns {ComponentRef<any>}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.appendComponent = function (componentClass, bindings, location) {
        if (bindings === void 0) { bindings = {}; }
        if (location === void 0) { location = this.getRootViewContainerNode(); }
        var componentFactory = this.componentFactoryResolver.resolveComponentFactory(componentClass);
        var componentRef = componentFactory.create(this.injector);
        var appRef = this.applicationRef;
        var componentRootNode = this.getComponentRootNode(componentRef);
        // project the options passed to the component instance
        this.projectComponentBindings(componentRef, bindings);
        appRef.attachView(componentRef.hostView);
        componentRef.onDestroy(function () {
            appRef.detachView(componentRef.hostView);
        });
        // use the renderer to append the element for univseral support
        var renderer = componentRef.instance.renderer;
        renderer.appendChild(location, componentRootNode);
        return componentRef;
    };
    var InjectionService_1, _a, _b, _c;
    InjectionService.globalRootViewContainer = null;
    InjectionService = InjectionService_1 = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ApplicationRef !== "undefined" && ApplicationRef) === "function" ? _a : Object, typeof (_b = typeof ComponentFactoryResolver !== "undefined" && ComponentFactoryResolver) === "function" ? _b : Object, typeof (_c = typeof Injector !== "undefined" && Injector) === "function" ? _c : Object])
    ], InjectionService);
InjectionService.ɵfac = function InjectionService_Factory(t) { return new (t || InjectionService)(ɵngcc0.ɵɵinject(typeof (_a = typeof ApplicationRef !== "undefined" && ApplicationRef) === "function" ? _a : Object), ɵngcc0.ɵɵinject(typeof (_b = typeof ComponentFactoryResolver !== "undefined" && ComponentFactoryResolver) === "function" ? _b : Object), ɵngcc0.ɵɵinject(typeof (_c = typeof Injector !== "undefined" && Injector) === "function" ? _c : Object)); };
InjectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: InjectionService, factory: function (t) { return InjectionService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(InjectionService, [{
        type: Injectable
    }], function () { return [{ type: typeof (_a = typeof ApplicationRef !== "undefined" && ApplicationRef) === "function" ? _a : Object }, { type: typeof (_b = typeof ComponentFactoryResolver !== "undefined" && ComponentFactoryResolver) === "function" ? _b : Object }, { type: typeof (_c = typeof Injector !== "undefined" && Injector) === "function" ? _c : Object }]; }, null); })();
    return InjectionService;
}());

var InjectionRegistery = /** @class */ (function () {
    function InjectionRegistery(injectionService) {
        this.injectionService = injectionService;
        this.defaults = {};
        this.components = new Map();
    }
    InjectionRegistery.prototype.getByType = function (type) {
        if (type === void 0) { type = this.type; }
        return this.components.get(type);
    };
    InjectionRegistery.prototype.create = function (bindings) {
        return this.createByType(this.type, bindings);
    };
    InjectionRegistery.prototype.createByType = function (type, bindings) {
        bindings = this.assignDefaults(bindings);
        var component = this.injectComponent(type, bindings);
        this.register(type, component);
        return component;
    };
    InjectionRegistery.prototype.destroy = function (instance) {
        var compsByType = this.components.get(instance.componentType);
        if (compsByType) {
            var idx = compsByType.indexOf(instance);
            if (idx > -1) {
                var component = compsByType[idx];
                component.destroy();
                compsByType.splice(idx, 1);
            }
        }
    };
    InjectionRegistery.prototype.destroyAll = function () {
        this.destroyByType(this.type);
    };
    InjectionRegistery.prototype.destroyByType = function (type) {
        var comps = this.components.get(type);
        if (comps) {
            for (var _i = 0, comps_1 = comps; _i < comps_1.length; _i++) {
                var comp = comps_1[_i];
                this.destroy(comp);
            }
        }
    };
    InjectionRegistery.prototype.assignDefaults = function (bindings) {
        var _a = this.defaults, inputs = _a.inputs, outputs = _a.outputs;
        if (!bindings.inputs && !bindings.outputs) {
            bindings = { inputs: bindings };
        }
        if (inputs) {
            bindings.inputs = Object.assign(inputs, bindings.inputs);
        }
        if (outputs) {
            bindings.outputs = Object.assign(outputs, bindings.outputs);
        }
        return bindings;
    };
    InjectionRegistery.prototype.injectComponent = function (type, bindings) {
        return this.injectionService.appendComponent(type, bindings);
    };
    InjectionRegistery.prototype.register = function (type, component) {
        if (!this.components.has(type)) {
            this.components.set(type, []);
        }
        var types = this.components.get(type);
        types.push(component);
    };
    return InjectionRegistery;
}());

/**
 * Throttle a function
 *
 * @export
 * @param {*}      func
 * @param {number} wait
 * @param {*}      [options]
 * @returns
 */
function throttle(func, wait, options) {
    options = options || {};
    var context;
    var args;
    var result;
    var timeout = null;
    var previous = 0;
    function later() {
        previous = options.leading === false ? 0 : +new Date();
        timeout = null;
        result = func.apply(context, args);
    }
    return function () {
        var now = +new Date();
        if (!previous && options.leading === false) {
            previous = now;
        }
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0) {
            clearTimeout(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
        }
        else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
}
/**
 * Throttle decorator
 *
 *  class MyClass {
 *    throttleable(10)
 *    myFn() { ... }
 *  }
 *
 * @export
 * @param {number} duration
 * @param {*} [options]
 * @returns
 */
function throttleable(duration, options) {
    return function innerDecorator(target, key, descriptor) {
        return {
            configurable: true,
            enumerable: descriptor.enumerable,
            get: function getter() {
                Object.defineProperty(this, key, {
                    configurable: true,
                    enumerable: descriptor.enumerable,
                    value: throttle(descriptor.value, duration, options)
                });
                return this[key];
            }
        };
    };
}

var TooltipContentComponent = /** @class */ (function () {
    function TooltipContentComponent(element, renderer) {
        this.element = element;
        this.renderer = renderer;
    }
    Object.defineProperty(TooltipContentComponent.prototype, "cssClasses", {
        get: function () {
            var clz = 'ngx-charts-tooltip-content';
            clz += " position-" + this.placement;
            clz += " type-" + this.type;
            clz += " " + this.cssClass;
            return clz;
        },
        enumerable: true,
        configurable: true
    });
    TooltipContentComponent.prototype.ngAfterViewInit = function () {
        setTimeout(this.position.bind(this));
    };
    TooltipContentComponent.prototype.position = function () {
        var _this = this;
        var nativeElm = this.element.nativeElement;
        var hostDim = this.host.nativeElement.getBoundingClientRect();
        if (!hostDim.height && !hostDim.width)
            return;
        var elmDim = nativeElm.getBoundingClientRect();
        this.checkFlip(hostDim, elmDim);
        this.positionContent(nativeElm, hostDim, elmDim);
        if (this.showCaret) {
            this.positionCaret(hostDim, elmDim);
        }
        setTimeout(function () { return _this.renderer.addClass(nativeElm, 'animate'); }, 1);
    };
    TooltipContentComponent.prototype.positionContent = function (nativeElm, hostDim, elmDim) {
        var _a = PositionHelper.positionContent(this.placement, elmDim, hostDim, this.spacing, this.alignment), top = _a.top, left = _a.left;
        this.renderer.setStyle(nativeElm, 'top', top + "px");
        this.renderer.setStyle(nativeElm, 'left', left + "px");
    };
    TooltipContentComponent.prototype.positionCaret = function (hostDim, elmDim) {
        var caretElm = this.caretElm.nativeElement;
        var caretDimensions = caretElm.getBoundingClientRect();
        var _a = PositionHelper.positionCaret(this.placement, elmDim, hostDim, caretDimensions, this.alignment), top = _a.top, left = _a.left;
        this.renderer.setStyle(caretElm, 'top', top + "px");
        this.renderer.setStyle(caretElm, 'left', left + "px");
    };
    TooltipContentComponent.prototype.checkFlip = function (hostDim, elmDim) {
        this.placement = PositionHelper.determinePlacement(this.placement, elmDim, hostDim, this.spacing);
    };
    TooltipContentComponent.prototype.onWindowResize = function () {
        this.position();
    };
    var _a, _b, _c, _d, _e;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "host", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipContentComponent.prototype, "showCaret", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof StyleTypes !== "undefined" && StyleTypes) === "function" ? _a : Object)
    ], TooltipContentComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof PlacementTypes !== "undefined" && PlacementTypes) === "function" ? _b : Object)
    ], TooltipContentComponent.prototype, "placement", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_c = typeof AlignmentTypes !== "undefined" && AlignmentTypes) === "function" ? _c : Object)
    ], TooltipContentComponent.prototype, "alignment", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipContentComponent.prototype, "spacing", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipContentComponent.prototype, "cssClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipContentComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "template", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "context", void 0);
    __decorate([
        ViewChild('caretElm', { static: false }),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "caretElm", void 0);
    __decorate([
        HostBinding('class'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TooltipContentComponent.prototype, "cssClasses", null);
    __decorate([
        HostListener('window:resize'),
        throttleable(100),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipContentComponent.prototype, "onWindowResize", null);
    TooltipContentComponent = __decorate([ __metadata("design:paramtypes", [typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object, typeof (_e = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _e : Object])
    ], TooltipContentComponent);
TooltipContentComponent.ɵfac = function TooltipContentComponent_Factory(t) { return new (t || TooltipContentComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_e = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _e : Object)); };
TooltipContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipContentComponent, selectors: [["ngx-tooltip-content"]], viewQuery: function TooltipContentComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.caretElm = _t.first);
    } }, hostVars: 2, hostBindings: function TooltipContentComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("resize", function TooltipContentComponent_resize_HostBindingHandler() { return ctx.onWindowResize(); }, false, ɵngcc0.ɵɵresolveWindow);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.cssClasses);
    } }, inputs: { placement: "placement", host: "host", showCaret: "showCaret", type: "type", alignment: "alignment", spacing: "spacing", cssClass: "cssClass", title: "title", template: "template", context: "context" }, decls: 6, vars: 6, consts: [[3, "hidden"], ["caretElm", ""], [1, "tooltip-content"], [4, "ngIf"], [3, "innerHTML", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"]], template: function TooltipContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelement(1, "span", 0, 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵtemplate(4, TooltipContentComponent_span_4_Template, 2, 4, "span", 3);
        ɵngcc0.ɵɵtemplate(5, TooltipContentComponent_span_5_Template, 1, 1, "span", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMapInterpolate1("tooltip-caret position-", ctx.placement, "");
        ɵngcc0.ɵɵproperty("hidden", !ctx.showCaret);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:400;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:rgba(0,0,0,.75);font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px 5px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translate3d(0,0,0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}"], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipContentComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-tooltip-content',
                template: "\n    <div>\n      <span #caretElm [hidden]=\"!showCaret\" class=\"tooltip-caret position-{{ this.placement }}\"> </span>\n      <div class=\"tooltip-content\">\n        <span *ngIf=\"!title\">\n          <ng-template [ngTemplateOutlet]=\"template\" [ngTemplateOutletContext]=\"{ model: context }\"> </ng-template>\n        </span>\n        <span *ngIf=\"title\" [innerHTML]=\"title\"> </span>\n      </div>\n    </div>\n  ",
                encapsulation: ViewEncapsulation.None,
                styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:400;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:rgba(0,0,0,.75);font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px 5px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translate3d(0,0,0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}"]
            }]
    }], function () { return [{ type: typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object }, { type: typeof (_e = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _e : Object }]; }, { cssClasses: [{
            type: HostBinding,
            args: ['class']
        }], placement: [{
            type: Input
        }], onWindowResize: [{
            type: HostListener,
            args: ['window:resize']
        }], host: [{
            type: Input
        }], showCaret: [{
            type: Input
        }], type: [{
            type: Input
        }], alignment: [{
            type: Input
        }], spacing: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], title: [{
            type: Input
        }], template: [{
            type: Input
        }], context: [{
            type: Input
        }], caretElm: [{
            type: ViewChild,
            args: ['caretElm', { static: false }]
        }] }); })();
    return TooltipContentComponent;
}());

var TooltipService = /** @class */ (function (_super) {
    __extends(TooltipService, _super);
    function TooltipService(injectionService) {
        var _this = _super.call(this, injectionService) || this;
        _this.injectionService = injectionService;
        _this.type = TooltipContentComponent;
        return _this;
    }
    var _a;
    TooltipService = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof InjectionService !== "undefined" && InjectionService) === "function" ? _a : Object])
    ], TooltipService);
TooltipService.ɵfac = function TooltipService_Factory(t) { return new (t || TooltipService)(ɵngcc0.ɵɵinject(typeof (_a = typeof InjectionService !== "undefined" && InjectionService) === "function" ? _a : Object)); };
TooltipService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TooltipService, factory: function (t) { return TooltipService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipService, [{
        type: Injectable
    }], function () { return [{ type: typeof (_a = typeof InjectionService !== "undefined" && InjectionService) === "function" ? _a : Object }]; }, null); })();
    return TooltipService;
}(InjectionRegistery));

var TooltipDirective = /** @class */ (function () {
    function TooltipDirective(tooltipService, viewContainerRef, renderer) {
        this.tooltipService = tooltipService;
        this.viewContainerRef = viewContainerRef;
        this.renderer = renderer;
        this.tooltipCssClass = '';
        this.tooltipTitle = '';
        this.tooltipAppendToBody = true;
        this.tooltipSpacing = 10;
        this.tooltipDisabled = false;
        this.tooltipShowCaret = true;
        this.tooltipPlacement = PlacementTypes.top;
        this.tooltipAlignment = AlignmentTypes.center;
        this.tooltipType = StyleTypes.popover;
        this.tooltipCloseOnClickOutside = true;
        this.tooltipCloseOnMouseLeave = true;
        this.tooltipHideTimeout = 300;
        this.tooltipShowTimeout = 100;
        this.tooltipShowEvent = ShowTypes.all;
        this.tooltipImmediateExit = false;
        this.show = new EventEmitter();
        this.hide = new EventEmitter();
    }
    Object.defineProperty(TooltipDirective.prototype, "listensForFocus", {
        get: function () {
            return this.tooltipShowEvent === ShowTypes.all ||
                this.tooltipShowEvent === ShowTypes.focus;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "listensForHover", {
        get: function () {
            return this.tooltipShowEvent === ShowTypes.all ||
                this.tooltipShowEvent === ShowTypes.mouseover;
        },
        enumerable: true,
        configurable: true
    });
    TooltipDirective.prototype.ngOnDestroy = function () {
        this.hideTooltip(true);
    };
    TooltipDirective.prototype.onFocus = function () {
        if (this.listensForFocus) {
            this.showTooltip();
        }
    };
    TooltipDirective.prototype.onBlur = function () {
        if (this.listensForFocus) {
            this.hideTooltip(true);
        }
    };
    TooltipDirective.prototype.onMouseEnter = function () {
        if (this.listensForHover) {
            this.showTooltip();
        }
    };
    TooltipDirective.prototype.onMouseLeave = function (target) {
        if (this.listensForHover && this.tooltipCloseOnMouseLeave) {
            clearTimeout(this.timeout);
            if (this.component) {
                var contentDom = this.component.instance.element.nativeElement;
                var contains = contentDom.contains(target);
                if (contains)
                    return;
            }
            this.hideTooltip(this.tooltipImmediateExit);
        }
    };
    TooltipDirective.prototype.onMouseClick = function () {
        if (this.listensForHover) {
            this.hideTooltip(true);
        }
    };
    TooltipDirective.prototype.showTooltip = function (immediate) {
        var _this = this;
        if (this.component || this.tooltipDisabled)
            return;
        var time = immediate ? 0 : this.tooltipShowTimeout;
        clearTimeout(this.timeout);
        this.timeout = setTimeout(function () {
            _this.tooltipService.destroyAll();
            var options = _this.createBoundOptions();
            _this.component = _this.tooltipService.create(options);
            // add a tiny timeout to avoid event re-triggers
            setTimeout(function () {
                if (_this.component) {
                    _this.addHideListeners(_this.component.instance.element.nativeElement);
                }
            }, 10);
            _this.show.emit(true);
        }, time);
    };
    TooltipDirective.prototype.addHideListeners = function (tooltip) {
        var _this = this;
        // on mouse enter, cancel the hide triggered by the leave
        this.mouseEnterContentEvent = this.renderer.listen(tooltip, 'mouseenter', function () {
            clearTimeout(_this.timeout);
        });
        // content mouse leave listener
        if (this.tooltipCloseOnMouseLeave) {
            this.mouseLeaveContentEvent = this.renderer.listen(tooltip, 'mouseleave', function () {
                _this.hideTooltip(_this.tooltipImmediateExit);
            });
        }
        // content close on click outside
        if (this.tooltipCloseOnClickOutside) {
            this.documentClickEvent = this.renderer.listen(document, 'click', function (event$$1) {
                var contains = tooltip.contains(event$$1.target);
                if (!contains)
                    _this.hideTooltip();
            });
        }
    };
    TooltipDirective.prototype.hideTooltip = function (immediate) {
        var _this = this;
        if (immediate === void 0) { immediate = false; }
        if (!this.component)
            return;
        var destroyFn = function () {
            // remove events
            if (_this.mouseLeaveContentEvent)
                _this.mouseLeaveContentEvent();
            if (_this.mouseEnterContentEvent)
                _this.mouseEnterContentEvent();
            if (_this.documentClickEvent)
                _this.documentClickEvent();
            // emit events
            _this.hide.emit(true);
            // destroy component
            _this.tooltipService.destroy(_this.component);
            _this.component = undefined;
        };
        clearTimeout(this.timeout);
        if (!immediate) {
            this.timeout = setTimeout(destroyFn, this.tooltipHideTimeout);
        }
        else {
            destroyFn();
        }
    };
    TooltipDirective.prototype.createBoundOptions = function () {
        return {
            title: this.tooltipTitle,
            template: this.tooltipTemplate,
            host: this.viewContainerRef.element,
            placement: this.tooltipPlacement,
            alignment: this.tooltipAlignment,
            type: this.tooltipType,
            showCaret: this.tooltipShowCaret,
            cssClass: this.tooltipCssClass,
            spacing: this.tooltipSpacing,
            context: this.tooltipContext
        };
    };
    var _a, _b, _c, _d, _e, _f, _g;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipDirective.prototype, "tooltipCssClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipDirective.prototype, "tooltipTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipAppendToBody", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "tooltipSpacing", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipShowCaret", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof PlacementTypes !== "undefined" && PlacementTypes) === "function" ? _a : Object)
    ], TooltipDirective.prototype, "tooltipPlacement", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof AlignmentTypes !== "undefined" && AlignmentTypes) === "function" ? _b : Object)
    ], TooltipDirective.prototype, "tooltipAlignment", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_c = typeof StyleTypes !== "undefined" && StyleTypes) === "function" ? _c : Object)
    ], TooltipDirective.prototype, "tooltipType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipCloseOnClickOutside", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipCloseOnMouseLeave", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "tooltipHideTimeout", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "tooltipShowTimeout", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_d = typeof ShowTypes !== "undefined" && ShowTypes) === "function" ? _d : Object)
    ], TooltipDirective.prototype, "tooltipShowEvent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "tooltipContext", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipImmediateExit", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "show", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "hide", void 0);
    __decorate([
        HostListener('focusin'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onFocus", null);
    __decorate([
        HostListener('blur'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onBlur", null);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave', ['$event.target']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onMouseLeave", null);
    __decorate([
        HostListener('click'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onMouseClick", null);
    TooltipDirective = __decorate([ __metadata("design:paramtypes", [typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object, typeof (_f = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _f : Object, typeof (_g = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _g : Object])
    ], TooltipDirective);
TooltipDirective.ɵfac = function TooltipDirective_Factory(t) { return new (t || TooltipDirective)(ɵngcc0.ɵɵdirectiveInject(typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_f = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _f : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_g = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _g : Object)); };
TooltipDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TooltipDirective, selectors: [["", "ngx-tooltip", ""]], hostBindings: function TooltipDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusin", function TooltipDirective_focusin_HostBindingHandler() { return ctx.onFocus(); })("blur", function TooltipDirective_blur_HostBindingHandler() { return ctx.onBlur(); })("mouseenter", function TooltipDirective_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function TooltipDirective_mouseleave_HostBindingHandler($event) { return ctx.onMouseLeave($event.target); })("click", function TooltipDirective_click_HostBindingHandler() { return ctx.onMouseClick(); });
    } }, inputs: { tooltipCssClass: "tooltipCssClass", tooltipTitle: "tooltipTitle", tooltipAppendToBody: "tooltipAppendToBody", tooltipSpacing: "tooltipSpacing", tooltipDisabled: "tooltipDisabled", tooltipShowCaret: "tooltipShowCaret", tooltipPlacement: "tooltipPlacement", tooltipAlignment: "tooltipAlignment", tooltipType: "tooltipType", tooltipCloseOnClickOutside: "tooltipCloseOnClickOutside", tooltipCloseOnMouseLeave: "tooltipCloseOnMouseLeave", tooltipHideTimeout: "tooltipHideTimeout", tooltipShowTimeout: "tooltipShowTimeout", tooltipShowEvent: "tooltipShowEvent", tooltipImmediateExit: "tooltipImmediateExit", tooltipTemplate: "tooltipTemplate", tooltipContext: "tooltipContext" }, outputs: { show: "show", hide: "hide" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipDirective, [{
        type: Directive,
        args: [{ selector: '[ngx-tooltip]' }]
    }], function () { return [{ type: typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object }, { type: typeof (_f = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _f : Object }, { type: typeof (_g = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _g : Object }]; }, { tooltipCssClass: [{
            type: Input
        }], tooltipTitle: [{
            type: Input
        }], tooltipAppendToBody: [{
            type: Input
        }], tooltipSpacing: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], tooltipShowCaret: [{
            type: Input
        }], tooltipPlacement: [{
            type: Input
        }], tooltipAlignment: [{
            type: Input
        }], tooltipType: [{
            type: Input
        }], tooltipCloseOnClickOutside: [{
            type: Input
        }], tooltipCloseOnMouseLeave: [{
            type: Input
        }], tooltipHideTimeout: [{
            type: Input
        }], tooltipShowTimeout: [{
            type: Input
        }], tooltipShowEvent: [{
            type: Input
        }], tooltipImmediateExit: [{
            type: Input
        }], show: [{
            type: Output
        }], hide: [{
            type: Output
        }], onFocus: [{
            type: HostListener,
            args: ['focusin']
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave', ['$event.target']]
        }], onMouseClick: [{
            type: HostListener,
            args: ['click']
        }], tooltipTemplate: [{
            type: Input
        }], tooltipContext: [{
            type: Input
        }] }); })();
    return TooltipDirective;
}());

var TooltipModule = /** @class */ (function () {
    function TooltipModule() {
    }
TooltipModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TooltipModule });
TooltipModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TooltipModule_Factory(t) { return new (t || TooltipModule)(); }, providers: [InjectionService, TooltipService], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TooltipModule, { declarations: function () { return [TooltipContentComponent,
        TooltipDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TooltipContentComponent,
        TooltipDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipModule, [{
        type: NgModule,
        args: [{
                declarations: [TooltipContentComponent, TooltipDirective],
                providers: [InjectionService, TooltipService],
                exports: [TooltipContentComponent, TooltipDirective],
                imports: [CommonModule],
                entryComponents: [TooltipContentComponent]
            }]
    }], function () { return []; }, null); })();
    return TooltipModule;
}());

var ChartComponent = /** @class */ (function () {
    function ChartComponent(vcr, tooltipService) {
        this.vcr = vcr;
        this.tooltipService = tooltipService;
        this.showLegend = false;
        this.animations = true;
        this.legendLabelClick = new EventEmitter();
        this.legendLabelActivate = new EventEmitter();
        this.legendLabelDeactivate = new EventEmitter();
        this.tooltipService.injectionService.setRootViewContainer(this.vcr);
    }
    ChartComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    ChartComponent.prototype.update = function () {
        var legendColumns = 0;
        if (this.showLegend) {
            this.legendType = this.getLegendType();
            if (!this.legendOptions || this.legendOptions.position === 'right') {
                if (this.legendType === 'scaleLegend') {
                    legendColumns = 1;
                }
                else {
                    legendColumns = 2;
                }
            }
        }
        var chartColumns = 12 - legendColumns;
        this.chartWidth = Math.floor((this.view[0] * chartColumns / 12.0));
        this.legendWidth = (!this.legendOptions || this.legendOptions.position === 'right')
            ? Math.floor((this.view[0] * legendColumns / 12.0))
            : this.chartWidth;
    };
    ChartComponent.prototype.getLegendType = function () {
        if (this.legendOptions.scaleType === 'linear') {
            return 'scaleLegend';
        }
        else {
            return 'legend';
        }
    };
    var _a, _b, _c, _d, _e;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "view", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "showLegend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "legendOptions", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "legendData", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "legendType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ChartComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], ChartComponent.prototype, "legendLabelClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], ChartComponent.prototype, "legendLabelActivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], ChartComponent.prototype, "legendLabelDeactivate", void 0);
    ChartComponent = __decorate([ __metadata("design:paramtypes", [typeof (_d = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _d : Object, typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object])
    ], ChartComponent);
ChartComponent.ɵfac = function ChartComponent_Factory(t) { return new (t || ChartComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _d : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object)); };
ChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChartComponent, selectors: [["ngx-charts-chart"]], inputs: { showLegend: "showLegend", animations: "animations", legendType: "legendType", view: "view", legendOptions: "legendOptions", data: "data", legendData: "legendData", colors: "colors", activeEntries: "activeEntries" }, outputs: { legendLabelClick: "legendLabelClick", legendLabelActivate: "legendLabelActivate", legendLabelDeactivate: "legendLabelDeactivate" }, features: [ɵngcc0.ɵɵProvidersFeature([TooltipService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c2, decls: 5, vars: 8, consts: [[1, "ngx-charts-outer"], [1, "ngx-charts"], ["class", "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width", 4, "ngIf"], ["class", "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate", 4, "ngIf"], [1, "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width"], [1, "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate"]], template: function ChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "svg", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ChartComponent_ngx_charts_scale_legend_3_Template, 1, 5, "ngx-charts-scale-legend", 2);
        ɵngcc0.ɵɵtemplate(4, ChartComponent_ngx_charts_legend_4_Template, 1, 7, "ngx-charts-legend", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.view[0], "px");
        ɵngcc0.ɵɵproperty("@animationState", "active")("@.disabled", !ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.chartWidth)("height", ctx.view[1]);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLegend && ctx.legendType === "scaleLegend");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLegend && ctx.legendType === "legend");
    } }, directives: function () { return [ɵngcc1.NgIf, ScaleLegendComponent,
        LegendComponent]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({ opacity: 0 }),
                    animate('500ms 100ms', style({ opacity: 1 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartComponent, [{
        type: Component,
        args: [{
                providers: [TooltipService],
                selector: 'ngx-charts-chart',
                template: "\n    <div\n      class=\"ngx-charts-outer\"\n      [style.width.px]=\"view[0]\"\n      [@animationState]=\"'active'\"\n      [@.disabled]=\"!animations\">\n      <svg\n        class=\"ngx-charts\"\n        [attr.width]=\"chartWidth\"\n        [attr.height]=\"view[1]\">\n        <ng-content></ng-content>\n      </svg>\n      <ngx-charts-scale-legend\n        *ngIf=\"showLegend && legendType === 'scaleLegend'\"\n        class=\"chart-legend\"\n        [horizontal]=\"legendOptions && legendOptions.position === 'below'\"\n        [valueRange]=\"legendOptions.domain\"\n        [colors]=\"legendOptions.colors\"\n        [height]=\"view[1]\"\n        [width]=\"legendWidth\">\n      </ngx-charts-scale-legend>\n      <ngx-charts-legend\n        *ngIf=\"showLegend && legendType === 'legend'\"\n        class=\"chart-legend\"\n        [horizontal]=\"legendOptions && legendOptions.position === 'below'\"\n        [data]=\"legendOptions.domain\"\n        [title]=\"legendOptions.title\"\n        [colors]=\"legendOptions.colors\"\n        [height]=\"view[1]\"\n        [width]=\"legendWidth\"\n        [activeEntries]=\"activeEntries\"\n        (labelClick)=\"legendLabelClick.emit($event)\"\n        (labelActivate)=\"legendLabelActivate.emit($event)\"\n        (labelDeactivate)=\"legendLabelDeactivate.emit($event)\">\n      </ngx-charts-legend>\n    </div>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({ opacity: 0 }),
                            animate('500ms 100ms', style({ opacity: 1 }))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: typeof (_d = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _d : Object }, { type: typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object }]; }, { showLegend: [{
            type: Input
        }], animations: [{
            type: Input
        }], legendLabelClick: [{
            type: Output
        }], legendLabelActivate: [{
            type: Output
        }], legendLabelDeactivate: [{
            type: Output
        }], legendType: [{
            type: Input
        }], view: [{
            type: Input
        }], legendOptions: [{
            type: Input
        }], data: [{
            type: Input
        }], legendData: [{
            type: Input
        }], colors: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }] }); })();
    return ChartComponent;
}());

/**
 * Formats a label given a date, number or string.
 *
 * @export
 * @param {*} label
 * @returns {string}
 */
function formatLabel(label) {
    if (label instanceof Date) {
        label = label.toLocaleDateString();
    }
    else {
        label = label.toLocaleString();
    }
    return label;
}

var LegendComponent = /** @class */ (function () {
    function LegendComponent(cd) {
        this.cd = cd;
        this.horizontal = false;
        this.labelClick = new EventEmitter();
        this.labelActivate = new EventEmitter();
        this.labelDeactivate = new EventEmitter();
        this.legendEntries = [];
    }
    LegendComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    LegendComponent.prototype.update = function () {
        this.cd.markForCheck();
        this.legendEntries = this.getLegendEntries();
    };
    LegendComponent.prototype.getLegendEntries = function () {
        var items = [];
        var _loop_1 = function (label) {
            var formattedLabel = formatLabel(label);
            var idx = items.findIndex(function (i) {
                return i.label === formattedLabel;
            });
            if (idx === -1) {
                items.push({
                    label: label,
                    formattedLabel: formattedLabel,
                    color: this_1.colors.getColor(label)
                });
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
            var label = _a[_i];
            _loop_1(label);
        }
        return items;
    };
    LegendComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.label === d.name;
        });
        return item !== undefined;
    };
    LegendComponent.prototype.activate = function (item) {
        this.labelActivate.emit(item);
    };
    LegendComponent.prototype.deactivate = function (item) {
        this.labelDeactivate.emit(item);
    };
    LegendComponent.prototype.trackBy = function (index, item) {
        return item.label;
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "horizontal", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], LegendComponent.prototype, "labelClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], LegendComponent.prototype, "labelActivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], LegendComponent.prototype, "labelDeactivate", void 0);
    LegendComponent = __decorate([ __metadata("design:paramtypes", [typeof (_d = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _d : Object])
    ], LegendComponent);
LegendComponent.ɵfac = function LegendComponent_Factory(t) { return new (t || LegendComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _d : Object)); };
LegendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LegendComponent, selectors: [["ngx-charts-legend"]], inputs: { horizontal: "horizontal", data: "data", title: "title", colors: "colors", height: "height", width: "width", activeEntries: "activeEntries" }, outputs: { labelClick: "labelClick", labelActivate: "labelActivate", labelDeactivate: "labelDeactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 9, consts: [["class", "legend-title", 4, "ngIf"], [1, "legend-wrap"], [1, "legend-labels"], ["class", "legend-label", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "legend-title"], [1, "legend-title-text"], [1, "legend-label"], [3, "label", "formattedLabel", "color", "isActive", "select", "activate", "deactivate"]], template: function LegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵtemplate(1, LegendComponent_header_1_Template, 3, 1, "header", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "ul", 2);
        ɵngcc0.ɵɵtemplate(4, LegendComponent_li_4_Template, 2, 4, "li", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", (ctx.title == null ? null : ctx.title.length) > 0);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.height - 45, "px");
        ɵngcc0.ɵɵclassProp("horizontal-legend", ctx.horizontal);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.legendEntries)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc1.NgForOf, LegendEntryComponent]; }, styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:700}.chart-legend li,.chart-legend ul{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:rgba(0,0,0,.05)}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LegendComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-legend',
                template: "\n    <div [style.width.px]=\"width\">\n      <header class=\"legend-title\" *ngIf=\"title?.length > 0\">\n        <span class=\"legend-title-text\">{{title}}</span>\n      </header>\n      <div class=\"legend-wrap\">\n        <ul class=\"legend-labels\"\n            [class.horizontal-legend]=\"horizontal\"\n          [style.max-height.px]=\"height - 45\">\n          <li\n            *ngFor=\"let entry of legendEntries; trackBy: trackBy\"\n            class=\"legend-label\">\n            <ngx-charts-legend-entry\n              [label]=\"entry.label\"\n              [formattedLabel]=\"entry.formattedLabel\"\n              [color]=\"entry.color\"\n              [isActive]=\"isActive(entry)\"\n              (select)=\"labelClick.emit($event)\"\n              (activate)=\"activate($event)\"\n              (deactivate)=\"deactivate($event)\">\n            </ngx-charts-legend-entry>\n          </li>\n        </ul>\n      </div>\n    </div>\n  ",
                styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:700}.chart-legend li,.chart-legend ul{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:rgba(0,0,0,.05)}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_d = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _d : Object }]; }, { horizontal: [{
            type: Input
        }], labelClick: [{
            type: Output
        }], labelActivate: [{
            type: Output
        }], labelDeactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], title: [{
            type: Input
        }], colors: [{
            type: Input
        }], height: [{
            type: Input
        }], width: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }] }); })();
    return LegendComponent;
}());

var ScaleLegendComponent = /** @class */ (function () {
    function ScaleLegendComponent(sanitizer) {
        this.sanitizer = sanitizer;
        this.horizontal = false;
    }
    ScaleLegendComponent.prototype.ngOnChanges = function (changes) {
        var gradientValues = this.gradientString(this.colors.range(), this.colors.domain());
        var direction = (this.horizontal) ? 'right' : 'bottom';
        this.gradient = this.sanitizer.bypassSecurityTrustStyle("linear-gradient(to " + direction + ", " + gradientValues + ")");
    };
    ScaleLegendComponent.prototype.gradientString = function (colors, splits) {
        splits.push(1);
        var pairs = [];
        colors.reverse().forEach(function (c, i) {
            pairs.push(c + " " + Math.round(splits[i] * 100) + "%");
        });
        return pairs.join(', ');
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "valueRange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "horizontal", void 0);
    ScaleLegendComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof DomSanitizer !== "undefined" && DomSanitizer) === "function" ? _a : Object])
    ], ScaleLegendComponent);
ScaleLegendComponent.ɵfac = function ScaleLegendComponent_Factory(t) { return new (t || ScaleLegendComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof DomSanitizer !== "undefined" && DomSanitizer) === "function" ? _a : Object)); };
ScaleLegendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ScaleLegendComponent, selectors: [["ngx-charts-scale-legend"]], inputs: { horizontal: "horizontal", valueRange: "valueRange", colors: "colors", height: "height", width: "width" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 10, consts: [[1, "scale-legend"], [1, "scale-legend-label"], [1, "scale-legend-wrap"]], template: function ScaleLegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "span");
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "div", 2);
        ɵngcc0.ɵɵelementStart(5, "div", 1);
        ɵngcc0.ɵɵelementStart(6, "span");
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("height", ctx.horizontal ? undefined : ctx.height, "px")("width", ctx.width, "px");
        ɵngcc0.ɵɵclassProp("horizontal-legend", ctx.horizontal);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.valueRange[1].toLocaleString());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("background", ctx.gradient, ɵngcc0.ɵɵdefaultStyleSanitizer);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.valueRange[0].toLocaleString());
    } }, styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{text-align:center;display:flex;flex-direction:column}.chart-legend .scale-legend-wrap{display:inline-block;flex:1;width:30px;border-radius:5px;margin:0 auto}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{width:auto;height:30px;margin:0 16px}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ScaleLegendComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-scale-legend',
                template: "\n    <div\n      class=\"scale-legend\"\n      [class.horizontal-legend]=\"horizontal\"\n      [style.height.px]=\"horizontal ? undefined : height\"\n      [style.width.px]=\"width\">\n      <div class=\"scale-legend-label\">\n        <span>{{ valueRange[1].toLocaleString() }}</span>\n      </div>\n      <div\n        class=\"scale-legend-wrap\"\n        [style.background]=\"gradient\">\n      </div>\n      <div class=\"scale-legend-label\">\n        <span>{{ valueRange[0].toLocaleString() }}</span>\n      </div>\n    </div>\n  ",
                styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{text-align:center;display:flex;flex-direction:column}.chart-legend .scale-legend-wrap{display:inline-block;flex:1;width:30px;border-radius:5px;margin:0 auto}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{width:auto;height:30px;margin:0 16px}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof DomSanitizer !== "undefined" && DomSanitizer) === "function" ? _a : Object }]; }, { horizontal: [{
            type: Input
        }], valueRange: [{
            type: Input
        }], colors: [{
            type: Input
        }], height: [{
            type: Input
        }], width: [{
            type: Input
        }] }); })();
    return ScaleLegendComponent;
}());

var LegendEntryComponent = /** @class */ (function () {
    function LegendEntryComponent() {
        this.isActive = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.toggle = new EventEmitter();
    }
    Object.defineProperty(LegendEntryComponent.prototype, "trimmedLabel", {
        get: function () {
            return this.formattedLabel || '(empty)';
        },
        enumerable: true,
        configurable: true
    });
    LegendEntryComponent.prototype.onMouseEnter = function () {
        this.activate.emit({ name: this.label });
    };
    LegendEntryComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit({ name: this.label });
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LegendEntryComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendEntryComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LegendEntryComponent.prototype, "formattedLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LegendEntryComponent.prototype, "isActive", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], LegendEntryComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], LegendEntryComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], LegendEntryComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_d = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _d : Object)
    ], LegendEntryComponent.prototype, "toggle", void 0);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], LegendEntryComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], LegendEntryComponent.prototype, "onMouseLeave", null);
LegendEntryComponent.ɵfac = function LegendEntryComponent_Factory(t) { return new (t || LegendEntryComponent)(); };
LegendEntryComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LegendEntryComponent, selectors: [["ngx-charts-legend-entry"]], hostBindings: function LegendEntryComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function LegendEntryComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function LegendEntryComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { isActive: "isActive", color: "color", label: "label", formattedLabel: "formattedLabel" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", toggle: "toggle" }, decls: 4, vars: 6, consts: [["tabindex", "-1", 3, "title", "click"], [1, "legend-label-color", 3, "click"], [1, "legend-label-text"]], template: function LegendEntryComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵlistener("click", function LegendEntryComponent_Template_span_click_0_listener() { return ctx.select.emit(ctx.formattedLabel); });
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵlistener("click", function LegendEntryComponent_Template_span_click_1_listener() { return ctx.toggle.emit(ctx.formattedLabel); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isActive);
        ɵngcc0.ɵɵproperty("title", ctx.formattedLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("background-color", ctx.color);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.trimmedLabel, " ");
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LegendEntryComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-legend-entry',
                template: "\n    <span \n      [title]=\"formattedLabel\"\n      tabindex=\"-1\"\n      [class.active]=\"isActive\"\n      (click)=\"select.emit(formattedLabel)\">\n      <span\n        class=\"legend-label-color\"\n        [style.background-color]=\"color\"\n        (click)=\"toggle.emit(formattedLabel)\">\n      </span>\n      <span class=\"legend-label-text\">\n        {{trimmedLabel}}\n      </span>\n    </span>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { isActive: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], toggle: [{
            type: Output
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], color: [{
            type: Input
        }], label: [{
            type: Input
        }], formattedLabel: [{
            type: Input
        }] }); })();
    return LegendEntryComponent;
}());

function trimLabel(s, max$$1) {
    if (max$$1 === void 0) { max$$1 = 16; }
    if (typeof s !== 'string') {
        if (typeof s === 'number') {
            return s + '';
        }
        else {
            return '';
        }
    }
    s = s.trim();
    if (s.length <= max$$1) {
        return s;
    }
    else {
        return s.slice(0, max$$1) + "...";
    }
}

var AdvancedLegendComponent = /** @class */ (function () {
    function AdvancedLegendComponent() {
        this.label = 'Total';
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.legendItems = [];
        this.labelFormatting = function (label) { return label; };
        this.percentageFormatting = function (percentage) { return percentage; };
        this.defaultValueFormatting = function (value) { return value.toLocaleString(); };
    }
    AdvancedLegendComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    AdvancedLegendComponent.prototype.getTotal = function () {
        return this.data.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
    };
    AdvancedLegendComponent.prototype.update = function () {
        this.total = this.getTotal();
        this.roundedTotal = this.total;
        this.legendItems = this.getLegendItems();
    };
    AdvancedLegendComponent.prototype.getLegendItems = function () {
        var _this = this;
        return this.data.map(function (d) {
            var label = formatLabel(d.name);
            var value = d.value;
            var color = _this.colors.getColor(label);
            var percentage = _this.total > 0 ? (value / _this.total) * 100 : 0;
            var formattedLabel = typeof _this.labelFormatting === 'function' ? _this.labelFormatting(label) : label;
            return {
                _value: value,
                data: d,
                value: value,
                color: color,
                label: formattedLabel,
                displayLabel: trimLabel(formattedLabel, 20),
                origialLabel: d.name,
                percentage: _this.percentageFormatting ? _this.percentageFormatting(percentage) : percentage.toLocaleString()
            };
        });
    };
    AdvancedLegendComponent.prototype.trackBy = function (item) {
        return item.formattedLabel;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AdvancedLegendComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AdvancedLegendComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AdvancedLegendComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AdvancedLegendComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AdvancedLegendComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AdvancedLegendComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AdvancedLegendComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], AdvancedLegendComponent.prototype, "deactivate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedLegendComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedLegendComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedLegendComponent.prototype, "percentageFormatting", void 0);
AdvancedLegendComponent.ɵfac = function AdvancedLegendComponent_Factory(t) { return new (t || AdvancedLegendComponent)(); };
AdvancedLegendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AdvancedLegendComponent, selectors: [["ngx-charts-advanced-legend"]], inputs: { label: "label", animations: "animations", labelFormatting: "labelFormatting", percentageFormatting: "percentageFormatting", width: "width", data: "data", colors: "colors", valueFormatting: "valueFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 7, consts: [[1, "advanced-pie-legend"], ["class", "total-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "total-value", 4, "ngIf"], [1, "total-label"], [1, "legend-items-container"], [1, "legend-items"], ["tabindex", "-1", "class", "legend-item", 3, "mouseenter", "mouseleave", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-count-up", "", 1, "total-value", 3, "countTo", "valueFormatting"], [1, "total-value"], ["tabindex", "-1", 1, "legend-item", 3, "mouseenter", "mouseleave", "click"], [1, "item-color"], ["class", "item-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "item-value", 4, "ngIf"], [1, "item-label"], ["class", "item-percent", "ngx-charts-count-up", "", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "item-percent", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "item-value", 3, "countTo", "valueFormatting"], [1, "item-value"], ["ngx-charts-count-up", "", 1, "item-percent", 3, "countTo", "countSuffix"], [1, "item-percent"]], template: function AdvancedLegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, AdvancedLegendComponent_div_1_Template, 1, 2, "div", 1);
        ɵngcc0.ɵɵtemplate(2, AdvancedLegendComponent_div_2_Template, 2, 1, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵtemplate(7, AdvancedLegendComponent_div_7_Template, 8, 7, "div", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.label, " ");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.legendItems)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc1.NgForOf, CountUpDirective]; }, styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translate(0,-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{white-space:nowrap;overflow:auto}.advanced-pie-legend .legend-items-container .legend-items .legend-item{margin-right:20px;display:inline-block;cursor:pointer}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:0}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-top:-6px;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;opacity:.7;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;opacity:.7;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;width:4px;height:42px;float:left;margin-right:7px}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AdvancedLegendComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-advanced-legend',
                template: "\n    <div class=\"advanced-pie-legend\" [style.width.px]=\"width\">\n      <div\n        *ngIf=\"animations\"\n        class=\"total-value\"\n        ngx-charts-count-up\n        [countTo]=\"roundedTotal\"\n        [valueFormatting]=\"valueFormatting\"\n      ></div>\n      <div class=\"total-value\" *ngIf=\"!animations\">\n        {{ valueFormatting ? valueFormatting(roundedTotal) : defaultValueFormatting(roundedTotal) }}\n      </div>\n      <div class=\"total-label\">\n        {{ label }}\n      </div>\n      <div class=\"legend-items-container\">\n        <div class=\"legend-items\">\n          <div\n            *ngFor=\"let legendItem of legendItems; trackBy: trackBy\"\n            tabindex=\"-1\"\n            class=\"legend-item\"\n            (mouseenter)=\"activate.emit(legendItem.data)\"\n            (mouseleave)=\"deactivate.emit(legendItem.data)\"\n            (click)=\"select.emit(legendItem.data)\"\n          >\n            <div class=\"item-color\" [style.border-left-color]=\"legendItem.color\"></div>\n            <div\n              *ngIf=\"animations\"\n              class=\"item-value\"\n              ngx-charts-count-up\n              [countTo]=\"legendItem._value\"\n              [valueFormatting]=\"valueFormatting\"\n            ></div>\n            <div *ngIf=\"!animations\" class=\"item-value\">\n              {{ valueFormatting ? valueFormatting(legendItem.value) : defaultValueFormatting(legendItem.value) }}\n            </div>\n            <div class=\"item-label\">{{ legendItem.displayLabel }}</div>\n            <div\n              *ngIf=\"animations\"\n              class=\"item-percent\"\n              ngx-charts-count-up\n              [countTo]=\"legendItem.percentage\"\n              [countSuffix]=\"'%'\"\n            ></div>\n            <div *ngIf=\"!animations\" class=\"item-percent\">{{ legendItem.percentage.toLocaleString() }}%</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  ",
                styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translate(0,-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{white-space:nowrap;overflow:auto}.advanced-pie-legend .legend-items-container .legend-items .legend-item{margin-right:20px;display:inline-block;cursor:pointer}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:0}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-top:-6px;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;opacity:.7;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;opacity:.7;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;width:4px;height:42px;float:left;margin-right:7px}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { label: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], labelFormatting: [{
            type: Input
        }], percentageFormatting: [{
            type: Input
        }], width: [{
            type: Input
        }], data: [{
            type: Input
        }], colors: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }] }); })();
    return AdvancedLegendComponent;
}());

var cache = {};
/**
 * Generates a short id.
 *
 * Description:
 *   A 4-character alphanumeric sequence (364 = 1.6 million)
 *   This should only be used for JavaScript specific models.
 *   http://stackoverflow.com/questions/6248666/how-to-generate-short-uid-like-ax4j9z-in-js
 *
 *   Example: `ebgf`
 */
function id() {
    var newId = ('0000' + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
    // append a 'a' because neo gets mad
    newId = "a" + newId;
    // ensure not already used
    if (!cache[newId]) {
        cache[newId] = true;
        return newId;
    }
    return id();
}

var colorSets = [
    {
        name: 'vivid',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#647c8a', '#3f51b5', '#2196f3', '#00b862', '#afdf0a', '#a7b61a', '#f3e562', '#ff9800', '#ff5722', '#ff4514'
        ]
    },
    {
        name: 'natural',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#bf9d76', '#e99450', '#d89f59', '#f2dfa7', '#a5d7c6', '#7794b1', '#afafaf', '#707160', '#ba9383', '#d9d5c3'
        ]
    },
    {
        name: 'cool',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#a8385d', '#7aa3e5', '#a27ea8', '#aae3f5', '#adcded', '#a95963', '#8796c0', '#7ed3ed', '#50abcc', '#ad6886'
        ]
    },
    {
        name: 'fire',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#ff3d00', '#bf360c', '#ff8f00', '#ff6f00', '#ff5722', '#e65100', '#ffca28', '#ffab00'
        ]
    },
    {
        name: 'solar',
        selectable: true,
        group: 'Continuous',
        domain: [
            '#fff8e1', '#ffecb3', '#ffe082', '#ffd54f', '#ffca28', '#ffc107', '#ffb300', '#ffa000', '#ff8f00', '#ff6f00'
        ]
    },
    {
        name: 'air',
        selectable: true,
        group: 'Continuous',
        domain: [
            '#e1f5fe', '#b3e5fc', '#81d4fa', '#4fc3f7', '#29b6f6', '#03a9f4', '#039be5', '#0288d1', '#0277bd', '#01579b'
        ]
    },
    {
        name: 'aqua',
        selectable: true,
        group: 'Continuous',
        domain: [
            '#e0f7fa', '#b2ebf2', '#80deea', '#4dd0e1', '#26c6da', '#00bcd4', '#00acc1', '#0097a7', '#00838f', '#006064'
        ]
    },
    {
        name: 'flame',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#A10A28', '#D3342D', '#EF6D49', '#FAAD67', '#FDDE90', '#DBED91', '#A9D770', '#6CBA67', '#2C9653', '#146738'
        ]
    },
    {
        name: 'ocean',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#1D68FB', '#33C0FC', '#4AFFFE', '#AFFFFF', '#FFFC63', '#FDBD2D', '#FC8A25', '#FA4F1E', '#FA141B', '#BA38D1'
        ]
    },
    {
        name: 'forest',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#55C22D', '#C1F33D', '#3CC099', '#AFFFFF', '#8CFC9D', '#76CFFA', '#BA60FB', '#EE6490', '#C42A1C', '#FC9F32'
        ]
    },
    {
        name: 'horizon',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#2597FB', '#65EBFD', '#99FDD0', '#FCEE4B', '#FEFCFA', '#FDD6E3', '#FCB1A8', '#EF6F7B', '#CB96E8', '#EFDEE0'
        ]
    },
    {
        name: 'neons',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#FF3333', '#FF33FF', '#CC33FF', '#0000FF', '#33CCFF', '#33FFFF', '#33FF66', '#CCFF33', '#FFCC00', '#FF6600'
        ]
    },
    {
        name: 'picnic',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#FAC51D', '#66BD6D', '#FAA026', '#29BB9C', '#E96B56', '#55ACD2', '#B7332F', '#2C83C9', '#9166B8', '#92E7E8'
        ]
    },
    {
        name: 'night',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#2B1B5A', '#501356', '#183356', '#28203F', '#391B3C', '#1E2B3C', '#120634',
            '#2D0432', '#051932', '#453080', '#75267D', '#2C507D', '#4B3880', '#752F7D', '#35547D'
        ]
    },
    {
        name: 'nightLights',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#4e31a5', '#9c25a7', '#3065ab', '#57468b', '#904497', '#46648b',
            '#32118d', '#a00fb3', '#1052a2', '#6e51bd', '#b63cc3', '#6c97cb', '#8671c1', '#b455be', '#7496c3'
        ]
    }
];

function sortLinear(data, property, direction) {
    if (direction === void 0) { direction = 'asc'; }
    return data.sort(function (a, b) {
        if (direction === 'asc') {
            return a[property] - b[property];
        }
        else {
            return b[property] - a[property];
        }
    });
}
function sortByDomain(data, property, direction, domain) {
    if (direction === void 0) { direction = 'asc'; }
    return data.sort(function (a, b) {
        var aVal = a[property];
        var bVal = b[property];
        var aIdx = domain.indexOf(aVal);
        var bIdx = domain.indexOf(bVal);
        if (direction === 'asc') {
            return aIdx - bIdx;
        }
        else {
            return bIdx - aIdx;
        }
    });
}
function sortByTime(data, property, direction) {
    if (direction === void 0) { direction = 'asc'; }
    return data.sort(function (a, b) {
        var aDate = a[property].getTime();
        var bDate = b[property].getTime();
        if (direction === 'asc') {
            if (aDate > bDate)
                return 1;
            if (bDate > aDate)
                return -1;
            return 0;
        }
        else {
            if (aDate > bDate)
                return -1;
            if (bDate > aDate)
                return 1;
            return 0;
        }
    });
}

/**
 * Accepts a color (string) and returns a inverted hex color (string)
 * http://stackoverflow.com/questions/9600295/automatically-change-text-color-to-assure-readability
 *
 * @export
 * @param {any} value
 * @returns {string}
 */
function invertColor(value) {
    var color = rgb(value);
    var r = color.r, g = color.g, b = color.b, opacity = color.opacity;
    if (opacity === 0) {
        return color.toString();
    }
    var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    var depth = (yiq >= 128) ? -.8 : .8;
    return shadeRGBColor(color, depth);
}
/**
 * Given a rgb, it will darken/lighten
 * http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
 *
 * @export
 * @param {any} { r, g, b }
 * @param {any} percent
 * @returns
 */
function shadeRGBColor(_a, percent) {
    var r = _a.r, g = _a.g, b = _a.b;
    var t = percent < 0 ? 0 : 255;
    var p = percent < 0 ? percent * -1 : percent;
    r = (Math.round((t - r) * p) + r);
    g = (Math.round((t - g) * p) + g);
    b = (Math.round((t - b) * p) + b);
    return "rgb(" + r + ", " + g + ", " + b + ")";
}

/**
 * Visibility Observer
 */
var VisibilityObserver = /** @class */ (function () {
    function VisibilityObserver(element, zone) {
        this.element = element;
        this.zone = zone;
        this.visible = new EventEmitter();
        this.isVisible = false;
        this.runCheck();
    }
    VisibilityObserver.prototype.destroy = function () {
        clearTimeout(this.timeout);
    };
    VisibilityObserver.prototype.onVisibilityChange = function () {
        var _this = this;
        // trigger zone recalc for columns
        this.zone.run(function () {
            _this.isVisible = true;
            _this.visible.emit(true);
        });
    };
    VisibilityObserver.prototype.runCheck = function () {
        var _this = this;
        var check = function () {
            if (!_this.element) {
                return;
            }
            // https://davidwalsh.name/offsetheight-visibility
            var _a = _this.element.nativeElement, offsetHeight = _a.offsetHeight, offsetWidth = _a.offsetWidth;
            if (offsetHeight && offsetWidth) {
                clearTimeout(_this.timeout);
                _this.onVisibilityChange();
            }
            else {
                clearTimeout(_this.timeout);
                _this.zone.runOutsideAngular(function () {
                    _this.timeout = setTimeout(function () { return check(); }, 100);
                });
            }
        };
        this.zone.runOutsideAngular(function () {
            _this.timeout = setTimeout(function () { return check(); });
        });
    };
    var _a;
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], VisibilityObserver.prototype, "visible", void 0);
VisibilityObserver.ɵfac = function VisibilityObserver_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
VisibilityObserver.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: VisibilityObserver, outputs: { visible: "visible" } });

    return VisibilityObserver;
}());

function isDate(value) {
    return toString.call(value) === '[object Date]';
}

var BaseChartComponent = /** @class */ (function () {
    function BaseChartComponent(chartElement, zone, cd) {
        this.chartElement = chartElement;
        this.zone = zone;
        this.cd = cd;
        this.scheme = 'cool';
        this.schemeType = 'ordinal';
        this.animations = true;
        this.select = new EventEmitter();
    }
    BaseChartComponent.prototype.ngAfterViewInit = function () {
        this.bindWindowResizeEvent();
        // listen for visibility of the element for hidden by default scenario
        this.visibilityObserver = new VisibilityObserver(this.chartElement, this.zone);
        this.visibilityObserver.visible.subscribe(this.update.bind(this));
    };
    BaseChartComponent.prototype.ngOnDestroy = function () {
        this.unbindEvents();
        if (this.visibilityObserver) {
            this.visibilityObserver.visible.unsubscribe();
            this.visibilityObserver.destroy();
        }
    };
    BaseChartComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    BaseChartComponent.prototype.update = function () {
        if (this.results) {
            this.results = this.cloneData(this.results);
        }
        else {
            this.results = [];
        }
        if (this.view) {
            this.width = this.view[0];
            this.height = this.view[1];
        }
        else {
            var dims = this.getContainerDims();
            if (dims) {
                this.width = dims.width;
                this.height = dims.height;
            }
        }
        // default values if width or height are 0 or undefined
        if (!this.width) {
            this.width = 600;
        }
        if (!this.height) {
            this.height = 400;
        }
        this.width = Math.floor(this.width);
        this.height = Math.floor(this.height);
        if (this.cd) {
            this.cd.markForCheck();
        }
    };
    BaseChartComponent.prototype.getContainerDims = function () {
        var width;
        var height;
        var hostElem = this.chartElement.nativeElement;
        if (hostElem.parentNode !== null) {
            // Get the container dimensions
            var dims = hostElem.parentNode.getBoundingClientRect();
            width = dims.width;
            height = dims.height;
        }
        if (width && height) {
            return { width: width, height: height };
        }
        return null;
    };
    /**
     * Converts all date objects that appear as name
     * into formatted date strings
     */
    BaseChartComponent.prototype.formatDates = function () {
        for (var i = 0; i < this.results.length; i++) {
            var g = this.results[i];
            g.label = g.name;
            if (g.label instanceof Date) {
                g.label = g.label.toLocaleDateString();
            }
            if (g.series) {
                for (var j = 0; j < g.series.length; j++) {
                    var d = g.series[j];
                    d.label = d.name;
                    if (d.label instanceof Date) {
                        d.label = d.label.toLocaleDateString();
                    }
                }
            }
        }
    };
    BaseChartComponent.prototype.unbindEvents = function () {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    };
    BaseChartComponent.prototype.bindWindowResizeEvent = function () {
        var _this = this;
        var source = fromEvent(window, 'resize');
        var subscription = source.pipe(debounceTime(200)).subscribe(function (e) {
            _this.update();
            if (_this.cd) {
                _this.cd.markForCheck();
            }
        });
        this.resizeSubscription = subscription;
    };
    /**
     * Clones the data into a new object
     *
     * @private
     * @param {any} data
     * @returns {*}
     *
     * @memberOf BaseChart
     */
    BaseChartComponent.prototype.cloneData = function (data) {
        var results = [];
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var item = data_1[_i];
            var copy = {
                name: item['name']
            };
            if (item['value'] !== undefined) {
                copy['value'] = item['value'];
            }
            if (item['series'] !== undefined) {
                copy['series'] = [];
                for (var _a = 0, _b = item['series']; _a < _b.length; _a++) {
                    var seriesItem = _b[_a];
                    var seriesItemCopy = Object.assign({}, seriesItem);
                    copy['series'].push(seriesItemCopy);
                }
            }
            if (item['extra'] !== undefined) {
                copy['extra'] = JSON.parse(JSON.stringify(item['extra']));
            }
            results.push(copy);
        }
        return results;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BaseChartComponent.prototype, "view", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "scheme", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BaseChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "customColors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BaseChartComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "select", void 0);
    BaseChartComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object, typeof (_b = typeof NgZone !== "undefined" && NgZone) === "function" ? _b : Object, typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object])
    ], BaseChartComponent);
BaseChartComponent.ɵfac = function BaseChartComponent_Factory(t) { return new (t || BaseChartComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof NgZone !== "undefined" && NgZone) === "function" ? _b : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object)); };
BaseChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BaseChartComponent, selectors: [["base-chart"]], inputs: { scheme: "scheme", schemeType: "schemeType", animations: "animations", results: "results", view: "view", customColors: "customColors" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 0, template: function BaseChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div");
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BaseChartComponent, [{
        type: Component,
        args: [{
                selector: 'base-chart',
                template: "\n    <div></div>\n  "
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }, { type: typeof (_b = typeof NgZone !== "undefined" && NgZone) === "function" ? _b : Object }, { type: typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object }]; }, { scheme: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], results: [{
            type: Input
        }], view: [{
            type: Input
        }], customColors: [{
            type: Input
        }] }); })();
    return BaseChartComponent;
}());

var AxisLabelComponent = /** @class */ (function () {
    function AxisLabelComponent(element) {
        this.textHeight = 25;
        this.margin = 5;
        this.element = element.nativeElement;
    }
    AxisLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    AxisLabelComponent.prototype.update = function () {
        this.strokeWidth = '0.01';
        this.textAnchor = 'middle';
        this.transform = '';
        switch (this.orient) {
            case 'top':
                this.y = this.offset;
                this.x = this.width / 2;
                break;
            case 'bottom':
                this.y = this.offset;
                this.x = this.width / 2;
                break;
            case 'left':
                this.y = -(this.offset + this.textHeight + this.margin);
                this.x = -this.height / 2;
                this.transform = 'rotate(270)';
                break;
            case 'right':
                this.y = this.offset + this.margin;
                this.x = -this.height / 2;
                this.transform = 'rotate(270)';
                break;
            default:
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "orient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "offset", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "height", void 0);
    AxisLabelComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], AxisLabelComponent);
AxisLabelComponent.ɵfac = function AxisLabelComponent_Factory(t) { return new (t || AxisLabelComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
AxisLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AxisLabelComponent, selectors: [["g", "ngx-charts-axis-label", ""]], inputs: { orient: "orient", label: "label", offset: "offset", width: "width", height: "height" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c3, decls: 2, vars: 6, template: function AxisLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "text");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("stroke-width", ctx.strokeWidth)("x", ctx.x)("y", ctx.y)("text-anchor", ctx.textAnchor)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.label, " ");
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AxisLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-axis-label]',
                template: "\n    <svg:text\n      [attr.stroke-width]=\"strokeWidth\"\n      [attr.x]=\"x\"\n      [attr.y]=\"y\"\n      [attr.text-anchor]=\"textAnchor\"\n      [attr.transform]=\"transform\">\n      {{label}}\n    </svg:text>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { orient: [{
            type: Input
        }], label: [{
            type: Input
        }], offset: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }] }); })();
    return AxisLabelComponent;
}());

function reduceTicks(ticks, maxTicks) {
    if (ticks.length > maxTicks) {
        var reduced = [];
        var modulus = Math.floor(ticks.length / maxTicks);
        for (var i = 0; i < ticks.length; i++) {
            if (i % modulus === 0) {
                reduced.push(ticks[i]);
            }
        }
        ticks = reduced;
    }
    return ticks;
}

var XAxisTicksComponent = /** @class */ (function () {
    function XAxisTicksComponent() {
        this.tickArguments = [5];
        this.tickStroke = '#ccc';
        this.trimTicks = true;
        this.maxTickLength = 16;
        this.showGridLines = false;
        this.rotateTicks = true;
        this.dimensionsChanged = new EventEmitter();
        this.verticalSpacing = 20;
        this.rotateLabels = false;
        this.innerTickSize = 6;
        this.outerTickSize = 6;
        this.tickPadding = 3;
        this.textAnchor = 'middle';
        this.maxTicksLength = 0;
        this.maxAllowedLength = 16;
        this.height = 0;
    }
    XAxisTicksComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    XAxisTicksComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () { return _this.updateDims(); });
    };
    XAxisTicksComponent.prototype.updateDims = function () {
        var _this = this;
        var height = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().height, 10);
        if (height !== this.height) {
            this.height = height;
            this.dimensionsChanged.emit({ height: height });
            setTimeout(function () { return _this.updateDims(); });
        }
    };
    XAxisTicksComponent.prototype.update = function () {
        var _this = this;
        var scale = this.scale;
        this.ticks = this.getTicks();
        if (this.tickFormatting) {
            this.tickFormat = this.tickFormatting;
        }
        else if (scale.tickFormat) {
            this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
        }
        else {
            this.tickFormat = function (d) {
                if (d.constructor.name === 'Date') {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        var angle = this.rotateTicks ? this.getRotationAngle(this.ticks) : null;
        this.adjustedScale = this.scale.bandwidth
            ? function (d) {
                return this.scale(d) + this.scale.bandwidth() * 0.5;
            }
            : this.scale;
        this.textTransform = '';
        if (angle && angle !== 0) {
            this.textTransform = "rotate(" + angle + ")";
            this.textAnchor = 'end';
            this.verticalSpacing = 10;
        }
        else {
            this.textAnchor = 'middle';
        }
        setTimeout(function () { return _this.updateDims(); });
    };
    XAxisTicksComponent.prototype.getRotationAngle = function (ticks) {
        var angle = 0;
        this.maxTicksLength = 0;
        for (var i = 0; i < ticks.length; i++) {
            var tick = this.tickFormat(ticks[i]).toString();
            var tickLength = tick.length;
            if (this.trimTicks) {
                tickLength = this.tickTrim(tick).length;
            }
            if (tickLength > this.maxTicksLength) {
                this.maxTicksLength = tickLength;
            }
        }
        var len = Math.min(this.maxTicksLength, this.maxAllowedLength);
        var charWidth = 8; // need to measure this
        var wordWidth = len * charWidth;
        var baseWidth = wordWidth;
        var maxBaseWidth = Math.floor(this.width / ticks.length);
        // calculate optimal angle
        while (baseWidth > maxBaseWidth && angle > -90) {
            angle -= 30;
            baseWidth = Math.cos(angle * (Math.PI / 180)) * wordWidth;
        }
        return angle;
    };
    XAxisTicksComponent.prototype.getTicks = function () {
        var ticks;
        var maxTicks = this.getMaxTicks(20);
        var maxScaleTicks = this.getMaxTicks(100);
        if (this.tickValues) {
            ticks = this.tickValues;
        }
        else if (this.scale.ticks) {
            ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
        }
        else {
            ticks = this.scale.domain();
            ticks = reduceTicks(ticks, maxTicks);
        }
        return ticks;
    };
    XAxisTicksComponent.prototype.getMaxTicks = function (tickWidth) {
        return Math.floor(this.width / tickWidth);
    };
    XAxisTicksComponent.prototype.tickTransform = function (tick) {
        return 'translate(' + this.adjustedScale(tick) + ',' + this.verticalSpacing + ')';
    };
    XAxisTicksComponent.prototype.gridLineTransform = function () {
        return "translate(0," + (-this.verticalSpacing - 5) + ")";
    };
    XAxisTicksComponent.prototype.tickTrim = function (label) {
        return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "scale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "orient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "tickArguments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], XAxisTicksComponent.prototype, "tickValues", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "tickStroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisTicksComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], XAxisTicksComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "gridLineHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisTicksComponent.prototype, "rotateTicks", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild('ticksel', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], XAxisTicksComponent.prototype, "ticksElement", void 0);
XAxisTicksComponent.ɵfac = function XAxisTicksComponent_Factory(t) { return new (t || XAxisTicksComponent)(); };
XAxisTicksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisTicksComponent, selectors: [["g", "ngx-charts-x-axis-ticks", ""]], viewQuery: function XAxisTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);
    } }, inputs: { tickArguments: "tickArguments", tickStroke: "tickStroke", trimTicks: "trimTicks", maxTickLength: "maxTickLength", showGridLines: "showGridLines", rotateTicks: "rotateTicks", scale: "scale", orient: "orient", tickValues: "tickValues", tickFormatting: "tickFormatting", gridLineHeight: "gridLineHeight", width: "width" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c5, decls: 4, vars: 2, consts: [["ticksel", ""], ["class", "tick", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf"], [1, "tick"], ["stroke-width", "0.01"], [4, "ngIf"], ["y2", "0", 1, "gridline-path", "gridline-path-vertical"]], template: function XAxisTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", null, 0);
        ɵngcc0.ɵɵtemplate(2, XAxisTicksComponent__svg_g_2_Template, 5, 7, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, XAxisTicksComponent__svg_g_3_Template, 2, 2, "g", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(XAxisTicksComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-x-axis-ticks]',
                template: "\n    <svg:g #ticksel>\n      <svg:g *ngFor=\"let tick of ticks\" class=\"tick\" [attr.transform]=\"tickTransform(tick)\">\n        <title>{{ tickFormat(tick) }}</title>\n        <svg:text\n          stroke-width=\"0.01\"\n          [attr.text-anchor]=\"textAnchor\"\n          [attr.transform]=\"textTransform\"\n          [style.font-size]=\"'12px'\"\n        >\n          {{ tickTrim(tickFormat(tick)) }}\n        </svg:text>\n      </svg:g>\n    </svg:g>\n\n    <svg:g *ngFor=\"let tick of ticks\" [attr.transform]=\"tickTransform(tick)\">\n      <svg:g *ngIf=\"showGridLines\" [attr.transform]=\"gridLineTransform()\">\n        <svg:line class=\"gridline-path gridline-path-vertical\" [attr.y1]=\"-gridLineHeight\" y2=\"0\" />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tickArguments: [{
            type: Input
        }], tickStroke: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], rotateTicks: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], scale: [{
            type: Input
        }], orient: [{
            type: Input
        }], tickValues: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], gridLineHeight: [{
            type: Input
        }], width: [{
            type: Input
        }], ticksElement: [{
            type: ViewChild,
            args: ['ticksel', { static: false }]
        }] }); })();
    return XAxisTicksComponent;
}());

var XAxisComponent = /** @class */ (function () {
    function XAxisComponent() {
        this.rotateTicks = true;
        this.showGridLines = false;
        this.xOrient = 'bottom';
        this.xAxisOffset = 0;
        this.dimensionsChanged = new EventEmitter();
        this.xAxisClassName = 'x axis';
        this.labelOffset = 0;
        this.fill = 'none';
        this.stroke = 'stroke';
        this.tickStroke = '#ccc';
        this.strokeWidth = 'none';
        this.padding = 5;
    }
    XAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    XAxisComponent.prototype.update = function () {
        this.transform = "translate(0," + (this.xAxisOffset + this.padding + this.dims.height) + ")";
        if (typeof this.xAxisTickCount !== 'undefined') {
            this.tickArguments = [this.xAxisTickCount];
        }
    };
    XAxisComponent.prototype.emitTicksHeight = function (_a) {
        var _this = this;
        var height = _a.height;
        var newLabelOffset = height + 25 + 5;
        if (newLabelOffset !== this.labelOffset) {
            this.labelOffset = newLabelOffset;
            setTimeout(function () {
                _this.dimensionsChanged.emit({ height: height });
            }, 0);
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisComponent.prototype, "rotateTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], XAxisComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "showLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "labelText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], XAxisComponent.prototype, "ticks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "xAxisTickInterval", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "xAxisTickCount", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], XAxisComponent.prototype, "xOrient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], XAxisComponent.prototype, "xAxisOffset", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild(XAxisTicksComponent, { static: false }),
        __metadata("design:type", typeof (_a = typeof XAxisTicksComponent !== "undefined" && XAxisTicksComponent) === "function" ? _a : Object)
    ], XAxisComponent.prototype, "ticksComponent", void 0);
XAxisComponent.ɵfac = function XAxisComponent_Factory(t) { return new (t || XAxisComponent)(); };
XAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisComponent, selectors: [["g", "ngx-charts-x-axis", ""]], viewQuery: function XAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(XAxisTicksComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { rotateTicks: "rotateTicks", showGridLines: "showGridLines", xOrient: "xOrient", xAxisOffset: "xAxisOffset", xScale: "xScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", showLabel: "showLabel", labelText: "labelText", ticks: "ticks", xAxisTickInterval: "xAxisTickInterval", xAxisTickCount: "xAxisTickCount" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c6, decls: 3, vars: 4, consts: [["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function XAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, XAxisComponent__svg_g_1_Template, 1, 12, "g", 0);
        ɵngcc0.ɵɵtemplate(2, XAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.xAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, XAxisTicksComponent,
        AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(XAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-x-axis]',
                template: "\n    <svg:g [attr.class]=\"xAxisClassName\" [attr.transform]=\"transform\">\n      <svg:g\n        ngx-charts-x-axis-ticks\n        *ngIf=\"xScale\"\n        [trimTicks]=\"trimTicks\"\n        [rotateTicks]=\"rotateTicks\"\n        [maxTickLength]=\"maxTickLength\"\n        [tickFormatting]=\"tickFormatting\"\n        [tickArguments]=\"tickArguments\"\n        [tickStroke]=\"tickStroke\"\n        [scale]=\"xScale\"\n        [orient]=\"xOrient\"\n        [showGridLines]=\"showGridLines\"\n        [gridLineHeight]=\"dims.height\"\n        [width]=\"dims.width\"\n        [tickValues]=\"ticks\"\n        (dimensionsChanged)=\"emitTicksHeight($event)\"\n      />\n      <svg:g\n        ngx-charts-axis-label\n        *ngIf=\"showLabel\"\n        [label]=\"labelText\"\n        [offset]=\"labelOffset\"\n        [orient]=\"'bottom'\"\n        [height]=\"dims.height\"\n        [width]=\"dims.width\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { rotateTicks: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], xOrient: [{
            type: Input
        }], xAxisOffset: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], xScale: [{
            type: Input
        }], dims: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], showLabel: [{
            type: Input
        }], labelText: [{
            type: Input
        }], ticks: [{
            type: Input
        }], xAxisTickInterval: [{
            type: Input
        }], xAxisTickCount: [{
            type: Input
        }], ticksComponent: [{
            type: ViewChild,
            args: [XAxisTicksComponent, { static: false }]
        }] }); })();
    return XAxisComponent;
}());

/**
 * Generates a rounded rectanglar path
 *
 * @export
 * @param {*} x, y, w, h, r, tl, tr, bl, br
 * @returns {string}
 */
function roundedRect(x, y, w, h, r, _a) {
    var tl = _a[0], tr = _a[1], bl = _a[2], br = _a[3];
    var retval = '';
    w = Math.floor(w);
    h = Math.floor(h);
    w = w === 0 ? 1 : w;
    h = h === 0 ? 1 : h;
    retval = "M" + [x + r, y];
    retval += "h" + (w - 2 * r);
    if (tr) {
        retval += "a" + [r, r] + " 0 0 1 " + [r, r];
    }
    else {
        retval += "h" + r + "v" + r;
    }
    retval += "v" + (h - 2 * r);
    if (br) {
        retval += "a" + [r, r] + " 0 0 1 " + [-r, r];
    }
    else {
        retval += "v" + r + "h" + -r;
    }
    retval += "h" + (2 * r - w);
    if (bl) {
        retval += "a" + [r, r] + " 0 0 1 " + [-r, -r];
    }
    else {
        retval += "h" + -r + "v" + -r;
    }
    retval += "v" + (2 * r - h);
    if (tl) {
        retval += "a" + [r, r] + " 0 0 1 " + [r, -r];
    }
    else {
        retval += "v" + -r + "h" + r;
    }
    retval += "z";
    return retval;
}

var YAxisTicksComponent = /** @class */ (function () {
    function YAxisTicksComponent() {
        this.tickArguments = [5];
        this.tickStroke = '#ccc';
        this.trimTicks = true;
        this.maxTickLength = 16;
        this.showGridLines = false;
        this.showRefLabels = false;
        this.showRefLines = false;
        this.dimensionsChanged = new EventEmitter();
        this.innerTickSize = 6;
        this.tickPadding = 3;
        this.verticalSpacing = 20;
        this.textAnchor = 'middle';
        this.width = 0;
        this.outerTickSize = 6;
        this.rotateLabels = false;
        this.referenceLineLength = 0;
    }
    YAxisTicksComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    YAxisTicksComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () { return _this.updateDims(); });
    };
    YAxisTicksComponent.prototype.updateDims = function () {
        var _this = this;
        var width = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().width, 10);
        if (width !== this.width) {
            this.width = width;
            this.dimensionsChanged.emit({ width: width });
            setTimeout(function () { return _this.updateDims(); });
        }
    };
    YAxisTicksComponent.prototype.update = function () {
        var _this = this;
        var scale;
        var sign = this.orient === 'top' || this.orient === 'right' ? -1 : 1;
        this.tickSpacing = Math.max(this.innerTickSize, 0) + this.tickPadding;
        scale = this.scale;
        this.ticks = this.getTicks();
        if (this.tickFormatting) {
            this.tickFormat = this.tickFormatting;
        }
        else if (scale.tickFormat) {
            this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
        }
        else {
            this.tickFormat = function (d) {
                if (d.constructor.name === 'Date') {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        this.adjustedScale = scale.bandwidth
            ? function (d) {
                return scale(d) + scale.bandwidth() * 0.5;
            }
            : scale;
        if (this.showRefLines && this.referenceLines) {
            this.setReferencelines();
        }
        switch (this.orient) {
            case 'top':
                this.transform = function (tick) {
                    return 'translate(' + this.adjustedScale(tick) + ',0)';
                };
                this.textAnchor = 'middle';
                this.y2 = this.innerTickSize * sign;
                this.y1 = this.tickSpacing * sign;
                this.dy = sign < 0 ? '0em' : '.71em';
                break;
            case 'bottom':
                this.transform = function (tick) {
                    return 'translate(' + this.adjustedScale(tick) + ',0)';
                };
                this.textAnchor = 'middle';
                this.y2 = this.innerTickSize * sign;
                this.y1 = this.tickSpacing * sign;
                this.dy = sign < 0 ? '0em' : '.71em';
                break;
            case 'left':
                this.transform = function (tick) {
                    return 'translate(0,' + this.adjustedScale(tick) + ')';
                };
                this.textAnchor = 'end';
                this.x2 = this.innerTickSize * -sign;
                this.x1 = this.tickSpacing * -sign;
                this.dy = '.32em';
                break;
            case 'right':
                this.transform = function (tick) {
                    return 'translate(0,' + this.adjustedScale(tick) + ')';
                };
                this.textAnchor = 'start';
                this.x2 = this.innerTickSize * -sign;
                this.x1 = this.tickSpacing * -sign;
                this.dy = '.32em';
                break;
            default:
        }
        setTimeout(function () { return _this.updateDims(); });
    };
    YAxisTicksComponent.prototype.setReferencelines = function () {
        this.refMin = this.adjustedScale(Math.min.apply(null, this.referenceLines.map(function (item) { return item.value; })));
        this.refMax = this.adjustedScale(Math.max.apply(null, this.referenceLines.map(function (item) { return item.value; })));
        this.referenceLineLength = this.referenceLines.length;
        this.referenceAreaPath = roundedRect(0, this.refMax, this.gridLineWidth, this.refMin - this.refMax, 0, [
            false,
            false,
            false,
            false
        ]);
    };
    YAxisTicksComponent.prototype.getTicks = function () {
        var ticks;
        var maxTicks = this.getMaxTicks(20);
        var maxScaleTicks = this.getMaxTicks(50);
        if (this.tickValues) {
            ticks = this.tickValues;
        }
        else if (this.scale.ticks) {
            ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
        }
        else {
            ticks = this.scale.domain();
            ticks = reduceTicks(ticks, maxTicks);
        }
        return ticks;
    };
    YAxisTicksComponent.prototype.getMaxTicks = function (tickHeight) {
        return Math.floor(this.height / tickHeight);
    };
    YAxisTicksComponent.prototype.tickTransform = function (tick) {
        return "translate(" + this.adjustedScale(tick) + "," + this.verticalSpacing + ")";
    };
    YAxisTicksComponent.prototype.gridLineTransform = function () {
        return "translate(5,0)";
    };
    YAxisTicksComponent.prototype.tickTrim = function (label) {
        return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "scale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "orient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "tickArguments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], YAxisTicksComponent.prototype, "tickValues", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "tickStroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisTicksComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], YAxisTicksComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "gridLineWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "referenceLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisTicksComponent.prototype, "showRefLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisTicksComponent.prototype, "showRefLines", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild('ticksel', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], YAxisTicksComponent.prototype, "ticksElement", void 0);
YAxisTicksComponent.ɵfac = function YAxisTicksComponent_Factory(t) { return new (t || YAxisTicksComponent)(); };
YAxisTicksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisTicksComponent, selectors: [["g", "ngx-charts-y-axis-ticks", ""]], viewQuery: function YAxisTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);
    } }, inputs: { tickArguments: "tickArguments", tickStroke: "tickStroke", trimTicks: "trimTicks", maxTickLength: "maxTickLength", showGridLines: "showGridLines", showRefLabels: "showRefLabels", showRefLines: "showRefLines", scale: "scale", orient: "orient", tickValues: "tickValues", tickFormatting: "tickFormatting", gridLineWidth: "gridLineWidth", height: "height", referenceLines: "referenceLines" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c7, decls: 6, vars: 4, consts: [["ticksel", ""], ["class", "tick", 4, "ngFor", "ngForOf"], ["class", "reference-area", 4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "tick"], ["stroke-width", "0.01"], [1, "reference-area"], [4, "ngIf"], ["class", "gridline-path gridline-path-horizontal", "x1", "0", 4, "ngIf"], ["x1", "0", 1, "gridline-path", "gridline-path-horizontal"], ["x1", "0", 1, "refline-path", "gridline-path-horizontal"], [1, "refline-label"]], template: function YAxisTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", null, 0);
        ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_2_Template, 5, 9, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, YAxisTicksComponent__svg_path_3_Template, 1, 2, "path", 2);
        ɵngcc0.ɵɵtemplate(4, YAxisTicksComponent__svg_g_4_Template, 2, 2, "g", 3);
        ɵngcc0.ɵɵtemplate(5, YAxisTicksComponent__svg_g_5_Template, 2, 1, "g", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.referenceLineLength > 1 && ctx.refMax && ctx.refMin && ctx.showRefLines);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.referenceLines);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(YAxisTicksComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-y-axis-ticks]',
                template: "\n    <svg:g #ticksel>\n      <svg:g *ngFor=\"let tick of ticks\" class=\"tick\" [attr.transform]=\"transform(tick)\">\n        <title>{{ tickFormat(tick) }}</title>\n        <svg:text\n          stroke-width=\"0.01\"\n          [attr.dy]=\"dy\"\n          [attr.x]=\"x1\"\n          [attr.y]=\"y1\"\n          [attr.text-anchor]=\"textAnchor\"\n          [style.font-size]=\"'12px'\"\n        >\n          {{ tickTrim(tickFormat(tick)) }}\n        </svg:text>\n      </svg:g>\n    </svg:g>\n\n    <svg:path\n      *ngIf=\"referenceLineLength > 1 && refMax && refMin && showRefLines\"\n      class=\"reference-area\"\n      [attr.d]=\"referenceAreaPath\"\n      [attr.transform]=\"gridLineTransform()\"\n    />\n    <svg:g *ngFor=\"let tick of ticks\" [attr.transform]=\"transform(tick)\">\n      <svg:g *ngIf=\"showGridLines\" [attr.transform]=\"gridLineTransform()\">\n        <svg:line\n          *ngIf=\"orient === 'left'\"\n          class=\"gridline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"gridLineWidth\"\n        />\n        <svg:line\n          *ngIf=\"orient === 'right'\"\n          class=\"gridline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"-gridLineWidth\"\n        />\n      </svg:g>\n    </svg:g>\n\n    <svg:g *ngFor=\"let refLine of referenceLines\">\n      <svg:g *ngIf=\"showRefLines\" [attr.transform]=\"transform(refLine.value)\">\n        <svg:line\n          class=\"refline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"gridLineWidth\"\n          [attr.transform]=\"gridLineTransform()\"\n        />\n        <svg:g *ngIf=\"showRefLabels\">\n          <title>{{ tickTrim(tickFormat(refLine.value)) }}</title>\n          <svg:text\n            class=\"refline-label\"\n            [attr.dy]=\"dy\"\n            [attr.y]=\"-6\"\n            [attr.x]=\"gridLineWidth\"\n            [attr.text-anchor]=\"textAnchor\"\n          >\n            {{ refLine.name }}\n          </svg:text>\n        </svg:g>\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tickArguments: [{
            type: Input
        }], tickStroke: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], showRefLabels: [{
            type: Input
        }], showRefLines: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], scale: [{
            type: Input
        }], orient: [{
            type: Input
        }], tickValues: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], gridLineWidth: [{
            type: Input
        }], height: [{
            type: Input
        }], referenceLines: [{
            type: Input
        }], ticksElement: [{
            type: ViewChild,
            args: ['ticksel', { static: false }]
        }] }); })();
    return YAxisTicksComponent;
}());

var YAxisComponent = /** @class */ (function () {
    function YAxisComponent() {
        this.showGridLines = false;
        this.yOrient = 'left';
        this.yAxisOffset = 0;
        this.dimensionsChanged = new EventEmitter();
        this.yAxisClassName = 'y axis';
        this.labelOffset = 15;
        this.fill = 'none';
        this.stroke = '#CCC';
        this.tickStroke = '#CCC';
        this.strokeWidth = 1;
        this.padding = 5;
    }
    YAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    YAxisComponent.prototype.update = function () {
        this.offset = -(this.yAxisOffset + this.padding);
        if (this.yOrient === 'right') {
            this.labelOffset = 65;
            this.transform = "translate(" + (this.offset + this.dims.width) + " , 0)";
        }
        else {
            this.offset = this.offset;
            this.transform = "translate(" + this.offset + " , 0)";
        }
        if (this.yAxisTickCount !== undefined) {
            this.tickArguments = [this.yAxisTickCount];
        }
    };
    YAxisComponent.prototype.emitTicksWidth = function (_a) {
        var _this = this;
        var width = _a.width;
        if (width !== this.labelOffset && this.yOrient === 'right') {
            this.labelOffset = width + this.labelOffset;
            setTimeout(function () {
                _this.dimensionsChanged.emit({ width: width });
            }, 0);
        }
        else if (width !== this.labelOffset) {
            this.labelOffset = width;
            setTimeout(function () {
                _this.dimensionsChanged.emit({ width: width });
            }, 0);
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], YAxisComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], YAxisComponent.prototype, "ticks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "labelText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "yAxisTickInterval", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "yAxisTickCount", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], YAxisComponent.prototype, "yOrient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "referenceLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showRefLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showRefLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], YAxisComponent.prototype, "yAxisOffset", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild(YAxisTicksComponent, { static: false }),
        __metadata("design:type", typeof (_a = typeof YAxisTicksComponent !== "undefined" && YAxisTicksComponent) === "function" ? _a : Object)
    ], YAxisComponent.prototype, "ticksComponent", void 0);
YAxisComponent.ɵfac = function YAxisComponent_Factory(t) { return new (t || YAxisComponent)(); };
YAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisComponent, selectors: [["g", "ngx-charts-y-axis", ""]], viewQuery: function YAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(YAxisTicksComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { showGridLines: "showGridLines", yOrient: "yOrient", yAxisOffset: "yAxisOffset", yScale: "yScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", ticks: "ticks", showLabel: "showLabel", labelText: "labelText", yAxisTickInterval: "yAxisTickInterval", yAxisTickCount: "yAxisTickCount", referenceLines: "referenceLines", showRefLines: "showRefLines", showRefLabels: "showRefLabels" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c8, decls: 3, vars: 4, consts: [["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function YAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, YAxisComponent__svg_g_1_Template, 1, 14, "g", 0);
        ɵngcc0.ɵɵtemplate(2, YAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.yAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, YAxisTicksComponent,
        AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(YAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-y-axis]',
                template: "\n    <svg:g [attr.class]=\"yAxisClassName\" [attr.transform]=\"transform\">\n      <svg:g\n        ngx-charts-y-axis-ticks\n        *ngIf=\"yScale\"\n        [trimTicks]=\"trimTicks\"\n        [maxTickLength]=\"maxTickLength\"\n        [tickFormatting]=\"tickFormatting\"\n        [tickArguments]=\"tickArguments\"\n        [tickValues]=\"ticks\"\n        [tickStroke]=\"tickStroke\"\n        [scale]=\"yScale\"\n        [orient]=\"yOrient\"\n        [showGridLines]=\"showGridLines\"\n        [gridLineWidth]=\"dims.width\"\n        [referenceLines]=\"referenceLines\"\n        [showRefLines]=\"showRefLines\"\n        [showRefLabels]=\"showRefLabels\"\n        [height]=\"dims.height\"\n        (dimensionsChanged)=\"emitTicksWidth($event)\"\n      />\n\n      <svg:g\n        ngx-charts-axis-label\n        *ngIf=\"showLabel\"\n        [label]=\"labelText\"\n        [offset]=\"labelOffset\"\n        [orient]=\"yOrient\"\n        [height]=\"dims.height\"\n        [width]=\"dims.width\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { showGridLines: [{
            type: Input
        }], yOrient: [{
            type: Input
        }], yAxisOffset: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], yScale: [{
            type: Input
        }], dims: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], ticks: [{
            type: Input
        }], showLabel: [{
            type: Input
        }], labelText: [{
            type: Input
        }], yAxisTickInterval: [{
            type: Input
        }], yAxisTickCount: [{
            type: Input
        }], referenceLines: [{
            type: Input
        }], showRefLines: [{
            type: Input
        }], showRefLabels: [{
            type: Input
        }], ticksComponent: [{
            type: ViewChild,
            args: [YAxisTicksComponent, { static: false }]
        }] }); })();
    return YAxisComponent;
}());

var AxesModule = /** @class */ (function () {
    function AxesModule() {
    }
AxesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AxesModule });
AxesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AxesModule_Factory(t) { return new (t || AxesModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AxesModule, { declarations: function () { return [AxisLabelComponent,
        XAxisComponent,
        XAxisTicksComponent,
        YAxisComponent,
        YAxisTicksComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [AxisLabelComponent,
        XAxisComponent,
        XAxisTicksComponent,
        YAxisComponent,
        YAxisTicksComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AxesModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent],
                exports: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent]
            }]
    }], function () { return []; }, null); })();
    return AxesModule;
}());

var ColorHelper = /** @class */ (function () {
    function ColorHelper(scheme, type, domain, customColors) {
        if (typeof scheme === 'string') {
            scheme = colorSets.find(function (cs) {
                return cs.name === scheme;
            });
        }
        this.colorDomain = scheme.domain;
        this.scaleType = type;
        this.domain = domain;
        this.customColors = customColors;
        this.scale = this.generateColorScheme(scheme, type, this.domain);
    }
    ColorHelper.prototype.generateColorScheme = function (scheme, type, domain) {
        if (typeof scheme === 'string') {
            scheme = colorSets.find(function (cs) {
                return cs.name === scheme;
            });
        }
        var colorScale;
        if (type === 'quantile') {
            colorScale = scaleQuantile()
                .range(scheme.domain)
                .domain(domain);
        }
        else if (type === 'ordinal') {
            colorScale = scaleOrdinal()
                .range(scheme.domain)
                .domain(domain);
        }
        else if (type === 'linear') {
            // linear schemes must have at least 2 colors
            var colorDomain = scheme.domain.slice();
            if (colorDomain.length === 1) {
                colorDomain.push(colorDomain[0]);
                this.colorDomain = colorDomain;
            }
            var points = range(0, 1, 1.0 / colorDomain.length);
            colorScale = scaleLinear()
                .domain(points)
                .range(colorDomain);
        }
        return colorScale;
    };
    ColorHelper.prototype.getColor = function (value) {
        if (value === undefined || value === null) {
            throw new Error('Value can not be null');
        }
        if (this.scaleType === 'linear') {
            var valueScale = scaleLinear()
                .domain(this.domain)
                .range([0, 1]);
            return this.scale(valueScale(value));
        }
        else {
            if (typeof this.customColors === 'function') {
                return this.customColors(value);
            }
            var formattedValue_1 = value.toString();
            var found = void 0; // todo type customColors
            if (this.customColors && this.customColors.length > 0) {
                found = this.customColors.find(function (mapping) {
                    return mapping.name.toLowerCase() === formattedValue_1.toLowerCase();
                });
            }
            if (found) {
                return found.value;
            }
            else {
                return this.scale(value);
            }
        }
    };
    ColorHelper.prototype.getLinearGradientStops = function (value, start) {
        if (start === undefined) {
            start = this.domain[0];
        }
        var valueScale = scaleLinear()
            .domain(this.domain)
            .range([0, 1]);
        var colorValueScale = scaleBand()
            .domain(this.colorDomain)
            .range([0, 1]);
        var endColor = this.getColor(value);
        // generate the stops
        var startVal = valueScale(start);
        var startColor = this.getColor(start);
        var endVal = valueScale(value);
        var i = 1;
        var currentVal = startVal;
        var stops = [];
        stops.push({
            color: startColor,
            offset: startVal,
            originalOffset: startVal,
            opacity: 1
        });
        while (currentVal < endVal && i < this.colorDomain.length) {
            var color = this.colorDomain[i];
            var offset = colorValueScale(color);
            if (offset <= startVal) {
                i++;
                continue;
            }
            if (offset.toFixed(4) >= (endVal - colorValueScale.bandwidth()).toFixed(4)) {
                break;
            }
            stops.push({
                color: color,
                offset: offset,
                opacity: 1
            });
            currentVal = offset;
            i++;
        }
        if (stops[stops.length - 1].offset < 100) {
            stops.push({
                color: endColor,
                offset: endVal,
                opacity: 1
            });
        }
        if (endVal === startVal) {
            stops[0].offset = 0;
            stops[1].offset = 100;
        }
        else {
            // normalize the offsets into percentages
            if (stops[stops.length - 1].offset !== 100) {
                for (var _i = 0, stops_1 = stops; _i < stops_1.length; _i++) {
                    var s = stops_1[_i];
                    s.offset = ((s.offset - startVal) / (endVal - startVal)) * 100;
                }
            }
        }
        return stops;
    };
    return ColorHelper;
}());

var CircleSeriesComponent = /** @class */ (function () {
    function CircleSeriesComponent() {
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.barVisible = false;
    }
    CircleSeriesComponent.prototype.ngOnInit = function () {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = "url(#" + this.gradientId + ")";
    };
    CircleSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    CircleSeriesComponent.prototype.update = function () {
        this.circle = this.getActiveCircle();
    };
    CircleSeriesComponent.prototype.getActiveCircle = function () {
        var _this = this;
        var indexActiveDataPoint = this.data.series.findIndex(function (d) {
            var label = d.name;
            return label && _this.visibleValue && label.toString() === _this.visibleValue.toString() && d.value !== undefined;
        });
        if (indexActiveDataPoint === -1) {
            // No valid point is 'active/hovered over' at this moment.
            return undefined;
        }
        return this.mapDataPointToCircle(this.data.series[indexActiveDataPoint], indexActiveDataPoint);
    };
    CircleSeriesComponent.prototype.mapDataPointToCircle = function (d, i) {
        var seriesName = this.data.name;
        var value = d.value;
        var label = d.name;
        var tooltipLabel = formatLabel(label);
        var cx;
        if (this.scaleType === 'time') {
            cx = this.xScale(label);
        }
        else if (this.scaleType === 'linear') {
            cx = this.xScale(Number(label));
        }
        else {
            cx = this.xScale(label);
        }
        var cy = this.yScale(this.type === 'standard' ? value : d.d1);
        var radius = 5;
        var height = this.yScale.range()[0] - cy;
        var opacity = 1;
        var color;
        if (this.colors.scaleType === 'linear') {
            if (this.type === 'standard') {
                color = this.colors.getColor(value);
            }
            else {
                color = this.colors.getColor(d.d1);
            }
        }
        else {
            color = this.colors.getColor(seriesName);
        }
        var data = Object.assign({}, d, {
            series: seriesName,
            value: value,
            name: label
        });
        return {
            classNames: ["circle-data-" + i],
            value: value,
            label: label,
            data: data,
            cx: cx,
            cy: cy,
            radius: radius,
            height: height,
            tooltipLabel: tooltipLabel,
            color: color,
            opacity: opacity,
            seriesName: seriesName,
            gradientStops: this.getGradientStops(color),
            min: d.min,
            max: d.max
        };
    };
    CircleSeriesComponent.prototype.getTooltipText = function (_a) {
        var tooltipLabel = _a.tooltipLabel, value = _a.value, seriesName = _a.seriesName, min$$1 = _a.min, max$$1 = _a.max;
        return "\n      <span class=\"tooltip-label\">" + seriesName + " \u2022 " + tooltipLabel + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + this.getTooltipMinMaxText(min$$1, max$$1) + "</span>\n    ";
    };
    CircleSeriesComponent.prototype.getTooltipMinMaxText = function (min$$1, max$$1) {
        if (min$$1 !== undefined || max$$1 !== undefined) {
            var result = ' (';
            if (min$$1 !== undefined) {
                if (max$$1 === undefined) {
                    result += '≥';
                }
                result += min$$1.toLocaleString();
                if (max$$1 !== undefined) {
                    result += ' - ';
                }
            }
            else if (max$$1 !== undefined) {
                result += '≤';
            }
            if (max$$1 !== undefined) {
                result += max$$1.toLocaleString();
            }
            result += ')';
            return result;
        }
        else {
            return '';
        }
    };
    CircleSeriesComponent.prototype.getGradientStops = function (color) {
        return [
            {
                offset: 0,
                color: color,
                opacity: 0.2
            },
            {
                offset: 100,
                color: color,
                opacity: 1
            }
        ];
    };
    CircleSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    CircleSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    CircleSeriesComponent.prototype.activateCircle = function () {
        this.barVisible = true;
        this.activate.emit({ name: this.data.name });
    };
    CircleSeriesComponent.prototype.deactivateCircle = function () {
        this.barVisible = false;
        this.circle.opacity = 0;
        this.deactivate.emit({ name: this.data.name });
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof ColorHelper !== "undefined" && ColorHelper) === "function" ? _a : Object)
    ], CircleSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "visibleValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], CircleSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], CircleSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _b : Object)
    ], CircleSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "deactivate", void 0);
CircleSeriesComponent.ɵfac = function CircleSeriesComponent_Factory(t) { return new (t || CircleSeriesComponent)(); };
CircleSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CircleSeriesComponent, selectors: [["g", "ngx-charts-circle-series", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", visibleValue: "visibleValue", activeEntries: "activeEntries", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c9, decls: 1, vars: 1, consts: [[4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], ["class", "tooltip-bar", 4, "ngIf"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"], [1, "tooltip-bar"]], template: function CircleSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CircleSeriesComponent__svg_g_0_Template, 5, 20, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.circle);
    } }, directives: function () { return [ɵngcc1.NgIf, SvgLinearGradientComponent,
        CircleComponent,
        TooltipDirective]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        opacity: 0
                    }),
                    animate(250, style({ opacity: 1 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CircleSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-circle-series]',
                template: "\n    <svg:g *ngIf=\"circle\">\n      <defs>\n        <svg:g\n          ngx-charts-svg-linear-gradient\n          orientation=\"vertical\"\n          [name]=\"gradientId\"\n          [stops]=\"circle.gradientStops\"\n        />\n      </defs>\n      <svg:rect\n        *ngIf=\"barVisible && type === 'standard'\"\n        [@animationState]=\"'active'\"\n        [attr.x]=\"circle.cx - circle.radius\"\n        [attr.y]=\"circle.cy\"\n        [attr.width]=\"circle.radius * 2\"\n        [attr.height]=\"circle.height\"\n        [attr.fill]=\"gradientFill\"\n        class=\"tooltip-bar\"\n      />\n      <svg:g\n        ngx-charts-circle\n        class=\"circle\"\n        [cx]=\"circle.cx\"\n        [cy]=\"circle.cy\"\n        [r]=\"circle.radius\"\n        [fill]=\"circle.color\"\n        [class.active]=\"isActive({ name: circle.seriesName })\"\n        [pointerEvents]=\"circle.value === 0 ? 'none' : 'all'\"\n        [data]=\"circle.value\"\n        [classNames]=\"circle.classNames\"\n        (select)=\"onClick(circle.data)\"\n        (activate)=\"activateCircle()\"\n        (deactivate)=\"deactivateCircle()\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(circle)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"circle.data\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                opacity: 0
                            }),
                            animate(250, style({ opacity: 1 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], visibleValue: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return CircleSeriesComponent;
}());

var CircleComponent = /** @class */ (function () {
    function CircleComponent() {
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    CircleComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    CircleComponent.prototype.onMouseEnter = function () {
        this.activate.emit(this.data);
    };
    CircleComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit(this.data);
    };
    CircleComponent.prototype.ngOnChanges = function (changes) {
        this.classNames = Array.isArray(this.classNames) ?
            this.classNames.join(' ') :
            '';
        this.classNames += 'circle';
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "cx", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "cy", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "r", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "stroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "classNames", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "circleOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "pointerEvents", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "deactivate", void 0);
    __decorate([
        HostListener('click'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CircleComponent.prototype, "onClick", null);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CircleComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CircleComponent.prototype, "onMouseLeave", null);
CircleComponent.ɵfac = function CircleComponent_Factory(t) { return new (t || CircleComponent)(); };
CircleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CircleComponent, selectors: [["g", "ngx-charts-circle", ""]], hostBindings: function CircleComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function CircleComponent_click_HostBindingHandler() { return ctx.onClick(); })("mouseenter", function CircleComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function CircleComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { classNames: "classNames", cx: "cx", cy: "cy", r: "r", fill: "fill", stroke: "stroke", data: "data", circleOpacity: "circleOpacity", pointerEvents: "pointerEvents" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c11, decls: 1, vars: 8, template: function CircleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "circle");
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r)("fill", ctx.fill)("stroke", ctx.stroke)("opacity", ctx.circleOpacity)("class", ctx.classNames)("pointer-events", ctx.pointerEvents);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CircleComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-circle]',
                template: "\n    <svg:circle\n      [attr.cx]=\"cx\"\n      [attr.cy]=\"cy\"\n      [attr.r]=\"r\"\n      [attr.fill]=\"fill\"\n      [attr.stroke]=\"stroke\"\n      [attr.opacity]=\"circleOpacity\"\n      [attr.class]=\"classNames\"\n      [attr.pointer-events]=\"pointerEvents\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], classNames: [{
            type: Input
        }], cx: [{
            type: Input
        }], cy: [{
            type: Input
        }], r: [{
            type: Input
        }], fill: [{
            type: Input
        }], stroke: [{
            type: Input
        }], data: [{
            type: Input
        }], circleOpacity: [{
            type: Input
        }], pointerEvents: [{
            type: Input
        }] }); })();
    return CircleComponent;
}());

var GridPanelComponent = /** @class */ (function () {
    function GridPanelComponent() {
    }
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "path", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "y", void 0);
GridPanelComponent.ɵfac = function GridPanelComponent_Factory(t) { return new (t || GridPanelComponent)(); };
GridPanelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GridPanelComponent, selectors: [["g", "ngx-charts-grid-panel", ""]], inputs: { path: "path", width: "width", height: "height", x: "x", y: "y" }, attrs: _c12, decls: 1, vars: 4, consts: [["stroke", "none", 1, "gridpanel"]], template: function GridPanelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "rect", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("height", ctx.height)("width", ctx.width)("x", ctx.x)("y", ctx.y);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GridPanelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-grid-panel]',
                template: "\n    <svg:rect\n      [attr.height]=\"height\"\n      [attr.width]=\"width\"\n      [attr.x]=\"x\"\n      [attr.y]=\"y\"\n      stroke=\"none\"\n      class=\"gridpanel\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { path: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }] }); })();
    return GridPanelComponent;
}());

var GridPanelSeriesComponent = /** @class */ (function () {
    function GridPanelSeriesComponent() {
    }
    GridPanelSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    GridPanelSeriesComponent.prototype.update = function () {
        this.gridPanels = this.getGridPanels();
    };
    GridPanelSeriesComponent.prototype.getGridPanels = function () {
        var _this = this;
        return this.data.map(function (d) {
            var offset;
            var width;
            var height;
            var x;
            var y;
            var className = 'odd';
            if (_this.orient === 'vertical') {
                var position = _this.xScale(d.name);
                var positionIndex = Number.parseInt((position / _this.xScale.step()).toString(), 10);
                if (positionIndex % 2 === 1) {
                    className = 'even';
                }
                offset = _this.xScale.bandwidth() * _this.xScale.paddingInner();
                width = _this.xScale.bandwidth() + offset;
                height = _this.dims.height;
                x = _this.xScale(d.name) - offset / 2;
                y = 0;
            }
            else if (_this.orient === 'horizontal') {
                var position = _this.yScale(d.name);
                var positionIndex = Number.parseInt((position / _this.yScale.step()).toString(), 10);
                if (positionIndex % 2 === 1) {
                    className = 'even';
                }
                offset = _this.yScale.bandwidth() * _this.yScale.paddingInner();
                width = _this.dims.width;
                height = _this.yScale.bandwidth() + offset;
                x = 0;
                y = _this.yScale(d.name) - offset / 2;
            }
            return {
                name: d.name,
                class: className,
                height: height,
                width: width,
                x: x,
                y: y
            };
        });
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "orient", void 0);
GridPanelSeriesComponent.ɵfac = function GridPanelSeriesComponent_Factory(t) { return new (t || GridPanelSeriesComponent)(); };
GridPanelSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GridPanelSeriesComponent, selectors: [["g", "ngx-charts-grid-panel-series", ""]], inputs: { data: "data", dims: "dims", xScale: "xScale", yScale: "yScale", orient: "orient" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c13, decls: 1, vars: 1, consts: [["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y", "grid-panel", "odd", "even", 4, "ngFor", "ngForOf"], ["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y"]], template: function GridPanelSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, GridPanelSeriesComponent__svg_g_0_Template, 1, 10, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.gridPanels);
    } }, directives: [ɵngcc1.NgForOf, GridPanelComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GridPanelSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-grid-panel-series]',
                template: "\n    <svg:g ngx-charts-grid-panel *ngFor=\"let gridPanel of gridPanels\"\n      [height]=\"gridPanel.height\"\n      [width]=\"gridPanel.width\"\n      [x]=\"gridPanel.x\"\n      [y]=\"gridPanel.y\"\n      [class.grid-panel]=\"true\"\n      [class.odd]=\"gridPanel.class === 'odd'\"\n      [class.even]=\"gridPanel.class === 'even'\">\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { data: [{
            type: Input
        }], dims: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], orient: [{
            type: Input
        }] }); })();
    return GridPanelSeriesComponent;
}());

var SvgLinearGradientComponent = /** @class */ (function () {
    function SvgLinearGradientComponent() {
        this.orientation = 'vertical';
    }
    SvgLinearGradientComponent.prototype.ngOnChanges = function (changes) {
        this.x1 = '0%';
        this.x2 = '0%';
        this.y1 = '0%';
        this.y2 = '0%';
        if (this.orientation === 'horizontal') {
            this.x2 = '100%';
        }
        else if (this.orientation === 'vertical') {
            this.y1 = '100%';
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SvgLinearGradientComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SvgLinearGradientComponent.prototype, "name", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], SvgLinearGradientComponent.prototype, "stops", void 0);
SvgLinearGradientComponent.ɵfac = function SvgLinearGradientComponent_Factory(t) { return new (t || SvgLinearGradientComponent)(); };
SvgLinearGradientComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SvgLinearGradientComponent, selectors: [["g", "ngx-charts-svg-linear-gradient", ""]], inputs: { orientation: "orientation", name: "name", stops: "stops" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c14, decls: 2, vars: 6, consts: [[3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgLinearGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "linearGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgLinearGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("x1", ctx.x1)("y1", ctx.y1)("x2", ctx.x2)("y2", ctx.y2);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SvgLinearGradientComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-svg-linear-gradient]',
                template: "\n    <svg:linearGradient\n      [id]=\"name\"\n      [attr.x1]=\"x1\"\n      [attr.y1]=\"y1\"\n      [attr.x2]=\"x2\"\n      [attr.y2]=\"y2\">\n      <svg:stop *ngFor=\"let stop of stops\"\n        [attr.offset]=\"stop.offset + '%'\"\n        [style.stop-color]=\"stop.color\"\n        [style.stop-opacity]=\"stop.opacity\"\n      />\n    </svg:linearGradient>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { orientation: [{
            type: Input
        }], name: [{
            type: Input
        }], stops: [{
            type: Input
        }] }); })();
    return SvgLinearGradientComponent;
}());

var SvgRadialGradientComponent = /** @class */ (function () {
    function SvgRadialGradientComponent() {
        this.endOpacity = 1;
        this.cx = 0;
        this.cy = 0;
    }
    Object.defineProperty(SvgRadialGradientComponent.prototype, "stops", {
        get: function () {
            return this.stopsInput || this.stopsDefault;
        },
        set: function (value) {
            this.stopsInput = value;
        },
        enumerable: true,
        configurable: true
    });
    SvgRadialGradientComponent.prototype.ngOnChanges = function (changes) {
        this.r = '30%';
        if (('color' in changes) ||
            ('startOpacity' in changes) ||
            ('endOpacity' in changes)) {
            this.stopsDefault = [{
                    offset: 0,
                    color: this.color,
                    opacity: this.startOpacity
                }, {
                    offset: 100,
                    color: this.color,
                    opacity: this.endOpacity
                }];
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SvgRadialGradientComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SvgRadialGradientComponent.prototype, "name", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SvgRadialGradientComponent.prototype, "startOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SvgRadialGradientComponent.prototype, "endOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SvgRadialGradientComponent.prototype, "cx", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SvgRadialGradientComponent.prototype, "cy", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], SvgRadialGradientComponent.prototype, "stops", null);
SvgRadialGradientComponent.ɵfac = function SvgRadialGradientComponent_Factory(t) { return new (t || SvgRadialGradientComponent)(); };
SvgRadialGradientComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SvgRadialGradientComponent, selectors: [["g", "ngx-charts-svg-radial-gradient", ""]], inputs: { endOpacity: "endOpacity", cx: "cx", cy: "cy", stops: "stops", color: "color", name: "name", startOpacity: "startOpacity" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c15, decls: 2, vars: 5, consts: [["gradientUnits", "userSpaceOnUse", 3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgRadialGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "radialGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgRadialGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SvgRadialGradientComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-svg-radial-gradient]',
                template: "\n    <svg:radialGradient\n      [id]=\"name\"\n      [attr.cx]=\"cx\"\n      [attr.cy]=\"cy\"\n      [attr.r]=\"r\"\n      gradientUnits=\"userSpaceOnUse\">\n      <svg:stop *ngFor=\"let stop of stops\"\n        [attr.offset]=\"stop.offset + '%'\"\n        [style.stop-color]=\"stop.color\"\n        [style.stop-opacity]=\"stop.opacity\"\n      />\n    </svg:radialGradient>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { endOpacity: [{
            type: Input
        }], cx: [{
            type: Input
        }], cy: [{
            type: Input
        }], stops: [{
            type: Input
        }], color: [{
            type: Input
        }], name: [{
            type: Input
        }], startOpacity: [{
            type: Input
        }] }); })();
    return SvgRadialGradientComponent;
}());

var Timeline = /** @class */ (function () {
    function Timeline(element, cd) {
        this.cd = cd;
        this.height = 50;
        this.select = new EventEmitter();
        this.onDomainChange = new EventEmitter();
        this.initialized = false;
        this.element = element.nativeElement;
    }
    Timeline.prototype.ngOnChanges = function (changes) {
        this.update();
        if (!this.initialized) {
            this.addBrush();
            this.initialized = true;
        }
    };
    Timeline.prototype.update = function () {
        this.dims = this.getDims();
        this.height = this.dims.height;
        var offsetY = this.view[1] - this.height;
        this.xDomain = this.getXDomain();
        this.xScale = this.getXScale();
        if (this.brush) {
            this.updateBrush();
        }
        this.transform = "translate(0 , " + offsetY + ")";
        this.filterId = 'filter' + id().toString();
        this.filter = "url(#" + this.filterId + ")";
        this.cd.markForCheck();
    };
    Timeline.prototype.getXDomain = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.name)) {
                    values.push(d.name);
                }
            }
        }
        var domain = [];
        if (this.scaleType === 'time') {
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [min$$1, max$$1];
        }
        else if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [min$$1, max$$1];
        }
        else {
            domain = values;
        }
        return domain;
    };
    Timeline.prototype.getXScale = function () {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime()
                .range([0, this.dims.width])
                .domain(this.xDomain);
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear()
                .range([0, this.dims.width])
                .domain(this.xDomain);
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint()
                .range([0, this.dims.width])
                .padding(0.1)
                .domain(this.xDomain);
        }
        return scale;
    };
    Timeline.prototype.addBrush = function () {
        var _this = this;
        if (this.brush)
            return;
        var height = this.height;
        var width = this.view[0];
        this.brush = brushX()
            .extent([[0, 0], [width, height]])
            .on('brush end', function () {
            var selection = event.selection || _this.xScale.range();
            var newDomain = selection.map(_this.xScale.invert);
            _this.onDomainChange.emit(newDomain);
            _this.cd.markForCheck();
        });
        select(this.element)
            .select('.brush')
            .call(this.brush);
    };
    Timeline.prototype.updateBrush = function () {
        if (!this.brush)
            return;
        var height = this.height;
        var width = this.view[0];
        this.brush.extent([[0, 0], [width, height]]);
        select(this.element)
            .select('.brush')
            .call(this.brush);
        select(this.element).select('.selection')
            .attr('fill', undefined)
            .attr('stroke', undefined)
            .attr('fill-opacity', undefined);
        this.cd.markForCheck();
    };
    Timeline.prototype.getDims = function () {
        var width = this.view[0];
        var dims = {
            width: width,
            height: this.height
        };
        return dims;
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "view", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "state", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "scheme", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "customColors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "miniChart", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], Timeline.prototype, "height", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "onDomainChange", void 0);
    Timeline = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object, typeof (_b = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _b : Object])
    ], Timeline);
Timeline.ɵfac = function Timeline_Factory(t) { return new (t || Timeline)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _b : Object)); };
Timeline.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Timeline, selectors: [["g", "ngx-charts-timeline", ""]], inputs: { height: "height", view: "view", state: "state", results: "results", scheme: "scheme", customColors: "customColors", legend: "legend", miniChart: "miniChart", autoScale: "autoScale", scaleType: "scaleType" }, outputs: { select: "select", onDomainChange: "onDomainChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c16, ngContentSelectors: _c2, decls: 7, vars: 4, consts: [[1, "timeline"], ["in", "SourceGraphic", "type", "matrix", "values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"], [1, "embedded-chart"], ["x", "0", "y", "0", 1, "brush-background"], [1, "brush"]], template: function Timeline_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "filter");
        ɵngcc0.ɵɵelement(2, "feColorMatrix", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "g", 2);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "rect", 3);
        ɵngcc0.ɵɵelement(6, "g", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("id", ctx.filterId);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵattribute("width", ctx.view[0])("height", ctx.height);
    } }, styles: [".timeline .brush-background{fill:rgba(0,0,0,.05)}.timeline .brush .selection{fill:rgba(0,0,0,.1);stroke-width:1px;stroke:#888}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Timeline, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-timeline]',
                template: "\n    <svg:g\n      class=\"timeline\"\n      [attr.transform]=\"transform\">\n      <svg:filter [attr.id]=\"filterId\">\n        <svg:feColorMatrix in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\" />\n      </svg:filter>\n      <svg:g class=\"embedded-chart\">\n        <ng-content></ng-content>\n      </svg:g>\n      <svg:rect x=\"0\"\n        [attr.width]=\"view[0]\"\n        y=\"0\"\n        [attr.height]=\"height\"\n        class=\"brush-background\"\n      />\n      <svg:g class=\"brush\"></svg:g>\n    </svg:g>\n  ",
                styles: [".timeline .brush-background{fill:rgba(0,0,0,.05)}.timeline .brush .selection{fill:rgba(0,0,0,.1);stroke-width:1px;stroke:#888}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }, { type: typeof (_b = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _b : Object }]; }, { height: [{
            type: Input
        }], select: [{
            type: Output
        }], onDomainChange: [{
            type: Output
        }], view: [{
            type: Input
        }], state: [{
            type: Input
        }], results: [{
            type: Input
        }], scheme: [{
            type: Input
        }], customColors: [{
            type: Input
        }], legend: [{
            type: Input
        }], miniChart: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], scaleType: [{
            type: Input
        }] }); })();
    return Timeline;
}());

var AreaComponent = /** @class */ (function () {
    function AreaComponent(element) {
        this.opacity = 1;
        this.startOpacity = 0.5;
        this.endOpacity = 1;
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
        this.hasGradient = false;
        this.element = element.nativeElement;
    }
    AreaComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            this.loadAnimation();
            this.initialized = true;
        }
        else {
            this.update();
        }
    };
    AreaComponent.prototype.update = function () {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = "url(#" + this.gradientId + ")";
        if (this.gradient || this.stops) {
            this.gradientStops = this.getGradient();
            this.hasGradient = true;
        }
        else {
            this.hasGradient = false;
        }
        this.updatePathEl();
    };
    AreaComponent.prototype.loadAnimation = function () {
        this.areaPath = this.startingPath;
        setTimeout(this.update.bind(this), 100);
    };
    AreaComponent.prototype.updatePathEl = function () {
        var node = select(this.element).select('.area');
        if (this.animations) {
            node.transition().duration(750)
                .attr('d', this.path);
        }
        else {
            node.attr('d', this.path);
        }
    };
    AreaComponent.prototype.getGradient = function () {
        if (this.stops) {
            return this.stops;
        }
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: this.startOpacity
            },
            {
                offset: 100,
                color: this.fill,
                opacity: this.endOpacity
            }
        ];
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "path", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "startingPath", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "opacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "startOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "endOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "activeLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaComponent.prototype, "stops", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "select", void 0);
    AreaComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], AreaComponent);
AreaComponent.ɵfac = function AreaComponent_Factory(t) { return new (t || AreaComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
AreaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaComponent, selectors: [["g", "ngx-charts-area", ""]], inputs: { opacity: "opacity", startOpacity: "startOpacity", endOpacity: "endOpacity", gradient: "gradient", animations: "animations", data: "data", path: "path", startingPath: "startingPath", fill: "fill", activeLabel: "activeLabel", stops: "stops" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c17, decls: 2, vars: 5, consts: [[4, "ngIf"], [1, "area"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"]], template: function AreaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, AreaComponent__svg_defs_0_Template, 2, 2, "defs", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(1, "path", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("opacity", ctx.opacity);
        ɵngcc0.ɵɵattribute("d", ctx.areaPath)("fill", ctx.gradient ? ctx.gradientFill : ctx.fill);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-area]',
                template: "\n    <svg:defs *ngIf=\"gradient\">\n      <svg:g ngx-charts-svg-linear-gradient\n        orientation=\"vertical\"\n        [name]=\"gradientId\"\n        [stops]=\"gradientStops\"\n      />\n    </svg:defs>\n    <svg:path\n      class=\"area\"\n      [attr.d]=\"areaPath\"\n      [attr.fill]=\"gradient ? gradientFill : fill\"\n      [style.opacity]=\"opacity\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { opacity: [{
            type: Input
        }], startOpacity: [{
            type: Input
        }], endOpacity: [{
            type: Input
        }], gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], path: [{
            type: Input
        }], startingPath: [{
            type: Input
        }], fill: [{
            type: Input
        }], activeLabel: [{
            type: Input
        }], stops: [{
            type: Input
        }] }); })();
    return AreaComponent;
}());

// If we don't check whether 'window' and 'global' variables are defined,
// code will fail in browser/node with 'variable is undefined' error.
var root;
if (typeof window !== 'undefined') {
    root = window;
}
else if (typeof global !== 'undefined') {
    root = global;
}
// tslint:disable-next-line:variable-name
var MouseEvent = root.MouseEvent;
function createMouseEvent(name, bubbles, cancelable) {
    if (bubbles === void 0) { bubbles = false; }
    if (cancelable === void 0) { cancelable = true; }
    // Calling new of an event does not work correctly on IE. The following is a tested workaround
    // See https://stackoverflow.com/questions/27176983/dispatchevent-not-working-in-ie11
    if (typeof (MouseEvent) === 'function') {
        // Sane browsers
        return new MouseEvent(name, { bubbles: bubbles, cancelable: cancelable });
    }
    else {
        // IE
        var event$$1 = document.createEvent('MouseEvent');
        event$$1.initEvent(name, bubbles, cancelable);
        return event$$1;
    }
}

var TooltipArea = /** @class */ (function () {
    function TooltipArea() {
        this.anchorOpacity = 0;
        this.anchorPos = -1;
        this.anchorValues = [];
        this.showPercentage = false;
        this.tooltipDisabled = false;
        this.hover = new EventEmitter();
    }
    TooltipArea.prototype.getValues = function (xVal) {
        var results = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            var item = group.series.find(function (d) { return d.name.toString() === xVal.toString(); });
            var groupName = group.name;
            if (groupName instanceof Date) {
                groupName = groupName.toLocaleDateString();
            }
            if (item) {
                var label = item.name;
                var val = item.value;
                if (this.showPercentage) {
                    val = (item.d1 - item.d0).toFixed(2) + '%';
                }
                var color = void 0;
                if (this.colors.scaleType === 'linear') {
                    var v = val;
                    if (item.d1) {
                        v = item.d1;
                    }
                    color = this.colors.getColor(v);
                }
                else {
                    color = this.colors.getColor(group.name);
                }
                var data = Object.assign({}, item, {
                    value: val,
                    name: label,
                    series: groupName,
                    min: item.min,
                    max: item.max,
                    color: color
                });
                results.push(data);
            }
        }
        return results;
    };
    TooltipArea.prototype.mouseMove = function (event$$1) {
        var xPos = event$$1.pageX - event$$1.target.getBoundingClientRect().left;
        var closestIndex = this.findClosestPointIndex(xPos);
        var closestPoint = this.xSet[closestIndex];
        this.anchorPos = this.xScale(closestPoint);
        this.anchorPos = Math.max(0, this.anchorPos);
        this.anchorPos = Math.min(this.dims.width, this.anchorPos);
        this.anchorValues = this.getValues(closestPoint);
        if (this.anchorPos !== this.lastAnchorPos) {
            var ev = createMouseEvent('mouseleave');
            this.tooltipAnchor.nativeElement.dispatchEvent(ev);
            this.anchorOpacity = 0.7;
            this.hover.emit({
                value: closestPoint
            });
            this.showTooltip();
            this.lastAnchorPos = this.anchorPos;
        }
    };
    TooltipArea.prototype.findClosestPointIndex = function (xPos) {
        var minIndex = 0;
        var maxIndex = this.xSet.length - 1;
        var minDiff = Number.MAX_VALUE;
        var closestIndex = 0;
        while (minIndex <= maxIndex) {
            var currentIndex = ((minIndex + maxIndex) / 2) | 0;
            var currentElement = this.xScale(this.xSet[currentIndex]);
            var curDiff = Math.abs(currentElement - xPos);
            if (curDiff < minDiff) {
                minDiff = curDiff;
                closestIndex = currentIndex;
            }
            if (currentElement < xPos) {
                minIndex = currentIndex + 1;
            }
            else if (currentElement > xPos) {
                maxIndex = currentIndex - 1;
            }
            else {
                minDiff = 0;
                closestIndex = currentIndex;
                break;
            }
        }
        return closestIndex;
    };
    TooltipArea.prototype.showTooltip = function () {
        var event$$1 = createMouseEvent('mouseenter');
        this.tooltipAnchor.nativeElement.dispatchEvent(event$$1);
    };
    TooltipArea.prototype.hideTooltip = function () {
        var event$$1 = createMouseEvent('mouseleave');
        this.tooltipAnchor.nativeElement.dispatchEvent(event$$1);
        this.anchorOpacity = 0;
        this.lastAnchorPos = -1;
    };
    TooltipArea.prototype.getToolTipText = function (tooltipItem) {
        var result = '';
        if (tooltipItem.series !== undefined) {
            result += tooltipItem.series;
        }
        else {
            result += '???';
        }
        result += ': ';
        if (tooltipItem.value !== undefined) {
            result += tooltipItem.value.toLocaleString();
        }
        if (tooltipItem.min !== undefined || tooltipItem.max !== undefined) {
            result += ' (';
            if (tooltipItem.min !== undefined) {
                if (tooltipItem.max === undefined) {
                    result += '≥';
                }
                result += tooltipItem.min.toLocaleString();
                if (tooltipItem.max !== undefined) {
                    result += ' - ';
                }
            }
            else if (tooltipItem.max !== undefined) {
                result += '≤';
            }
            if (tooltipItem.max !== undefined) {
                result += tooltipItem.max.toLocaleString();
            }
            result += ')';
        }
        return result;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "xSet", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipArea.prototype, "showPercentage", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipArea.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], TooltipArea.prototype, "tooltipTemplate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "hover", void 0);
    __decorate([
        ViewChild('tooltipAnchor', { static: false }),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "tooltipAnchor", void 0);
TooltipArea.ɵfac = function TooltipArea_Factory(t) { return new (t || TooltipArea)(); };
TooltipArea.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipArea, selectors: [["g", "ngx-charts-tooltip-area", ""]], viewQuery: function TooltipArea_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c18, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipAnchor = _t.first);
    } }, inputs: { showPercentage: "showPercentage", tooltipDisabled: "tooltipDisabled", dims: "dims", xSet: "xSet", xScale: "xScale", yScale: "yScale", results: "results", colors: "colors", tooltipTemplate: "tooltipTemplate" }, outputs: { hover: "hover" }, attrs: _c19, decls: 6, vars: 18, consts: [["y", "0", 1, "tooltip-area", 2, "opacity", "0", "cursor", "auto", 3, "mousemove", "mouseleave"], ["defaultTooltipTemplate", ""], ["y", "0", "ngx-tooltip", "", 1, "tooltip-anchor", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipSpacing", "tooltipTemplate", "tooltipContext", "tooltipImmediateExit"], ["tooltipAnchor", ""], [1, "area-tooltip-container"], ["class", "tooltip-item", 4, "ngFor", "ngForOf"], [1, "tooltip-item"], [1, "tooltip-item-color"]], template: function TooltipArea_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵelementStart(1, "rect", 0);
        ɵngcc0.ɵɵlistener("mousemove", function TooltipArea_Template__svg_rect_mousemove_1_listener($event) { return ctx.mouseMove($event); })("mouseleave", function TooltipArea_Template__svg_rect_mouseleave_1_listener() { return ctx.hideTooltip(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, TooltipArea__xhtml_ng_template_2_Template, 2, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelement(4, "rect", 2, 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        var _r0 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("x", 0)("width", ctx.dims.width)("height", ctx.dims.height);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵstyleProp("opacity", ctx.anchorOpacity)("pointer-events", "none");
        ɵngcc0.ɵɵproperty("@animationState", ctx.anchorOpacity !== 0 ? "active" : "inactive")("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", "right")("tooltipType", "tooltip")("tooltipSpacing", 15)("tooltipTemplate", ctx.tooltipTemplate ? ctx.tooltipTemplate : _r0)("tooltipContext", ctx.anchorValues)("tooltipImmediateExit", true);
        ɵngcc0.ɵɵattribute("x", ctx.anchorPos)("width", 1)("height", ctx.dims.height);
    } }, directives: [TooltipDirective, ɵngcc1.NgForOf], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition('inactive => active', [
                    style({
                        opacity: 0
                    }),
                    animate(250, style({ opacity: 0.7 }))
                ]),
                transition('active => inactive', [
                    style({
                        opacity: 0.7
                    }),
                    animate(250, style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TooltipArea, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-tooltip-area]',
                template: "\n    <svg:g>\n      <svg:rect\n        class=\"tooltip-area\"\n        [attr.x]=\"0\"\n        y=\"0\"\n        [attr.width]=\"dims.width\"\n        [attr.height]=\"dims.height\"\n        style=\"opacity: 0; cursor: 'auto';\"\n        (mousemove)=\"mouseMove($event)\"\n        (mouseleave)=\"hideTooltip()\"\n      />\n      <xhtml:ng-template #defaultTooltipTemplate let-model=\"model\">\n        <xhtml:div class=\"area-tooltip-container\">\n          <xhtml:div *ngFor=\"let tooltipItem of model\" class=\"tooltip-item\">\n            <span class=\"tooltip-item-color\" [style.background-color]=\"tooltipItem.color\"> </span>\n            {{ getToolTipText(tooltipItem) }}\n          </xhtml:div>\n        </xhtml:div>\n      </xhtml:ng-template>\n      <svg:rect\n        #tooltipAnchor\n        [@animationState]=\"anchorOpacity !== 0 ? 'active' : 'inactive'\"\n        class=\"tooltip-anchor\"\n        [attr.x]=\"anchorPos\"\n        y=\"0\"\n        [attr.width]=\"1\"\n        [attr.height]=\"dims.height\"\n        [style.opacity]=\"anchorOpacity\"\n        [style.pointer-events]=\"'none'\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'right'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipSpacing]=\"15\"\n        [tooltipTemplate]=\"tooltipTemplate ? tooltipTemplate : defaultTooltipTemplate\"\n        [tooltipContext]=\"anchorValues\"\n        [tooltipImmediateExit]=\"true\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition('inactive => active', [
                            style({
                                opacity: 0
                            }),
                            animate(250, style({ opacity: 0.7 }))
                        ]),
                        transition('active => inactive', [
                            style({
                                opacity: 0.7
                            }),
                            animate(250, style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { showPercentage: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], hover: [{
            type: Output
        }], dims: [{
            type: Input
        }], xSet: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], results: [{
            type: Input
        }], colors: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }], tooltipAnchor: [{
            type: ViewChild,
            args: ['tooltipAnchor', { static: false }]
        }] }); })();
    return TooltipArea;
}());

// Robert Penner's easeOutExpo
function easeOutExpo(t, b, c, d) {
    return (c * (-Math.pow(2, (-10 * t) / d) + 1) * 1024) / 1023 + b;
}
/**
 * Counts from a number to the end incrementally.
 *
 * @export
 * @param {any} countFrom
 * @param {any} countTo
 * @param {any} countDecimals
 * @param {any} countDuration
 * @param {any} callback
 * @returns
 */
function count(countFrom, countTo, countDecimals, countDuration, callback) {
    var startVal = Number(countFrom);
    var endVal = Number(countTo);
    var countDown = startVal > endVal;
    var decimals = Math.max(0, countDecimals);
    var dec = Math.pow(10, decimals);
    var duration = Number(countDuration) * 1000;
    var startTime;
    function runCount(timestamp) {
        var frameVal;
        var progress = timestamp - startTime;
        if (countDown) {
            frameVal = startVal - easeOutExpo(progress, 0, startVal - endVal, duration);
        }
        else {
            frameVal = easeOutExpo(progress, startVal, endVal - startVal, duration);
        }
        if (countDown) {
            frameVal = frameVal < endVal ? endVal : frameVal;
        }
        else {
            frameVal = frameVal > endVal ? endVal : frameVal;
        }
        frameVal = Math.round(frameVal * dec) / dec;
        var tick = progress < duration;
        callback({
            value: frameVal,
            progress: progress,
            timestamp: timestamp,
            finished: !tick
        });
        if (tick) {
            return requestAnimationFrame(function (val) { return runCount(val); });
        }
    }
    return requestAnimationFrame(function (timestamp) {
        startTime = timestamp;
        return runCount(timestamp);
    });
}
/**
 * Determine decimals places
 *
 * @export
 * @param {any} countTo
 * @returns
 */
function decimalChecker(countTo) {
    var endVal = Number(countTo);
    if (endVal % 1 !== 0 && Math.abs(endVal) <= 10) {
        return 2;
    }
    return 0;
}

/**
 * Count up component
 *
 * Loosely inspired by:
 *  - https://github.com/izupet/angular2-counto
 *  - https://inorganik.github.io/countUp.js/
 *
 * @export
 * @class CountUpDirective
 */
var CountUpDirective = /** @class */ (function () {
    function CountUpDirective(cd, element) {
        this.cd = cd;
        this.countDuration = 1;
        this.countPrefix = '';
        this.countSuffix = '';
        this.countChange = new EventEmitter();
        this.countFinish = new EventEmitter();
        this.value = '';
        this._countDecimals = 0;
        this._countTo = 0;
        this._countFrom = 0;
        this.nativeElement = element.nativeElement;
    }
    Object.defineProperty(CountUpDirective.prototype, "countDecimals", {
        get: function () {
            if (this._countDecimals)
                return this._countDecimals;
            return decimalChecker(this.countTo);
        },
        set: function (val) {
            this._countDecimals = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CountUpDirective.prototype, "countTo", {
        get: function () {
            return this._countTo;
        },
        set: function (val) {
            this._countTo = parseFloat(val);
            this.start();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CountUpDirective.prototype, "countFrom", {
        get: function () {
            return this._countFrom;
        },
        set: function (val) {
            this._countFrom = parseFloat(val);
            this.start();
        },
        enumerable: true,
        configurable: true
    });
    CountUpDirective.prototype.ngOnDestroy = function () {
        cancelAnimationFrame(this.animationReq);
    };
    CountUpDirective.prototype.start = function () {
        var _this = this;
        cancelAnimationFrame(this.animationReq);
        var valueFormatting = this.valueFormatting || (function (value) { return "" + _this.countPrefix + value.toLocaleString() + _this.countSuffix; });
        var callback = function (_a) {
            var value = _a.value, progress = _a.progress, finished = _a.finished;
            _this.value = valueFormatting(value);
            _this.cd.markForCheck();
            if (!finished)
                _this.countChange.emit({ value: _this.value, progress: progress });
            if (finished)
                _this.countFinish.emit({ value: _this.value, progress: progress });
        };
        this.animationReq = count(this.countFrom, this.countTo, this.countDecimals, this.countDuration, callback);
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], CountUpDirective.prototype, "countDuration", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CountUpDirective.prototype, "countPrefix", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CountUpDirective.prototype, "countSuffix", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CountUpDirective.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], CountUpDirective.prototype, "countDecimals", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], CountUpDirective.prototype, "countTo", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], CountUpDirective.prototype, "countFrom", null);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CountUpDirective.prototype, "countChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CountUpDirective.prototype, "countFinish", void 0);
    CountUpDirective = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _a : Object, typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object])
    ], CountUpDirective);
CountUpDirective.ɵfac = function CountUpDirective_Factory(t) { return new (t || CountUpDirective)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _a : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object)); };
CountUpDirective.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CountUpDirective, selectors: [["", "ngx-charts-count-up", ""]], inputs: { countDuration: "countDuration", countPrefix: "countPrefix", countSuffix: "countSuffix", countDecimals: "countDecimals", countTo: "countTo", countFrom: "countFrom", valueFormatting: "valueFormatting" }, outputs: { countChange: "countChange", countFinish: "countFinish" }, attrs: _c20, decls: 1, vars: 1, template: function CountUpDirective_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate(ctx.value);
    } }, encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CountUpDirective, [{
        type: Component,
        args: [{
                selector: '[ngx-charts-count-up]',
                template: "{{value}}"
            }]
    }], function () { return [{ type: typeof (_a = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _a : Object }, { type: typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object }]; }, { countDuration: [{
            type: Input
        }], countPrefix: [{
            type: Input
        }], countSuffix: [{
            type: Input
        }], countChange: [{
            type: Output
        }], countFinish: [{
            type: Output
        }], countDecimals: [{
            type: Input
        }], countTo: [{
            type: Input
        }], countFrom: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }] }); })();
    return CountUpDirective;
}());

var COMPONENTS = [
    AreaComponent,
    BaseChartComponent,
    CountUpDirective,
    TooltipArea,
    ChartComponent,
    LegendComponent,
    LegendEntryComponent,
    ScaleLegendComponent,
    CircleComponent,
    CircleSeriesComponent,
    GridPanelComponent,
    GridPanelSeriesComponent,
    SvgLinearGradientComponent,
    SvgRadialGradientComponent,
    Timeline,
    AdvancedLegendComponent
];
var ChartCommonModule = /** @class */ (function () {
    function ChartCommonModule() {
    }
ChartCommonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ChartCommonModule });
ChartCommonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ChartCommonModule_Factory(t) { return new (t || ChartCommonModule)(); }, imports: [[
            CommonModule,
            AxesModule,
            TooltipModule
        ],
        CommonModule,
        AxesModule,
        TooltipModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChartCommonModule, { declarations: function () { return [AreaComponent,
        BaseChartComponent,
        CountUpDirective,
        TooltipArea,
        ChartComponent,
        LegendComponent,
        LegendEntryComponent,
        ScaleLegendComponent,
        CircleComponent,
        CircleSeriesComponent,
        GridPanelComponent,
        GridPanelSeriesComponent,
        SvgLinearGradientComponent,
        SvgRadialGradientComponent,
        Timeline,
        AdvancedLegendComponent]; }, imports: function () { return [CommonModule,
        AxesModule,
        TooltipModule]; }, exports: function () { return [CommonModule,
        AxesModule,
        TooltipModule,
        AreaComponent,
        BaseChartComponent,
        CountUpDirective,
        TooltipArea,
        ChartComponent,
        LegendComponent,
        LegendEntryComponent,
        ScaleLegendComponent,
        CircleComponent,
        CircleSeriesComponent,
        GridPanelComponent,
        GridPanelSeriesComponent,
        SvgLinearGradientComponent,
        SvgRadialGradientComponent,
        Timeline,
        AdvancedLegendComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartCommonModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    AxesModule,
                    TooltipModule
                ],
                declarations: COMPONENTS.slice(),
                exports: [
                    CommonModule,
                    AxesModule,
                    TooltipModule
                ].concat(COMPONENTS)
            }]
    }], function () { return []; }, null); })();
    return ChartCommonModule;
}());

function calculateViewDimensions(_a) {
    var width = _a.width, height = _a.height, margins = _a.margins, _b = _a.showXAxis, showXAxis = _b === void 0 ? false : _b, _c = _a.showYAxis, showYAxis = _c === void 0 ? false : _c, _d = _a.xAxisHeight, xAxisHeight = _d === void 0 ? 0 : _d, _e = _a.yAxisWidth, yAxisWidth = _e === void 0 ? 0 : _e, _f = _a.showXLabel, showXLabel = _f === void 0 ? false : _f, _g = _a.showYLabel, showYLabel = _g === void 0 ? false : _g, _h = _a.showLegend, showLegend = _h === void 0 ? false : _h, _j = _a.legendType, legendType = _j === void 0 ? 'ordinal' : _j, _k = _a.legendPosition, legendPosition = _k === void 0 ? 'right' : _k, _l = _a.columns, columns = _l === void 0 ? 12 : _l;
    var xOffset = margins[3];
    var chartWidth = width;
    var chartHeight = height - margins[0] - margins[2];
    if (showLegend && legendPosition === 'right') {
        if (legendType === 'ordinal') {
            columns -= 2;
        }
        else {
            columns -= 1;
        }
    }
    chartWidth = chartWidth * columns / 12;
    chartWidth = chartWidth - margins[1] - margins[3];
    if (showXAxis) {
        chartHeight -= 5;
        chartHeight -= xAxisHeight;
        if (showXLabel) {
            // text height + spacing between axis label and tick labels
            var offset = 25 + 5;
            chartHeight -= offset;
        }
    }
    if (showYAxis) {
        chartWidth -= 5;
        chartWidth -= yAxisWidth;
        xOffset += yAxisWidth;
        xOffset += 10;
        if (showYLabel) {
            // text height + spacing between axis label and tick labels
            var offset = 25 + 5;
            chartWidth -= offset;
            xOffset += offset;
        }
    }
    chartWidth = Math.max(0, chartWidth);
    chartHeight = Math.max(0, chartHeight);
    return {
        width: Math.floor(chartWidth),
        height: Math.floor(chartHeight),
        xOffset: Math.floor(xOffset)
    };
}

/**
 * Based on the data, return an array with unique values.
 *
 * @export
 * @returns array
 * @param results
 */
function getUniqueXDomainValues(results) {
    var valueSet = new Set();
    for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
        var result = results_1[_i];
        for (var _a = 0, _b = result.series; _a < _b.length; _a++) {
            var d = _b[_a];
            valueSet.add(d.name);
        }
    }
    return Array.from(valueSet);
}
/**
 * Get the scaleType of enumerable of values.
 * @param values
 * @returns {string} 'time', 'linear' or 'ordinal'
 */
function getScaleType(values, checkDateType) {
    if (checkDateType === void 0) { checkDateType = true; }
    if (checkDateType) {
        var allDates = values.every(function (value) { return value instanceof Date; });
        if (allDates) {
            return 'time';
        }
    }
    var allNumbers = values.every(function (value) { return typeof value === 'number'; });
    if (allNumbers) {
        return 'linear';
    }
    return 'ordinal';
}

var AreaChartComponent = /** @class */ (function (_super) {
    __extends(AreaChartComponent, _super);
    function AreaChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.baseValue = 'auto';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    AreaChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + ", " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    AreaChartComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    AreaChartComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
        }
        var min$$1;
        var max$$1;
        if (this.scaleType === 'time' || this.scaleType === 'linear') {
            min$$1 = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, values);
            max$$1 = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, values);
        }
        if (this.scaleType === 'time') {
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    AreaChartComponent.prototype.getYDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        var values = domain.slice();
        if (!this.autoScale) {
            values.push(0);
        }
        if (this.baseValue !== 'auto') {
            values.push(this.baseValue);
        }
        var min$$1 = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, values);
        var max$$1 = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, values);
        return [min$$1, max$$1];
    };
    AreaChartComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    AreaChartComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime();
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear();
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint().padding(0.1);
        }
        scale.range([0, width]).domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartComponent.prototype.getScaleType = function (values) {
        var date = true;
        var num = true;
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value = values_1[_i];
            if (!this.isDate(value)) {
                date = false;
            }
            if (typeof value !== 'number') {
                num = false;
            }
        }
        if (date) {
            return 'time';
        }
        if (num) {
            return 'linear';
        }
        return 'ordinal';
    };
    AreaChartComponent.prototype.isDate = function (value) {
        if (value instanceof Date) {
            return true;
        }
        return false;
    };
    AreaChartComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    AreaChartComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    AreaChartComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    AreaChartComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    AreaChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    AreaChartComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    AreaChartComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    AreaChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    AreaChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    AreaChartComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "state", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "baseValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AreaChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AreaChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AreaChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], AreaChartComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AreaChartComponent.prototype, "hideCircles", null);
AreaChartComponent.ɵfac = function AreaChartComponent_Factory(t) { return ɵAreaChartComponent_BaseFactory(t || AreaChartComponent); };
AreaChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaChartComponent, selectors: [["ngx-charts-area-chart"]], contentQueries: function AreaChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", state: "state", xAxis: "xAxis", yAxis: "yAxis", baseValue: "baseValue", autoScale: "autoScale", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "activeEntries", "scaleType", "gradient", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartComponent__svg_g_8_Template, 2, 10, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartComponent__svg_g_9_Template, 3, 9, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        AreaSeriesComponent,
        TooltipArea,
        CircleSeriesComponent,
        Timeline]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵAreaChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AreaChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-area-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [baseValue]=\"baseValue\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [gradient]=\"gradient\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [baseValue]=\"baseValue\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], state: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], baseValue: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return AreaChartComponent;
}(BaseChartComponent));

var AreaChartNormalizedComponent = /** @class */ (function (_super) {
    __extends(AreaChartNormalizedComponent, _super);
    function AreaChartNormalizedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    AreaChartNormalizedComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        var _loop_1 = function (i) {
            var val = this_1.xSet[i];
            var d0 = 0;
            var total = 0;
            for (var _i = 0, _a = this_1.results; _i < _a.length; _i++) {
                var group = _a[_i];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    total += d.value;
                }
            }
            for (var _b = 0, _c = this_1.results; _b < _c.length; _b++) {
                var group = _c[_b];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    d.d0 = d0;
                    d.d1 = d0 + d.value;
                    d0 += d.value;
                }
                else {
                    d = {
                        name: val,
                        value: 0,
                        d0: d0,
                        d1: d0
                    };
                    group.series.push(d);
                }
                if (total > 0) {
                    d.d0 = (d.d0 * 100) / total;
                    d.d1 = (d.d1 * 100) / total;
                }
                else {
                    d.d0 = 0;
                    d.d1 = 0;
                }
            }
        };
        var this_1 = this;
        for (var i = 0; i < this.xSet.length; i++) {
            _loop_1(i);
        }
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    AreaChartNormalizedComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    AreaChartNormalizedComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'time') {
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    AreaChartNormalizedComponent.prototype.getYDomain = function () {
        return [0, 100];
    };
    AreaChartNormalizedComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    AreaChartNormalizedComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime();
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear();
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint().padding(0.1);
        }
        scale.range([0, width]).domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartNormalizedComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartNormalizedComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    AreaChartNormalizedComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    AreaChartNormalizedComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    AreaChartNormalizedComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    AreaChartNormalizedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    AreaChartNormalizedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    AreaChartNormalizedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    AreaChartNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    AreaChartNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    AreaChartNormalizedComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartNormalizedComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartNormalizedComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartNormalizedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartNormalizedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartNormalizedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartNormalizedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartNormalizedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartNormalizedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartNormalizedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartNormalizedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AreaChartNormalizedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AreaChartNormalizedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AreaChartNormalizedComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], AreaChartNormalizedComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AreaChartNormalizedComponent.prototype, "hideCircles", null);
AreaChartNormalizedComponent.ɵfac = function AreaChartNormalizedComponent_Factory(t) { return ɵAreaChartNormalizedComponent_BaseFactory(t || AreaChartNormalizedComponent); };
AreaChartNormalizedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaChartNormalizedComponent, selectors: [["ngx-charts-area-chart-normalized"]], contentQueries: function AreaChartNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartNormalizedComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartNormalizedComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", "normalized", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "activeEntries", "gradient", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "showPercentage", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", "type", "stacked", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", "normalized", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartNormalizedComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartNormalizedComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartNormalizedComponent__svg_g_8_Template, 2, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartNormalizedComponent__svg_g_9_Template, 3, 10, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartNormalizedComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        AreaSeriesComponent,
        TooltipArea,
        CircleSeriesComponent,
        Timeline]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵAreaChartNormalizedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AreaChartNormalizedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaChartNormalizedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-area-chart-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [scaleType]=\"scaleType\"\n              [activeEntries]=\"activeEntries\"\n              [gradient]=\"gradient\"\n              normalized=\"true\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [showPercentage]=\"true\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                type=\"stacked\"\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            normalized=\"true\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return AreaChartNormalizedComponent;
}(BaseChartComponent));

var AreaChartStackedComponent = /** @class */ (function (_super) {
    __extends(AreaChartStackedComponent, _super);
    function AreaChartStackedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    AreaChartStackedComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        var _loop_1 = function (i) {
            var val = this_1.xSet[i];
            var d0 = 0;
            for (var _i = 0, _a = this_1.results; _i < _a.length; _i++) {
                var group = _a[_i];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    d.d0 = d0;
                    d.d1 = d0 + d.value;
                    d0 += d.value;
                }
                else {
                    d = {
                        name: val,
                        value: 0,
                        d0: d0,
                        d1: d0
                    };
                    group.series.push(d);
                }
            }
        };
        var this_1 = this;
        for (var i = 0; i < this.xSet.length; i++) {
            _loop_1(i);
        }
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    AreaChartStackedComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    AreaChartStackedComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
        }
        var min$$1;
        var max$$1;
        if (this.scaleType === 'time' || this.scaleType === 'linear') {
            min$$1 = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, values);
            max$$1 = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, values);
        }
        if (this.scaleType === 'time') {
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    AreaChartStackedComponent.prototype.getYDomain = function () {
        var _this = this;
        var domain = [];
        var _loop_2 = function (i) {
            var val = this_2.xSet[i];
            var sum = 0;
            for (var _i = 0, _a = this_2.results; _i < _a.length; _i++) {
                var group = _a[_i];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    sum += d.value;
                }
            }
            domain.push(sum);
        };
        var this_2 = this;
        for (var i = 0; i < this.xSet.length; i++) {
            _loop_2(i);
        }
        var min$$1 = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, domain);
        return [min$$1, max$$1];
    };
    AreaChartStackedComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    AreaChartStackedComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime();
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear();
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint().padding(0.1);
        }
        scale.range([0, width]).domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartStackedComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartStackedComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    AreaChartStackedComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    AreaChartStackedComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    AreaChartStackedComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    AreaChartStackedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    AreaChartStackedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    AreaChartStackedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    AreaChartStackedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    AreaChartStackedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    AreaChartStackedComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartStackedComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartStackedComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartStackedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartStackedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartStackedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartStackedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartStackedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartStackedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AreaChartStackedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AreaChartStackedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AreaChartStackedComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], AreaChartStackedComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AreaChartStackedComponent.prototype, "hideCircles", null);
AreaChartStackedComponent.ɵfac = function AreaChartStackedComponent_Factory(t) { return ɵAreaChartStackedComponent_BaseFactory(t || AreaChartStackedComponent); };
AreaChartStackedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaChartStackedComponent, selectors: [["ngx-charts-area-chart-stacked"]], contentQueries: function AreaChartStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartStackedComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartStackedComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", "stacked", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "activeEntries", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], ["ngx-charts-circle-series", "", "type", "stacked", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", "stacked", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartStackedComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartStackedComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartStackedComponent__svg_g_8_Template, 2, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartStackedComponent__svg_g_9_Template, 3, 10, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartStackedComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        AreaSeriesComponent,
        TooltipArea,
        CircleSeriesComponent,
        Timeline]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵAreaChartStackedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AreaChartStackedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaChartStackedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-area-chart-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [scaleType]=\"scaleType\"\n              [gradient]=\"gradient\"\n              [activeEntries]=\"activeEntries\"\n              stacked=\"true\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n              <svg:g\n                ngx-charts-circle-series\n                type=\"stacked\"\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            stacked=\"true\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return AreaChartStackedComponent;
}(BaseChartComponent));

var AreaSeriesComponent = /** @class */ (function () {
    function AreaSeriesComponent() {
        this.baseValue = 'auto';
        this.stacked = false;
        this.normalized = false;
        this.animations = true;
        this.select = new EventEmitter();
    }
    AreaSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    AreaSeriesComponent.prototype.update = function () {
        var _this = this;
        this.updateGradient();
        var currentArea;
        var startingArea;
        var xProperty = function (d) {
            var label = d.name;
            return _this.xScale(label);
        };
        if (this.stacked || this.normalized) {
            currentArea = area()
                .x(xProperty)
                .y0(function (d, i) { return _this.yScale(d.d0); })
                .y1(function (d, i) { return _this.yScale(d.d1); });
            startingArea = area()
                .x(xProperty)
                .y0(function (d) { return _this.yScale.range()[0]; })
                .y1(function (d) { return _this.yScale.range()[0]; });
        }
        else {
            currentArea = area()
                .x(xProperty)
                .y0(function () { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); })
                .y1(function (d) { return _this.yScale(d.value); });
            startingArea = area()
                .x(xProperty)
                .y0(function (d) { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); })
                .y1(function (d) { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); });
        }
        currentArea.curve(this.curve);
        startingArea.curve(this.curve);
        this.opacity = .8;
        var data = this.data.series;
        if (this.scaleType === 'linear') {
            data = sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            data = sortByTime(data, 'name');
        }
        else {
            data = sortByDomain(data, 'name', 'asc', this.xScale.domain());
        }
        this.path = currentArea(data);
        this.startingPath = startingArea(data);
    };
    AreaSeriesComponent.prototype.updateGradient = function () {
        if (this.colors.scaleType === 'linear') {
            this.hasGradient = true;
            if (this.stacked || this.normalized) {
                var d0values = this.data.series.map(function (d) { return d.d0; });
                var d1values = this.data.series.map(function (d) { return d.d1; });
                var max$$1 = Math.max.apply(Math, d1values);
                var min$$1 = Math.min.apply(Math, d0values);
                this.gradientStops = this.colors.getLinearGradientStops(max$$1, min$$1);
            }
            else {
                var values = this.data.series.map(function (d) { return d.value; });
                var max$$1 = Math.max.apply(Math, values);
                this.gradientStops = this.colors.getLinearGradientStops(max$$1);
            }
        }
        else {
            this.hasGradient = false;
            this.gradientStops = undefined;
        }
    };
    AreaSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    AreaSeriesComponent.prototype.isInactive = function (entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item === undefined;
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "baseValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaSeriesComponent.prototype, "stacked", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaSeriesComponent.prototype, "normalized", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "select", void 0);
AreaSeriesComponent.ɵfac = function AreaSeriesComponent_Factory(t) { return new (t || AreaSeriesComponent)(); };
AreaSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaSeriesComponent, selectors: [["g", "ngx-charts-area-series", ""]], inputs: { baseValue: "baseValue", stacked: "stacked", normalized: "normalized", animations: "animations", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", gradient: "gradient", curve: "curve", activeEntries: "activeEntries" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c24, decls: 1, vars: 12, consts: [["ngx-charts-area", "", 1, "area-series", 3, "data", "path", "fill", "stops", "startingPath", "opacity", "gradient", "animations"]], template: function AreaSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.path)("fill", ctx.colors.getColor(ctx.data.name))("stops", ctx.gradientStops)("startingPath", ctx.startingPath)("opacity", ctx.opacity)("gradient", ctx.gradient || ctx.hasGradient)("animations", ctx.animations);
    } }, directives: [AreaComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-area-series]',
                template: "\n    <svg:g ngx-charts-area\n      class=\"area-series\"\n      [data]=\"data\"\n      [path]=\"path\"\n      [fill]=\"colors.getColor(data.name)\"\n      [stops]=\"gradientStops\"\n      [startingPath]=\"startingPath\"\n      [opacity]=\"opacity\"\n      [gradient]=\"gradient || hasGradient\"\n      [animations]=\"animations\"\n      [class.active]=\"isActive(data)\"\n      [class.inactive]=\"isInactive(data)\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { baseValue: [{
            type: Input
        }], stacked: [{
            type: Input
        }], normalized: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], gradient: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }] }); })();
    return AreaSeriesComponent;
}());

var AreaChartModule = /** @class */ (function () {
    function AreaChartModule() {
    }
AreaChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AreaChartModule });
AreaChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AreaChartModule_Factory(t) { return new (t || AreaChartModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AreaChartModule, { declarations: [AreaChartComponent,
        AreaChartNormalizedComponent,
        AreaChartStackedComponent,
        AreaSeriesComponent], imports: [ChartCommonModule], exports: [AreaChartComponent,
        AreaChartNormalizedComponent,
        AreaChartStackedComponent,
        AreaSeriesComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AreaChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    AreaChartComponent,
                    AreaChartNormalizedComponent,
                    AreaChartStackedComponent,
                    AreaSeriesComponent
                ],
                exports: [
                    AreaChartComponent,
                    AreaChartNormalizedComponent,
                    AreaChartStackedComponent,
                    AreaSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return AreaChartModule;
}());

var BarComponent = /** @class */ (function () {
    function BarComponent(element) {
        this.roundEdges = true;
        this.gradient = false;
        this.offset = 0;
        this.isActive = false;
        this.animations = true;
        this.noBarWhenZero = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.initialized = false;
        this.hasGradient = false;
        this.hideBar = false;
        this.element = element.nativeElement;
    }
    BarComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            this.loadAnimation();
            this.initialized = true;
        }
        else {
            this.update();
        }
    };
    BarComponent.prototype.update = function () {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = "url(#" + this.gradientId + ")";
        if (this.gradient || this.stops) {
            this.gradientStops = this.getGradient();
            this.hasGradient = true;
        }
        else {
            this.hasGradient = false;
        }
        this.updatePathEl();
        this.checkToHideBar();
    };
    BarComponent.prototype.loadAnimation = function () {
        this.path = this.getStartingPath();
        setTimeout(this.update.bind(this), 100);
    };
    BarComponent.prototype.updatePathEl = function () {
        var node = select(this.element).select('.bar');
        var path = this.getPath();
        if (this.animations) {
            node
                .transition()
                .duration(500)
                .attr('d', path);
        }
        else {
            node.attr('d', path);
        }
    };
    BarComponent.prototype.getGradient = function () {
        if (this.stops) {
            return this.stops;
        }
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: this.getStartOpacity()
            },
            {
                offset: 100,
                color: this.fill,
                opacity: 1
            }
        ];
    };
    BarComponent.prototype.getStartingPath = function () {
        if (!this.animations) {
            return this.getPath();
        }
        var radius = this.getRadius();
        var path;
        if (this.roundEdges) {
            if (this.orientation === 'vertical') {
                radius = Math.min(this.height, radius);
                path = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
            }
            else if (this.orientation === 'horizontal') {
                radius = Math.min(this.width, radius);
                path = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
            }
        }
        else {
            if (this.orientation === 'vertical') {
                path = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
            }
            else if (this.orientation === 'horizontal') {
                path = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
            }
        }
        return path;
    };
    BarComponent.prototype.getPath = function () {
        var radius = this.getRadius();
        var path;
        if (this.roundEdges) {
            if (this.orientation === 'vertical') {
                radius = Math.min(this.height, radius);
                path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
            }
            else if (this.orientation === 'horizontal') {
                radius = Math.min(this.width, radius);
                path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
            }
        }
        else {
            path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
        }
        return path;
    };
    BarComponent.prototype.getRadius = function () {
        var radius = 0;
        if (this.roundEdges && this.height > 5 && this.width > 5) {
            radius = Math.floor(Math.min(5, this.height / 2, this.width / 2));
        }
        return radius;
    };
    BarComponent.prototype.getStartOpacity = function () {
        if (this.roundEdges) {
            return 0.2;
        }
        else {
            return 0.5;
        }
    };
    Object.defineProperty(BarComponent.prototype, "edges", {
        get: function () {
            var edges = [false, false, false, false];
            if (this.roundEdges) {
                if (this.orientation === 'vertical') {
                    if (this.data.value > 0) {
                        edges = [true, true, false, false];
                    }
                    else {
                        edges = [false, false, true, true];
                    }
                }
                else if (this.orientation === 'horizontal') {
                    if (this.data.value > 0) {
                        edges = [false, true, false, true];
                    }
                    else {
                        edges = [true, false, true, false];
                    }
                }
            }
            return edges;
        },
        enumerable: true,
        configurable: true
    });
    BarComponent.prototype.onMouseEnter = function () {
        this.activate.emit(this.data);
    };
    BarComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit(this.data);
    };
    BarComponent.prototype.checkToHideBar = function () {
        this.hideBar =
            this.noBarWhenZero &&
                ((this.orientation === 'vertical' && this.height === 0) ||
                    (this.orientation === 'horizontal' && this.width === 0));
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "offset", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "isActive", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarComponent.prototype, "stops", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarComponent.prototype, "ariaLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "deactivate", void 0);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], BarComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], BarComponent.prototype, "onMouseLeave", null);
    BarComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], BarComponent);
BarComponent.ɵfac = function BarComponent_Factory(t) { return new (t || BarComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
BarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarComponent, selectors: [["g", "ngx-charts-bar", ""]], hostBindings: function BarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function BarComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function BarComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { roundEdges: "roundEdges", gradient: "gradient", offset: "offset", isActive: "isActive", animations: "animations", noBarWhenZero: "noBarWhenZero", fill: "fill", data: "data", width: "width", height: "height", x: "x", y: "y", orientation: "orientation", stops: "stops", ariaLabel: "ariaLabel" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c25, decls: 2, vars: 8, consts: [[4, "ngIf"], ["stroke", "none", "role", "img", "tabIndex", "-1", 1, "bar", 3, "click"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"]], template: function BarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BarComponent__svg_defs_0_Template, 2, 3, "defs", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "path", 1);
        ɵngcc0.ɵɵlistener("click", function BarComponent_Template__svg_path_click_1_listener() { return ctx.select.emit(ctx.data); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive)("hidden", ctx.hideBar);
        ɵngcc0.ɵɵattribute("d", ctx.path)("aria-label", ctx.ariaLabel)("fill", ctx.hasGradient ? ctx.gradientFill : ctx.fill);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bar]',
                template: "\n    <svg:defs *ngIf=\"hasGradient\">\n      <svg:g ngx-charts-svg-linear-gradient [orientation]=\"orientation\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n    </svg:defs>\n    <svg:path\n      class=\"bar\"\n      stroke=\"none\"\n      role=\"img\"\n      tabIndex=\"-1\"\n      [class.active]=\"isActive\"\n      [class.hidden]=\"hideBar\"\n      [attr.d]=\"path\"\n      [attr.aria-label]=\"ariaLabel\"\n      [attr.fill]=\"hasGradient ? gradientFill : fill\"\n      (click)=\"select.emit(data)\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { roundEdges: [{
            type: Input
        }], gradient: [{
            type: Input
        }], offset: [{
            type: Input
        }], isActive: [{
            type: Input
        }], animations: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], fill: [{
            type: Input
        }], data: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], orientation: [{
            type: Input
        }], stops: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }] }); })();
    return BarComponent;
}());

var BarHorizontalComponent = /** @class */ (function (_super) {
    __extends(BarHorizontalComponent, _super);
    function BarHorizontalComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        return _this;
    }
    BarHorizontalComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        }
        this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontalComponent.prototype.getXScale = function () {
        this.xDomain = this.getXDomain();
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.xDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontalComponent.prototype.getYScale = function () {
        this.yDomain = this.getYDomain();
        var spacing = this.yDomain.length / (this.dims.height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .domain(this.yDomain);
    };
    BarHorizontalComponent.prototype.getXDomain = function () {
        var values = this.results.map(function (d) { return d.value; });
        var min$$1 = this.xScaleMin ? Math.min.apply(Math, [this.xScaleMin].concat(values)) : Math.min.apply(Math, [0].concat(values));
        var max$$1 = this.xScaleMax ? Math.max.apply(Math, [this.xScaleMax].concat(values)) : Math.max.apply(Math, [0].concat(values));
        return [min$$1, max$$1];
    };
    BarHorizontalComponent.prototype.getYDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    BarHorizontalComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    BarHorizontalComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.yDomain;
        }
        else {
            domain = this.xDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontalComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.yDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.xDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontalComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontalComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontalComponent.prototype.onDataLabelMaxWidthChanged = function (event$$1) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event$$1.size.width);
        }
        else {
            this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event$$1.size.width);
        }
        if (event$$1.index === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarHorizontalComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontalComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontalComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontalComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontalComponent.prototype, "tooltipTemplate", void 0);
BarHorizontalComponent.ɵfac = function BarHorizontalComponent_Factory(t) { return ɵBarHorizontalComponent_BaseFactory(t || BarHorizontalComponent); };
BarHorizontalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalComponent, selectors: [["ngx-charts-bar-horizontal"]], contentQueries: function BarHorizontalComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", xScaleMax: "xScaleMax", xScaleMin: "xScaleMin", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 25, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-horizontal", "", 3, "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "activeEntries", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"]], template: function BarHorizontalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(4, "g", 4);
        ɵngcc0.ɵɵlistener("select", function BarHorizontalComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("activate", function BarHorizontalComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function BarHorizontalComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); })("dataLabelWidthChanged", function BarHorizontalComponent_Template__svg_g_dataLabelWidthChanged_4_listener($event) { return ctx.onDataLabelMaxWidthChanged($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(22, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("noBarWhenZero", ctx.noBarWhenZero);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, SeriesHorizontal,
        XAxisComponent,
        YAxisComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵBarHorizontalComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarHorizontalComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-horizontal\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [series]=\"results\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [activeEntries]=\"activeEntries\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n          (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event)\"\n        ></svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontalComponent;
}(BaseChartComponent));

var BarHorizontal2DComponent = /** @class */ (function (_super) {
    __extends(BarHorizontal2DComponent, _super);
    function BarHorizontal2DComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.groupPadding = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        return _this;
    }
    BarHorizontal2DComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        }
        this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valuesDomain = this.getValueDomain();
        this.groupScale = this.getGroupScale();
        this.innerScale = this.getInnerScale();
        this.valueScale = this.getValueScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontal2DComponent.prototype.getGroupScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .paddingOuter(spacing / 2)
            .domain(this.groupDomain);
    };
    BarHorizontal2DComponent.prototype.getInnerScale = function () {
        var height = this.groupScale.bandwidth();
        var spacing = this.innerDomain.length / (height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, height])
            .paddingInner(spacing)
            .domain(this.innerDomain);
    };
    BarHorizontal2DComponent.prototype.getValueScale = function () {
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valuesDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontal2DComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarHorizontal2DComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarHorizontal2DComponent.prototype.getValueDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.xScaleMax ? Math.max.apply(Math, [this.xScaleMax].concat(domain)) : Math.max.apply(Math, [0].concat(domain));
        return [min$$1, max$$1];
    };
    BarHorizontal2DComponent.prototype.groupTransform = function (group) {
        return "translate(0, " + this.groupScale(group.label) + ")";
    };
    BarHorizontal2DComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarHorizontal2DComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarHorizontal2DComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valuesDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontal2DComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valuesDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontal2DComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontal2DComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontal2DComponent.prototype.onDataLabelMaxWidthChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event$$1.size.width);
        }
        else {
            this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event$$1.size.width);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarHorizontal2DComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontal2DComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontal2DComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontal2DComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontal2DComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontal2DComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontal2DComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontal2DComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontal2DComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontal2DComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "groupPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontal2DComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontal2DComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontal2DComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontal2DComponent.prototype, "tooltipTemplate", void 0);
BarHorizontal2DComponent.ɵfac = function BarHorizontal2DComponent_Factory(t) { return ɵBarHorizontal2DComponent_BaseFactory(t || BarHorizontal2DComponent); };
BarHorizontal2DComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontal2DComponent, selectors: [["ngx-charts-bar-horizontal-2d"]], contentQueries: function BarHorizontal2DComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", groupPadding: "groupPadding", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", xScaleMax: "xScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 17, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", "orient", "horizontal", 3, "xScale", "yScale", "data", "dims"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", 3, "xScale", "activeEntries", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"]], template: function BarHorizontal2DComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontal2DComponent__svg_g_3_Template, 1, 10, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontal2DComponent__svg_g_4_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(5, BarHorizontal2DComponent__svg_g_5_Template, 2, 17, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(14, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.valueScale)("yScale", ctx.groupScale)("data", ctx.results)("dims", ctx.dims);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent,
        GridPanelSeriesComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesHorizontal]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarHorizontal2DComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontal2DComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarHorizontal2DComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-2d',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-grid-panel-series\n          [xScale]=\"valueScale\"\n          [yScale]=\"groupScale\"\n          [data]=\"results\"\n          [dims]=\"dims\"\n          orient=\"horizontal\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"valueScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"groupScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            [xScale]=\"valueScale\"\n            [activeEntries]=\"activeEntries\"\n            [yScale]=\"innerScale\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [roundEdges]=\"roundEdges\"\n            [animations]=\"animations\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], groupPadding: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontal2DComponent;
}(BaseChartComponent));

var BarHorizontalNormalizedComponent = /** @class */ (function (_super) {
    __extends(BarHorizontalNormalizedComponent, _super);
    function BarHorizontalNormalizedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        return _this;
    }
    BarHorizontalNormalizedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontalNormalizedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarHorizontalNormalizedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarHorizontalNormalizedComponent.prototype.getValueDomain = function () {
        return [0, 100];
    };
    BarHorizontalNormalizedComponent.prototype.getYScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarHorizontalNormalizedComponent.prototype.getXScale = function () {
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontalNormalizedComponent.prototype.groupTransform = function (group) {
        return "translate(0, " + this.yScale(group.name) + ")";
    };
    BarHorizontalNormalizedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarHorizontalNormalizedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarHorizontalNormalizedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontalNormalizedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontalNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontalNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontalNormalizedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontalNormalizedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalNormalizedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalNormalizedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalNormalizedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalNormalizedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalNormalizedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalNormalizedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalNormalizedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalNormalizedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontalNormalizedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontalNormalizedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontalNormalizedComponent.prototype, "tooltipTemplate", void 0);
BarHorizontalNormalizedComponent.ɵfac = function BarHorizontalNormalizedComponent_Factory(t) { return ɵBarHorizontalNormalizedComponent_BaseFactory(t || BarHorizontalNormalizedComponent); };
BarHorizontalNormalizedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalNormalizedComponent, selectors: [["ngx-charts-bar-horizontal-normalized"]], contentQueries: function BarHorizontalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", "type", "normalized", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate"]], template: function BarHorizontalNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalNormalizedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalNormalizedComponent__svg_g_3_Template, 1, 8, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontalNormalizedComponent__svg_g_4_Template, 2, 14, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesHorizontal]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarHorizontalNormalizedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalNormalizedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarHorizontalNormalizedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            type=\"normalized\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontalNormalizedComponent;
}(BaseChartComponent));

var BarHorizontalStackedComponent = /** @class */ (function (_super) {
    __extends(BarHorizontalStackedComponent, _super);
    function BarHorizontalStackedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        return _this;
    }
    BarHorizontalStackedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        }
        this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontalStackedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarHorizontalStackedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarHorizontalStackedComponent.prototype.getValueDomain = function () {
        var domain = [];
        var smallest = 0;
        var biggest = 0;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            var smallestSum = 0;
            var biggestSum = 0;
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (d.value < 0) {
                    smallestSum += d.value;
                }
                else {
                    biggestSum += d.value;
                }
                smallest = d.value < smallest ? d.value : smallest;
                biggest = d.value > biggest ? d.value : biggest;
            }
            domain.push(smallestSum);
            domain.push(biggestSum);
        }
        domain.push(smallest);
        domain.push(biggest);
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.xScaleMax ? Math.max.apply(Math, [this.xScaleMax].concat(domain)) : Math.max.apply(Math, domain);
        return [min$$1, max$$1];
    };
    BarHorizontalStackedComponent.prototype.getYScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarHorizontalStackedComponent.prototype.getXScale = function () {
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontalStackedComponent.prototype.groupTransform = function (group) {
        return "translate(0, " + this.yScale(group.name) + ")";
    };
    BarHorizontalStackedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarHorizontalStackedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarHorizontalStackedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontalStackedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontalStackedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontalStackedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontalStackedComponent.prototype.onDataLabelMaxWidthChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event$$1.size.width);
        }
        else {
            this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event$$1.size.width);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarHorizontalStackedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontalStackedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalStackedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalStackedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalStackedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalStackedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalStackedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalStackedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalStackedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalStackedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalStackedComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontalStackedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontalStackedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontalStackedComponent.prototype, "tooltipTemplate", void 0);
BarHorizontalStackedComponent.ɵfac = function BarHorizontalStackedComponent_Factory(t) { return ɵBarHorizontalStackedComponent_BaseFactory(t || BarHorizontalStackedComponent); };
BarHorizontalStackedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalStackedComponent, selectors: [["ngx-charts-bar-horizontal-stacked"]], contentQueries: function BarHorizontalStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", xScaleMax: "xScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", "type", "stacked", 3, "xScale", "yScale", "colors", "series", "activeEntries", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"]], template: function BarHorizontalStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalStackedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalStackedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontalStackedComponent__svg_g_4_Template, 2, 16, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesHorizontal]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarHorizontalStackedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalStackedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarHorizontalStackedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            type=\"stacked\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [activeEntries]=\"activeEntries\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontalStackedComponent;
}(BaseChartComponent));

var BarVerticalComponent = /** @class */ (function (_super) {
    __extends(BarVerticalComponent, _super);
    function BarVerticalComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        return _this;
    }
    BarVerticalComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        }
        this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        if (this.showDataLabel) {
            this.dims.height -= this.dataLabelMaxHeight.negative;
        }
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
    };
    BarVerticalComponent.prototype.getXScale = function () {
        this.xDomain = this.getXDomain();
        var spacing = this.xDomain.length / (this.dims.width / this.barPadding + 1);
        return scaleBand()
            .range([0, this.dims.width])
            .paddingInner(spacing)
            .domain(this.xDomain);
    };
    BarVerticalComponent.prototype.getYScale = function () {
        this.yDomain = this.getYDomain();
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.yDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVerticalComponent.prototype.getXDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    BarVerticalComponent.prototype.getYDomain = function () {
        var values = this.results.map(function (d) { return d.value; });
        var min$$1 = this.yScaleMin ? Math.min.apply(Math, [this.yScaleMin].concat(values)) : Math.min.apply(Math, [0].concat(values));
        if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
            min$$1 = Math.min.apply(Math, [min$$1].concat(this.yAxisTicks));
        }
        var max$$1 = this.yScaleMax ? Math.max.apply(Math, [this.yScaleMax].concat(values)) : Math.max.apply(Math, [0].concat(values));
        if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
            max$$1 = Math.max.apply(Math, [max$$1].concat(this.yAxisTicks));
        }
        return [min$$1, max$$1];
    };
    BarVerticalComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    BarVerticalComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.xDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVerticalComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.xDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVerticalComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVerticalComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVerticalComponent.prototype.onDataLabelMaxHeightChanged = function (event$$1) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event$$1.size.height);
        }
        else {
            this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event$$1.size.height);
        }
        if (event$$1.index === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarVerticalComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVerticalComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVerticalComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVerticalComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVerticalComponent.prototype, "tooltipTemplate", void 0);
BarVerticalComponent.ɵfac = function BarVerticalComponent_Factory(t) { return ɵBarVerticalComponent_BaseFactory(t || BarVerticalComponent); };
BarVerticalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVerticalComponent, selectors: [["ngx-charts-bar-vertical"]], contentQueries: function BarVerticalComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", yScaleMax: "yScaleMax", yScaleMin: "yScaleMin", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 25, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-vertical", "", 3, "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "activeEntries", "roundEdges", "animations", "noBarWhenZero", "activate", "deactivate", "select", "dataLabelHeightChanged"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"]], template: function BarVerticalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(4, "g", 4);
        ɵngcc0.ɵɵlistener("activate", function BarVerticalComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function BarVerticalComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); })("select", function BarVerticalComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("dataLabelHeightChanged", function BarVerticalComponent_Template__svg_g_dataLabelHeightChanged_4_listener($event) { return ctx.onDataLabelMaxHeightChanged($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(22, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("noBarWhenZero", ctx.noBarWhenZero);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, SeriesVerticalComponent,
        XAxisComponent,
        YAxisComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵBarVerticalComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVerticalComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarVerticalComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-vertical\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [series]=\"results\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [activeEntries]=\"activeEntries\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n          (select)=\"onClick($event)\"\n          (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event)\"\n        ></svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVerticalComponent;
}(BaseChartComponent));

var BarVertical2DComponent = /** @class */ (function (_super) {
    __extends(BarVertical2DComponent, _super);
    function BarVertical2DComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.scaleType = 'ordinal';
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.groupPadding = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        return _this;
    }
    BarVertical2DComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        }
        this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.showDataLabel) {
            this.dims.height -= this.dataLabelMaxHeight.negative;
        }
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valuesDomain = this.getValueDomain();
        this.groupScale = this.getGroupScale();
        this.innerScale = this.getInnerScale();
        this.valueScale = this.getValueScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
    };
    BarVertical2DComponent.prototype.onDataLabelMaxHeightChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event$$1.size.height);
        }
        else {
            this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event$$1.size.height);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarVertical2DComponent.prototype.getGroupScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .paddingInner(spacing)
            .paddingOuter(spacing / 2)
            .domain(this.groupDomain);
    };
    BarVertical2DComponent.prototype.getInnerScale = function () {
        var width = this.groupScale.bandwidth();
        var spacing = this.innerDomain.length / (width / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, width])
            .paddingInner(spacing)
            .domain(this.innerDomain);
    };
    BarVertical2DComponent.prototype.getValueScale = function () {
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.valuesDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVertical2DComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarVertical2DComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarVertical2DComponent.prototype.getValueDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.yScaleMax ? Math.max.apply(Math, [this.yScaleMax].concat(domain)) : Math.max.apply(Math, [0].concat(domain));
        return [min$$1, max$$1];
    };
    BarVertical2DComponent.prototype.groupTransform = function (group) {
        return "translate(" + this.groupScale(group.label) + ", 0)";
    };
    BarVertical2DComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarVertical2DComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarVertical2DComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valuesDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVertical2DComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valuesDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVertical2DComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVertical2DComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVertical2DComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVertical2DComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVertical2DComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVertical2DComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVertical2DComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVertical2DComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVertical2DComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVertical2DComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVertical2DComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVertical2DComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "groupPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVertical2DComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVertical2DComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVertical2DComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVertical2DComponent.prototype, "tooltipTemplate", void 0);
BarVertical2DComponent.ɵfac = function BarVertical2DComponent_Factory(t) { return ɵBarVertical2DComponent_BaseFactory(t || BarVertical2DComponent); };
BarVertical2DComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVertical2DComponent, selectors: [["ngx-charts-bar-vertical-2d"]], contentQueries: function BarVertical2DComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", scaleType: "scaleType", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", groupPadding: "groupPadding", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", yScaleMax: "yScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 17, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", "orient", "vertical", 3, "xScale", "yScale", "data", "dims"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-vertical", "", 3, "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", 3, "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged"]], template: function BarVertical2DComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVertical2DComponent__svg_g_3_Template, 1, 10, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVertical2DComponent__svg_g_4_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(5, BarVertical2DComponent__svg_g_5_Template, 1, 17, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(14, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.groupScale)("yScale", ctx.valueScale)("data", ctx.results)("dims", ctx.dims);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent,
        GridPanelSeriesComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesVerticalComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarVertical2DComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVertical2DComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarVertical2DComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-2d',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-grid-panel-series\n          [xScale]=\"groupScale\"\n          [yScale]=\"valueScale\"\n          [data]=\"results\"\n          [dims]=\"dims\"\n          orient=\"vertical\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"groupScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"valueScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-vertical\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n          [activeEntries]=\"activeEntries\"\n          [xScale]=\"innerScale\"\n          [yScale]=\"valueScale\"\n          [colors]=\"colors\"\n          [series]=\"group.series\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [seriesName]=\"group.name\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (select)=\"onClick($event, group)\"\n          (activate)=\"onActivate($event, group)\"\n          (deactivate)=\"onDeactivate($event, group)\"\n          (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], groupPadding: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVertical2DComponent;
}(BaseChartComponent));

var BarVerticalNormalizedComponent = /** @class */ (function (_super) {
    __extends(BarVerticalNormalizedComponent, _super);
    function BarVerticalNormalizedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        return _this;
    }
    BarVerticalNormalizedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarVerticalNormalizedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarVerticalNormalizedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarVerticalNormalizedComponent.prototype.getValueDomain = function () {
        return [0, 100];
    };
    BarVerticalNormalizedComponent.prototype.getXScale = function () {
        var spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarVerticalNormalizedComponent.prototype.getYScale = function () {
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVerticalNormalizedComponent.prototype.groupTransform = function (group) {
        return "translate(" + this.xScale(group.name) + ", 0)";
    };
    BarVerticalNormalizedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarVerticalNormalizedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarVerticalNormalizedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVerticalNormalizedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVerticalNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVerticalNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVerticalNormalizedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVerticalNormalizedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalNormalizedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalNormalizedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalNormalizedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalNormalizedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalNormalizedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalNormalizedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalNormalizedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalNormalizedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVerticalNormalizedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVerticalNormalizedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVerticalNormalizedComponent.prototype, "tooltipTemplate", void 0);
BarVerticalNormalizedComponent.ɵfac = function BarVerticalNormalizedComponent_Factory(t) { return ɵBarVerticalNormalizedComponent_BaseFactory(t || BarVerticalNormalizedComponent); };
BarVerticalNormalizedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVerticalNormalizedComponent, selectors: [["ngx-charts-bar-vertical-normalized"]], contentQueries: function BarVerticalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", "type", "normalized", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate"]], template: function BarVerticalNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalNormalizedComponent__svg_g_2_Template, 1, 9, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalNormalizedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVerticalNormalizedComponent__svg_g_4_Template, 2, 14, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesVerticalComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarVerticalNormalizedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVerticalNormalizedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarVerticalNormalizedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-vertical\n            type=\"normalized\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVerticalNormalizedComponent;
}(BaseChartComponent));

var BarVerticalStackedComponent = /** @class */ (function (_super) {
    __extends(BarVerticalStackedComponent, _super);
    function BarVerticalStackedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        return _this;
    }
    BarVerticalStackedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        }
        this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.showDataLabel) {
            this.dims.height -= this.dataLabelMaxHeight.negative;
        }
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
    };
    BarVerticalStackedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarVerticalStackedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarVerticalStackedComponent.prototype.getValueDomain = function () {
        var domain = [];
        var smallest = 0;
        var biggest = 0;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            var smallestSum = 0;
            var biggestSum = 0;
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (d.value < 0) {
                    smallestSum += d.value;
                }
                else {
                    biggestSum += d.value;
                }
                smallest = d.value < smallest ? d.value : smallest;
                biggest = d.value > biggest ? d.value : biggest;
            }
            domain.push(smallestSum);
            domain.push(biggestSum);
        }
        domain.push(smallest);
        domain.push(biggest);
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.yScaleMax ? Math.max.apply(Math, [this.yScaleMax].concat(domain)) : Math.max.apply(Math, domain);
        return [min$$1, max$$1];
    };
    BarVerticalStackedComponent.prototype.getXScale = function () {
        var spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarVerticalStackedComponent.prototype.getYScale = function () {
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVerticalStackedComponent.prototype.onDataLabelMaxHeightChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event$$1.size.height);
        }
        else {
            this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event$$1.size.height);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarVerticalStackedComponent.prototype.groupTransform = function (group) {
        return "translate(" + this.xScale(group.name) + ", 0)";
    };
    BarVerticalStackedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarVerticalStackedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarVerticalStackedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVerticalStackedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVerticalStackedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVerticalStackedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVerticalStackedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVerticalStackedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalStackedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalStackedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalStackedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalStackedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalStackedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalStackedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalStackedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalStackedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalStackedComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVerticalStackedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVerticalStackedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVerticalStackedComponent.prototype, "tooltipTemplate", void 0);
BarVerticalStackedComponent.ɵfac = function BarVerticalStackedComponent_Factory(t) { return ɵBarVerticalStackedComponent_BaseFactory(t || BarVerticalStackedComponent); };
BarVerticalStackedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVerticalStackedComponent, selectors: [["ngx-charts-bar-vertical-stacked"]], contentQueries: function BarVerticalStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", yScaleMax: "yScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", "type", "stacked", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged"]], template: function BarVerticalStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalStackedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalStackedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVerticalStackedComponent__svg_g_4_Template, 2, 16, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        SeriesVerticalComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarVerticalStackedComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BarVerticalStackedComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarVerticalStackedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-vertical\n            type=\"stacked\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVerticalStackedComponent;
}(BaseChartComponent));

var D0Types;
(function (D0Types) {
    D0Types["positive"] = "positive";
    D0Types["negative"] = "negative";
})(D0Types || (D0Types = {}));
var SeriesVerticalComponent = /** @class */ (function () {
    function SeriesVerticalComponent() {
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.animations = true;
        this.showDataLabel = false;
        this.noBarWhenZero = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dataLabelHeightChanged = new EventEmitter();
        this.barsForDataLabels = [];
    }
    SeriesVerticalComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    SeriesVerticalComponent.prototype.update = function () {
        var _this = this;
        var _a;
        this.updateTooltipSettings();
        var width;
        if (this.series.length) {
            width = this.xScale.bandwidth();
        }
        width = Math.round(width);
        var yScaleMin = Math.max(this.yScale.domain()[0], 0);
        var d0 = (_a = {},
            _a[D0Types.positive] = 0,
            _a[D0Types.negative] = 0,
            _a);
        var d0Type = D0Types.positive;
        var total;
        if (this.type === 'normalized') {
            total = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
        }
        this.bars = this.series.map(function (d, index) {
            var value = d.value;
            var label = _this.getLabel(d);
            var formattedLabel = formatLabel(label);
            var roundEdges = _this.roundEdges;
            d0Type = value > 0 ? D0Types.positive : D0Types.negative;
            var bar = {
                value: value,
                label: label,
                roundEdges: roundEdges,
                data: d,
                width: width,
                formattedLabel: formattedLabel,
                height: 0,
                x: 0,
                y: 0
            };
            if (_this.type === 'standard') {
                bar.height = Math.abs(_this.yScale(value) - _this.yScale(yScaleMin));
                bar.x = _this.xScale(label);
                if (value < 0) {
                    bar.y = _this.yScale(0);
                }
                else {
                    bar.y = _this.yScale(value);
                }
            }
            else if (_this.type === 'stacked') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                bar.height = _this.yScale(offset0) - _this.yScale(offset1);
                bar.x = 0;
                bar.y = _this.yScale(offset1);
                bar.offset0 = offset0;
                bar.offset1 = offset1;
            }
            else if (_this.type === 'normalized') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                if (total > 0) {
                    offset0 = (offset0 * 100) / total;
                    offset1 = (offset1 * 100) / total;
                }
                else {
                    offset0 = 0;
                    offset1 = 0;
                }
                bar.height = _this.yScale(offset0) - _this.yScale(offset1);
                bar.x = 0;
                bar.y = _this.yScale(offset1);
                bar.offset0 = offset0;
                bar.offset1 = offset1;
                value = (offset1 - offset0).toFixed(2) + '%';
            }
            if (_this.colors.scaleType === 'ordinal') {
                bar.color = _this.colors.getColor(label);
            }
            else {
                if (_this.type === 'standard') {
                    bar.color = _this.colors.getColor(value);
                    bar.gradientStops = _this.colors.getLinearGradientStops(value);
                }
                else {
                    bar.color = _this.colors.getColor(bar.offset1);
                    bar.gradientStops = _this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
                }
            }
            var tooltipLabel = formattedLabel;
            bar.ariaLabel = formattedLabel + ' ' + value.toLocaleString();
            if (_this.seriesName) {
                tooltipLabel = _this.seriesName + " \u2022 " + formattedLabel;
                bar.data.series = _this.seriesName;
                bar.ariaLabel = _this.seriesName + ' ' + bar.ariaLabel;
            }
            bar.tooltipText = _this.tooltipDisabled
                ? undefined
                : "\n        <span class=\"tooltip-label\">" + tooltipLabel + "</span>\n        <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n      ";
            return bar;
        });
        this.updateDataLabels();
    };
    SeriesVerticalComponent.prototype.updateDataLabels = function () {
        var _this = this;
        if (this.type === 'stacked') {
            this.barsForDataLabels = [];
            var section = {};
            section.series = this.seriesName;
            var totalPositive = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d > 0 ? sum + d : sum); }, 0);
            var totalNegative = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d < 0 ? sum + d : sum); }, 0);
            section.total = totalPositive + totalNegative;
            section.x = 0;
            section.y = 0;
            if (section.total > 0) {
                section.height = this.yScale(totalPositive);
            }
            else {
                section.height = this.yScale(totalNegative);
            }
            section.width = this.xScale.bandwidth();
            this.barsForDataLabels.push(section);
        }
        else {
            this.barsForDataLabels = this.series.map(function (d) {
                var section = {};
                section.series = _this.seriesName ? _this.seriesName : d.label;
                section.total = d.value;
                section.x = _this.xScale(d.label);
                section.y = _this.yScale(0);
                section.height = _this.yScale(section.total) - _this.yScale(0);
                section.width = _this.xScale.bandwidth();
                return section;
            });
        }
    };
    SeriesVerticalComponent.prototype.updateTooltipSettings = function () {
        this.tooltipPlacement = this.tooltipDisabled ? undefined : 'top';
        this.tooltipType = this.tooltipDisabled ? undefined : 'tooltip';
    };
    SeriesVerticalComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    SeriesVerticalComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    SeriesVerticalComponent.prototype.getLabel = function (dataItem) {
        if (dataItem.label) {
            return dataItem.label;
        }
        return dataItem.name;
    };
    SeriesVerticalComponent.prototype.trackBy = function (index, bar) {
        return bar.label;
    };
    SeriesVerticalComponent.prototype.trackDataLabelBy = function (index, barLabel) {
        return index + '#' + barLabel.series + '#' + barLabel.total;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "series", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], SeriesVerticalComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SeriesVerticalComponent.prototype, "seriesName", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], SeriesVerticalComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "dataLabelHeightChanged", void 0);
SeriesVerticalComponent.ɵfac = function SeriesVerticalComponent_Factory(t) { return new (t || SeriesVerticalComponent)(); };
SeriesVerticalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesVerticalComponent, selectors: [["g", "ngx-charts-series-vertical", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", animations: "animations", showDataLabel: "showDataLabel", noBarWhenZero: "noBarWhenZero", dims: "dims", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", dataLabelFormatting: "dataLabelFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelHeightChanged: "dataLabelHeightChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c26, decls: 2, vars: 3, consts: [["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged"]], template: function SeriesVerticalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SeriesVerticalComponent__svg_g_0_Template, 1, 22, "g", 0);
        ɵngcc0.ɵɵtemplate(1, SeriesVerticalComponent__svg_g_1_Template, 2, 2, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.bars)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showDataLabel);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, BarComponent,
        TooltipDirective,
        BarLabelComponent]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SeriesVerticalComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-series-vertical]',
                template: "\n    <svg:g\n      ngx-charts-bar\n      *ngFor=\"let bar of bars; trackBy: trackBy\"\n      [@animationState]=\"'active'\"\n      [@.disabled]=\"!animations\"\n      [width]=\"bar.width\"\n      [height]=\"bar.height\"\n      [x]=\"bar.x\"\n      [y]=\"bar.y\"\n      [fill]=\"bar.color\"\n      [stops]=\"bar.gradientStops\"\n      [data]=\"bar.data\"\n      [orientation]=\"'vertical'\"\n      [roundEdges]=\"bar.roundEdges\"\n      [gradient]=\"gradient\"\n      [ariaLabel]=\"bar.ariaLabel\"\n      [isActive]=\"isActive(bar.data)\"\n      (select)=\"onClick($event)\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"tooltipPlacement\"\n      [tooltipType]=\"tooltipType\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"bar.data\"\n      [noBarWhenZero]=\"noBarWhenZero\"\n      [animations]=\"animations\"\n    ></svg:g>\n    <svg:g *ngIf=\"showDataLabel\">\n      <svg:g\n        ngx-charts-bar-label\n        *ngFor=\"let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy\"\n        [barX]=\"b.x\"\n        [barY]=\"b.y\"\n        [barWidth]=\"b.width\"\n        [barHeight]=\"b.height\"\n        [value]=\"b.total\"\n        [valueFormatting]=\"dataLabelFormatting\"\n        [orientation]=\"'vertical'\"\n        (dimensionsChanged)=\"dataLabelHeightChanged.emit({ size: $event, index: i })\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dataLabelHeightChanged: [{
            type: Output
        }], dims: [{
            type: Input
        }], series: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], gradient: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], seriesName: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }] }); })();
    return SeriesVerticalComponent;
}());

var SeriesHorizontal = /** @class */ (function () {
    function SeriesHorizontal() {
        this.barsForDataLabels = [];
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.animations = true;
        this.showDataLabel = false;
        this.noBarWhenZero = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dataLabelWidthChanged = new EventEmitter();
    }
    SeriesHorizontal.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    SeriesHorizontal.prototype.update = function () {
        var _this = this;
        var _a;
        this.updateTooltipSettings();
        var d0 = (_a = {},
            _a[D0Types.positive] = 0,
            _a[D0Types.negative] = 0,
            _a);
        var d0Type;
        d0Type = D0Types.positive;
        var total;
        if (this.type === 'normalized') {
            total = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
        }
        var xScaleMin = Math.max(this.xScale.domain()[0], 0);
        this.bars = this.series.map(function (d, index) {
            var value = d.value;
            var label = _this.getLabel(d);
            var formattedLabel = formatLabel(label);
            var roundEdges = _this.roundEdges;
            d0Type = value > 0 ? D0Types.positive : D0Types.negative;
            var bar = {
                value: value,
                label: label,
                roundEdges: roundEdges,
                data: d,
                formattedLabel: formattedLabel
            };
            bar.height = _this.yScale.bandwidth();
            if (_this.type === 'standard') {
                bar.width = Math.abs(_this.xScale(value) - _this.xScale(xScaleMin));
                if (value < 0) {
                    bar.x = _this.xScale(value);
                }
                else {
                    bar.x = _this.xScale(xScaleMin);
                }
                bar.y = _this.yScale(label);
            }
            else if (_this.type === 'stacked') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                bar.width = _this.xScale(offset1) - _this.xScale(offset0);
                bar.x = _this.xScale(offset0);
                bar.y = 0;
                bar.offset0 = offset0;
                bar.offset1 = offset1;
            }
            else if (_this.type === 'normalized') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                if (total > 0) {
                    offset0 = (offset0 * 100) / total;
                    offset1 = (offset1 * 100) / total;
                }
                else {
                    offset0 = 0;
                    offset1 = 0;
                }
                bar.width = _this.xScale(offset1) - _this.xScale(offset0);
                bar.x = _this.xScale(offset0);
                bar.y = 0;
                bar.offset0 = offset0;
                bar.offset1 = offset1;
                value = (offset1 - offset0).toFixed(2) + '%';
            }
            if (_this.colors.scaleType === 'ordinal') {
                bar.color = _this.colors.getColor(label);
            }
            else {
                if (_this.type === 'standard') {
                    bar.color = _this.colors.getColor(value);
                    bar.gradientStops = _this.colors.getLinearGradientStops(value);
                }
                else {
                    bar.color = _this.colors.getColor(bar.offset1);
                    bar.gradientStops = _this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
                }
            }
            var tooltipLabel = formattedLabel;
            bar.ariaLabel = formattedLabel + ' ' + value.toLocaleString();
            if (_this.seriesName) {
                tooltipLabel = _this.seriesName + " \u2022 " + formattedLabel;
                bar.data.series = _this.seriesName;
                bar.ariaLabel = _this.seriesName + ' ' + bar.ariaLabel;
            }
            bar.tooltipText = _this.tooltipDisabled
                ? undefined
                : "\n        <span class=\"tooltip-label\">" + tooltipLabel + "</span>\n        <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n      ";
            return bar;
        });
        this.updateDataLabels();
    };
    SeriesHorizontal.prototype.updateDataLabels = function () {
        var _this = this;
        if (this.type === 'stacked') {
            this.barsForDataLabels = [];
            var section = {};
            section.series = this.seriesName;
            var totalPositive = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d > 0 ? sum + d : sum); }, 0);
            var totalNegative = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d < 0 ? sum + d : sum); }, 0);
            section.total = totalPositive + totalNegative;
            section.x = 0;
            section.y = 0;
            // if total is positive then we show it on the right, otherwise on the left
            if (section.total > 0) {
                section.width = this.xScale(totalPositive);
            }
            else {
                section.width = this.xScale(totalNegative);
            }
            section.height = this.yScale.bandwidth();
            this.barsForDataLabels.push(section);
        }
        else {
            this.barsForDataLabels = this.series.map(function (d) {
                var section = {};
                section.series = _this.seriesName ? _this.seriesName : d.label;
                section.total = d.value;
                section.x = _this.xScale(0);
                section.y = _this.yScale(d.label);
                section.width = _this.xScale(section.total) - _this.xScale(0);
                section.height = _this.yScale.bandwidth();
                return section;
            });
        }
    };
    SeriesHorizontal.prototype.updateTooltipSettings = function () {
        this.tooltipPlacement = this.tooltipDisabled ? undefined : 'top';
        this.tooltipType = this.tooltipDisabled ? undefined : 'tooltip';
    };
    SeriesHorizontal.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    SeriesHorizontal.prototype.getLabel = function (dataItem) {
        if (dataItem.label) {
            return dataItem.label;
        }
        return dataItem.name;
    };
    SeriesHorizontal.prototype.trackBy = function (index, bar) {
        return bar.label;
    };
    SeriesHorizontal.prototype.trackDataLabelBy = function (index, barLabel) {
        return index + '#' + barLabel.series + '#' + barLabel.total;
    };
    SeriesHorizontal.prototype.click = function (data) {
        this.select.emit(data);
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "series", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], SeriesHorizontal.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SeriesHorizontal.prototype, "seriesName", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], SeriesHorizontal.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "dataLabelWidthChanged", void 0);
SeriesHorizontal.ɵfac = function SeriesHorizontal_Factory(t) { return new (t || SeriesHorizontal)(); };
SeriesHorizontal.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesHorizontal, selectors: [["g", "ngx-charts-series-horizontal", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", animations: "animations", showDataLabel: "showDataLabel", noBarWhenZero: "noBarWhenZero", dims: "dims", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", dataLabelFormatting: "dataLabelFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelWidthChanged: "dataLabelWidthChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c27, decls: 2, vars: 3, consts: [["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged"]], template: function SeriesHorizontal_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SeriesHorizontal__svg_g_0_Template, 1, 21, "g", 0);
        ɵngcc0.ɵɵtemplate(1, SeriesHorizontal__svg_g_1_Template, 2, 2, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.bars)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showDataLabel);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, BarComponent,
        TooltipDirective,
        BarLabelComponent]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SeriesHorizontal, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-series-horizontal]',
                template: "\n    <svg:g\n      ngx-charts-bar\n      *ngFor=\"let bar of bars; trackBy: trackBy\"\n      [@animationState]=\"'active'\"\n      [width]=\"bar.width\"\n      [height]=\"bar.height\"\n      [x]=\"bar.x\"\n      [y]=\"bar.y\"\n      [fill]=\"bar.color\"\n      [stops]=\"bar.gradientStops\"\n      [data]=\"bar.data\"\n      [orientation]=\"'horizontal'\"\n      [roundEdges]=\"bar.roundEdges\"\n      (select)=\"click($event)\"\n      [gradient]=\"gradient\"\n      [isActive]=\"isActive(bar.data)\"\n      [ariaLabel]=\"bar.ariaLabel\"\n      [animations]=\"animations\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"tooltipPlacement\"\n      [tooltipType]=\"tooltipType\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"bar.data\"\n      [noBarWhenZero]=\"noBarWhenZero\"\n    ></svg:g>\n    <svg:g *ngIf=\"showDataLabel\">\n      <svg:g\n        ngx-charts-bar-label\n        *ngFor=\"let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy\"\n        [barX]=\"b.x\"\n        [barY]=\"b.y\"\n        [barWidth]=\"b.width\"\n        [barHeight]=\"b.height\"\n        [value]=\"b.total\"\n        [valueFormatting]=\"dataLabelFormatting\"\n        [orientation]=\"'horizontal'\"\n        (dimensionsChanged)=\"dataLabelWidthChanged.emit({ size: $event, index: i })\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dataLabelWidthChanged: [{
            type: Output
        }], dims: [{
            type: Input
        }], series: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], gradient: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], seriesName: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }] }); })();
    return SeriesHorizontal;
}());

var BarLabelComponent = /** @class */ (function () {
    function BarLabelComponent(element) {
        this.dimensionsChanged = new EventEmitter();
        this.horizontalPadding = 2;
        this.verticalPadding = 5;
        this.element = element.nativeElement;
    }
    BarLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    BarLabelComponent.prototype.getSize = function () {
        var h = this.element.getBoundingClientRect().height;
        var w = this.element.getBoundingClientRect().width;
        return { height: h, width: w, negative: this.value < 0 };
    };
    BarLabelComponent.prototype.ngAfterViewInit = function () {
        this.dimensionsChanged.emit(this.getSize());
    };
    BarLabelComponent.prototype.update = function () {
        if (this.valueFormatting) {
            this.formatedValue = this.valueFormatting(this.value);
        }
        else {
            this.formatedValue = formatLabel(this.value);
        }
        if (this.orientation === 'horizontal') {
            this.x = this.barX + this.barWidth;
            if (this.value < 0) {
                this.x = this.x - this.horizontalPadding;
                this.textAnchor = 'end';
            }
            else {
                this.x = this.x + this.horizontalPadding;
                this.textAnchor = 'start';
            }
            this.y = this.barY + this.barHeight / 2;
        }
        else {
            this.x = this.barX + this.barWidth / 2;
            this.y = this.barY + this.barHeight;
            if (this.value < 0) {
                this.y = this.y + this.verticalPadding;
                this.textAnchor = 'end';
            }
            else {
                this.y = this.y - this.verticalPadding;
                this.textAnchor = 'start';
            }
            this.transform = "rotate(-45, " + this.x + " , " + this.y + ")";
        }
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barX", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barY", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "orientation", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarLabelComponent.prototype, "dimensionsChanged", void 0);
    BarLabelComponent = __decorate([ __metadata("design:paramtypes", [typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object])
    ], BarLabelComponent);
BarLabelComponent.ɵfac = function BarLabelComponent_Factory(t) { return new (t || BarLabelComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object)); };
BarLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarLabelComponent, selectors: [["g", "ngx-charts-bar-label", ""]], inputs: { value: "value", valueFormatting: "valueFormatting", barX: "barX", barY: "barY", barWidth: "barWidth", barHeight: "barHeight", orientation: "orientation" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c28, decls: 2, vars: 5, consts: [["alignment-baseline", "middle", 1, "textDataLabel"]], template: function BarLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "text", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("text-anchor", ctx.textAnchor)("transform", ctx.transform)("x", ctx.x)("y", ctx.y);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.formatedValue, " ");
    } }, styles: [".textDataLabel[_ngcontent-%COMP%]{font-size:11px}"], changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bar-label]',
                template: "  \n    <svg:text   \n      class=\"textDataLabel\" \n      alignment-baseline=\"middle\"     \n      [attr.text-anchor]=\"textAnchor\"\n      [attr.transform]=\"transform\"\n      [attr.x]=\"x\" \n      [attr.y]=\"y\">\n      {{formatedValue}}     \n    </svg:text>          \n\n  ",
                styles: [".textDataLabel{font-size:11px}"],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object }]; }, { dimensionsChanged: [{
            type: Output
        }], value: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], barX: [{
            type: Input
        }], barY: [{
            type: Input
        }], barWidth: [{
            type: Input
        }], barHeight: [{
            type: Input
        }], orientation: [{
            type: Input
        }] }); })();
    return BarLabelComponent;
}());

var BarChartModule = /** @class */ (function () {
    function BarChartModule() {
    }
BarChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BarChartModule });
BarChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function BarChartModule_Factory(t) { return new (t || BarChartModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BarChartModule, { declarations: [BarComponent,
        BarHorizontalComponent,
        BarHorizontal2DComponent,
        BarHorizontalNormalizedComponent,
        BarHorizontalStackedComponent,
        BarVerticalComponent,
        BarVertical2DComponent,
        BarVerticalNormalizedComponent,
        BarVerticalStackedComponent,
        BarLabelComponent,
        SeriesHorizontal,
        SeriesVerticalComponent], imports: [ChartCommonModule], exports: [BarComponent,
        BarHorizontalComponent,
        BarHorizontal2DComponent,
        BarHorizontalNormalizedComponent,
        BarHorizontalStackedComponent,
        BarVerticalComponent,
        BarVertical2DComponent,
        BarVerticalNormalizedComponent,
        BarVerticalStackedComponent,
        BarLabelComponent,
        SeriesHorizontal,
        SeriesVerticalComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BarChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    BarComponent,
                    BarHorizontalComponent,
                    BarHorizontal2DComponent,
                    BarHorizontalNormalizedComponent,
                    BarHorizontalStackedComponent,
                    BarVerticalComponent,
                    BarVertical2DComponent,
                    BarVerticalNormalizedComponent,
                    BarVerticalStackedComponent,
                    BarLabelComponent,
                    SeriesHorizontal,
                    SeriesVerticalComponent
                ],
                exports: [
                    BarComponent,
                    BarHorizontalComponent,
                    BarHorizontal2DComponent,
                    BarHorizontalNormalizedComponent,
                    BarHorizontalStackedComponent,
                    BarVerticalComponent,
                    BarVertical2DComponent,
                    BarVerticalNormalizedComponent,
                    BarVerticalStackedComponent,
                    BarLabelComponent,
                    SeriesHorizontal,
                    SeriesVerticalComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return BarChartModule;
}());

function getDomain(values, scaleType, autoScale, minVal, maxVal) {
    var domain = [];
    if (scaleType === 'linear') {
        values = values.map(function (v) { return Number(v); });
        if (!autoScale) {
            values.push(0);
        }
    }
    if (scaleType === 'time' || scaleType === 'linear') {
        var min$$1 = minVal ? minVal : Math.min.apply(Math, values);
        var max$$1 = maxVal ? maxVal : Math.max.apply(Math, values);
        domain = [min$$1, max$$1];
    }
    else {
        domain = values;
    }
    return domain;
}
function getScale(domain, range$$1, scaleType, roundDomains) {
    var scale;
    if (scaleType === 'time') {
        scale = scaleTime()
            .range(range$$1)
            .domain(domain);
    }
    else if (scaleType === 'linear') {
        scale = scaleLinear()
            .range(range$$1)
            .domain(domain);
        if (roundDomains) {
            scale = scale.nice();
        }
    }
    else if (scaleType === 'ordinal') {
        scale = scalePoint()
            .range([range$$1[0], range$$1[1]])
            .domain(domain);
    }
    return scale;
}

var BubbleChartComponent = /** @class */ (function (_super) {
    __extends(BubbleChartComponent, _super);
    function BubbleChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.showGridLines = true;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.xAxis = true;
        _this.yAxis = true;
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.maxRadius = 10;
        _this.minRadius = 3;
        _this.schemeType = 'ordinal';
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.scaleType = 'linear';
        _this.margin = [10, 20, 10, 20];
        _this.bubblePadding = [0, 0, 0, 0];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.activeEntries = [];
        return _this;
    }
    BubbleChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.seriesDomain = this.results.map(function (d) { return d.name; });
        this.rDomain = this.getRDomain();
        this.xDomain = this.getXDomain();
        this.yDomain = this.getYDomain();
        this.transform = "translate(" + this.dims.xOffset + "," + this.margin[0] + ")";
        var colorDomain = this.schemeType === 'ordinal' ? this.seriesDomain : this.rDomain;
        this.colors = new ColorHelper(this.scheme, this.schemeType, colorDomain, this.customColors);
        this.data = this.results;
        this.minRadius = Math.max(this.minRadius, 1);
        this.maxRadius = Math.max(this.maxRadius, 1);
        this.rScale = this.getRScale(this.rDomain, [this.minRadius, this.maxRadius]);
        this.bubblePadding = [0, 0, 0, 0];
        this.setScales();
        this.bubblePadding = this.getBubblePadding();
        this.setScales();
        this.legendOptions = this.getLegendOptions();
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    BubbleChartComponent.prototype.hideCircles = function () {
        this.deactivateAll();
    };
    BubbleChartComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    BubbleChartComponent.prototype.getBubblePadding = function () {
        var yMin = 0;
        var xMin = 0;
        var yMax = this.dims.height;
        var xMax = this.dims.width;
        for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
            var s = _a[_i];
            for (var _b = 0, _c = s.series; _b < _c.length; _b++) {
                var d = _c[_b];
                var r = this.rScale(d.r);
                var cx = this.xScaleType === 'linear' ? this.xScale(Number(d.x)) : this.xScale(d.x);
                var cy = this.yScaleType === 'linear' ? this.yScale(Number(d.y)) : this.yScale(d.y);
                xMin = Math.max(r - cx, xMin);
                yMin = Math.max(r - cy, yMin);
                yMax = Math.max(cy + r, yMax);
                xMax = Math.max(cx + r, xMax);
            }
        }
        xMax = Math.max(xMax - this.dims.width, 0);
        yMax = Math.max(yMax - this.dims.height, 0);
        return [yMin, xMax, yMax, xMin];
    };
    BubbleChartComponent.prototype.setScales = function () {
        var width = this.dims.width;
        if (this.xScaleMin === undefined && this.xScaleMax === undefined) {
            width = width - this.bubblePadding[1];
        }
        var height = this.dims.height;
        if (this.yScaleMin === undefined && this.yScaleMax === undefined) {
            height = height - this.bubblePadding[2];
        }
        this.xScale = this.getXScale(this.xDomain, width);
        this.yScale = this.getYScale(this.yDomain, height);
    };
    BubbleChartComponent.prototype.getYScale = function (domain, height) {
        return getScale(domain, [height, this.bubblePadding[0]], this.yScaleType, this.roundDomains);
    };
    BubbleChartComponent.prototype.getXScale = function (domain, width) {
        return getScale(domain, [this.bubblePadding[3], width], this.xScaleType, this.roundDomains);
    };
    BubbleChartComponent.prototype.getRScale = function (domain, range$$1) {
        var scale = scaleLinear()
            .range(range$$1)
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BubbleChartComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            position: this.legendPosition,
            title: undefined
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.rDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BubbleChartComponent.prototype.getXDomain = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.x)) {
                    values.push(d.x);
                }
            }
        }
        this.xScaleType = getScaleType(values);
        return getDomain(values, this.xScaleType, this.autoScale, this.xScaleMin, this.xScaleMax);
    };
    BubbleChartComponent.prototype.getYDomain = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.y)) {
                    values.push(d.y);
                }
            }
        }
        this.yScaleType = getScaleType(values);
        return getDomain(values, this.yScaleType, this.autoScale, this.yScaleMin, this.yScaleMax);
    };
    BubbleChartComponent.prototype.getRDomain = function () {
        var min$$1 = Infinity;
        var max$$1 = -Infinity;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                var value = Number(d.r) || 1;
                min$$1 = Math.min(min$$1, value);
                max$$1 = Math.max(max$$1, value);
            }
        }
        return [min$$1, max$$1];
    };
    BubbleChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BubbleChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BubbleChartComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BubbleChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    BubbleChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    BubbleChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BubbleChartComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BubbleChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BubbleChartComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BubbleChartComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "maxRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "minRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BubbleChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BubbleChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BubbleChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], BubbleChartComponent.prototype, "hideCircles", null);
BubbleChartComponent.ɵfac = function BubbleChartComponent_Factory(t) { return ɵBubbleChartComponent_BaseFactory(t || BubbleChartComponent); };
BubbleChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BubbleChartComponent, selectors: [["ngx-charts-bubble-chart"]], contentQueries: function BubbleChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, hostBindings: function BubbleChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function BubbleChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { minRadius: "minRadius", maxRadius: "maxRadius", showGridLines: "showGridLines", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", autoScale: "autoScale", schemeType: "schemeType", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 20, consts: [[3, "view", "showLegend", "activeEntries", "legendOptions", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bubble-chart", "chart"], ["ngx-charts-x-axis", "", 3, "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["x", "0", "y", "0", 1, "bubble-chart-area", 2, "fill", "rgb(255, 0, 0)", "opacity", "0", "cursor", "auto", 3, "mouseenter"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-bubble-series", "", 3, "xScale", "yScale", "rScale", "xScaleType", "yScaleType", "xAxisLabel", "yAxisLabel", "colors", "data", "activeEntries", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"]], template: function BubbleChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, BubbleChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, BubbleChartComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "rect", 4);
        ɵngcc0.ɵɵlistener("mouseenter", function BubbleChartComponent_Template__svg_rect_mouseenter_7_listener() { return ctx.deactivateAll(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "g");
        ɵngcc0.ɵɵtemplate(9, BubbleChartComponent__svg_g_9_Template, 2, 13, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("activeEntries", ctx.activeEntries)("legendOptions", ctx.legendOptions)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width)("height", ctx.dims.height);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        BubbleSeriesComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBubbleChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(BubbleChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BubbleChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bubble-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [activeEntries]=\"activeEntries\"\n      [legendOptions]=\"legendOptions\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"bubble-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [showGridLines]=\"showGridLines\"\n          [dims]=\"dims\"\n          [xScale]=\"xScale\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        />\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [showGridLines]=\"showGridLines\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        />\n        <svg:rect\n          class=\"bubble-chart-area\"\n          x=\"0\"\n          y=\"0\"\n          [attr.width]=\"dims.width\"\n          [attr.height]=\"dims.height\"\n          style=\"fill: rgb(255, 0, 0); opacity: 0; cursor: 'auto';\"\n          (mouseenter)=\"deactivateAll()\"\n        />\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of data; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-bubble-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [rScale]=\"rScale\"\n              [xScaleType]=\"xScaleType\"\n              [yScaleType]=\"yScaleType\"\n              [xAxisLabel]=\"xAxisLabel\"\n              [yAxisLabel]=\"yAxisLabel\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              (select)=\"onClick($event, series)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n            />\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({
                                opacity: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], null, { minRadius: [{
            type: Input
        }], maxRadius: [{
            type: Input
        }], hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], showGridLines: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BubbleChartComponent;
}(BaseChartComponent));

var BubbleSeriesComponent = /** @class */ (function () {
    function BubbleSeriesComponent() {
        this.tooltipDisabled = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    BubbleSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    BubbleSeriesComponent.prototype.update = function () {
        this.circles = this.getCircles();
    };
    BubbleSeriesComponent.prototype.getCircles = function () {
        var _this = this;
        var seriesName = this.data.name;
        return this.data.series
            .map(function (d, i) {
            if (typeof d.y !== 'undefined' && typeof d.x !== 'undefined') {
                var y = d.y;
                var x = d.x;
                var r = d.r;
                var radius = _this.rScale(r || 1);
                var tooltipLabel = formatLabel(d.name);
                var cx = _this.xScaleType === 'linear' ? _this.xScale(Number(x)) : _this.xScale(x);
                var cy = _this.yScaleType === 'linear' ? _this.yScale(Number(y)) : _this.yScale(y);
                var color = _this.colors.scaleType === 'linear' ? _this.colors.getColor(r) : _this.colors.getColor(seriesName);
                var isActive = !_this.activeEntries.length ? true : _this.isActive({ name: seriesName });
                var opacity = isActive ? 1 : 0.3;
                var data = Object.assign({}, d, {
                    series: seriesName,
                    name: d.name,
                    value: d.y,
                    x: d.x,
                    radius: d.r
                });
                return {
                    data: data,
                    x: x,
                    y: y,
                    r: r,
                    classNames: ["circle-data-" + i],
                    value: y,
                    label: x,
                    cx: cx,
                    cy: cy,
                    radius: radius,
                    tooltipLabel: tooltipLabel,
                    color: color,
                    opacity: opacity,
                    seriesName: seriesName,
                    isActive: isActive,
                    transform: "translate(" + cx + "," + cy + ")"
                };
            }
        })
            .filter(function (circle) { return circle !== undefined; });
    };
    BubbleSeriesComponent.prototype.getTooltipText = function (circle) {
        var hasRadius = typeof circle.r !== 'undefined';
        var hasTooltipLabel = circle.tooltipLabel && circle.tooltipLabel.length;
        var hasSeriesName = circle.seriesName && circle.seriesName.length;
        var radiusValue = hasRadius ? formatLabel(circle.r) : '';
        var xAxisLabel = this.xAxisLabel && this.xAxisLabel !== '' ? this.xAxisLabel + ":" : '';
        var yAxisLabel = this.yAxisLabel && this.yAxisLabel !== '' ? this.yAxisLabel + ":" : '';
        var x = formatLabel(circle.x);
        var y = formatLabel(circle.y);
        var name = hasSeriesName && hasTooltipLabel
            ? circle.seriesName + " \u2022 " + circle.tooltipLabel
            : circle.seriesName + circle.tooltipLabel;
        var tooltipTitle = hasSeriesName || hasTooltipLabel ? "<span class=\"tooltip-label\">" + name + "</span>" : '';
        return "\n      " + tooltipTitle + "\n      <span class=\"tooltip-label\">\n        <label>" + xAxisLabel + "</label> " + x + "<br />\n        <label>" + yAxisLabel + "</label> " + y + "\n      </span>\n      <span class=\"tooltip-val\">\n        " + radiusValue + "\n      </span>\n    ";
    };
    BubbleSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    BubbleSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    BubbleSeriesComponent.prototype.isVisible = function (circle) {
        if (this.activeEntries.length > 0) {
            return this.isActive({ name: circle.seriesName });
        }
        return circle.opacity !== 0;
    };
    BubbleSeriesComponent.prototype.activateCircle = function (circle) {
        circle.barVisible = true;
        this.activate.emit({ name: this.data.name });
    };
    BubbleSeriesComponent.prototype.deactivateCircle = function (circle) {
        circle.barVisible = false;
        this.deactivate.emit({ name: this.data.name });
    };
    BubbleSeriesComponent.prototype.trackBy = function (index, circle) {
        return circle.data.series + " " + circle.data.name;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "rScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "xScaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "yScaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "visibleValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BubbleSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleSeriesComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleSeriesComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], BubbleSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "deactivate", void 0);
BubbleSeriesComponent.ɵfac = function BubbleSeriesComponent_Factory(t) { return new (t || BubbleSeriesComponent)(); };
BubbleSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BubbleSeriesComponent, selectors: [["g", "ngx-charts-bubble-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", data: "data", xScale: "xScale", yScale: "yScale", rScale: "rScale", xScaleType: "xScaleType", yScaleType: "yScaleType", colors: "colors", visibleValue: "visibleValue", activeEntries: "activeEntries", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c29, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function BubbleSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BubbleSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.circles)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, CircleComponent,
        TooltipDirective], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        opacity: 0,
                        transform: 'scale(0)'
                    }),
                    animate(250, style({ opacity: 1, transform: 'scale(1)' }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BubbleSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bubble-series]',
                template: "\n    <svg:g *ngFor=\"let circle of circles; trackBy: trackBy\">\n      <svg:g [attr.transform]=\"circle.transform\">\n        <svg:g\n          ngx-charts-circle\n          [@animationState]=\"'active'\"\n          class=\"circle\"\n          [cx]=\"0\"\n          [cy]=\"0\"\n          [r]=\"circle.radius\"\n          [fill]=\"circle.color\"\n          [style.opacity]=\"circle.opacity\"\n          [class.active]=\"circle.isActive\"\n          [pointerEvents]=\"'all'\"\n          [data]=\"circle.value\"\n          [classNames]=\"circle.classNames\"\n          (select)=\"onClick(circle.data)\"\n          (activate)=\"activateCircle(circle)\"\n          (deactivate)=\"deactivateCircle(circle)\"\n          ngx-tooltip\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipPlacement]=\"'top'\"\n          [tooltipType]=\"'tooltip'\"\n          [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(circle)\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipContext]=\"circle.data\"\n        />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                opacity: 0,
                                transform: 'scale(0)'
                            }),
                            animate(250, style({ opacity: 1, transform: 'scale(1)' }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], rScale: [{
            type: Input
        }], xScaleType: [{
            type: Input
        }], yScaleType: [{
            type: Input
        }], colors: [{
            type: Input
        }], visibleValue: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return BubbleSeriesComponent;
}());

var BubbleChartModule = /** @class */ (function () {
    function BubbleChartModule() {
    }
BubbleChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BubbleChartModule });
BubbleChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function BubbleChartModule_Factory(t) { return new (t || BubbleChartModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BubbleChartModule, { declarations: [BubbleChartComponent,
        BubbleSeriesComponent], imports: [ChartCommonModule], exports: [BubbleChartComponent,
        BubbleSeriesComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BubbleChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    BubbleChartComponent,
                    BubbleSeriesComponent
                ],
                exports: [
                    BubbleChartComponent,
                    BubbleSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return BubbleChartModule;
}());

var ForceDirectedGraphComponent = /** @class */ (function (_super) {
    __extends(ForceDirectedGraphComponent, _super);
    function ForceDirectedGraphComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.force = forceSimulation()
            .force('charge', forceManyBody())
            .force('collide', forceCollide(5))
            .force('x', forceX())
            .force('y', forceY());
        _this.forceLink = forceLink().id(function (node) { return node.value; });
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.nodes = [];
        _this.links = [];
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [0, 0, 0, 0];
        _this.results = [];
        _this.groupResultsBy = function (node) { return node.value; };
        return _this;
    }
    ForceDirectedGraphComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showLegend: this.legend,
            legendPosition: this.legendPosition
        });
        this.seriesDomain = this.getSeriesDomain();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "\n      translate(" + (this.dims.xOffset + this.dims.width / 2) + ", " + (this.margin[0] + this.dims.height / 2) + ")\n    ";
        if (this.force) {
            this.force
                .nodes(this.nodes)
                .force('link', this.forceLink.links(this.links))
                .alpha(0.5)
                .restart();
        }
    };
    ForceDirectedGraphComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    ForceDirectedGraphComponent.prototype.onActivate = function (event$$1) {
        if (this.activeEntries.indexOf(event$$1) > -1)
            return;
        this.activeEntries = [event$$1].concat(this.activeEntries);
        this.activate.emit({ value: event$$1, entries: this.activeEntries });
    };
    ForceDirectedGraphComponent.prototype.onDeactivate = function (event$$1) {
        var idx = this.activeEntries.indexOf(event$$1);
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: event$$1, entries: this.activeEntries });
    };
    ForceDirectedGraphComponent.prototype.getSeriesDomain = function () {
        var _this = this;
        return this.nodes
            .map(function (d) { return _this.groupResultsBy(d); })
            .reduce(function (nodes, node) { return (nodes.includes(node) ? nodes : nodes.concat([node])); }, [])
            .sort();
    };
    ForceDirectedGraphComponent.prototype.trackLinkBy = function (index, link) {
        return link.index;
    };
    ForceDirectedGraphComponent.prototype.trackNodeBy = function (index, node) {
        return node.value;
    };
    ForceDirectedGraphComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.seriesDomain, this.customColors);
    };
    ForceDirectedGraphComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: 'ordinal',
            domain: this.seriesDomain,
            colors: this.colors,
            title: this.legendTitle,
            position: this.legendPosition
        };
    };
    ForceDirectedGraphComponent.prototype.onDragStart = function (node, $event) {
        this.force.alphaTarget(0.3).restart();
        this.draggingNode = node;
        this.draggingStart = { x: $event.x - node.x, y: $event.y - node.y };
        this.draggingNode.fx = $event.x - this.draggingStart.x;
        this.draggingNode.fy = $event.y - this.draggingStart.y;
    };
    ForceDirectedGraphComponent.prototype.onDrag = function ($event) {
        if (!this.draggingNode)
            return;
        this.draggingNode.fx = $event.x - this.draggingStart.x;
        this.draggingNode.fy = $event.y - this.draggingStart.y;
    };
    ForceDirectedGraphComponent.prototype.onDragEnd = function ($event) {
        if (!this.draggingNode)
            return;
        this.force.alphaTarget(0);
        this.draggingNode.fx = undefined;
        this.draggingNode.fy = undefined;
        this.draggingNode = undefined;
    };
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ForceDirectedGraphComponent.prototype, "force", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ForceDirectedGraphComponent.prototype, "forceLink", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ForceDirectedGraphComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ForceDirectedGraphComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ForceDirectedGraphComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ForceDirectedGraphComponent.prototype, "nodes", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof Array !== "undefined" && Array) === "function" ? _a : Object)
    ], ForceDirectedGraphComponent.prototype, "links", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ForceDirectedGraphComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ForceDirectedGraphComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], ForceDirectedGraphComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], ForceDirectedGraphComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('linkTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], ForceDirectedGraphComponent.prototype, "linkTemplate", void 0);
    __decorate([
        ContentChild('nodeTemplate', { static: false }),
        __metadata("design:type", typeof (_e = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _e : Object)
    ], ForceDirectedGraphComponent.prototype, "nodeTemplate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_f = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _f : Object)
    ], ForceDirectedGraphComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ViewChild(ChartComponent, { read: ElementRef, static: false }),
        __metadata("design:type", typeof (_g = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _g : Object)
    ], ForceDirectedGraphComponent.prototype, "chart", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], ForceDirectedGraphComponent.prototype, "groupResultsBy", void 0);
    __decorate([
        HostListener('document:mousemove', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [typeof (_h = typeof MouseEvent !== "undefined" && MouseEvent) === "function" ? _h : Object]),
        __metadata("design:returntype", void 0)
    ], ForceDirectedGraphComponent.prototype, "onDrag", null);
    __decorate([
        HostListener('document:mouseup', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [typeof (_j = typeof MouseEvent !== "undefined" && MouseEvent) === "function" ? _j : Object]),
        __metadata("design:returntype", void 0)
    ], ForceDirectedGraphComponent.prototype, "onDragEnd", null);
ForceDirectedGraphComponent.ɵfac = function ForceDirectedGraphComponent_Factory(t) { return ɵForceDirectedGraphComponent_BaseFactory(t || ForceDirectedGraphComponent); };
ForceDirectedGraphComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ForceDirectedGraphComponent, selectors: [["ngx-charts-force-directed-graph"]], contentQueries: function ForceDirectedGraphComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c30, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c31, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.linkTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, viewQuery: function ForceDirectedGraphComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(ChartComponent, true, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chart = _t.first);
    } }, hostBindings: function ForceDirectedGraphComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousemove", function ForceDirectedGraphComponent_mousemove_HostBindingHandler($event) { return ctx.onDrag($event); }, false, ɵngcc0.ɵɵresolveDocument)("mouseup", function ForceDirectedGraphComponent_mouseup_HostBindingHandler($event) { return ctx.onDragEnd($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { activeEntries: "activeEntries", force: "force", forceLink: "forceLink", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", nodes: "nodes", links: "links", tooltipDisabled: "tooltipDisabled", groupResultsBy: "groupResultsBy" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 12, consts: [[3, "view", "showLegend", "legendOptions", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "force-directed-graph", "chart"], [1, "links"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "nodes"], ["ngx-tooltip", "", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "mousedown", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["strokeWidth", "1", "class", "edge", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["strokeWidth", "1", 1, "edge"], ["ngx-tooltip", "", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "mousedown", "click"], ["r", "5", 4, "ngIf"], ["r", "5"]], template: function ForceDirectedGraphComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function ForceDirectedGraphComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function ForceDirectedGraphComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function ForceDirectedGraphComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵtemplate(3, ForceDirectedGraphComponent__svg_g_3_Template, 3, 2, "g", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 4);
        ɵngcc0.ɵɵtemplate(5, ForceDirectedGraphComponent__svg_g_5_Template, 3, 11, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(9, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.links)("ngForTrackBy", ctx.trackLinkBy);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.nodes)("ngForTrackBy", ctx.trackNodeBy);
    } }, directives: [ChartComponent, ɵngcc1.NgForOf, ɵngcc1.NgIf, TooltipDirective], styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".force-directed-graph .edge{stroke:#333}"], encapsulation: 2, changeDetection: 0 });
var ɵForceDirectedGraphComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(ForceDirectedGraphComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ForceDirectedGraphComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-force-directed-graph',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"force-directed-graph chart\">\n        <svg:g class=\"links\">\n          <svg:g *ngFor=\"let link of links; trackBy: trackLinkBy\">\n            <ng-template\n              *ngIf=\"linkTemplate\"\n              [ngTemplateOutlet]=\"linkTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: link }\"\n            ></ng-template>\n            <svg:line\n              *ngIf=\"!linkTemplate\"\n              strokeWidth=\"1\"\n              class=\"edge\"\n              [attr.x1]=\"link.source.x\"\n              [attr.y1]=\"link.source.y\"\n              [attr.x2]=\"link.target.x\"\n              [attr.y2]=\"link.target.y\"\n            />\n          </svg:g>\n        </svg:g>\n        <svg:g class=\"nodes\">\n          <svg:g\n            *ngFor=\"let node of nodes; trackBy: trackNodeBy\"\n            [attr.transform]=\"'translate(' + node.x + ',' + node.y + ')'\"\n            [attr.fill]=\"colors.getColor(groupResultsBy(node))\"\n            [attr.stroke]=\"colors.getColor(groupResultsBy(node))\"\n            (mousedown)=\"onDragStart(node, $event)\"\n            (click)=\"onClick({ name: node.value })\"\n            ngx-tooltip\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipPlacement]=\"'top'\"\n            [tooltipType]=\"'tooltip'\"\n            [tooltipTitle]=\"tooltipTemplate ? undefined : node.value\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [tooltipContext]=\"node\"\n          >\n            <ng-template\n              *ngIf=\"nodeTemplate\"\n              [ngTemplateOutlet]=\"nodeTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: node }\"\n            ></ng-template>\n            <svg:circle *ngIf=\"!nodeTemplate\" r=\"5\" />\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".force-directed-graph .edge{stroke:#333}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { activeEntries: [{
            type: Input
        }], onDrag: [{
            type: HostListener,
            args: ['document:mousemove', ['$event']]
        }], onDragEnd: [{
            type: HostListener,
            args: ['document:mouseup', ['$event']]
        }], force: [{
            type: Input
        }], forceLink: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], nodes: [{
            type: Input
        }], links: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], linkTemplate: [{
            type: ContentChild,
            args: ['linkTemplate', { static: false }]
        }], nodeTemplate: [{
            type: ContentChild,
            args: ['nodeTemplate', { static: false }]
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], chart: [{
            type: ViewChild,
            args: [ChartComponent, { read: ElementRef, static: false }]
        }], groupResultsBy: [{
            type: Input
        }] }); })();
    return ForceDirectedGraphComponent;
}(BaseChartComponent));

var ForceDirectedGraphModule = /** @class */ (function () {
    function ForceDirectedGraphModule() {
    }
ForceDirectedGraphModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ForceDirectedGraphModule });
ForceDirectedGraphModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ForceDirectedGraphModule_Factory(t) { return new (t || ForceDirectedGraphModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ForceDirectedGraphModule, { declarations: [ForceDirectedGraphComponent], imports: [ChartCommonModule], exports: [ForceDirectedGraphComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ForceDirectedGraphModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    ForceDirectedGraphComponent,
                ],
                exports: [
                    ForceDirectedGraphComponent,
                ]
            }]
    }], function () { return []; }, null); })();
    return ForceDirectedGraphModule;
}());

var HeatMapCellComponent = /** @class */ (function () {
    function HeatMapCellComponent(element) {
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.element = element.nativeElement;
    }
    HeatMapCellComponent.prototype.ngOnChanges = function (changes) {
        this.transform = "translate(" + this.x + " , " + this.y + ")";
        this.startOpacity = 0.3;
        this.gradientId = 'grad' + id().toString();
        this.gradientUrl = "url(#" + this.gradientId + ")";
        this.gradientStops = this.getGradientStops();
        if (this.animations) {
            this.loadAnimation();
        }
    };
    HeatMapCellComponent.prototype.getGradientStops = function () {
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: this.startOpacity
            },
            {
                offset: 100,
                color: this.fill,
                opacity: 1
            }
        ];
    };
    HeatMapCellComponent.prototype.loadAnimation = function () {
        var node = select(this.element).select('.cell');
        node.attr('opacity', 0);
        this.animateToCurrentForm();
    };
    HeatMapCellComponent.prototype.animateToCurrentForm = function () {
        var node = select(this.element).select('.cell');
        node
            .transition()
            .duration(750)
            .attr('opacity', 1);
    };
    HeatMapCellComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    HeatMapCellComponent.prototype.onMouseEnter = function () {
        this.activate.emit(this.data);
    };
    HeatMapCellComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit(this.data);
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapCellComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapCellComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "deactivate", void 0);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeatMapCellComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeatMapCellComponent.prototype, "onMouseLeave", null);
    HeatMapCellComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], HeatMapCellComponent);
HeatMapCellComponent.ɵfac = function HeatMapCellComponent_Factory(t) { return new (t || HeatMapCellComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
HeatMapCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeatMapCellComponent, selectors: [["g", "ngx-charts-heat-map-cell", ""]], hostBindings: function HeatMapCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function HeatMapCellComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function HeatMapCellComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { gradient: "gradient", animations: "animations", fill: "fill", x: "x", y: "y", width: "width", height: "height", data: "data", label: "label" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c32, decls: 3, vars: 5, consts: [[1, "cell"], [4, "ngIf"], ["rx", "3", 1, "cell", 2, "cursor", "pointer", 3, "click"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"]], template: function HeatMapCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, HeatMapCellComponent__svg_defs_1_Template, 2, 2, "defs", 1);
        ɵngcc0.ɵɵelementStart(2, "rect", 2);
        ɵngcc0.ɵɵlistener("click", function HeatMapCellComponent_Template__svg_rect_click_2_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeatMapCellComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-heat-map-cell]',
                template: "\n    <svg:g [attr.transform]=\"transform\" class=\"cell\">\n      <defs *ngIf=\"gradient\">\n        <svg:g ngx-charts-svg-linear-gradient orientation=\"vertical\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n      </defs>\n      <svg:rect\n        [attr.fill]=\"gradient ? gradientUrl : fill\"\n        rx=\"3\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        class=\"cell\"\n        style=\"cursor: pointer\"\n        (click)=\"onClick()\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], fill: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], data: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();
    return HeatMapCellComponent;
}());

var HeatCellSeriesComponent = /** @class */ (function () {
    function HeatCellSeriesComponent() {
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    HeatCellSeriesComponent.prototype.ngOnInit = function () {
        if (!this.tooltipText) {
            this.tooltipText = this.getTooltipText;
        }
    };
    HeatCellSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    HeatCellSeriesComponent.prototype.update = function () {
        this.cells = this.getCells();
    };
    HeatCellSeriesComponent.prototype.getCells = function () {
        var _this = this;
        var cells = [];
        this.data.map(function (row) {
            row.series.map(function (cell) {
                var value = cell.value;
                cell.series = row.name;
                cells.push({
                    row: row,
                    cell: cell,
                    x: _this.xScale(row.name),
                    y: _this.yScale(cell.name),
                    width: _this.xScale.bandwidth(),
                    height: _this.yScale.bandwidth(),
                    fill: _this.colors.getColor(value),
                    data: value,
                    label: formatLabel(cell.name),
                    series: row.name
                });
            });
        });
        return cells;
    };
    HeatCellSeriesComponent.prototype.getTooltipText = function (_a) {
        var label = _a.label, data = _a.data, series = _a.series;
        return "\n      <span class=\"tooltip-label\">" + series + " \u2022 " + label + "</span>\n      <span class=\"tooltip-val\">" + data.toLocaleString() + "</span>\n    ";
    };
    HeatCellSeriesComponent.prototype.trackBy = function (index, item) {
        return item.tooltipText;
    };
    HeatCellSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatCellSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatCellSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], HeatCellSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatCellSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], HeatCellSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], HeatCellSeriesComponent.prototype, "deactivate", void 0);
HeatCellSeriesComponent.ɵfac = function HeatCellSeriesComponent_Factory(t) { return new (t || HeatCellSeriesComponent)(); };
HeatCellSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeatCellSeriesComponent, selectors: [["g", "ngx-charts-heat-map-cell-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", animations: "animations", tooltipText: "tooltipText", data: "data", colors: "colors", xScale: "xScale", yScale: "yScale", gradient: "gradient", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c33, decls: 1, vars: 2, consts: [["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function HeatCellSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, HeatCellSeriesComponent__svg_g_0_Template, 1, 18, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, HeatMapCellComponent,
        TooltipDirective], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeatCellSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-heat-map-cell-series]',
                template: "\n    <svg:g\n      ngx-charts-heat-map-cell\n      *ngFor=\"let c of cells; trackBy: trackBy\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [fill]=\"c.fill\"\n      [data]=\"c.data\"\n      (select)=\"onClick(c.cell)\"\n      (activate)=\"activate.emit(c.cell)\"\n      (deactivate)=\"deactivate.emit(c.cell)\"\n      [gradient]=\"gradient\"\n      [animations]=\"animations\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(c)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"{ series: c.series, name: c.label, value: c.data }\"\n    ></svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipText: [{
            type: Input
        }], data: [{
            type: Input
        }], colors: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], gradient: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return HeatCellSeriesComponent;
}());

var HeatMapComponent = /** @class */ (function (_super) {
    __extends(HeatMapComponent, _super);
    function HeatMapComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.innerPadding = 8;
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.tooltipDisabled = false;
        _this.activeEntries = [];
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.scaleType = 'linear';
        return _this;
    }
    HeatMapComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.formatDates();
        this.xDomain = this.getXDomain();
        this.yDomain = this.getYDomain();
        this.valueDomain = this.getValueDomain();
        this.scaleType = getScaleType(this.valueDomain, false);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.scaleType,
            legendPosition: this.legendPosition
        });
        if (this.scaleType === 'linear') {
            var min$$1 = this.min;
            var max$$1 = this.max;
            if (!this.min) {
                min$$1 = Math.min.apply(Math, [0].concat(this.valueDomain));
            }
            if (!this.max) {
                max$$1 = Math.max.apply(Math, this.valueDomain);
            }
            this.valueDomain = [min$$1, max$$1];
        }
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.rects = this.getRects();
    };
    HeatMapComponent.prototype.getXDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.name)) {
                domain.push(group.name);
            }
        }
        return domain;
    };
    HeatMapComponent.prototype.getYDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.name)) {
                    domain.push(d.name);
                }
            }
        }
        return domain;
    };
    HeatMapComponent.prototype.getValueDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        return domain;
    };
    HeatMapComponent.prototype.getDimension = function (value, index, N, L) {
        if (index === void 0) { index = 0; }
        if (typeof value === 'string') {
            value = value
                .replace('[', '')
                .replace(']', '')
                .replace('px', '')
                .replace('\'', '');
            if (value.includes(',')) {
                value = value.split(',');
            }
        }
        if (Array.isArray(value) && typeof index === 'number') {
            return this.getDimension(value[index], null, N, L);
        }
        if (typeof value === 'string' && value.includes('%')) {
            return +value.replace('%', '') / 100;
        }
        return N / (L / +value + 1);
    };
    HeatMapComponent.prototype.getXScale = function () {
        var f = this.getDimension(this.innerPadding, 0, this.xDomain.length, this.dims.width);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .domain(this.xDomain)
            .paddingInner(f);
    };
    HeatMapComponent.prototype.getYScale = function () {
        var f = this.getDimension(this.innerPadding, 1, this.yDomain.length, this.dims.height);
        return scaleBand()
            .rangeRound([this.dims.height, 0])
            .domain(this.yDomain)
            .paddingInner(f);
    };
    HeatMapComponent.prototype.getRects = function () {
        var _this = this;
        var rects = [];
        this.xDomain.map(function (xVal) {
            _this.yDomain.map(function (yVal) {
                rects.push({
                    x: _this.xScale(xVal),
                    y: _this.yScale(yVal),
                    rx: 3,
                    width: _this.xScale.bandwidth(),
                    height: _this.yScale.bandwidth(),
                    fill: 'rgba(200,200,200,0.03)'
                });
            });
        });
        return rects;
    };
    HeatMapComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    HeatMapComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, this.scaleType, this.valueDomain);
    };
    HeatMapComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: this.scaleType,
            domain: this.valueDomain,
            colors: this.scaleType === 'ordinal' ? this.colors : this.colors.scale,
            title: this.scaleType === 'ordinal' ? this.legendTitle : undefined,
            position: this.legendPosition
        };
    };
    HeatMapComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    HeatMapComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    HeatMapComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    HeatMapComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], HeatMapComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], HeatMapComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "innerPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], HeatMapComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], HeatMapComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], HeatMapComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], HeatMapComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], HeatMapComponent.prototype, "activeEntries", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], HeatMapComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], HeatMapComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], HeatMapComponent.prototype, "tooltipTemplate", void 0);
HeatMapComponent.ɵfac = function HeatMapComponent_Factory(t) { return ɵHeatMapComponent_BaseFactory(t || HeatMapComponent); };
HeatMapComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeatMapComponent, selectors: [["ngx-charts-heat-map"]], contentQueries: function HeatMapComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", gradient: "gradient", innerPadding: "innerPadding", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", tooltipDisabled: "tooltipDisabled", tooltipText: "tooltipText", min: "min", max: "max" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 20, consts: [[3, "view", "showLegend", "animations", "legendOptions", "legendLabelClick"], [1, "heat-map", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["ngx-charts-heat-map-cell-series", "", 3, "xScale", "yScale", "colors", "data", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText", "select", "activate", "deactivate"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"]], template: function HeatMapComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function HeatMapComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, HeatMapComponent__svg_g_2_Template, 1, 9, "g", 2);
        ɵngcc0.ɵɵtemplate(3, HeatMapComponent__svg_g_3_Template, 1, 8, "g", 3);
        ɵngcc0.ɵɵtemplate(4, HeatMapComponent__svg_rect_4_Template, 1, 6, "rect", 4);
        ɵngcc0.ɵɵelementStart(5, "g", 5);
        ɵngcc0.ɵɵlistener("select", function HeatMapComponent_Template__svg_g_select_5_listener($event) { return ctx.onClick($event); })("activate", function HeatMapComponent_Template__svg_g_activate_5_listener($event) { return ctx.onActivate($event); })("deactivate", function HeatMapComponent_Template__svg_g_deactivate_5_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("animations", ctx.animations)("legendOptions", ctx.legendOptions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.rects);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("data", ctx.results)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
    } }, directives: [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, HeatCellSeriesComponent,
        XAxisComponent,
        YAxisComponent], styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, changeDetection: 0 });
var ɵHeatMapComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(HeatMapComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeatMapComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-heat-map',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [animations]=\"animations\"\n      [legendOptions]=\"legendOptions\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"heat-map chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:rect\n          *ngFor=\"let rect of rects\"\n          [attr.x]=\"rect.x\"\n          [attr.y]=\"rect.y\"\n          [attr.rx]=\"rect.rx\"\n          [attr.width]=\"rect.width\"\n          [attr.height]=\"rect.height\"\n          [attr.fill]=\"rect.fill\"\n        />\n        <svg:g\n          ngx-charts-heat-map-cell-series\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [data]=\"results\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipText]=\"tooltipText\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], gradient: [{
            type: Input
        }], innerPadding: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return HeatMapComponent;
}(BaseChartComponent));

var HeatMapModule = /** @class */ (function () {
    function HeatMapModule() {
    }
HeatMapModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: HeatMapModule });
HeatMapModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function HeatMapModule_Factory(t) { return new (t || HeatMapModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HeatMapModule, { declarations: [HeatMapCellComponent,
        HeatCellSeriesComponent,
        HeatMapComponent], imports: [ChartCommonModule], exports: [HeatMapCellComponent,
        HeatCellSeriesComponent,
        HeatMapComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HeatMapModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    HeatMapCellComponent,
                    HeatCellSeriesComponent,
                    HeatMapComponent
                ],
                exports: [
                    HeatMapCellComponent,
                    HeatCellSeriesComponent,
                    HeatMapComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return HeatMapModule;
}());

var LineComponent = /** @class */ (function () {
    function LineComponent(element) {
        this.element = element;
        this.fill = 'none';
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
    }
    LineComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            this.initialized = true;
            this.initialPath = this.path;
        }
        else {
            this.updatePathEl();
        }
    };
    LineComponent.prototype.updatePathEl = function () {
        var node = select(this.element.nativeElement).select('.line');
        if (this.animations) {
            node
                .transition().duration(750)
                .attr('d', this.path);
        }
        else {
            node.attr('d', this.path);
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "path", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "stroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "select", void 0);
    LineComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], LineComponent);
LineComponent.ɵfac = function LineComponent_Factory(t) { return new (t || LineComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
LineComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineComponent, selectors: [["g", "ngx-charts-line", ""]], inputs: { fill: "fill", animations: "animations", path: "path", stroke: "stroke", data: "data" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c35, decls: 1, vars: 4, consts: [["stroke-width", "1.5px", 1, "line"]], template: function LineComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "path", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("@animationState", "active");
        ɵngcc0.ɵɵattribute("d", ctx.initialPath)("fill", ctx.fill)("stroke", ctx.stroke);
    } }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        strokeDasharray: 2000,
                        strokeDashoffset: 2000
                    }),
                    animate(1000, style({
                        strokeDashoffset: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LineComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-line]',
                template: "\n    <svg:path\n      [@animationState]=\"'active'\"\n      class=\"line\"\n      [attr.d]=\"initialPath\"\n      [attr.fill]=\"fill\"\n      [attr.stroke]=\"stroke\"\n      stroke-width=\"1.5px\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                strokeDasharray: 2000,
                                strokeDashoffset: 2000
                            }),
                            animate(1000, style({
                                strokeDashoffset: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { fill: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], path: [{
            type: Input
        }], stroke: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
    return LineComponent;
}());

var LineChartComponent = /** @class */ (function (_super) {
    __extends(LineChartComponent, _super);
    function LineChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.showRefLines = false;
        _this.showRefLabels = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    LineChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    LineChartComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    LineChartComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
        }
        var min$$1;
        var max$$1;
        if (this.scaleType === 'time' || this.scaleType === 'linear') {
            min$$1 = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, values);
            max$$1 = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, values);
        }
        if (this.scaleType === 'time') {
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    LineChartComponent.prototype.getYDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (domain.indexOf(d.value) < 0) {
                    domain.push(d.value);
                }
                if (d.min !== undefined) {
                    this.hasRange = true;
                    if (domain.indexOf(d.min) < 0) {
                        domain.push(d.min);
                    }
                }
                if (d.max !== undefined) {
                    this.hasRange = true;
                    if (domain.indexOf(d.max) < 0) {
                        domain.push(d.max);
                    }
                }
            }
        }
        var values = domain.slice();
        if (!this.autoScale) {
            values.push(0);
        }
        var min$$1 = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, values);
        var max$$1 = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, values);
        return [min$$1, max$$1];
    };
    LineChartComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    LineChartComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime()
                .range([0, width])
                .domain(domain);
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear()
                .range([0, width])
                .domain(domain);
            if (this.roundDomains) {
                scale = scale.nice();
            }
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint()
                .range([0, width])
                .padding(0.1)
                .domain(domain);
        }
        return scale;
    };
    LineChartComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    LineChartComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    LineChartComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    LineChartComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    LineChartComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    LineChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    LineChartComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    LineChartComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    LineChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    LineChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    LineChartComponent.prototype.onActivate = function (item) {
        this.deactivateAll();
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item];
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    LineChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    LineChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineChartComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineChartComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "showRefLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "referenceLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "showRefLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], LineChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], LineChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], LineChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], LineChartComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], LineChartComponent.prototype, "hideCircles", null);
LineChartComponent.ɵfac = function LineChartComponent_Factory(t) { return ɵLineChartComponent_BaseFactory(t || LineChartComponent); };
LineChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineChartComponent, selectors: [["ngx-charts-line-chart"]], contentQueries: function LineChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function LineChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function LineChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", autoScale: "autoScale", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", rangeFillOpacity: "rangeFillOpacity", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", showRefLines: "showRefLines", referenceLines: "referenceLines", showRefLabels: "showRefLabels", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "line-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "scaleType", "legend", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "dimensionsChanged"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "hasRange", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "visibleValue", "activeEntries", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "scaleType", "legend", "onDomainChange"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "curve", "hasRange", "animations"]], template: function LineChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function LineChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, LineChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, LineChartComponent__svg_g_6_Template, 1, 12, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, LineChartComponent__svg_g_8_Template, 2, 11, "g", 4);
        ɵngcc0.ɵɵtemplate(9, LineChartComponent__svg_g_9_Template, 3, 9, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, LineChartComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent,
        YAxisComponent,
        LineSeriesComponent,
        TooltipArea,
        CircleSeriesComponent,
        Timeline]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵLineChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(LineChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LineChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-line-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"line-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [referenceLines]=\"referenceLines\"\n          [showRefLines]=\"showRefLines\"\n          [showRefLabels]=\"showRefLabels\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-line-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [curve]=\"curve\"\n              [rangeFillOpacity]=\"rangeFillOpacity\"\n              [hasRange]=\"hasRange\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [activeEntries]=\"activeEntries\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [scaleType]=\"scaleType\"\n        [legend]=\"legend\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-line-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [curve]=\"curve\"\n            [hasRange]=\"hasRange\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({
                                opacity: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], showRefLines: [{
            type: Input
        }], referenceLines: [{
            type: Input
        }], showRefLabels: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return LineChartComponent;
}(BaseChartComponent));

var LineSeriesComponent = /** @class */ (function () {
    function LineSeriesComponent() {
        this.animations = true;
    }
    LineSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    LineSeriesComponent.prototype.update = function () {
        this.updateGradients();
        var data = this.sortData(this.data.series);
        var lineGen = this.getLineGenerator();
        this.path = lineGen(data) || '';
        var areaGen = this.getAreaGenerator();
        this.areaPath = areaGen(data) || '';
        if (this.hasRange) {
            var range$$1 = this.getRangeGenerator();
            this.outerPath = range$$1(data) || '';
        }
        if (this.hasGradient) {
            this.stroke = this.gradientUrl;
            var values = this.data.series.map(function (d) { return d.value; });
            var max$$1 = Math.max.apply(Math, values);
            var min$$1 = Math.min.apply(Math, values);
            if (max$$1 === min$$1) {
                this.stroke = this.colors.getColor(max$$1);
            }
        }
        else {
            this.stroke = this.colors.getColor(this.data.name);
        }
    };
    LineSeriesComponent.prototype.getLineGenerator = function () {
        var _this = this;
        return line()
            .x(function (d) {
            var label = d.name;
            var value;
            if (_this.scaleType === 'time') {
                value = _this.xScale(label);
            }
            else if (_this.scaleType === 'linear') {
                value = _this.xScale(Number(label));
            }
            else {
                value = _this.xScale(label);
            }
            return value;
        })
            .y(function (d) { return _this.yScale(d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.getRangeGenerator = function () {
        var _this = this;
        return area()
            .x(function (d) {
            var label = d.name;
            var value;
            if (_this.scaleType === 'time') {
                value = _this.xScale(label);
            }
            else if (_this.scaleType === 'linear') {
                value = _this.xScale(Number(label));
            }
            else {
                value = _this.xScale(label);
            }
            return value;
        })
            .y0(function (d) { return _this.yScale(typeof d.min === 'number' ? d.min : d.value); })
            .y1(function (d) { return _this.yScale(typeof d.max === 'number' ? d.max : d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.getAreaGenerator = function () {
        var _this = this;
        var xProperty = function (d) {
            var label = d.name;
            return _this.xScale(label);
        };
        return area()
            .x(xProperty)
            .y0(function () { return _this.yScale.range()[0]; })
            .y1(function (d) { return _this.yScale(d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.sortData = function (data) {
        if (this.scaleType === 'linear') {
            data = sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            data = sortByTime(data, 'name');
        }
        else {
            data = sortByDomain(data, 'name', 'asc', this.xScale.domain());
        }
        return data;
    };
    LineSeriesComponent.prototype.updateGradients = function () {
        if (this.colors.scaleType === 'linear') {
            this.hasGradient = true;
            this.gradientId = 'grad' + id().toString();
            this.gradientUrl = "url(#" + this.gradientId + ")";
            var values = this.data.series.map(function (d) { return d.value; });
            var max$$1 = Math.max.apply(Math, values);
            var min$$1 = Math.min.apply(Math, values);
            this.gradientStops = this.colors.getLinearGradientStops(max$$1, min$$1);
            this.areaGradientStops = this.colors.getLinearGradientStops(max$$1);
        }
        else {
            this.hasGradient = false;
            this.gradientStops = undefined;
            this.areaGradientStops = undefined;
        }
    };
    LineSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    LineSeriesComponent.prototype.isInactive = function (entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item === undefined;
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineSeriesComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineSeriesComponent.prototype, "hasRange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineSeriesComponent.prototype, "animations", void 0);
LineSeriesComponent.ɵfac = function LineSeriesComponent_Factory(t) { return new (t || LineSeriesComponent)(); };
LineSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineSeriesComponent, selectors: [["g", "ngx-charts-line-series", ""]], inputs: { animations: "animations", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", curve: "curve", activeEntries: "activeEntries", rangeFillOpacity: "rangeFillOpacity", hasRange: "hasRange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c36, decls: 6, vars: 22, consts: [["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops", 4, "ngIf"], ["ngx-charts-area", "", 1, "line-highlight", 3, "data", "path", "fill", "opacity", "startOpacity", "gradient", "stops", "animations"], ["ngx-charts-line", "", 1, "line-series", 3, "data", "path", "stroke", "animations"], ["ngx-charts-area", "", "class", "line-series-range", 3, "data", "path", "fill", "active", "inactive", "opacity", "animations", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], ["ngx-charts-area", "", 1, "line-series-range", 3, "data", "path", "fill", "opacity", "animations"]], template: function LineSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵtemplate(2, LineSeriesComponent__svg_g_2_Template, 1, 2, "g", 0);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "g", 1);
        ɵngcc0.ɵɵelement(4, "g", 2);
        ɵngcc0.ɵɵtemplate(5, LineSeriesComponent__svg_g_5_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.areaPath)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.colors.getColor(ctx.data.name))("opacity", 0.25)("startOpacity", 0)("gradient", true)("stops", ctx.areaGradientStops)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.path)("stroke", ctx.stroke)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasRange);
    } }, directives: [ɵngcc1.NgIf, AreaComponent,
        LineComponent,
        SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LineSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-line-series]',
                template: "\n    <svg:g>\n      <defs>\n        <svg:g ngx-charts-svg-linear-gradient *ngIf=\"hasGradient\"\n          orientation=\"vertical\"\n          [name]=\"gradientId\"\n          [stops]=\"gradientStops\"\n        />\n      </defs>\n      <svg:g ngx-charts-area\n        class=\"line-highlight\"\n        [data]=\"data\"\n        [path]=\"areaPath\"\n        [fill]=\"hasGradient ? gradientUrl : colors.getColor(data.name)\"\n        [opacity]=\"0.25\"\n        [startOpacity]=\"0\"\n        [gradient]=\"true\"\n        [stops]=\"areaGradientStops\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n        [animations]=\"animations\"\n      />\n      <svg:g ngx-charts-line\n        class=\"line-series\"\n        [data]=\"data\"\n        [path]=\"path\"\n        [stroke]=\"stroke\"\n        [animations]=\"animations\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n      />\n     <svg:g ngx-charts-area\n        *ngIf=\"hasRange\"\n        class=\"line-series-range\"\n        [data]=\"data\"\n        [path]=\"outerPath\"\n        [fill]=\"hasGradient ? gradientUrl : colors.getColor(data.name)\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n        [opacity]=\"rangeFillOpacity\"\n        [animations]=\"animations\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { animations: [{
            type: Input
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], hasRange: [{
            type: Input
        }] }); })();
    return LineSeriesComponent;
}());

var LineChartModule = /** @class */ (function () {
    function LineChartModule() {
    }
LineChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LineChartModule });
LineChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LineChartModule_Factory(t) { return new (t || LineChartModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LineChartModule, { declarations: [LineComponent,
        LineChartComponent,
        LineSeriesComponent], imports: [ChartCommonModule], exports: [LineComponent,
        LineChartComponent,
        LineSeriesComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LineChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    LineComponent,
                    LineChartComponent,
                    LineSeriesComponent
                ],
                exports: [
                    LineComponent,
                    LineChartComponent,
                    LineSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return LineChartModule;
}());

var twoPI = 2 * Math.PI;
var PolarChartComponent = /** @class */ (function (_super) {
    __extends(PolarChartComponent, _super);
    function PolarChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveCardinalClosed;
        _this.activeEntries = [];
        _this.rangeFillOpacity = 0.15;
        _this.trimYAxisTicks = true;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.showSeriesOnHover = true;
        _this.gradient = false;
        _this.yAxisMinScale = 0;
        _this.labelTrim = true;
        _this.labelTrimSize = 10;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        return _this;
    }
    PolarChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.setDims();
        this.setScales();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.setTicks();
    };
    PolarChartComponent.prototype.setDims = function () {
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        var halfWidth = Math.floor(this.dims.width / 2);
        var halfHeight = Math.floor(this.dims.height / 2);
        var outerRadius = (this.outerRadius = Math.min(halfHeight / 1.5, halfWidth / 1.5));
        var yOffset = Math.max(0, halfHeight - outerRadius);
        this.yAxisDims = __assign({}, this.dims, { width: halfWidth });
        this.transform = "translate(" + this.dims.xOffset + ", " + this.margin[0] + ")";
        this.transformYAxis = "translate(0, " + yOffset + ")";
        this.labelOffset = this.dims.height + 40;
        this.transformPlot = "translate(" + halfWidth + ", " + halfHeight + ")";
    };
    PolarChartComponent.prototype.setScales = function () {
        var xValues = this.getXValues();
        this.scaleType = getScaleType(xValues);
        this.xDomain = this.filteredDomain || this.getXDomain(xValues);
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, twoPI);
        this.yScale = this.getYScale(this.yDomain, this.outerRadius);
        this.yAxisScale = this.getYScale(this.yDomain.reverse(), this.outerRadius);
    };
    PolarChartComponent.prototype.setTicks = function () {
        var _this = this;
        var tickFormat;
        if (this.xAxisTickFormatting) {
            tickFormat = this.xAxisTickFormatting;
        }
        else if (this.xScale.tickFormat) {
            tickFormat = this.xScale.tickFormat.apply(this.xScale, [5]);
        }
        else {
            tickFormat = function (d) {
                if (isDate(d)) {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        var outerRadius = this.outerRadius;
        var s = 1.1;
        this.thetaTicks = this.xDomain.map(function (d) {
            var startAngle = _this.xScale(d);
            var dd = s * outerRadius * (startAngle > Math.PI ? -1 : 1);
            var label = tickFormat(d);
            var startPos = [outerRadius * Math.sin(startAngle), -outerRadius * Math.cos(startAngle)];
            var pos = [dd, s * startPos[1]];
            return {
                innerRadius: 0,
                outerRadius: outerRadius,
                startAngle: startAngle,
                endAngle: startAngle,
                value: outerRadius,
                label: label,
                startPos: startPos,
                pos: pos
            };
        });
        var minDistance = 10;
        for (var i = 0; i < this.thetaTicks.length - 1; i++) {
            var a = this.thetaTicks[i];
            for (var j = i + 1; j < this.thetaTicks.length; j++) {
                var b = this.thetaTicks[j];
                if (b.pos[0] * a.pos[0] > 0) {
                    var o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
                    if (o > 0) {
                        b.pos[1] += Math.sign(b.pos[0]) * o;
                    }
                }
            }
        }
        this.radiusTicks = this.yAxisScale.ticks(Math.floor(this.dims.height / 50)).map(function (d) { return _this.yScale(d); });
    };
    PolarChartComponent.prototype.getXValues = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.name)) {
                    values.push(d.name);
                }
            }
        }
        return values;
    };
    PolarChartComponent.prototype.getXDomain = function (values) {
        if (values === void 0) { values = this.getXValues(); }
        if (this.scaleType === 'time') {
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            return [min$$1, max$$1];
        }
        else if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            return [min$$1, max$$1];
        }
        return values;
    };
    PolarChartComponent.prototype.getYValues = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (domain.indexOf(d.value) < 0) {
                    domain.push(d.value);
                }
                if (d.min !== undefined) {
                    if (domain.indexOf(d.min) < 0) {
                        domain.push(d.min);
                    }
                }
                if (d.max !== undefined) {
                    if (domain.indexOf(d.max) < 0) {
                        domain.push(d.max);
                    }
                }
            }
        }
        return domain;
    };
    PolarChartComponent.prototype.getYDomain = function (domain) {
        if (domain === void 0) { domain = this.getYValues(); }
        var min$$1 = Math.min.apply(Math, domain);
        var max$$1 = Math.max.apply(Math, [this.yAxisMinScale].concat(domain));
        min$$1 = Math.max(0, min$$1);
        if (!this.autoScale) {
            min$$1 = Math.min(0, min$$1);
        }
        return [min$$1, max$$1];
    };
    PolarChartComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    PolarChartComponent.prototype.getXScale = function (domain, width) {
        switch (this.scaleType) {
            case 'time':
                return scaleTime()
                    .range([0, width])
                    .domain(domain);
            case 'linear':
                var scale = scaleLinear()
                    .range([0, width])
                    .domain(domain);
                return this.roundDomains ? scale.nice() : scale;
            default:
                return scalePoint()
                    .range([0, width - twoPI / domain.length])
                    .padding(0)
                    .domain(domain);
        }
    };
    PolarChartComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([0, height])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    PolarChartComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    PolarChartComponent.prototype.setColors = function () {
        var domain = this.schemeType === 'ordinal' ? this.seriesDomain : this.yDomain.reverse();
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    PolarChartComponent.prototype.getLegendOptions = function () {
        if (this.schemeType === 'ordinal') {
            return {
                scaleType: this.schemeType,
                colors: this.colors,
                domain: this.seriesDomain,
                title: this.legendTitle,
                position: this.legendPosition
            };
        }
        return {
            scaleType: this.schemeType,
            colors: this.colors.scale,
            domain: this.yDomain,
            title: undefined,
            position: this.legendPosition
        };
    };
    PolarChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    PolarChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    PolarChartComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = this.showSeriesOnHover ? [item].concat(this.activeEntries) : this.activeEntries;
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    PolarChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    PolarChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    PolarChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarChartComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PolarChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PolarChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PolarChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showSeriesOnHover", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "yAxisMinScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "labelTrim", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "labelTrimSize", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], PolarChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], PolarChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], PolarChartComponent.prototype, "tooltipTemplate", void 0);
PolarChartComponent.ɵfac = function PolarChartComponent_Factory(t) { return ɵPolarChartComponent_BaseFactory(t || PolarChartComponent); };
PolarChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PolarChartComponent, selectors: [["ngx-charts-polar-chart"]], contentQueries: function PolarChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", autoScale: "autoScale", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", rangeFillOpacity: "rangeFillOpacity", trimYAxisTicks: "trimYAxisTicks", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", showSeriesOnHover: "showSeriesOnHover", gradient: "gradient", yAxisMinScale: "yAxisMinScale", labelTrim: "labelTrim", labelTrimSize: "labelTrimSize" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 18, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "polar-chart", "chart"], ["cx", "0", "cy", "0", 1, "polar-chart-background"], [4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "gridline-path radial-gridline-path", "cx", "0", "cy", "0", 4, "ngFor", "ngForOf"], ["cx", "0", "cy", "0", 1, "gridline-path", "radial-gridline-path"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize", 4, "ngFor", "ngForOf"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"], ["ngx-charts-polar-series", "", 3, "gradient", "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "animations", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"]], template: function PolarChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function PolarChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g");
        ɵngcc0.ɵɵelement(3, "circle", 2);
        ɵngcc0.ɵɵtemplate(4, PolarChartComponent__svg_g_4_Template, 2, 1, "g", 3);
        ɵngcc0.ɵɵtemplate(5, PolarChartComponent__svg_g_5_Template, 2, 1, "g", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, PolarChartComponent__svg_g_6_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(7, PolarChartComponent__svg_g_7_Template, 1, 5, "g", 5);
        ɵngcc0.ɵɵelementStart(8, "g");
        ɵngcc0.ɵɵtemplate(9, PolarChartComponent__svg_g_9_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(15, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transformPlot);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("r", ctx.outerRadius);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showGridLines);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis && ctx.showXAxisLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transformPlot);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, PieLabelComponent,
        YAxisComponent,
        AxisLabelComponent,
        PolarSeriesComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-label{font-size:11px}.pie-label.animation{animation:750ms ease-in fadeIn}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d 750ms}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}", ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area{pointer-events:none}.polar-series-path{pointer-events:none}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵPolarChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PolarChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PolarChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-polar-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:g class=\"polar-chart chart\" [attr.transform]=\"transform\">\n        <svg:g [attr.transform]=\"transformPlot\">\n          <svg:circle class=\"polar-chart-background\" cx=\"0\" cy=\"0\" [attr.r]=\"this.outerRadius\" />\n          <svg:g *ngIf=\"showGridLines\">\n            <svg:circle\n              *ngFor=\"let r of radiusTicks\"\n              class=\"gridline-path radial-gridline-path\"\n              cx=\"0\"\n              cy=\"0\"\n              [attr.r]=\"r\"\n            />\n          </svg:g>\n          <svg:g *ngIf=\"xAxis\">\n            <svg:g\n              ngx-charts-pie-label\n              *ngFor=\"let tick of thetaTicks\"\n              [data]=\"tick\"\n              [radius]=\"outerRadius\"\n              [label]=\"tick.label\"\n              [max]=\"outerRadius\"\n              [value]=\"showGridLines ? 1 : outerRadius\"\n              [explodeSlices]=\"true\"\n              [animations]=\"animations\"\n              [labelTrim]=\"labelTrim\"\n              [labelTrimSize]=\"labelTrimSize\"\n            ></svg:g>\n          </svg:g>\n        </svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          [attr.transform]=\"transformYAxis\"\n          *ngIf=\"yAxis\"\n          [yScale]=\"yAxisScale\"\n          [dims]=\"yAxisDims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-axis-label\n          *ngIf=\"xAxis && showXAxisLabel\"\n          [label]=\"xAxisLabel\"\n          [offset]=\"labelOffset\"\n          [orient]=\"'bottom'\"\n          [height]=\"dims.height\"\n          [width]=\"dims.width\"\n        ></svg:g>\n        <svg:g [attr.transform]=\"transformPlot\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-polar-series\n              [gradient]=\"gradient\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [curve]=\"curve\"\n              [rangeFillOpacity]=\"rangeFillOpacity\"\n              [animations]=\"animations\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              (select)=\"onClick($event)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n            />\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [
                    ".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}",
                    ".pie-label{font-size:11px}.pie-label.animation{animation:750ms ease-in fadeIn}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d 750ms}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}",
                    ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area{pointer-events:none}.polar-series-path{pointer-events:none}"
                ],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({
                                opacity: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], showSeriesOnHover: [{
            type: Input
        }], gradient: [{
            type: Input
        }], yAxisMinScale: [{
            type: Input
        }], labelTrim: [{
            type: Input
        }], labelTrimSize: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return PolarChartComponent;
}(BaseChartComponent));

var PolarSeriesComponent = /** @class */ (function () {
    function PolarSeriesComponent() {
        this.tooltipDisabled = false;
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.circleRadius = 3;
    }
    PolarSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PolarSeriesComponent.prototype.update = function () {
        var _this = this;
        this.updateGradients();
        var line$$1 = this.getLineGenerator();
        var data = this.sortData(this.data.series);
        var seriesName = this.data.name;
        var linearScaleType = this.colors.scaleType === 'linear';
        var min$$1 = this.yScale.domain()[0];
        this.seriesColor = this.colors.getColor(linearScaleType ? min$$1 : seriesName);
        this.path = line$$1(data) || '';
        this.circles = data.map(function (d) {
            var a = _this.getAngle(d);
            var r = _this.getRadius(d);
            var value = d.value;
            var color = _this.colors.getColor(linearScaleType ? Math.abs(value) : seriesName);
            var cData = Object.assign({}, d, {
                series: seriesName,
                value: value,
                name: d.name
            });
            return {
                data: cData,
                cx: r * Math.sin(a),
                cy: -r * Math.cos(a),
                value: value,
                color: color,
                label: d.name
            };
        });
        this.active = this.isActive(this.data);
        this.inactive = this.isInactive(this.data);
        this.tooltipText = this.tooltipText || (function (c) { return _this.defaultTooltipText(c); });
    };
    PolarSeriesComponent.prototype.getAngle = function (d) {
        var label = d.name;
        if (this.scaleType === 'time') {
            return this.xScale(label);
        }
        else if (this.scaleType === 'linear') {
            return this.xScale(Number(label));
        }
        return this.xScale(label);
    };
    PolarSeriesComponent.prototype.getRadius = function (d) {
        return this.yScale(d.value);
    };
    PolarSeriesComponent.prototype.getLineGenerator = function () {
        var _this = this;
        return lineRadial()
            .angle(function (d) { return _this.getAngle(d); })
            .radius(function (d) { return _this.getRadius(d); })
            .curve(this.curve);
    };
    PolarSeriesComponent.prototype.sortData = function (data) {
        if (this.scaleType === 'linear') {
            return sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            return sortByTime(data, 'name');
        }
        return sortByDomain(data, 'name', 'asc', this.xScale.domain());
    };
    PolarSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    PolarSeriesComponent.prototype.isInactive = function (entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item === undefined;
    };
    PolarSeriesComponent.prototype.defaultTooltipText = function (_a) {
        var label = _a.label, value = _a.value;
        return "\n      <span class=\"tooltip-label\">" + this.data.name + " \u2022 " + label + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n    ";
    };
    PolarSeriesComponent.prototype.updateGradients = function () {
        this.hasGradient = this.gradient || this.colors.scaleType === 'linear';
        if (!this.hasGradient) {
            return;
        }
        this.gradientId = 'grad' + id().toString();
        this.gradientUrl = "url(#" + this.gradientId + ")";
        if (this.colors.scaleType === 'linear') {
            var values = this.data.series.map(function (d) { return d.value; });
            var max$$1 = Math.max.apply(Math, values);
            var min$$1 = Math.min.apply(Math, values);
            this.gradientStops = this.colors.getLinearGradientStops(max$$1, min$$1);
        }
        else {
            this.gradientStops = undefined;
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "name", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PolarSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarSeriesComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PolarSeriesComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], PolarSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "deactivate", void 0);
PolarSeriesComponent.ɵfac = function PolarSeriesComponent_Factory(t) { return new (t || PolarSeriesComponent)(); };
PolarSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PolarSeriesComponent, selectors: [["g", "ngx-charts-polar-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", gradient: "gradient", animations: "animations", tooltipText: "tooltipText", name: "name", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", curve: "curve", activeEntries: "activeEntries", rangeFillOpacity: "rangeFillOpacity", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c37, decls: 5, vars: 11, consts: [[1, "polar-charts-series"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity", "endOpacity", "stops", 4, "ngIf"], ["ngx-charts-line", "", 1, "polar-series-path", 3, "path", "stroke", "fill", "animations"], ["ngx-charts-circle", "", "class", "circle", "ngx-tooltip", "", "tooltipType", "tooltip", 3, "cx", "cy", "r", "fill", "opacity", "tooltipDisabled", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity", "endOpacity", "stops"], ["ngx-charts-circle", "", "ngx-tooltip", "", "tooltipType", "tooltip", 1, "circle", 3, "cx", "cy", "r", "fill", "tooltipDisabled", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function PolarSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵtemplate(2, PolarSeriesComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "g", 2);
        ɵngcc0.ɵɵtemplate(4, PolarSeriesComponent__svg_g_4_Template, 1, 11, "g", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.active)("inactive", ctx.inactive);
        ɵngcc0.ɵɵproperty("path", ctx.path)("stroke", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("animations", ctx.animations);
        ɵngcc0.ɵɵattribute("fill-opacity", ctx.rangeFillOpacity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.circles);
    } }, directives: [ɵngcc1.NgIf, LineComponent, ɵngcc1.NgForOf, SvgRadialGradientComponent,
        CircleComponent,
        TooltipDirective], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PolarSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-polar-series]',
                template: "\n    <svg:g class=\"polar-charts-series\">\n      <defs>\n        <svg:g\n          ngx-charts-svg-radial-gradient\n          *ngIf=\"hasGradient\"\n          orientation=\"vertical\"\n          [color]=\"seriesColor\"\n          [name]=\"gradientId\"\n          [startOpacity]=\"0.25\"\n          [endOpacity]=\"1\"\n          [stops]=\"gradientStops\"\n        />\n      </defs>\n      <svg:g\n        ngx-charts-line\n        class=\"polar-series-path\"\n        [path]=\"path\"\n        [stroke]=\"hasGradient ? gradientUrl : seriesColor\"\n        [class.active]=\"active\"\n        [class.inactive]=\"inactive\"\n        [attr.fill-opacity]=\"rangeFillOpacity\"\n        [fill]=\"hasGradient ? gradientUrl : seriesColor\"\n        [animations]=\"animations\"\n      />\n      <svg:g\n        ngx-charts-circle\n        *ngFor=\"let circle of circles\"\n        class=\"circle\"\n        [cx]=\"circle.cx\"\n        [cy]=\"circle.cy\"\n        [r]=\"circleRadius\"\n        [fill]=\"circle.color\"\n        [style.opacity]=\"inactive ? 0.2 : 1\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        tooltipType=\"tooltip\"\n        [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(circle)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"circle.data\"\n        (select)=\"select.emit(circle.data)\"\n        (activate)=\"activate.emit({ name: circle.data.series })\"\n        (deactivate)=\"deactivate.emit({ name: circle.data.series })\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipText: [{
            type: Input
        }], name: [{
            type: Input
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return PolarSeriesComponent;
}());

var AdvancedPieChartComponent = /** @class */ (function (_super) {
    __extends(AdvancedPieChartComponent, _super);
    function AdvancedPieChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.label = 'Total';
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [20, 20, 20, 20];
        return _this;
    }
    AdvancedPieChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: (this.width * 4) / 12.0,
            height: this.height,
            margins: this.margin
        });
        this.formatDates();
        this.domain = this.getDomain();
        this.setColors();
        var xOffset = this.dims.width / 2;
        var yOffset = this.margin[0] + this.dims.height / 2;
        this.legendWidth = this.width - this.dims.width - this.margin[1];
        this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2.5;
        this.innerRadius = this.outerRadius * 0.75;
        this.transform = "translate(" + xOffset + " , " + yOffset + ")";
    };
    AdvancedPieChartComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    AdvancedPieChartComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    AdvancedPieChartComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    AdvancedPieChartComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AdvancedPieChartComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AdvancedPieChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AdvancedPieChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AdvancedPieChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AdvancedPieChartComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AdvancedPieChartComponent.prototype, "label", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AdvancedPieChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AdvancedPieChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AdvancedPieChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedPieChartComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedPieChartComponent.prototype, "nameFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedPieChartComponent.prototype, "percentageFormatting", void 0);
AdvancedPieChartComponent.ɵfac = function AdvancedPieChartComponent_Factory(t) { return ɵAdvancedPieChartComponent_BaseFactory(t || AdvancedPieChartComponent); };
AdvancedPieChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AdvancedPieChartComponent, selectors: [["ngx-charts-advanced-pie-chart"]], contentQueries: function AdvancedPieChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", gradient: "gradient", tooltipDisabled: "tooltipDisabled", tooltipText: "tooltipText", label: "label", valueFormatting: "valueFormatting", nameFormatting: "nameFormatting", percentageFormatting: "percentageFormatting" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 7, vars: 37, consts: [[1, "advanced-pie", "chart"], [3, "view", "showLegend", "animations"], [1, "pie", "chart"], ["ngx-charts-pie-series", "", 3, "colors", "series", "innerRadius", "activeEntries", "outerRadius", "gradient", "tooltipDisabled", "tooltipTemplate", "tooltipText", "animations", "select", "activate", "deactivate"], [1, "advanced-pie-legend-wrapper"], [3, "data", "colors", "width", "label", "animations", "valueFormatting", "labelFormatting", "percentageFormatting", "select", "activate", "deactivate"]], template: function AdvancedPieChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵelementStart(2, "ngx-charts-chart", 1);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(3, "g", 2);
        ɵngcc0.ɵɵelementStart(4, "g", 3);
        ɵngcc0.ɵɵlistener("select", function AdvancedPieChartComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("activate", function AdvancedPieChartComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function AdvancedPieChartComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "ngx-charts-advanced-legend", 5);
        ɵngcc0.ɵɵlistener("select", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_select_6_listener($event) { return ctx.onClick($event); })("activate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_activate_6_listener($event) { return ctx.onActivate($event, undefined, true); })("deactivate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_deactivate_6_listener($event) { return ctx.onDeactivate($event, undefined, true); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px")("height", ctx.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.dims.width, "px")("height", ctx.dims.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(34, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("series", ctx.results)("innerRadius", ctx.innerRadius)("activeEntries", ctx.activeEntries)("outerRadius", ctx.outerRadius)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.width - ctx.dims.width, "px")("height", ctx.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("data", ctx.results)("colors", ctx.colors)("width", ctx.width - ctx.dims.width - ctx.margin[1])("label", ctx.label)("animations", ctx.animations)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.nameFormatting)("percentageFormatting", ctx.percentageFormatting);
    } }, directives: function () { return [ChartComponent,
        PieSeriesComponent,
        AdvancedLegendComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".advanced-pie{display:inline-block;float:left}.advanced-pie-legend-wrapper{display:inline-block}"], encapsulation: 2, changeDetection: 0 });
var ɵAdvancedPieChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(AdvancedPieChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AdvancedPieChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-advanced-pie-chart',
                template: "\n    <div [style.width.px]=\"width\" [style.height.px]=\"height\">\n      <div class=\"advanced-pie chart\" [style.width.px]=\"dims.width\" [style.height.px]=\"dims.height\">\n        <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n          <svg:g [attr.transform]=\"transform\" class=\"pie chart\">\n            <svg:g\n              ngx-charts-pie-series\n              [colors]=\"colors\"\n              [series]=\"results\"\n              [innerRadius]=\"innerRadius\"\n              [activeEntries]=\"activeEntries\"\n              [outerRadius]=\"outerRadius\"\n              [gradient]=\"gradient\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              [tooltipText]=\"tooltipText\"\n              (select)=\"onClick($event)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n              [animations]=\"animations\"\n            ></svg:g>\n          </svg:g>\n        </ngx-charts-chart>\n      </div>\n      <div class=\"advanced-pie-legend-wrapper\" [style.width.px]=\"width - dims.width\" [style.height.px]=\"height\">\n        <ngx-charts-advanced-legend\n          [data]=\"results\"\n          [colors]=\"colors\"\n          [width]=\"width - dims.width - margin[1]\"\n          [label]=\"label\"\n          [animations]=\"animations\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"nameFormatting\"\n          [percentageFormatting]=\"percentageFormatting\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event, undefined, true)\"\n          (deactivate)=\"onDeactivate($event, undefined, true)\"\n        >\n        </ngx-charts-advanced-legend>\n      </div>\n    </div>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".advanced-pie{display:inline-block;float:left}.advanced-pie-legend-wrapper{display:inline-block}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { activeEntries: [{
            type: Input
        }], gradient: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], label: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], valueFormatting: [{
            type: Input
        }], nameFormatting: [{
            type: Input
        }], percentageFormatting: [{
            type: Input
        }] }); })();
    return AdvancedPieChartComponent;
}(BaseChartComponent));

var PieLabelComponent = /** @class */ (function () {
    function PieLabelComponent() {
        this.animations = true;
        this.labelTrim = true;
        this.labelTrimSize = 10;
        this.isIE = /(edge|msie|trident)/i.test(navigator.userAgent);
        this.trimLabel = trimLabel;
    }
    PieLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieLabelComponent.prototype.update = function () {
        var startRadius = this.radius;
        if (this.explodeSlices) {
            startRadius = this.radius * this.value / this.max;
        }
        var innerArc = arc()
            .innerRadius(startRadius)
            .outerRadius(startRadius);
        // Calculate innerPos then scale outer position to match label position
        var innerPos = innerArc.centroid(this.data);
        var scale = this.data.pos[1] / innerPos[1];
        if (this.data.pos[1] === 0 || innerPos[1] === 0) {
            scale = 1;
        }
        var outerPos = [scale * innerPos[0], scale * innerPos[1]];
        this.line = "M" + innerPos + "L" + outerPos + "L" + this.data.pos;
    };
    Object.defineProperty(PieLabelComponent.prototype, "textX", {
        get: function () {
            return this.data.pos[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "textY", {
        get: function () {
            return this.data.pos[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "styleTransform", {
        get: function () {
            return this.isIE ? null : "translate3d(" + this.textX + "px," + this.textY + "px, 0)";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "attrTransform", {
        get: function () {
            return !this.isIE ? null : "translate(" + this.textX + "," + this.textY + ")";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "textTransition", {
        get: function () {
            return this.isIE || !this.animations ? null : 'transform 0.75s';
        },
        enumerable: true,
        configurable: true
    });
    PieLabelComponent.prototype.textAnchor = function () {
        return this.midAngle(this.data) < Math.PI ? 'start' : 'end';
    };
    PieLabelComponent.prototype.midAngle = function (d) {
        return d.startAngle + (d.endAngle - d.startAngle) / 2;
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "radius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieLabelComponent.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieLabelComponent.prototype, "labelTrim", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieLabelComponent.prototype, "labelTrimSize", void 0);
    PieLabelComponent = __decorate([ __metadata("design:paramtypes", [])
    ], PieLabelComponent);
PieLabelComponent.ɵfac = function PieLabelComponent_Factory(t) { return new (t || PieLabelComponent)(); };
PieLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieLabelComponent, selectors: [["g", "ngx-charts-pie-label", ""]], inputs: { animations: "animations", labelTrim: "labelTrim", labelTrimSize: "labelTrimSize", data: "data", radius: "radius", label: "label", color: "color", max: "max", value: "value", explodeSlices: "explodeSlices" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c38, decls: 6, vars: 17, consts: [["dy", ".35em", 1, "pie-label"], ["fill", "none", 1, "pie-label-line", "line"]], template: function PieLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "title");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(2, "g");
        ɵngcc0.ɵɵelementStart(3, "text", 0);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "path", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("transform", ctx.styleTransform)("transition", ctx.textTransition);
        ɵngcc0.ɵɵattribute("transform", ctx.attrTransform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", ctx.textAnchor())("shape-rendering", "crispEdges");
        ɵngcc0.ɵɵclassProp("animation", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.labelTrim ? ctx.trimLabel(ctx.label, ctx.labelTrimSize) : ctx.label, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("animation", ctx.animations);
        ɵngcc0.ɵɵattribute("d", ctx.line)("stroke", ctx.color);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-label]',
                template: "\n    <title>{{label}}</title>\n    <svg:g\n      [attr.transform]=\"attrTransform\"\n      [style.transform]=\"styleTransform\"\n      [style.transition]=\"textTransition\">\n      <svg:text\n        class=\"pie-label\"\n        [class.animation]=\"animations\"\n        dy=\".35em\"\n        [style.textAnchor]=\"textAnchor()\"\n        [style.shapeRendering]=\"'crispEdges'\">\n        {{labelTrim ? trimLabel(label, labelTrimSize) : label}}\n      </svg:text>\n    </svg:g>\n    <svg:path\n      [attr.d]=\"line\"\n      [attr.stroke]=\"color\"\n      fill=\"none\"\n      class=\"pie-label-line line\"\n      [class.animation]=\"animations\">\n    </svg:path>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { animations: [{
            type: Input
        }], labelTrim: [{
            type: Input
        }], labelTrimSize: [{
            type: Input
        }], data: [{
            type: Input
        }], radius: [{
            type: Input
        }], label: [{
            type: Input
        }], color: [{
            type: Input
        }], max: [{
            type: Input
        }], value: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }] }); })();
    return PieLabelComponent;
}());

var PieArcComponent = /** @class */ (function () {
    function PieArcComponent(element) {
        this.startAngle = 0;
        this.endAngle = Math.PI * 2;
        this.cornerRadius = 0;
        this.explodeSlices = false;
        this.gradient = false;
        this.animate = true;
        this.pointerEvents = true;
        this.isActive = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dblclick = new EventEmitter();
        this.initialized = false;
        this.element = element.nativeElement;
    }
    PieArcComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieArcComponent.prototype.getGradient = function () {
        return this.gradient ? this.gradientFill : this.fill;
    };
    PieArcComponent.prototype.getPointerEvents = function () {
        return this.pointerEvents ? 'auto' : 'none';
    };
    PieArcComponent.prototype.update = function () {
        var calc = this.calculateArc();
        this.startOpacity = 0.5;
        this.radialGradientId = 'linearGrad' + id().toString();
        this.gradientFill = "url(#" + this.radialGradientId + ")";
        if (this.animate) {
            if (this.initialized) {
                this.updateAnimation();
            }
            else {
                this.loadAnimation();
                this.initialized = true;
            }
        }
        else {
            this.path = calc.startAngle(this.startAngle).endAngle(this.endAngle)();
        }
    };
    PieArcComponent.prototype.calculateArc = function () {
        var outerRadius = this.outerRadius;
        if (this.explodeSlices && this.innerRadius === 0) {
            outerRadius = (this.outerRadius * this.value) / this.max;
        }
        return arc()
            .innerRadius(this.innerRadius)
            .outerRadius(outerRadius)
            .cornerRadius(this.cornerRadius);
    };
    PieArcComponent.prototype.loadAnimation = function () {
        var node = select(this.element)
            .selectAll('.arc')
            .data([{ startAngle: this.startAngle, endAngle: this.endAngle }]);
        var calc = this.calculateArc();
        node
            .transition()
            .attrTween('d', function (d) {
            this._current = this._current || d;
            var copyOfD = Object.assign({}, d);
            copyOfD.endAngle = copyOfD.startAngle;
            var interpolater = interpolate(copyOfD, copyOfD);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        })
            .transition()
            .duration(750)
            .attrTween('d', function (d) {
            this._current = this._current || d;
            var interpolater = interpolate(this._current, d);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        });
    };
    PieArcComponent.prototype.updateAnimation = function () {
        var node = select(this.element)
            .selectAll('.arc')
            .data([{ startAngle: this.startAngle, endAngle: this.endAngle }]);
        var calc = this.calculateArc();
        node
            .transition()
            .duration(750)
            .attrTween('d', function (d) {
            this._current = this._current || d;
            var interpolater = interpolate(this._current, d);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        });
    };
    PieArcComponent.prototype.onClick = function () {
        var _this = this;
        clearTimeout(this._timeout);
        this._timeout = setTimeout(function () { return _this.select.emit(_this.data); }, 200);
    };
    PieArcComponent.prototype.onDblClick = function (event$$1) {
        event$$1.preventDefault();
        event$$1.stopPropagation();
        clearTimeout(this._timeout);
        this.dblclick.emit({
            data: this.data,
            nativeEvent: event$$1
        });
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieArcComponent.prototype, "startAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieArcComponent.prototype, "endAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "innerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "outerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieArcComponent.prototype, "cornerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "animate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "pointerEvents", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "isActive", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "dblclick", void 0);
    PieArcComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], PieArcComponent);
PieArcComponent.ɵfac = function PieArcComponent_Factory(t) { return new (t || PieArcComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
PieArcComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieArcComponent, selectors: [["g", "ngx-charts-pie-arc", ""]], inputs: { startAngle: "startAngle", endAngle: "endAngle", cornerRadius: "cornerRadius", explodeSlices: "explodeSlices", gradient: "gradient", animate: "animate", pointerEvents: "pointerEvents", isActive: "isActive", fill: "fill", innerRadius: "innerRadius", outerRadius: "outerRadius", value: "value", max: "max", data: "data" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dblclick: "dblclick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c39, decls: 3, vars: 7, consts: [[1, "arc-group"], [4, "ngIf"], [1, "arc", 3, "click", "dblclick", "mouseenter", "mouseleave"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity"]], template: function PieArcComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, PieArcComponent__svg_defs_1_Template, 2, 3, "defs", 1);
        ɵngcc0.ɵɵelementStart(2, "path", 2);
        ɵngcc0.ɵɵlistener("click", function PieArcComponent_Template__svg_path_click_2_listener() { return ctx.onClick(); })("dblclick", function PieArcComponent_Template__svg_path_dblclick_2_listener($event) { return ctx.onDblClick($event); })("mouseenter", function PieArcComponent_Template__svg_path_mouseenter_2_listener() { return ctx.activate.emit(ctx.data); })("mouseleave", function PieArcComponent_Template__svg_path_mouseleave_2_listener() { return ctx.deactivate.emit(ctx.data); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("pointer-events", ctx.getPointerEvents());
        ɵngcc0.ɵɵclassProp("active", ctx.isActive);
        ɵngcc0.ɵɵattribute("d", ctx.path)("fill", ctx.getGradient());
    } }, directives: [ɵngcc1.NgIf, SvgRadialGradientComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieArcComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-arc]',
                template: "\n    <svg:g class=\"arc-group\">\n      <svg:defs *ngIf=\"gradient\">\n        <svg:g ngx-charts-svg-radial-gradient\n          [color]=\"fill\"\n          orientation=\"vertical\"\n          [name]=\"radialGradientId\"\n          [startOpacity]=\"startOpacity\"\n        />\n      </svg:defs>\n      <svg:path\n        [attr.d]=\"path\"\n        class=\"arc\"\n        [class.active]=\"isActive\"\n        [attr.fill]=\"getGradient()\"\n        (click)=\"onClick()\"\n        (dblclick)=\"onDblClick($event)\"\n        (mouseenter)=\"activate.emit(data)\"\n        (mouseleave)=\"deactivate.emit(data)\"\n        [style.pointer-events]=\"getPointerEvents()\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { startAngle: [{
            type: Input
        }], endAngle: [{
            type: Input
        }], cornerRadius: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }], gradient: [{
            type: Input
        }], animate: [{
            type: Input
        }], pointerEvents: [{
            type: Input
        }], isActive: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dblclick: [{
            type: Output
        }], fill: [{
            type: Input
        }], innerRadius: [{
            type: Input
        }], outerRadius: [{
            type: Input
        }], value: [{
            type: Input
        }], max: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
    return PieArcComponent;
}());

var PieChartComponent = /** @class */ (function (_super) {
    __extends(PieChartComponent, _super);
    function PieChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.labels = false;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.explodeSlices = false;
        _this.doughnut = false;
        _this.arcWidth = 0.25;
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.trimLabels = true;
        _this.maxLabelLength = 10;
        _this.dblclick = new EventEmitter();
        _this.select = new EventEmitter();
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        return _this;
    }
    PieChartComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        if (this.labels && this.hasNoOptionalMarginsSet()) {
            this.margins = [30, 80, 30, 80];
        }
        else if (!this.labels && this.hasNoOptionalMarginsSet()) {
            this.margins = [20, 20, 20, 20];
        }
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margins,
            showLegend: this.legend,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        var xOffset = this.margins[3] + this.dims.width / 2;
        var yOffset = this.margins[0] + this.dims.height / 2;
        this.translation = "translate(" + xOffset + ", " + yOffset + ")";
        this.outerRadius = Math.min(this.dims.width, this.dims.height);
        if (this.labels) {
            this.outerRadius /= 3;
        }
        else {
            this.outerRadius /= 2;
        }
        this.innerRadius = 0;
        if (this.doughnut) {
            this.innerRadius = this.outerRadius * (1 - this.arcWidth);
        }
        this.domain = this.getDomain();
        this.data = this.results.sort(function (a, b) {
            return _this.domain.indexOf(a.name) - _this.domain.indexOf(b.name);
        });
        this.setColors();
        this.legendOptions = this.getLegendOptions();
    };
    PieChartComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    PieChartComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    PieChartComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    PieChartComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: 'ordinal',
            domain: this.domain,
            colors: this.colors,
            title: this.legendTitle,
            position: this.legendPosition
        };
    };
    PieChartComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    PieChartComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    PieChartComponent.prototype.hasNoOptionalMarginsSet = function () {
        return !this.margins || this.margins.length <= 0;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "labels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PieChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PieChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "doughnut", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "arcWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieChartComponent.prototype, "trimLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieChartComponent.prototype, "maxLabelLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "tooltipText", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "dblclick", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieChartComponent.prototype, "margins", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], PieChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], PieChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], PieChartComponent.prototype, "tooltipTemplate", void 0);
PieChartComponent.ɵfac = function PieChartComponent_Factory(t) { return ɵPieChartComponent_BaseFactory(t || PieChartComponent); };
PieChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieChartComponent, selectors: [["ngx-charts-pie-chart"]], contentQueries: function PieChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { margins: "margins", activeEntries: "activeEntries", labels: "labels", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", explodeSlices: "explodeSlices", doughnut: "doughnut", arcWidth: "arcWidth", gradient: "gradient", tooltipDisabled: "tooltipDisabled", labelFormatting: "labelFormatting", trimLabels: "trimLabels", maxLabelLength: "maxLabelLength", tooltipText: "tooltipText" }, outputs: { dblclick: "dblclick", select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 24, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "pie-chart", "chart"], ["ngx-charts-pie-series", "", 3, "colors", "series", "showLabels", "labelFormatting", "trimLabels", "maxLabelLength", "activeEntries", "innerRadius", "outerRadius", "explodeSlices", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText", "dblclick", "select", "activate", "deactivate"]], template: function PieChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); })("legendLabelClick", function PieChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("dblclick", function PieChartComponent_Template__svg_g_dblclick_2_listener($event) { return ctx.dblclick.emit($event); })("select", function PieChartComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); })("activate", function PieChartComponent_Template__svg_g_activate_2_listener($event) { return ctx.onActivate($event); })("deactivate", function PieChartComponent_Template__svg_g_deactivate_2_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(21, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.translation);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("series", ctx.data)("showLabels", ctx.labels)("labelFormatting", ctx.labelFormatting)("trimLabels", ctx.trimLabels)("maxLabelLength", ctx.maxLabelLength)("activeEntries", ctx.activeEntries)("innerRadius", ctx.innerRadius)("outerRadius", ctx.outerRadius)("explodeSlices", ctx.explodeSlices)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
    } }, directives: function () { return [ChartComponent,
        PieSeriesComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-label{font-size:11px}.pie-label.animation{animation:750ms ease-in fadeIn}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d 750ms}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}"], encapsulation: 2, changeDetection: 0 });
var ɵPieChartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PieChartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-pie-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"translation\" class=\"pie-chart chart\">\n        <svg:g\n          ngx-charts-pie-series\n          [colors]=\"colors\"\n          [series]=\"data\"\n          [showLabels]=\"labels\"\n          [labelFormatting]=\"labelFormatting\"\n          [trimLabels]=\"trimLabels\"\n          [maxLabelLength]=\"maxLabelLength\"\n          [activeEntries]=\"activeEntries\"\n          [innerRadius]=\"innerRadius\"\n          [outerRadius]=\"outerRadius\"\n          [explodeSlices]=\"explodeSlices\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipText]=\"tooltipText\"\n          (dblclick)=\"dblclick.emit($event)\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-label{font-size:11px}.pie-label.animation{animation:750ms ease-in fadeIn}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d 750ms}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { margins: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], labels: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }], doughnut: [{
            type: Input
        }], arcWidth: [{
            type: Input
        }], gradient: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], trimLabels: [{
            type: Input
        }], maxLabelLength: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], dblclick: [{
            type: Output
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return PieChartComponent;
}(BaseChartComponent));

function gridSize(dims, len, minWidth) {
    var rows = 1;
    var cols = len;
    var width = dims.width;
    if (width > minWidth) {
        while (width / cols < minWidth) {
            rows += 1;
            cols = Math.ceil(len / rows);
        }
    }
    return [cols, rows];
}
function gridLayout(dims, data, minWidth, designatedTotal) {
    var xScale = scaleBand();
    var yScale = scaleBand();
    var width = dims.width;
    var height = dims.height;
    var _a = gridSize(dims, data.length, minWidth), columns = _a[0], rows = _a[1];
    var xDomain = [];
    var yDomain = [];
    for (var i = 0; i < rows; i++) {
        yDomain.push(i);
    }
    for (var i = 0; i < columns; i++) {
        xDomain.push(i);
    }
    xScale.domain(xDomain);
    yScale.domain(yDomain);
    xScale.rangeRound([0, width], 0.1);
    yScale.rangeRound([0, height], 0.1);
    var res = [];
    var total = designatedTotal ? designatedTotal : getTotal(data);
    var cardWidth = xScale.bandwidth();
    var cardHeight = yScale.bandwidth();
    for (var i = 0; i < data.length; i++) {
        res[i] = {};
        res[i].data = {
            name: data[i] ? data[i].name : '',
            value: data[i] ? data[i].value : undefined,
            extra: data[i] ? data[i].extra : undefined,
            label: data[i] ? data[i].label : ''
        };
        res[i].x = xScale(i % columns);
        res[i].y = yScale(Math.floor(i / columns));
        res[i].width = cardWidth;
        res[i].height = cardHeight;
        res[i].data.percent = total > 0 ? res[i].data.value / total : 0;
        res[i].data.total = total;
    }
    return res;
}
function getTotal(results) {
    return results.map(function (d) { return (d ? d.value : 0); }).reduce(function (sum, val) { return sum + val; }, 0);
}

var PieGridComponent = /** @class */ (function (_super) {
    __extends(PieGridComponent, _super);
    function PieGridComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.tooltipDisabled = false;
        _this.label = 'Total';
        _this.minWidth = 150;
        _this.activeEntries = [];
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [20, 20, 20, 20];
        return _this;
    }
    PieGridComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.formatDates();
        this.domain = this.getDomain();
        this.data = gridLayout(this.dims, this.results, this.minWidth, this.designatedTotal);
        this.transform = "translate(" + this.margin[3] + " , " + this.margin[0] + ")";
        this.series = this.getSeries();
        this.setColors();
        this.tooltipText = this.tooltipText || this.defaultTooltipText;
    };
    PieGridComponent.prototype.defaultTooltipText = function (_a) {
        var data = _a.data;
        var label = trimLabel(formatLabel(data.name));
        var val = data.value.toLocaleString();
        return "\n      <span class=\"tooltip-label\">" + label + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
    };
    PieGridComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    PieGridComponent.prototype.getSeries = function () {
        var _this = this;
        var total = this.designatedTotal ? this.designatedTotal : this.getTotal();
        return this.data.map(function (d) {
            var baselineLabelHeight = 20;
            var padding = 10;
            var name = d.data.name;
            var label = formatLabel(name);
            var value = d.data.value;
            var radius = min([d.width - padding, d.height - baselineLabelHeight]) / 2 - 5;
            var innerRadius = radius * 0.9;
            var count = 0;
            var colors = function () {
                count += 1;
                if (count === 1) {
                    return 'rgba(100,100,100,0.3)';
                }
                else {
                    return _this.colorScale.getColor(label);
                }
            };
            var xPos = d.x + (d.width - padding) / 2;
            var yPos = d.y + (d.height - baselineLabelHeight) / 2;
            return {
                transform: "translate(" + xPos + ", " + yPos + ")",
                colors: colors,
                innerRadius: innerRadius,
                outerRadius: radius,
                name: name,
                label: trimLabel(label),
                total: value,
                value: value,
                percent: format('.1%')(d.data.percent),
                data: [
                    d,
                    {
                        data: {
                            other: true,
                            value: total - value,
                            name: d.data.name
                        }
                    }
                ]
            };
        });
    };
    PieGridComponent.prototype.getTotal = function () {
        return this.results.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
    };
    PieGridComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    PieGridComponent.prototype.setColors = function () {
        this.colorScale = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    PieGridComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    PieGridComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieGridComponent.prototype, "designatedTotal", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieGridComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PieGridComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PieGridComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieGridComponent.prototype, "minWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieGridComponent.prototype, "activeEntries", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], PieGridComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], PieGridComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], PieGridComponent.prototype, "tooltipTemplate", void 0);
PieGridComponent.ɵfac = function PieGridComponent_Factory(t) { return ɵPieGridComponent_BaseFactory(t || PieGridComponent); };
PieGridComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieGridComponent, selectors: [["ngx-charts-pie-grid"]], contentQueries: function PieGridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { tooltipText: "tooltipText", activeEntries: "activeEntries", designatedTotal: "designatedTotal", tooltipDisabled: "tooltipDisabled", label: "label", minWidth: "minWidth" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 8, consts: [[3, "view", "showLegend", "animations"], [1, "pie-grid", "chart"], ["class", "pie-grid-item", 4, "ngFor", "ngForOf"], [1, "pie-grid-item"], ["ngx-charts-pie-grid-series", "", "ngx-tooltip", "", 3, "colors", "data", "innerRadius", "outerRadius", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 4, "ngIf"], ["dy", "0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 3, "countTo", "countPrefix", 4, "ngIf"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", 4, "ngIf"], ["dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 1, "label", "percent-label", 3, "countTo", "countSuffix"], ["dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label", "percent-label"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 1, "label", 3, "countTo", "countPrefix"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", 1, "label"]], template: function PieGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, PieGridComponent__svg_g_2_Template, 8, 19, "g", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(5, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.series);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgForOf, PieGridSeriesComponent,
        TooltipDirective, ɵngcc1.NgIf, CountUpDirective]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}"], encapsulation: 2, changeDetection: 0 });
var ɵPieGridComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(PieGridComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieGridComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-pie-grid',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"pie-grid chart\">\n        <svg:g *ngFor=\"let series of series\" class=\"pie-grid-item\" [attr.transform]=\"series.transform\">\n          <svg:g\n            ngx-charts-pie-grid-series\n            [colors]=\"series.colors\"\n            [data]=\"series.data\"\n            [innerRadius]=\"series.innerRadius\"\n            [outerRadius]=\"series.outerRadius\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event)\"\n            ngx-tooltip\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipPlacement]=\"'top'\"\n            [tooltipType]=\"'tooltip'\"\n            [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText({ data: series })\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [tooltipContext]=\"series.data[0].data\"\n            (activate)=\"onActivate($event)\"\n            (deactivate)=\"onDeactivate($event)\"\n          />\n          <svg:text\n            *ngIf=\"animations\"\n            class=\"label percent-label\"\n            dy=\"-0.5em\"\n            x=\"0\"\n            y=\"5\"\n            ngx-charts-count-up\n            [countTo]=\"series.percent\"\n            [countSuffix]=\"'%'\"\n            text-anchor=\"middle\"\n          ></svg:text>\n          <svg:text *ngIf=\"!animations\" class=\"label percent-label\" dy=\"-0.5em\" x=\"0\" y=\"5\" text-anchor=\"middle\">\n            {{ series.percent.toLocaleString() }}\n          </svg:text>\n          <svg:text class=\"label\" dy=\"0.5em\" x=\"0\" y=\"5\" text-anchor=\"middle\">\n            {{ series.label }}\n          </svg:text>\n          <svg:text\n            *ngIf=\"animations\"\n            class=\"label\"\n            dy=\"1.23em\"\n            x=\"0\"\n            [attr.y]=\"series.outerRadius\"\n            text-anchor=\"middle\"\n            ngx-charts-count-up\n            [countTo]=\"series.total\"\n            [countPrefix]=\"label + ': '\"\n          ></svg:text>\n          <svg:text\n            *ngIf=\"!animations\"\n            class=\"label\"\n            dy=\"1.23em\"\n            x=\"0\"\n            [attr.y]=\"series.outerRadius\"\n            text-anchor=\"middle\"\n          >\n            {{ label }}: {{ series.total.toLocaleString() }}\n          </svg:text>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { tooltipText: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], designatedTotal: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], label: [{
            type: Input
        }], minWidth: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return PieGridComponent;
}(BaseChartComponent));

var PieGridSeriesComponent = /** @class */ (function () {
    function PieGridSeriesComponent(element) {
        this.innerRadius = 70;
        this.outerRadius = 80;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.element = element.nativeElement;
    }
    PieGridSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieGridSeriesComponent.prototype.update = function () {
        this.layout = pie()
            .value(function (d) { return d.data.value; })
            .sort(null);
        this.arcs = this.getArcs();
    };
    PieGridSeriesComponent.prototype.getArcs = function () {
        var _this = this;
        return this.layout(this.data).map(function (arc$$1, index) {
            var label = arc$$1.data.data.name;
            var other = arc$$1.data.data.other;
            if (index === 0) {
                arc$$1.startAngle = 0;
            }
            var color = _this.colors(label);
            return {
                data: arc$$1.data.data,
                class: 'arc ' + 'arc' + index,
                fill: color,
                startAngle: other ? 0 : arc$$1.startAngle,
                endAngle: arc$$1.endAngle,
                animate: _this.animations && !other,
                pointerEvents: !other
            };
        });
    };
    PieGridSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(this.data[0].data);
    };
    PieGridSeriesComponent.prototype.trackBy = function (index, item) {
        return item.data.name;
    };
    PieGridSeriesComponent.prototype.label = function (arc$$1) {
        return arc$$1.data.name;
    };
    PieGridSeriesComponent.prototype.color = function (arc$$1) {
        return this.colors(this.label(arc$$1));
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "innerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "outerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieGridSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "deactivate", void 0);
    PieGridSeriesComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], PieGridSeriesComponent);
PieGridSeriesComponent.ɵfac = function PieGridSeriesComponent_Factory(t) { return new (t || PieGridSeriesComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
PieGridSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieGridSeriesComponent, selectors: [["g", "ngx-charts-pie-grid-series", ""]], inputs: { innerRadius: "innerRadius", outerRadius: "outerRadius", animations: "animations", colors: "colors", data: "data" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c41, decls: 2, vars: 2, consts: [[1, "pie-grid-arcs"], ["ngx-charts-pie-arc", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-arc", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate", "select", "activate", "deactivate"]], template: function PieGridSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, PieGridSeriesComponent__svg_g_1_Template, 1, 11, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, PieArcComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieGridSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-grid-series]',
                template: "\n    <svg:g class=\"pie-grid-arcs\">\n      <svg:g\n        ngx-charts-pie-arc\n        *ngFor=\"let arc of arcs; trackBy: trackBy\"\n        [attr.class]=\"arc.class\"\n        [startAngle]=\"arc.startAngle\"\n        [endAngle]=\"arc.endAngle\"\n        [innerRadius]=\"innerRadius\"\n        [outerRadius]=\"outerRadius\"\n        [fill]=\"color(arc)\"\n        [value]=\"arc.data.value\"\n        [data]=\"arc.data\"\n        [gradient]=\"false\"\n        [pointerEvents]=\"arc.pointerEvents\"\n        [animate]=\"arc.animate\"\n        (select)=\"onClick($event)\"\n        (activate)=\"activate.emit($event)\"\n        (deactivate)=\"deactivate.emit($event)\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { innerRadius: [{
            type: Input
        }], outerRadius: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], colors: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
    return PieGridSeriesComponent;
}());

var PieSeriesComponent = /** @class */ (function () {
    function PieSeriesComponent() {
        this.series = [];
        this.innerRadius = 60;
        this.outerRadius = 80;
        this.trimLabels = true;
        this.maxLabelLength = 10;
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dblclick = new EventEmitter();
    }
    PieSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieSeriesComponent.prototype.update = function () {
        var pieGenerator = pie()
            .value(function (d) { return d.value; })
            .sort(null);
        var arcData = pieGenerator(this.series);
        this.max = max(arcData, function (d) {
            return d.value;
        });
        this.data = this.calculateLabelPositions(arcData);
        this.tooltipText = this.tooltipText || this.defaultTooltipText;
    };
    PieSeriesComponent.prototype.midAngle = function (d) {
        return d.startAngle + (d.endAngle - d.startAngle) / 2;
    };
    PieSeriesComponent.prototype.outerArc = function () {
        var factor = 1.5;
        return arc()
            .innerRadius(this.outerRadius * factor)
            .outerRadius(this.outerRadius * factor);
    };
    PieSeriesComponent.prototype.calculateLabelPositions = function (pieData) {
        var _this = this;
        var factor = 1.5;
        var minDistance = 10;
        var labelPositions = pieData;
        labelPositions.forEach(function (d) {
            d.pos = _this.outerArc().centroid(d);
            d.pos[0] = factor * _this.outerRadius * (_this.midAngle(d) < Math.PI ? 1 : -1);
        });
        for (var i = 0; i < labelPositions.length - 1; i++) {
            var a = labelPositions[i];
            if (!this.labelVisible(a)) {
                continue;
            }
            for (var j = i + 1; j < labelPositions.length; j++) {
                var b = labelPositions[j];
                if (!this.labelVisible(b)) {
                    continue;
                }
                // if they're on the same side
                if (b.pos[0] * a.pos[0] > 0) {
                    // if they're overlapping
                    var o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
                    if (o > 0) {
                        // push the second up or down
                        b.pos[1] += Math.sign(b.pos[0]) * o;
                    }
                }
            }
        }
        return labelPositions;
    };
    PieSeriesComponent.prototype.labelVisible = function (myArc) {
        return this.showLabels && myArc.endAngle - myArc.startAngle > Math.PI / 30;
    };
    PieSeriesComponent.prototype.getTooltipTitle = function (a) {
        return this.tooltipTemplate ? undefined : this.tooltipText(a);
    };
    PieSeriesComponent.prototype.labelText = function (myArc) {
        if (this.labelFormatting) {
            return this.labelFormatting(myArc.data.name);
        }
        return this.label(myArc);
    };
    PieSeriesComponent.prototype.label = function (myArc) {
        return formatLabel(myArc.data.name);
    };
    PieSeriesComponent.prototype.defaultTooltipText = function (myArc) {
        var label = this.label(myArc);
        var val = formatLabel(myArc.data.value);
        return "\n      <span class=\"tooltip-label\">" + label + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
    };
    PieSeriesComponent.prototype.color = function (myArc) {
        return this.colors.getColor(this.label(myArc));
    };
    PieSeriesComponent.prototype.trackBy = function (index, item) {
        return item.data.name;
    };
    PieSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    PieSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "series", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "innerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "outerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "showLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "trimLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieSeriesComponent.prototype, "maxLabelLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PieSeriesComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], PieSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "dblclick", void 0);
PieSeriesComponent.ɵfac = function PieSeriesComponent_Factory(t) { return new (t || PieSeriesComponent)(); };
PieSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieSeriesComponent, selectors: [["g", "ngx-charts-pie-series", ""]], inputs: { series: "series", innerRadius: "innerRadius", outerRadius: "outerRadius", trimLabels: "trimLabels", maxLabelLength: "maxLabelLength", tooltipDisabled: "tooltipDisabled", animations: "animations", tooltipText: "tooltipText", colors: "colors", dims: "dims", explodeSlices: "explodeSlices", showLabels: "showLabels", gradient: "gradient", activeEntries: "activeEntries", labelFormatting: "labelFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dblclick: "dblclick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c42, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations", 4, "ngIf"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "gradient", "data", "max", "explodeSlices", "isActive", "animate", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", "dblclick"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations"]], template: function PieSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, PieSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, PieArcComponent,
        TooltipDirective,
        PieLabelComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-series]',
                template: "\n    <svg:g *ngFor=\"let arc of data; trackBy: trackBy\">\n      <svg:g\n        ngx-charts-pie-label\n        *ngIf=\"labelVisible(arc)\"\n        [data]=\"arc\"\n        [radius]=\"outerRadius\"\n        [color]=\"color(arc)\"\n        [label]=\"labelText(arc)\"\n        [labelTrim]=\"trimLabels\"\n        [labelTrimSize]=\"maxLabelLength\"\n        [max]=\"max\"\n        [value]=\"arc.value\"\n        [explodeSlices]=\"explodeSlices\"\n        [animations]=\"animations\"\n      ></svg:g>\n      <svg:g\n        ngx-charts-pie-arc\n        [startAngle]=\"arc.startAngle\"\n        [endAngle]=\"arc.endAngle\"\n        [innerRadius]=\"innerRadius\"\n        [outerRadius]=\"outerRadius\"\n        [fill]=\"color(arc)\"\n        [value]=\"arc.data.value\"\n        [gradient]=\"gradient\"\n        [data]=\"arc.data\"\n        [max]=\"max\"\n        [explodeSlices]=\"explodeSlices\"\n        [isActive]=\"isActive(arc.data)\"\n        [animate]=\"animations\"\n        (select)=\"onClick($event)\"\n        (activate)=\"activate.emit($event)\"\n        (deactivate)=\"deactivate.emit($event)\"\n        (dblclick)=\"dblclick.emit($event)\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipTitle]=\"getTooltipTitle(arc)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"arc.data\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { series: [{
            type: Input
        }], innerRadius: [{
            type: Input
        }], outerRadius: [{
            type: Input
        }], trimLabels: [{
            type: Input
        }], maxLabelLength: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dblclick: [{
            type: Output
        }], tooltipText: [{
            type: Input
        }], colors: [{
            type: Input
        }], dims: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }], showLabels: [{
            type: Input
        }], gradient: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return PieSeriesComponent;
}());

var PieChartModule = /** @class */ (function () {
    function PieChartModule() {
    }
PieChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PieChartModule });
PieChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PieChartModule_Factory(t) { return new (t || PieChartModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PieChartModule, { declarations: [AdvancedPieChartComponent,
        PieLabelComponent,
        PieArcComponent,
        PieChartComponent,
        PieGridComponent,
        PieGridSeriesComponent,
        PieSeriesComponent], imports: [ChartCommonModule], exports: [AdvancedPieChartComponent,
        PieLabelComponent,
        PieArcComponent,
        PieChartComponent,
        PieGridComponent,
        PieGridSeriesComponent,
        PieSeriesComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PieChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    AdvancedPieChartComponent,
                    PieLabelComponent,
                    PieArcComponent,
                    PieChartComponent,
                    PieGridComponent,
                    PieGridSeriesComponent,
                    PieSeriesComponent
                ],
                exports: [
                    AdvancedPieChartComponent,
                    PieLabelComponent,
                    PieArcComponent,
                    PieChartComponent,
                    PieGridComponent,
                    PieGridSeriesComponent,
                    PieSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return PieChartModule;
}());

var PolarChartModule = /** @class */ (function () {
    function PolarChartModule() {
    }
PolarChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PolarChartModule });
PolarChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function PolarChartModule_Factory(t) { return new (t || PolarChartModule)(); }, imports: [[ChartCommonModule, PieChartModule, LineChartModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PolarChartModule, { declarations: [PolarChartComponent,
        PolarSeriesComponent], imports: [ChartCommonModule,
        PieChartModule,
        LineChartModule], exports: [PolarChartComponent,
        PolarSeriesComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PolarChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule, PieChartModule, LineChartModule],
                declarations: [
                    PolarChartComponent,
                    PolarSeriesComponent
                ],
                exports: [
                    PolarChartComponent,
                    PolarSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return PolarChartModule;
}());

var CardComponent = /** @class */ (function () {
    function CardComponent(element, cd, zone) {
        this.cd = cd;
        this.zone = zone;
        this.animations = true;
        this.select = new EventEmitter();
        this.value = '';
        this.textFontSize = 12;
        this.textTransform = '';
        this.initialized = false;
        this.bandHeight = 10;
        this.textPadding = [10, 20, 5, 20];
        this.labelFontSize = 15;
        this.element = element.nativeElement;
    }
    CardComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    CardComponent.prototype.ngOnDestroy = function () {
        cancelAnimationFrame(this.animationReq);
    };
    CardComponent.prototype.update = function () {
        var _this = this;
        this.zone.run(function () {
            var hasValue = _this.data && typeof _this.data.value !== 'undefined';
            var valueFormatting = _this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
            var labelFormatting = _this.labelFormatting || (function (card) { return trimLabel(card.label, 55); });
            _this.transform = "translate(" + _this.x + " , " + _this.y + ")";
            _this.textWidth = Math.max(0, _this.width) - _this.textPadding[1] - _this.textPadding[3];
            _this.cardWidth = Math.max(0, _this.width);
            _this.cardHeight = Math.max(0, _this.height);
            _this.label = _this.label ? _this.label : _this.data.name;
            var cardData = {
                label: _this.label,
                data: _this.data,
                value: _this.data.value
            };
            _this.formattedLabel = labelFormatting(cardData);
            _this.transformBand = "translate(0 , " + (_this.cardHeight - _this.bandHeight) + ")";
            var value = hasValue ? valueFormatting(cardData) : '';
            _this.value = _this.paddedValue(value);
            _this.setPadding();
            _this.bandPath = roundedRect(0, 0, _this.cardWidth, _this.bandHeight, 3, [false, false, true, true]);
            setTimeout(function () {
                _this.scaleText();
                _this.value = value;
                if (hasValue && !_this.initialized) {
                    setTimeout(function () { return _this.startCount(); }, 20);
                }
            }, 8);
        });
    };
    CardComponent.prototype.paddedValue = function (value) {
        if (this.medianSize && this.medianSize > value.length) {
            value += '\u2007'.repeat(this.medianSize - value.length);
        }
        return value;
    };
    CardComponent.prototype.startCount = function () {
        var _this = this;
        if (!this.initialized && this.animations) {
            cancelAnimationFrame(this.animationReq);
            var val_1 = this.data.value;
            var decs = decimalChecker(val_1);
            var valueFormatting_1 = this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
            var callback = function (_a) {
                var value = _a.value, finished = _a.finished;
                _this.zone.run(function () {
                    value = finished ? val_1 : value;
                    _this.value = valueFormatting_1({ label: _this.label, data: _this.data, value: value });
                    if (!finished) {
                        _this.value = _this.paddedValue(_this.value);
                    }
                    _this.cd.markForCheck();
                });
            };
            this.animationReq = count(0, val_1, decs, 1, callback);
            this.initialized = true;
        }
    };
    CardComponent.prototype.scaleText = function () {
        var _this = this;
        this.zone.run(function () {
            var _a = _this.textEl.nativeElement.getBoundingClientRect(), width = _a.width, height = _a.height;
            if (width === 0 || height === 0) {
                return;
            }
            var textPadding = (_this.textPadding[1] = _this.textPadding[3] = _this.cardWidth / 8);
            var availableWidth = _this.cardWidth - 2 * textPadding;
            var availableHeight = _this.cardHeight / 3;
            var resizeScale = Math.min(availableWidth / width, availableHeight / height);
            _this.textFontSize = Math.floor(_this.textFontSize * resizeScale);
            _this.labelFontSize = Math.min(_this.textFontSize, 15);
            _this.setPadding();
            _this.cd.markForCheck();
        });
    };
    CardComponent.prototype.setPadding = function () {
        this.textPadding[1] = this.textPadding[3] = this.cardWidth / 8;
        var padding = this.cardHeight / 2;
        this.textPadding[0] = padding - this.textFontSize - this.labelFontSize / 2;
        this.textPadding[2] = padding - this.labelFontSize;
    };
    CardComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "bandColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "textColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], CardComponent.prototype, "medianSize", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], CardComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "select", void 0);
    __decorate([
        ViewChild('textEl', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], CardComponent.prototype, "textEl", void 0);
    CardComponent = __decorate([ __metadata("design:paramtypes", [typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object, typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object, typeof (_d = typeof NgZone !== "undefined" && NgZone) === "function" ? _d : Object])
    ], CardComponent);
CardComponent.ɵfac = function CardComponent_Factory(t) { return new (t || CardComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof NgZone !== "undefined" && NgZone) === "function" ? _d : Object)); };
CardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardComponent, selectors: [["g", "ngx-charts-card", ""]], viewQuery: function CardComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c43, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textEl = _t.first);
    } }, inputs: { animations: "animations", color: "color", bandColor: "bandColor", textColor: "textColor", x: "x", y: "y", width: "width", height: "height", label: "label", data: "data", medianSize: "medianSize", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c44, decls: 10, vars: 25, consts: [[1, "cell", 3, "click"], ["rx", "3", "ry", "3", 1, "card"], ["class", "card-band", "stroke", "none", 4, "ngIf"], ["x", "5", "alignment-baseline", "hanging", 1, "trimmed-label"], [3, "innerHTML"], ["text-anchor", "start", "alignment-baseline", "hanging", 1, "value-text"], ["textEl", ""], ["stroke", "none", 1, "card-band"]], template: function CardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵlistener("click", function CardComponent_Template__svg_g_click_0_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelement(1, "rect", 1);
        ɵngcc0.ɵɵtemplate(2, CardComponent__svg_path_2_Template, 1, 3, "path", 2);
        ɵngcc0.ɵɵelementStart(3, "title");
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "foreignObject", 3);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(6, "p", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(7, "text", 5, 6);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("fill", ctx.color);
        ɵngcc0.ɵɵattribute("width", ctx.cardWidth)("height", ctx.cardHeight);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.bandColor && ctx.bandColor !== ctx.color);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("x", ctx.textPadding[3])("y", ctx.cardHeight - ctx.textPadding[2])("width", ctx.textWidth)("height", ctx.labelFontSize + ctx.textPadding[2]);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("color", ctx.textColor)("font-size", ctx.labelFontSize, "px")("line-height", ctx.labelFontSize, "px");
        ɵngcc0.ɵɵproperty("innerHTML", ctx.formattedLabel, ɵngcc0.ɵɵsanitizeHtml);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("fill", ctx.textColor)("font-size", ctx.textFontSize, "pt");
        ɵngcc0.ɵɵattribute("x", ctx.textPadding[3])("y", ctx.textPadding[0]);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.value, " ");
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-card]',
                template: "\n    <svg:g [attr.transform]=\"transform\" class=\"cell\" (click)=\"onClick()\">\n      <svg:rect class=\"card\" [style.fill]=\"color\" [attr.width]=\"cardWidth\" [attr.height]=\"cardHeight\" rx=\"3\" ry=\"3\" />\n      <svg:path\n        *ngIf=\"bandColor && bandColor !== color\"\n        class=\"card-band\"\n        [attr.fill]=\"bandColor\"\n        [attr.transform]=\"transformBand\"\n        stroke=\"none\"\n        [attr.d]=\"bandPath\"\n      />\n      <title>{{ label }}</title>\n      <svg:foreignObject\n        class=\"trimmed-label\"\n        x=\"5\"\n        [attr.x]=\"textPadding[3]\"\n        [attr.y]=\"cardHeight - textPadding[2]\"\n        [attr.width]=\"textWidth\"\n        [attr.height]=\"labelFontSize + textPadding[2]\"\n        alignment-baseline=\"hanging\"\n      >\n        <xhtml:p\n          [style.color]=\"textColor\"\n          [style.fontSize.px]=\"labelFontSize\"\n          [style.lineHeight.px]=\"labelFontSize\"\n          [innerHTML]=\"formattedLabel\"\n        >\n        </xhtml:p>\n      </svg:foreignObject>\n      <svg:text\n        #textEl\n        class=\"value-text\"\n        [attr.x]=\"textPadding[3]\"\n        [attr.y]=\"textPadding[0]\"\n        [style.fill]=\"textColor\"\n        text-anchor=\"start\"\n        alignment-baseline=\"hanging\"\n        [style.font-size.pt]=\"textFontSize\"\n      >\n        {{ value }}\n      </svg:text>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object }, { type: typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object }, { type: typeof (_d = typeof NgZone !== "undefined" && NgZone) === "function" ? _d : Object }]; }, { animations: [{
            type: Input
        }], select: [{
            type: Output
        }], color: [{
            type: Input
        }], bandColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], label: [{
            type: Input
        }], data: [{
            type: Input
        }], medianSize: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], textEl: [{
            type: ViewChild,
            args: ['textEl', { static: false }]
        }] }); })();
    return CardComponent;
}());

var CardSeriesComponent = /** @class */ (function () {
    function CardSeriesComponent() {
        this.innerPadding = 15;
        this.emptyColor = 'rgba(0, 0, 0, 0)';
        this.animations = true;
        this.select = new EventEmitter();
    }
    CardSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    CardSeriesComponent.prototype.update = function () {
        if (this.data.length > 2) {
            var valueFormatting_1 = this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
            var sortedLengths = this.data
                .map(function (d) {
                var hasValue = d && d.data && typeof d.data.value !== 'undefined' && d.data.value !== null;
                return hasValue
                    ? valueFormatting_1({
                        data: d.data,
                        label: d ? d.data.name : '',
                        value: d && d.data ? d.data.value : ''
                    }).length
                    : 0;
            })
                .sort(function (a, b) { return b - a; });
            var idx = Math.ceil(this.data.length / 2);
            this.medianSize = sortedLengths[idx];
        }
        var cards = this.getCards();
        this.cards = cards.filter(function (d) { return d.data.value !== null; });
        this.emptySlots = cards.filter(function (d) { return d.data.value === null; });
    };
    CardSeriesComponent.prototype.getCards = function () {
        var _this = this;
        var yPadding = typeof this.innerPadding === 'number' ? this.innerPadding : this.innerPadding[0] + this.innerPadding[2];
        var xPadding = typeof this.innerPadding === 'number' ? this.innerPadding : this.innerPadding[1] + this.innerPadding[3];
        return this.data.map(function (d, index) {
            var label = d.data.name;
            if (label && label.constructor.name === 'Date') {
                label = label.toLocaleDateString();
            }
            else {
                label = label ? label.toLocaleString() : label;
            }
            var value = d.data.value;
            var valueColor = label ? _this.colors.getColor(label) : _this.emptyColor;
            var color = _this.cardColor || valueColor || '#000';
            return {
                x: d.x,
                y: d.y,
                width: d.width - xPadding,
                height: d.height - yPadding,
                color: color,
                bandColor: _this.bandColor || valueColor,
                textColor: _this.textColor || invertColor(color),
                label: label,
                data: d.data,
                tooltipText: label + ": " + value
            };
        });
    };
    CardSeriesComponent.prototype.trackBy = function (index, card) {
        return card.label;
    };
    CardSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], CardSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], CardSeriesComponent.prototype, "slots", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "innerPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "cardColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "bandColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "emptyColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "textColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], CardSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "select", void 0);
CardSeriesComponent.ɵfac = function CardSeriesComponent_Factory(t) { return new (t || CardSeriesComponent)(); };
CardSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardSeriesComponent, selectors: [["g", "ngx-charts-card-series", ""]], inputs: { innerPadding: "innerPadding", emptyColor: "emptyColor", animations: "animations", data: "data", slots: "slots", dims: "dims", colors: "colors", cardColor: "cardColor", bandColor: "bandColor", textColor: "textColor", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c45, decls: 2, vars: 4, consts: [["class", "card-empty", "rx", "3", "ry", "3", 3, "fill", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["rx", "3", "ry", "3", 1, "card-empty"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select"]], template: function CardSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CardSeriesComponent__svg_rect_0_Template, 1, 6, "rect", 0);
        ɵngcc0.ɵɵtemplate(1, CardSeriesComponent__svg_g_1_Template, 1, 13, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.emptySlots)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cards)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, CardComponent], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CardSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-card-series]',
                template: "\n    <svg:rect\n      *ngFor=\"let c of emptySlots; trackBy: trackBy\"\n      class=\"card-empty\"\n      [attr.x]=\"c.x\"\n      [attr.y]=\"c.y\"\n      [style.fill]=\"emptyColor\"\n      [attr.width]=\"c.width\"\n      [attr.height]=\"c.height\"\n      rx=\"3\"\n      ry=\"3\"\n    />\n    <svg:g\n      ngx-charts-card\n      *ngFor=\"let c of cards; trackBy: trackBy\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [color]=\"c.color\"\n      [bandColor]=\"c.bandColor\"\n      [textColor]=\"c.textColor\"\n      [data]=\"c.data\"\n      [label]=\"c.label\"\n      [medianSize]=\"medianSize\"\n      [valueFormatting]=\"valueFormatting\"\n      [labelFormatting]=\"labelFormatting\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event)\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { innerPadding: [{
            type: Input
        }], emptyColor: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], slots: [{
            type: Input
        }], dims: [{
            type: Input
        }], colors: [{
            type: Input
        }], cardColor: [{
            type: Input
        }], bandColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }] }); })();
    return CardSeriesComponent;
}());

var NumberCardComponent = /** @class */ (function (_super) {
    __extends(NumberCardComponent, _super);
    function NumberCardComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.emptyColor = 'rgba(0, 0, 0, 0)';
        _this.innerPadding = 15;
        _this.margin = [10, 10, 10, 10];
        return _this;
    }
    Object.defineProperty(NumberCardComponent.prototype, "clickable", {
        get: function () {
            return !!this.select.observers.length;
        },
        enumerable: true,
        configurable: true
    });
    NumberCardComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.formatDates();
        this.domain = this.getDomain();
        this.setColors();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        var size = gridSize(this.dims, this.results.length, 150);
        var N = size[0] * size[1];
        var data = this.results.slice();
        while (data.length < N) {
            data.push({ value: null });
        }
        this.data = gridLayout(this.dims, data, 150, this.designatedTotal);
    };
    NumberCardComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    NumberCardComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    NumberCardComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "cardColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "bandColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "emptyColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NumberCardComponent.prototype, "innerPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "textColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NumberCardComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NumberCardComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], NumberCardComponent.prototype, "designatedTotal", void 0);
NumberCardComponent.ɵfac = function NumberCardComponent_Factory(t) { return ɵNumberCardComponent_BaseFactory(t || NumberCardComponent); };
NumberCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NumberCardComponent, selectors: [["ngx-charts-number-card"]], inputs: { cardColor: "cardColor", bandColor: "bandColor", emptyColor: "emptyColor", innerPadding: "innerPadding", textColor: "textColor", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", designatedTotal: "designatedTotal" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 20, consts: [[3, "view", "showLegend", "animations"], [1, "number-card", "chart"], ["ngx-charts-card-series", "", 3, "colors", "cardColor", "bandColor", "textColor", "emptyColor", "data", "dims", "innerPadding", "valueFormatting", "labelFormatting", "animations", "select"]], template: function NumberCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("select", function NumberCardComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("clickable", ctx.clickable);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("cardColor", ctx.cardColor)("bandColor", ctx.bandColor)("textColor", ctx.textColor)("emptyColor", ctx.emptyColor)("data", ctx.data)("dims", ctx.dims)("innerPadding", ctx.innerPadding)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("animations", ctx.animations);
    } }, directives: [ChartComponent,
        CardSeriesComponent], styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", "ngx-charts-number-card .cell .trimmed-label{font-size:12px;pointer-events:none;overflow:hidden;text-align:left;line-height:1em}ngx-charts-number-card .cell .trimmed-label p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;padding:0;margin:0}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}"], encapsulation: 2, changeDetection: 0 });
var ɵNumberCardComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NumberCardComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumberCardComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-number-card',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"number-card chart\" [class.clickable]=\"clickable\">\n        <svg:g\n          ngx-charts-card-series\n          [colors]=\"colors\"\n          [cardColor]=\"cardColor\"\n          [bandColor]=\"bandColor\"\n          [textColor]=\"textColor\"\n          [emptyColor]=\"emptyColor\"\n          [data]=\"data\"\n          [dims]=\"dims\"\n          [innerPadding]=\"innerPadding\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"labelFormatting\"\n          [animations]=\"animations\"\n          (select)=\"onClick($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", "ngx-charts-number-card .cell .trimmed-label{font-size:12px;pointer-events:none;overflow:hidden;text-align:left;line-height:1em}ngx-charts-number-card .cell .trimmed-label p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;padding:0;margin:0}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { cardColor: [{
            type: Input
        }], bandColor: [{
            type: Input
        }], emptyColor: [{
            type: Input
        }], innerPadding: [{
            type: Input
        }], textColor: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], designatedTotal: [{
            type: Input
        }] }); })();
    return NumberCardComponent;
}(BaseChartComponent));

var NumberCardModule = /** @class */ (function () {
    function NumberCardModule() {
    }
NumberCardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NumberCardModule });
NumberCardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NumberCardModule_Factory(t) { return new (t || NumberCardModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NumberCardModule, { declarations: [CardComponent,
        CardSeriesComponent,
        NumberCardComponent], imports: [ChartCommonModule], exports: [CardComponent,
        CardSeriesComponent,
        NumberCardComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumberCardModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    CardComponent,
                    CardSeriesComponent,
                    NumberCardComponent
                ],
                exports: [
                    CardComponent,
                    CardSeriesComponent,
                    NumberCardComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return NumberCardModule;
}());

var TreeMapCellComponent = /** @class */ (function () {
    function TreeMapCellComponent(element) {
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
        this.element = element.nativeElement;
    }
    TreeMapCellComponent.prototype.ngOnChanges = function () {
        this.update();
        this.valueFormatting = this.valueFormatting || (function (value) { return value.toLocaleString(); });
        var labelFormatting = this.labelFormatting || (function (cell) { return trimLabel(cell.label, 55); });
        var cellData = {
            data: this.data,
            label: this.label,
            value: this.value
        };
        this.formattedValue = this.valueFormatting(cellData.value);
        this.formattedLabel = labelFormatting(cellData);
        this.gradientId = 'grad' + id().toString();
        this.gradientUrl = "url(#" + this.gradientId + ")";
        this.gradientStops = this.getGradientStops();
    };
    TreeMapCellComponent.prototype.update = function () {
        if (this.initialized) {
            this.animateToCurrentForm();
        }
        else {
            if (this.animations) {
                this.loadAnimation();
            }
            this.initialized = true;
        }
    };
    TreeMapCellComponent.prototype.loadAnimation = function () {
        var node = select(this.element).select('.cell');
        node
            .attr('opacity', 0)
            .attr('x', this.x)
            .attr('y', this.y);
        this.animateToCurrentForm();
    };
    TreeMapCellComponent.prototype.getTextColor = function () {
        return invertColor(this.fill);
    };
    TreeMapCellComponent.prototype.animateToCurrentForm = function () {
        var node = select(this.element).select('.cell');
        if (this.animations) {
            node
                .transition()
                .duration(750)
                .attr('opacity', 1)
                .attr('x', this.x)
                .attr('y', this.y)
                .attr('width', this.width)
                .attr('height', this.height);
        }
        else {
            node
                .attr('opacity', 1)
                .attr('x', this.x)
                .attr('y', this.y)
                .attr('width', this.width)
                .attr('height', this.height);
        }
    };
    TreeMapCellComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    TreeMapCellComponent.prototype.getGradientStops = function () {
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: 0.3
            },
            {
                offset: 100,
                color: this.fill,
                opacity: 1
            }
        ];
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "valueType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "select", void 0);
    TreeMapCellComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], TreeMapCellComponent);
TreeMapCellComponent.ɵfac = function TreeMapCellComponent_Factory(t) { return new (t || TreeMapCellComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
TreeMapCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeMapCellComponent, selectors: [["g", "ngx-charts-tree-map-cell", ""]], inputs: { gradient: "gradient", animations: "animations", valueFormatting: "valueFormatting", data: "data", fill: "fill", x: "x", y: "y", width: "width", height: "height", label: "label", value: "value", valueType: "valueType", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c46, decls: 4, vars: 9, consts: [[4, "ngIf"], [1, "cell", 3, "click"], ["class", "treemap-label", 3, "pointer-events", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], [1, "treemap-label"], [1, "treemap-label", 3, "innerHTML"], ["class", "treemap-val", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "treemap-val", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "treemap-val", 3, "countTo", "valueFormatting"], [1, "treemap-val"]], template: function TreeMapCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, TreeMapCellComponent__svg_defs_1_Template, 2, 2, "defs", 0);
        ɵngcc0.ɵɵelementStart(2, "rect", 1);
        ɵngcc0.ɵɵlistener("click", function TreeMapCellComponent_Template__svg_rect_click_2_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, TreeMapCellComponent__svg_foreignObject_3_Template, 6, 15, "foreignObject", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("cursor", "pointer");
        ɵngcc0.ɵɵattribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height)("x", ctx.x)("y", ctx.y);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.width >= 70 && ctx.height >= 35);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent,
        CountUpDirective], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeMapCellComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-tree-map-cell]',
                template: "\n    <svg:g>\n      <defs *ngIf=\"gradient\">\n        <svg:g ngx-charts-svg-linear-gradient orientation=\"vertical\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n      </defs>\n      <svg:rect\n        [attr.fill]=\"gradient ? gradientUrl : fill\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        [attr.x]=\"x\"\n        [attr.y]=\"y\"\n        [style.cursor]=\"'pointer'\"\n        class=\"cell\"\n        (click)=\"onClick()\"\n      />\n      <svg:foreignObject\n        *ngIf=\"width >= 70 && height >= 35\"\n        [attr.x]=\"x\"\n        [attr.y]=\"y\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        class=\"treemap-label\"\n        [style.pointer-events]=\"'none'\"\n      >\n        <xhtml:p [style.color]=\"getTextColor()\" [style.height]=\"height + 'px'\" [style.width]=\"width + 'px'\">\n          <xhtml:span class=\"treemap-label\" [innerHTML]=\"formattedLabel\"> </xhtml:span>\n          <xhtml:br />\n          <xhtml:span\n            *ngIf=\"animations\"\n            class=\"treemap-val\"\n            ngx-charts-count-up\n            [countTo]=\"value\"\n            [valueFormatting]=\"valueFormatting\"\n          >\n          </xhtml:span>\n          <xhtml:span *ngIf=\"!animations\" class=\"treemap-val\">\n            {{ formattedValue }}\n          </xhtml:span>\n        </xhtml:p>\n      </svg:foreignObject>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], valueFormatting: [{
            type: Input
        }], data: [{
            type: Input
        }], fill: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], label: [{
            type: Input
        }], value: [{
            type: Input
        }], valueType: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }] }); })();
    return TreeMapCellComponent;
}());

var TreeMapCellSeriesComponent = /** @class */ (function () {
    function TreeMapCellSeriesComponent() {
        this.gradient = false;
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
    }
    TreeMapCellSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.cells = this.getCells();
    };
    TreeMapCellSeriesComponent.prototype.getCells = function () {
        var _this = this;
        return this.data.children
            .filter(function (d) {
            return d.depth === 1;
        })
            .map(function (d, index) {
            var label = d.id;
            return {
                data: d.data,
                x: d.x0,
                y: d.y0,
                width: d.x1 - d.x0,
                height: d.y1 - d.y0,
                fill: _this.colors.getColor(label),
                label: label,
                value: d.value,
                valueType: d.valueType
            };
        });
    };
    TreeMapCellSeriesComponent.prototype.getTooltipText = function (_a) {
        var label = _a.label, value = _a.value;
        return "\n      <span class=\"tooltip-label\">" + label + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n    ";
    };
    TreeMapCellSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    TreeMapCellSeriesComponent.prototype.trackBy = function (index, item) {
        return item.label;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], TreeMapCellSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "select", void 0);
TreeMapCellSeriesComponent.ɵfac = function TreeMapCellSeriesComponent_Factory(t) { return new (t || TreeMapCellSeriesComponent)(); };
TreeMapCellSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeMapCellSeriesComponent, selectors: [["g", "ngx-charts-tree-map-cell-series", ""]], inputs: { gradient: "gradient", tooltipDisabled: "tooltipDisabled", animations: "animations", data: "data", dims: "dims", colors: "colors", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c47, decls: 1, vars: 2, consts: [["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "data", "x", "y", "width", "height", "fill", "label", "value", "valueType", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "data", "x", "y", "width", "height", "fill", "label", "value", "valueType", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select"]], template: function TreeMapCellSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TreeMapCellSeriesComponent__svg_g_0_Template, 1, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, TreeMapCellComponent,
        TooltipDirective], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeMapCellSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-tree-map-cell-series]',
                template: "\n    <svg:g\n      ngx-charts-tree-map-cell\n      *ngFor=\"let c of cells; trackBy: trackBy\"\n      [data]=\"c.data\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [fill]=\"c.fill\"\n      [label]=\"c.label\"\n      [value]=\"c.value\"\n      [valueType]=\"c.valueType\"\n      [valueFormatting]=\"valueFormatting\"\n      [labelFormatting]=\"labelFormatting\"\n      [gradient]=\"gradient\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(c)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"c.data\"\n    ></svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { gradient: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], dims: [{
            type: Input
        }], colors: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return TreeMapCellSeriesComponent;
}());

var TreeMapComponent = /** @class */ (function (_super) {
    __extends(TreeMapComponent, _super);
    function TreeMapComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.tooltipDisabled = false;
        _this.gradient = false;
        _this.select = new EventEmitter();
        _this.margin = [10, 10, 10, 10];
        return _this;
    }
    TreeMapComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.domain = this.getDomain();
        this.treemap = treemap().size([this.dims.width, this.dims.height]);
        var rootNode = {
            name: 'root',
            value: 0,
            isRoot: true
        };
        var root = stratify()
            .id(function (d) {
            var label = d.name;
            if (label.constructor.name === 'Date') {
                label = label.toLocaleDateString();
            }
            else {
                label = label.toLocaleString();
            }
            return label;
        })
            .parentId(function (d) { return (d.isRoot ? null : 'root'); })([rootNode].concat(this.results))
            .sum(function (d) { return d.value; });
        this.data = this.treemap(root);
        this.setColors();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    TreeMapComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    TreeMapComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    TreeMapComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapComponent.prototype, "gradient", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "select", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], TreeMapComponent.prototype, "tooltipTemplate", void 0);
TreeMapComponent.ɵfac = function TreeMapComponent_Factory(t) { return ɵTreeMapComponent_BaseFactory(t || TreeMapComponent); };
TreeMapComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeMapComponent, selectors: [["ngx-charts-tree-map"]], contentQueries: function TreeMapComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { results: "results", tooltipDisabled: "tooltipDisabled", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", gradient: "gradient" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 16, consts: [[3, "view", "showLegend", "animations"], [1, "tree-map", "chart"], ["ngx-charts-tree-map-cell-series", "", 3, "colors", "data", "dims", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "labelFormatting", "gradient", "animations", "select"]], template: function TreeMapComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("select", function TreeMapComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(13, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("data", ctx.data)("dims", ctx.dims)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("gradient", ctx.gradient)("animations", ctx.animations);
    } }, directives: [ChartComponent,
        TreeMapCellSeriesComponent], styles: [".tree-map .treemap-val{font-size:1.3em;padding-top:5px;display:inline-block}.tree-map .treemap-label p{display:table-cell;text-align:center;line-height:1.2em;vertical-align:middle}"], encapsulation: 2, changeDetection: 0 });
var ɵTreeMapComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TreeMapComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeMapComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-tree-map',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"tree-map chart\">\n        <svg:g\n          ngx-charts-tree-map-cell-series\n          [colors]=\"colors\"\n          [data]=\"data\"\n          [dims]=\"dims\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"labelFormatting\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          (select)=\"onClick($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".tree-map .treemap-val{font-size:1.3em;padding-top:5px;display:inline-block}.tree-map .treemap-label p{display:table-cell;text-align:center;line-height:1.2em;vertical-align:middle}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { results: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], gradient: [{
            type: Input
        }], select: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return TreeMapComponent;
}(BaseChartComponent));

var TreeMapModule = /** @class */ (function () {
    function TreeMapModule() {
    }
TreeMapModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TreeMapModule });
TreeMapModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TreeMapModule_Factory(t) { return new (t || TreeMapModule)(); }, imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TreeMapModule, { declarations: [TreeMapCellComponent,
        TreeMapCellSeriesComponent,
        TreeMapComponent], imports: [ChartCommonModule], exports: [TreeMapCellComponent,
        TreeMapCellSeriesComponent,
        TreeMapComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TreeMapModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    TreeMapCellComponent,
                    TreeMapCellSeriesComponent,
                    TreeMapComponent
                ],
                exports: [
                    TreeMapCellComponent,
                    TreeMapCellSeriesComponent,
                    TreeMapComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return TreeMapModule;
}());

var LinearGaugeComponent = /** @class */ (function (_super) {
    __extends(LinearGaugeComponent, _super);
    function LinearGaugeComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.min = 0;
        _this.max = 100;
        _this.value = 0;
        _this.margin = [10, 20, 10, 20];
        _this.valueResizeScale = 1;
        _this.unitsResizeScale = 1;
        _this.valueTextTransform = '';
        _this.valueTranslate = '';
        _this.unitsTextTransform = '';
        _this.unitsTranslate = '';
        return _this;
    }
    LinearGaugeComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        _super.prototype.ngAfterViewInit.call(this);
        setTimeout(function () {
            _this.scaleText('value');
            _this.scaleText('units');
        });
    };
    LinearGaugeComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        this.hasPreviousValue = this.previousValue !== undefined;
        this.max = Math.max(this.max, this.value);
        this.min = Math.min(this.min, this.value);
        if (this.hasPreviousValue) {
            this.max = Math.max(this.max, this.previousValue);
            this.min = Math.min(this.min, this.previousValue);
        }
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.valueDomain = this.getValueDomain();
        this.valueScale = this.getValueScale();
        this.displayValue = this.getDisplayValue();
        this.setColors();
        var xOffset = this.margin[3] + this.dims.width / 2;
        var yOffset = this.margin[0] + this.dims.height / 2;
        this.transform = "translate(" + xOffset + ", " + yOffset + ")";
        this.transformLine = "translate(" + (this.margin[3] + this.valueScale(this.previousValue)) + ", " + yOffset + ")";
        this.valueTranslate = "translate(0, -15)";
        this.unitsTranslate = "translate(0, 15)";
        setTimeout(function () { return _this.scaleText('value'); }, 50);
        setTimeout(function () { return _this.scaleText('units'); }, 50);
    };
    LinearGaugeComponent.prototype.getValueDomain = function () {
        return [this.min, this.max];
    };
    LinearGaugeComponent.prototype.getValueScale = function () {
        return scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valueDomain);
    };
    LinearGaugeComponent.prototype.getDisplayValue = function () {
        if (this.valueFormatting) {
            return this.valueFormatting(this.value);
        }
        return this.value.toLocaleString();
    };
    LinearGaugeComponent.prototype.scaleText = function (element, repeat) {
        var _this = this;
        if (repeat === void 0) { repeat = true; }
        var el;
        var resizeScale;
        if (element === 'value') {
            el = this.valueTextEl;
            resizeScale = this.valueResizeScale;
        }
        else {
            el = this.unitsTextEl;
            resizeScale = this.unitsResizeScale;
        }
        var _a = el.nativeElement.getBoundingClientRect(), width = _a.width, height = _a.height;
        if (width === 0 || height === 0)
            return;
        var oldScale = resizeScale;
        var availableWidth = this.dims.width;
        var availableHeight = Math.max(this.dims.height / 2 - 15, 0);
        var resizeScaleWidth = Math.floor((availableWidth / (width / resizeScale)) * 100) / 100;
        var resizeScaleHeight = Math.floor((availableHeight / (height / resizeScale)) * 100) / 100;
        resizeScale = Math.min(resizeScaleHeight, resizeScaleWidth);
        if (resizeScale !== oldScale) {
            if (element === 'value') {
                this.valueResizeScale = resizeScale;
                this.valueTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
            }
            else {
                this.unitsResizeScale = resizeScale;
                this.unitsTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
            }
            this.cd.markForCheck();
            if (repeat) {
                setTimeout(function () {
                    _this.scaleText(element, false);
                }, 50);
            }
        }
    };
    LinearGaugeComponent.prototype.onClick = function () {
        this.select.emit({
            name: 'Value',
            value: this.value
        });
    };
    LinearGaugeComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', [this.value], this.customColors);
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LinearGaugeComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LinearGaugeComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LinearGaugeComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LinearGaugeComponent.prototype, "units", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LinearGaugeComponent.prototype, "previousValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LinearGaugeComponent.prototype, "valueFormatting", void 0);
    __decorate([
        ViewChild('valueTextEl', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], LinearGaugeComponent.prototype, "valueTextEl", void 0);
    __decorate([
        ViewChild('unitsTextEl', { static: false }),
        __metadata("design:type", typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object)
    ], LinearGaugeComponent.prototype, "unitsTextEl", void 0);
LinearGaugeComponent.ɵfac = function LinearGaugeComponent_Factory(t) { return ɵLinearGaugeComponent_BaseFactory(t || LinearGaugeComponent); };
LinearGaugeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearGaugeComponent, selectors: [["ngx-charts-linear-gauge"]], viewQuery: function LinearGaugeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c48, true);
        ɵngcc0.ɵɵviewQuery(_c49, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.valueTextEl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.unitsTextEl = _t.first);
    } }, inputs: { max: "max", min: "min", value: "value", units: "units", previousValue: "previousValue", valueFormatting: "valueFormatting" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 15, vars: 38, consts: [[3, "view", "showLegend", "animations", "click"], [1, "linear-gauge", "chart"], ["ngx-charts-bar", "", 1, "background-bar", 3, "width", "height", "x", "y", "data", "orientation", "roundEdges", "animations"], ["ngx-charts-bar", "", 3, "width", "height", "x", "y", "fill", "data", "orientation", "roundEdges", "animations"], ["x1", "0", "y1", "5", "x2", "0", "y2", "15", 4, "ngIf"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15", 4, "ngIf"], ["alignment-baseline", "after-edge", 1, "value"], ["valueTextEl", ""], ["alignment-baseline", "before-edge", 1, "units"], ["unitsTextEl", ""], ["x1", "0", "y1", "5", "x2", "0", "y2", "15"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15"]], template: function LinearGaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("click", function LinearGaugeComponent_Template_ngx_charts_chart_click_0_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵelement(3, "g", 3);
        ɵngcc0.ɵɵtemplate(4, LinearGaugeComponent__svg_line_4_Template, 1, 2, "line", 4);
        ɵngcc0.ɵɵtemplate(5, LinearGaugeComponent__svg_line_5_Template, 1, 2, "line", 5);
        ɵngcc0.ɵɵelementStart(6, "g");
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵelementStart(8, "text", 6, 7);
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "g");
        ɵngcc0.ɵɵelementStart(12, "text", 8, 9);
        ɵngcc0.ɵɵtext(14);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(33, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("width", ctx.dims.width)("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("data", ɵngcc0.ɵɵpureFunction0(36, _c50))("orientation", "horizontal")("roundEdges", true)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("width", ctx.valueScale(ctx.value))("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("fill", ctx.colors.getColor(ctx.units))("data", ɵngcc0.ɵɵpureFunction0(37, _c50))("orientation", "horizontal")("roundEdges", true)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasPreviousValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasPreviousValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.valueTranslate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
        ɵngcc0.ɵɵattribute("transform", ctx.valueTextTransform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.displayValue, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.unitsTranslate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
        ɵngcc0.ɵɵattribute("transform", ctx.unitsTextTransform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.units, " ");
    } }, directives: [ChartComponent,
        BarComponent, ɵngcc1.NgIf], styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:rgba(0,0,0,.05)}.linear-gauge .units{fill:#666}"], encapsulation: 2, changeDetection: 0 });
var ɵLinearGaugeComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(LinearGaugeComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LinearGaugeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-linear-gauge',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\" (click)=\"onClick()\">\n      <svg:g class=\"linear-gauge chart\">\n        <svg:g\n          ngx-charts-bar\n          class=\"background-bar\"\n          [width]=\"dims.width\"\n          [height]=\"3\"\n          [x]=\"margin[3]\"\n          [y]=\"dims.height / 2 + margin[0] - 2\"\n          [data]=\"{}\"\n          [orientation]=\"'horizontal'\"\n          [roundEdges]=\"true\"\n          [animations]=\"animations\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-bar\n          [width]=\"valueScale(value)\"\n          [height]=\"3\"\n          [x]=\"margin[3]\"\n          [y]=\"dims.height / 2 + margin[0] - 2\"\n          [fill]=\"colors.getColor(units)\"\n          [data]=\"{}\"\n          [orientation]=\"'horizontal'\"\n          [roundEdges]=\"true\"\n          [animations]=\"animations\"\n        ></svg:g>\n\n        <svg:line\n          *ngIf=\"hasPreviousValue\"\n          [attr.transform]=\"transformLine\"\n          x1=\"0\"\n          y1=\"5\"\n          x2=\"0\"\n          y2=\"15\"\n          [attr.stroke]=\"colors.getColor(units)\"\n        />\n\n        <svg:line\n          *ngIf=\"hasPreviousValue\"\n          [attr.transform]=\"transformLine\"\n          x1=\"0\"\n          y1=\"-5\"\n          x2=\"0\"\n          y2=\"-15\"\n          [attr.stroke]=\"colors.getColor(units)\"\n        />\n\n        <svg:g [attr.transform]=\"transform\">\n          <svg:g [attr.transform]=\"valueTranslate\">\n            <svg:text\n              #valueTextEl\n              class=\"value\"\n              [style.textAnchor]=\"'middle'\"\n              [attr.transform]=\"valueTextTransform\"\n              alignment-baseline=\"after-edge\"\n            >\n              {{ displayValue }}\n            </svg:text>\n          </svg:g>\n\n          <svg:g [attr.transform]=\"unitsTranslate\">\n            <svg:text\n              #unitsTextEl\n              class=\"units\"\n              [style.textAnchor]=\"'middle'\"\n              [attr.transform]=\"unitsTextTransform\"\n              alignment-baseline=\"before-edge\"\n            >\n              {{ units }}\n            </svg:text>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:rgba(0,0,0,.05)}.linear-gauge .units{fill:#666}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { max: [{
            type: Input
        }], min: [{
            type: Input
        }], value: [{
            type: Input
        }], units: [{
            type: Input
        }], previousValue: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], valueTextEl: [{
            type: ViewChild,
            args: ['valueTextEl', { static: false }]
        }], unitsTextEl: [{
            type: ViewChild,
            args: ['unitsTextEl', { static: false }]
        }] }); })();
    return LinearGaugeComponent;
}(BaseChartComponent));

var GaugeComponent = /** @class */ (function (_super) {
    __extends(GaugeComponent, _super);
    function GaugeComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.min = 0;
        _this.max = 100;
        _this.bigSegments = 10;
        _this.smallSegments = 5;
        _this.showAxis = true;
        _this.startAngle = -120;
        _this.angleSpan = 240;
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.showText = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.resizeScale = 1;
        _this.rotation = '';
        _this.textTransform = 'scale(1, 1)';
        _this.cornerRadius = 10;
        return _this;
    }
    GaugeComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        _super.prototype.ngAfterViewInit.call(this);
        setTimeout(function () { return _this.scaleText(); });
    };
    GaugeComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        if (!this.showAxis) {
            if (!this.margin) {
                this.margin = [10, 20, 10, 20];
            }
        }
        else {
            if (!this.margin) {
                this.margin = [60, 100, 60, 100];
            }
        }
        if (this.startAngle < 0) {
            this.startAngle = (this.startAngle % 360) + 360;
        }
        this.angleSpan = Math.min(this.angleSpan, 360);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showLegend: this.legend,
            legendPosition: this.legendPosition
        });
        this.domain = this.getDomain();
        this.valueDomain = this.getValueDomain();
        this.valueScale = this.getValueScale();
        this.displayValue = this.getDisplayValue();
        this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2;
        this.arcs = this.getArcs();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        var xOffset = this.margin[3] + this.dims.width / 2;
        var yOffset = this.margin[0] + this.dims.height / 2;
        this.transform = "translate(" + xOffset + ", " + yOffset + ")";
        this.rotation = "rotate(" + this.startAngle + ")";
        setTimeout(function () { return _this.scaleText(); }, 50);
    };
    GaugeComponent.prototype.getArcs = function () {
        var arcs = [];
        var availableRadius = this.outerRadius * 0.7;
        var radiusPerArc = Math.min(availableRadius / this.results.length, 10);
        var arcWidth = radiusPerArc * 0.7;
        this.textRadius = this.outerRadius - this.results.length * radiusPerArc;
        this.cornerRadius = Math.floor(arcWidth / 2);
        var i = 0;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var d = _a[_i];
            var outerRadius = this.outerRadius - i * radiusPerArc;
            var innerRadius = outerRadius - arcWidth;
            var backgroundArc = {
                endAngle: (this.angleSpan * Math.PI) / 180,
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                data: {
                    value: this.max,
                    name: d.name
                }
            };
            var valueArc = {
                endAngle: (Math.min(this.valueScale(d.value), this.angleSpan) * Math.PI) / 180,
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                data: {
                    value: d.value,
                    name: d.name
                }
            };
            var arc$$1 = {
                backgroundArc: backgroundArc,
                valueArc: valueArc
            };
            arcs.push(arc$$1);
            i++;
        }
        return arcs;
    };
    GaugeComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    GaugeComponent.prototype.getValueDomain = function () {
        var values = this.results.map(function (d) { return d.value; });
        var dataMin = Math.min.apply(Math, values);
        var dataMax = Math.max.apply(Math, values);
        if (this.min !== undefined) {
            this.min = Math.min(this.min, dataMin);
        }
        else {
            this.min = dataMin;
        }
        if (this.max !== undefined) {
            this.max = Math.max(this.max, dataMax);
        }
        else {
            this.max = dataMax;
        }
        return [this.min, this.max];
    };
    GaugeComponent.prototype.getValueScale = function () {
        return scaleLinear()
            .range([0, this.angleSpan])
            .nice()
            .domain(this.valueDomain);
    };
    GaugeComponent.prototype.getDisplayValue = function () {
        var value = this.results.map(function (d) { return d.value; }).reduce(function (a, b) { return a + b; }, 0);
        if (this.textValue && 0 !== this.textValue.length) {
            return this.textValue.toLocaleString();
        }
        if (this.valueFormatting) {
            return this.valueFormatting(value);
        }
        return value.toLocaleString();
    };
    GaugeComponent.prototype.scaleText = function (repeat) {
        var _this = this;
        if (repeat === void 0) { repeat = true; }
        if (!this.showText) {
            return;
        }
        var width = this.textEl.nativeElement.getBoundingClientRect().width;
        var oldScale = this.resizeScale;
        if (width === 0) {
            this.resizeScale = 1;
        }
        else {
            var availableSpace = this.textRadius;
            this.resizeScale = Math.floor((availableSpace / (width / this.resizeScale)) * 100) / 100;
        }
        if (this.resizeScale !== oldScale) {
            this.textTransform = "scale(" + this.resizeScale + ", " + this.resizeScale + ")";
            this.cd.markForCheck();
            if (repeat) {
                setTimeout(function () { return _this.scaleText(false); }, 50);
            }
        }
    };
    GaugeComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    GaugeComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: 'ordinal',
            colors: this.colors,
            domain: this.domain,
            title: this.legendTitle,
            position: this.legendPosition
        };
    };
    GaugeComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    GaugeComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    GaugeComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    GaugeComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    GaugeComponent.prototype.trackBy = function (index, item) {
        return item.valueArc.data.name;
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "textValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "units", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "bigSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "smallSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GaugeComponent.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeComponent.prototype, "showAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "startAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "angleSpan", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GaugeComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeComponent.prototype, "axisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], GaugeComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeComponent.prototype, "showText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GaugeComponent.prototype, "margin", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], GaugeComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], GaugeComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], GaugeComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ViewChild('textEl', { static: false }),
        __metadata("design:type", typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object)
    ], GaugeComponent.prototype, "textEl", void 0);
GaugeComponent.ɵfac = function GaugeComponent_Factory(t) { return ɵGaugeComponent_BaseFactory(t || GaugeComponent); };
GaugeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeComponent, selectors: [["ngx-charts-gauge"]], contentQueries: function GaugeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, viewQuery: function GaugeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c43, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textEl = _t.first);
    } }, inputs: { margin: "margin", startAngle: "startAngle", angleSpan: "angleSpan", min: "min", max: "max", activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", textValue: "textValue", units: "units", bigSegments: "bigSegments", smallSegments: "smallSegments", results: "results", showAxis: "showAxis", axisTickFormatting: "axisTickFormatting", tooltipDisabled: "tooltipDisabled", valueFormatting: "valueFormatting", showText: "showText" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "gauge", "chart"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting", 4, "ngIf"], ["alignment-baseline", "central", 3, "textAnchor", 4, "ngIf"], ["ngx-charts-gauge-arc", "", 3, "backgroundArc", "valueArc", "cornerRadius", "colors", "isActive", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "animations", "select", "activate", "deactivate"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting"], ["alignment-baseline", "central"], ["textEl", ""], ["x", "0", "dy", "0"], ["x", "0", "dy", "1.2em"]], template: function GaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function GaugeComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, GaugeComponent__svg_g_2_Template, 2, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, GaugeComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, GaugeComponent__svg_text_4_Template, 6, 5, "text", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showText);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgForOf, ɵngcc1.NgIf, GaugeArcComponent,
        GaugeAxisComponent]; }, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".gauge .background-arc path{fill:rgba(0,0,0,.05)}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{font-size:12px;fill:#666;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}"], encapsulation: 2, changeDetection: 0 });
var ɵGaugeComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(GaugeComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GaugeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-gauge',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"gauge chart\">\n        <svg:g *ngFor=\"let arc of arcs; trackBy: trackBy\" [attr.transform]=\"rotation\">\n          <svg:g\n            ngx-charts-gauge-arc\n            [backgroundArc]=\"arc.backgroundArc\"\n            [valueArc]=\"arc.valueArc\"\n            [cornerRadius]=\"cornerRadius\"\n            [colors]=\"colors\"\n            [isActive]=\"isActive(arc.valueArc.data)\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [valueFormatting]=\"valueFormatting\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event)\"\n            (activate)=\"onActivate($event)\"\n            (deactivate)=\"onDeactivate($event)\"\n          ></svg:g>\n        </svg:g>\n\n        <svg:g\n          ngx-charts-gauge-axis\n          *ngIf=\"showAxis\"\n          [bigSegments]=\"bigSegments\"\n          [smallSegments]=\"smallSegments\"\n          [min]=\"min\"\n          [max]=\"max\"\n          [radius]=\"outerRadius\"\n          [angleSpan]=\"angleSpan\"\n          [valueScale]=\"valueScale\"\n          [startAngle]=\"startAngle\"\n          [tickFormatting]=\"axisTickFormatting\"\n        ></svg:g>\n\n        <svg:text\n          #textEl\n          *ngIf=\"showText\"\n          [style.textAnchor]=\"'middle'\"\n          [attr.transform]=\"textTransform\"\n          alignment-baseline=\"central\"\n        >\n          <tspan x=\"0\" dy=\"0\">{{ displayValue }}</tspan>\n          <tspan x=\"0\" dy=\"1.2em\">{{ units }}</tspan>\n        </svg:text>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".gauge .background-arc path{fill:rgba(0,0,0,.05)}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{font-size:12px;fill:#666;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { margin: [{
            type: Input
        }], startAngle: [{
            type: Input
        }], angleSpan: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], textValue: [{
            type: Input
        }], units: [{
            type: Input
        }], bigSegments: [{
            type: Input
        }], smallSegments: [{
            type: Input
        }], results: [{
            type: Input
        }], showAxis: [{
            type: Input
        }], axisTickFormatting: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], showText: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], textEl: [{
            type: ViewChild,
            args: ['textEl', { static: false }]
        }] }); })();
    return GaugeComponent;
}(BaseChartComponent));

var GaugeArcComponent = /** @class */ (function () {
    function GaugeArcComponent() {
        this.isActive = false;
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    GaugeArcComponent.prototype.tooltipText = function (arc$$1) {
        var label = formatLabel(arc$$1.data.name);
        var val;
        if (this.valueFormatting) {
            val = this.valueFormatting(arc$$1.data.value);
        }
        else {
            val = formatLabel(arc$$1.data.value);
        }
        return "\n      <span class=\"tooltip-label\">" + label + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "backgroundArc", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "valueArc", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "cornerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof ColorHelper !== "undefined" && ColorHelper) === "function" ? _a : Object)
    ], GaugeArcComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeArcComponent.prototype, "isActive", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeArcComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], GaugeArcComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _b : Object)
    ], GaugeArcComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeArcComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "deactivate", void 0);
GaugeArcComponent.ɵfac = function GaugeArcComponent_Factory(t) { return new (t || GaugeArcComponent)(); };
GaugeArcComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeArcComponent, selectors: [["g", "ngx-charts-gauge-arc", ""]], inputs: { isActive: "isActive", tooltipDisabled: "tooltipDisabled", animations: "animations", backgroundArc: "backgroundArc", valueArc: "valueArc", cornerRadius: "cornerRadius", colors: "colors", valueFormatting: "valueFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, attrs: _c51, decls: 2, vars: 23, consts: [["ngx-charts-pie-arc", "", 1, "background-arc", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "data", "animate", "pointerEvents"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "fill", "data", "animate", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function GaugeArcComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵlistener("select", function GaugeArcComponent_Template__svg_g_select_1_listener($event) { return ctx.select.emit($event); })("activate", function GaugeArcComponent_Template__svg_g_activate_1_listener($event) { return ctx.activate.emit($event); })("deactivate", function GaugeArcComponent_Template__svg_g_deactivate_1_listener($event) { return ctx.deactivate.emit($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("startAngle", 0)("endAngle", ctx.backgroundArc.endAngle)("innerRadius", ctx.backgroundArc.innerRadius)("outerRadius", ctx.backgroundArc.outerRadius)("cornerRadius", ctx.cornerRadius)("data", ctx.backgroundArc.data)("animate", false)("pointerEvents", false);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("startAngle", 0)("endAngle", ctx.valueArc.endAngle)("innerRadius", ctx.valueArc.innerRadius)("outerRadius", ctx.valueArc.outerRadius)("cornerRadius", ctx.cornerRadius)("fill", ctx.colors.getColor(ctx.valueArc.data.name))("data", ctx.valueArc.data)("animate", ctx.animations)("isActive", ctx.isActive)("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx.tooltipTemplate ? undefined : ctx.tooltipText(ctx.valueArc))("tooltipTemplate", ctx.tooltipTemplate)("tooltipContext", ctx.valueArc.data);
    } }, directives: [PieArcComponent,
        TooltipDirective], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GaugeArcComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-gauge-arc]',
                template: "\n    <svg:g ngx-charts-pie-arc\n      class=\"background-arc\"\n      [startAngle]=\"0\"\n      [endAngle]=\"backgroundArc.endAngle\"\n      [innerRadius]=\"backgroundArc.innerRadius\"\n      [outerRadius]=\"backgroundArc.outerRadius\"\n      [cornerRadius]=\"cornerRadius\"\n      [data]=\"backgroundArc.data\"\n      [animate]=\"false\"\n      [pointerEvents]=\"false\">\n    </svg:g>\n    <svg:g ngx-charts-pie-arc\n      [startAngle]=\"0\"\n      [endAngle]=\"valueArc.endAngle\"\n      [innerRadius]=\"valueArc.innerRadius\"\n      [outerRadius]=\"valueArc.outerRadius\"\n      [cornerRadius]=\"cornerRadius\"\n      [fill]=\"colors.getColor(valueArc.data.name)\"\n      [data]=\"valueArc.data\"\n      [animate]=\"animations\"\n      [isActive]=\"isActive\"\n      (select)=\"select.emit($event)\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(valueArc)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"valueArc.data\">\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { isActive: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], backgroundArc: [{
            type: Input
        }], valueArc: [{
            type: Input
        }], cornerRadius: [{
            type: Input
        }], colors: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return GaugeArcComponent;
}());

var GaugeAxisComponent = /** @class */ (function () {
    function GaugeAxisComponent() {
        this.rotate = '';
    }
    GaugeAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    GaugeAxisComponent.prototype.update = function () {
        this.rotationAngle = -90 + this.startAngle;
        this.rotate = "rotate(" + this.rotationAngle + ")";
        this.ticks = this.getTicks();
    };
    GaugeAxisComponent.prototype.getTicks = function () {
        var bigTickSegment = this.angleSpan / this.bigSegments;
        var smallTickSegment = bigTickSegment / (this.smallSegments);
        var tickLength = 20;
        var ticks = {
            big: [],
            small: []
        };
        var startDistance = this.radius + 10;
        var textDist = startDistance + tickLength + 10;
        for (var i = 0; i <= this.bigSegments; i++) {
            var angleDeg = i * bigTickSegment;
            var angle = angleDeg * Math.PI / 180;
            var textAnchor = this.getTextAnchor(angleDeg);
            var skip = false;
            if (i === 0 && this.angleSpan === 360) {
                skip = true;
            }
            if (!skip) {
                var text = Number.parseFloat(this.valueScale.invert(angleDeg).toString()).toLocaleString();
                if (this.tickFormatting) {
                    text = this.tickFormatting(text);
                }
                ticks.big.push({
                    line: this.getTickPath(startDistance, tickLength, angle),
                    textAnchor: textAnchor,
                    text: text,
                    textTransform: "\n            translate(" + textDist * Math.cos(angle) + ", " + textDist * Math.sin(angle) + ") rotate(" + -this.rotationAngle + ")\n          "
                });
            }
            if (i === this.bigSegments) {
                continue;
            }
            for (var j = 1; j <= this.smallSegments; j++) {
                var smallAngleDeg = angleDeg + j * smallTickSegment;
                var smallAngle = smallAngleDeg * Math.PI / 180;
                ticks.small.push({
                    line: this.getTickPath(startDistance, tickLength / 2, smallAngle)
                });
            }
        }
        return ticks;
    };
    GaugeAxisComponent.prototype.getTextAnchor = function (angle) {
        // [0, 45] = 'middle';
        // [46, 135] = 'start';
        // [136, 225] = 'middle';
        // [226, 315] = 'end';
        angle = (this.startAngle + angle) % 360;
        var textAnchor = 'middle';
        if (angle > 45 && angle <= 135) {
            textAnchor = 'start';
        }
        else if (angle > 225 && angle <= 315) {
            textAnchor = 'end';
        }
        return textAnchor;
    };
    GaugeAxisComponent.prototype.getTickPath = function (startDistance, tickLength, angle) {
        var y1 = startDistance * Math.sin(angle);
        var y2 = (startDistance + tickLength) * Math.sin(angle);
        var x1 = startDistance * Math.cos(angle);
        var x2 = (startDistance + tickLength) * Math.cos(angle);
        var points = [{ x: x1, y: y1 }, { x: x2, y: y2 }];
        var lineGenerator = line().x(function (d) { return d.x; }).y(function (d) { return d.y; });
        return lineGenerator(points);
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "bigSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "smallSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeAxisComponent.prototype, "angleSpan", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeAxisComponent.prototype, "startAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "radius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "valueScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "tickFormatting", void 0);
GaugeAxisComponent.ɵfac = function GaugeAxisComponent_Factory(t) { return new (t || GaugeAxisComponent)(); };
GaugeAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeAxisComponent, selectors: [["g", "ngx-charts-gauge-axis", ""]], inputs: { bigSegments: "bigSegments", smallSegments: "smallSegments", min: "min", max: "max", angleSpan: "angleSpan", startAngle: "startAngle", radius: "radius", valueScale: "valueScale", tickFormatting: "tickFormatting" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c52, decls: 4, vars: 4, consts: [["class", "gauge-tick gauge-tick-large", 4, "ngFor", "ngForOf"], ["class", "gauge-tick gauge-tick-small", 4, "ngFor", "ngForOf"], [1, "gauge-tick", "gauge-tick-large"], ["alignment-baseline", "central"], [1, "gauge-tick", "gauge-tick-small"]], template: function GaugeAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, GaugeAxisComponent__svg_g_1_Template, 2, 1, "g", 0);
        ɵngcc0.ɵɵtemplate(2, GaugeAxisComponent__svg_g_2_Template, 3, 4, "g", 0);
        ɵngcc0.ɵɵtemplate(3, GaugeAxisComponent__svg_g_3_Template, 2, 1, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.rotate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.small);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GaugeAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-gauge-axis]',
                template: "\n    <svg:g [attr.transform]=\"rotate\">\n        <svg:g *ngFor=\"let tick of ticks.big\"\n            class=\"gauge-tick gauge-tick-large\">\n            <svg:path [attr.d]=\"tick.line\" />\n        </svg:g>\n        <svg:g *ngFor=\"let tick of ticks.big\"\n            class=\"gauge-tick gauge-tick-large\">\n            <svg:text\n                [style.textAnchor]=\"tick.textAnchor\"\n                [attr.transform]=\"tick.textTransform\"\n                alignment-baseline=\"central\">\n                {{tick.text}}\n            </svg:text>\n        </svg:g>\n        <svg:g *ngFor=\"let tick of ticks.small\"\n            class=\"gauge-tick gauge-tick-small\">\n            <svg:path [attr.d]=\"tick.line\" />\n        </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { bigSegments: [{
            type: Input
        }], smallSegments: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], angleSpan: [{
            type: Input
        }], startAngle: [{
            type: Input
        }], radius: [{
            type: Input
        }], valueScale: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }] }); })();
    return GaugeAxisComponent;
}());

var GaugeModule = /** @class */ (function () {
    function GaugeModule() {
    }
GaugeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: GaugeModule });
GaugeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function GaugeModule_Factory(t) { return new (t || GaugeModule)(); }, imports: [[ChartCommonModule, PieChartModule, BarChartModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GaugeModule, { declarations: [LinearGaugeComponent,
        GaugeComponent,
        GaugeArcComponent,
        GaugeAxisComponent], imports: [ChartCommonModule,
        PieChartModule,
        BarChartModule], exports: [LinearGaugeComponent,
        GaugeComponent,
        GaugeArcComponent,
        GaugeAxisComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GaugeModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule, PieChartModule, BarChartModule],
                declarations: [
                    LinearGaugeComponent,
                    GaugeComponent,
                    GaugeArcComponent,
                    GaugeAxisComponent
                ],
                exports: [
                    LinearGaugeComponent,
                    GaugeComponent,
                    GaugeArcComponent,
                    GaugeAxisComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return GaugeModule;
}());

var NgxChartsModule = /** @class */ (function () {
    function NgxChartsModule() {
    }
NgxChartsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxChartsModule });
NgxChartsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxChartsModule_Factory(t) { return new (t || NgxChartsModule)(); }, imports: [ChartCommonModule,
        AreaChartModule,
        BarChartModule,
        BubbleChartModule,
        ForceDirectedGraphModule,
        HeatMapModule,
        LineChartModule,
        PolarChartModule,
        NumberCardModule,
        PieChartModule,
        TreeMapModule,
        GaugeModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxChartsModule, { exports: [ChartCommonModule,
        AreaChartModule,
        BarChartModule,
        BubbleChartModule,
        ForceDirectedGraphModule,
        HeatMapModule,
        LineChartModule,
        PolarChartModule,
        NumberCardModule,
        PieChartModule,
        TreeMapModule,
        GaugeModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxChartsModule, [{
        type: NgModule,
        args: [{
                exports: [
                    ChartCommonModule,
                    AreaChartModule,
                    BarChartModule,
                    BubbleChartModule,
                    ForceDirectedGraphModule,
                    HeatMapModule,
                    LineChartModule,
                    PolarChartModule,
                    NumberCardModule,
                    PieChartModule,
                    TreeMapModule,
                    GaugeModule
                ]
            }]
    }], function () { return []; }, null); })();
    return NgxChartsModule;
}());

function tickFormat(fieldType, groupByType) {
    return function (label) {
        if (label === 'No Value' || label === 'Other') {
            return label;
        }
        if (fieldType === 'date' && groupByType === 'groupBy') {
            var formatter = timeFormat('MM/DD/YYYY');
            return formatter(label);
        }
        return label.toString();
    };
}

export { NgxChartsModule, ChartCommonModule, LegendComponent, ScaleLegendComponent, LegendEntryComponent, AdvancedLegendComponent, TooltipModule, TooltipService, TooltipContentComponent, TooltipDirective, StyleTypes, AlignmentTypes, ShowTypes, AxesModule, AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent, reduceTicks, CountUpDirective, count, decimalChecker, Timeline, ColorHelper, ChartComponent, AreaComponent, BaseChartComponent, CircleComponent, CircleSeriesComponent, gridSize, gridLayout, GridPanelComponent, GridPanelSeriesComponent, SvgLinearGradientComponent, SvgRadialGradientComponent, TooltipArea, tickFormat, trimLabel, calculateViewDimensions, formatLabel, getUniqueXDomainValues, getScaleType, AreaChartModule, AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent, BarChartModule, BarComponent, BarHorizontalComponent, BarHorizontal2DComponent, BarHorizontalNormalizedComponent, BarHorizontalStackedComponent, SeriesHorizontal, BarLabelComponent, BarVerticalComponent, BarVertical2DComponent, BarVerticalNormalizedComponent, BarVerticalStackedComponent, D0Types, SeriesVerticalComponent, BubbleChartModule, BubbleChartComponent, getDomain, getScale, BubbleSeriesComponent, ForceDirectedGraphModule, ForceDirectedGraphComponent, HeatMapModule, HeatMapComponent, HeatMapCellComponent, HeatCellSeriesComponent, LineChartModule, LineChartComponent, LineComponent, LineSeriesComponent, PolarChartModule, PolarChartComponent, PolarSeriesComponent, NumberCardModule, NumberCardComponent, CardComponent, CardSeriesComponent, PieChartModule, AdvancedPieChartComponent, PieChartComponent, PieArcComponent, PieGridComponent, PieGridSeriesComponent, PieSeriesComponent, PieLabelComponent, TreeMapModule, TreeMapComponent, TreeMapCellComponent, TreeMapCellSeriesComponent, GaugeModule, GaugeArcComponent, GaugeAxisComponent, GaugeComponent, LinearGaugeComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXNtLmpzIiwic291cmNlcyI6WyJlc20uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUVPO0FBQ1A7Ozs7O2dZQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQU9PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FFTztBQUNQOzs7OztnS0FBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FFTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztnREFTc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBZU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQVFPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FRTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU82QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBU2dDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBS087QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU80QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU80QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU91QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBT21CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBaUI4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU93QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU8yQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU9tQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBUU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBdUJvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FLTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBZTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBUzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBU3FDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBaUJ3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBTU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVMrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFvQmlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQW9CeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFvQnNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVM2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFvQitCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQW9CdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFvQm9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQWlCZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFpQnlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQU9PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFpQ3VCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFxQjZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFrQjhCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFhMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBU29DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O2dEQVdpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT2dDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBU3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBZXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FtQk87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBcUIyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBZXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQXlCNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBU2tDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBTU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBTU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBTU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU8yQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREF1QnVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBTU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVM0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWV5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBTU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBU3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBZXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVN1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBaUJvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWtCd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcGxpY2F0aW9uUmVmLCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIEluamVjdGFibGUsIEluamVjdG9yLCBJbnB1dCwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBWaWV3RW5jYXBzdWxhdGlvbiwgSG9zdExpc3RlbmVyLCBWaWV3Q2hpbGQsIEhvc3RCaW5kaW5nLCBSZW5kZXJlcjIsIERpcmVjdGl2ZSwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIFZpZXdDb250YWluZXJSZWYsIE5nTW9kdWxlLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIE5nWm9uZSwgVGVtcGxhdGVSZWYsIENvbnRlbnRDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyB0cmlnZ2VyLCBzdHlsZSwgYW5pbWF0ZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcclxuaW1wb3J0IHsgcmdiIH0gZnJvbSAnZDMtY29sb3InO1xyXG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyByYW5nZSwgbWluLCBtYXggfSBmcm9tICdkMy1hcnJheSc7XHJcbmltcG9ydCB7IHNjYWxlQmFuZCwgc2NhbGVMaW5lYXIsIHNjYWxlT3JkaW5hbCwgc2NhbGVRdWFudGlsZSwgc2NhbGVUaW1lLCBzY2FsZVBvaW50IH0gZnJvbSAnZDMtc2NhbGUnO1xyXG5pbXBvcnQgeyBicnVzaFggfSBmcm9tICdkMy1icnVzaCc7XHJcbmltcG9ydCB7IHNlbGVjdCwgZXZlbnQgfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xyXG5pbXBvcnQgeyBjdXJ2ZUxpbmVhciwgYXJlYSwgbGluZSwgY3VydmVDYXJkaW5hbENsb3NlZCwgbGluZVJhZGlhbCwgYXJjLCBwaWUgfSBmcm9tICdkMy1zaGFwZSc7XHJcbmltcG9ydCB7IGZvcmNlQ29sbGlkZSwgZm9yY2VMaW5rLCBmb3JjZU1hbnlCb2R5LCBmb3JjZVNpbXVsYXRpb24sIGZvcmNlWCwgZm9yY2VZIH0gZnJvbSAnZDMtZm9yY2UnO1xyXG5pbXBvcnQgeyBpbnRlcnBvbGF0ZSB9IGZyb20gJ2QzLWludGVycG9sYXRlJztcclxuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnZDMtZm9ybWF0JztcclxuaW1wb3J0IHsgdHJlZW1hcCwgc3RyYXRpZnkgfSBmcm9tICdkMy1oaWVyYXJjaHknO1xyXG5pbXBvcnQgeyB0aW1lRm9ybWF0IH0gZnJvbSAnZDMtdGltZS1mb3JtYXQnO1xyXG5cclxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbi8vIFRoZSBleHBvcnQgaXMgbmVlZGVkIGhlcmUgdG8gZ2VuZXJhdGUgYSB2YWxpZCBwb2x5ZmlsbHMubWV0YWRhdGEuanNvbiBmaWxlXHJcbmZ1bmN0aW9uIG5neENoYXJ0c1BvbHlmaWxscygpIHtcclxuICAgIC8vIElFMTEgZml4XHJcbiAgICAvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9zd2ltbGFuZS9uZ3gtY2hhcnRzL2lzc3Vlcy8zODZcclxuICAgIGlmICh0eXBlb2YgKFNWR0VsZW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU1ZHRWxlbWVudC5wcm90b3R5cGUuY29udGFpbnMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgU1ZHRWxlbWVudC5wcm90b3R5cGUuY29udGFpbnMgPSBIVE1MRGl2RWxlbWVudC5wcm90b3R5cGUuY29udGFpbnM7XHJcbiAgICB9XHJcbn1cclxubmd4Q2hhcnRzUG9seWZpbGxzKCk7XHJcblxyXG52YXIgUGxhY2VtZW50VHlwZXM7XHJcbihmdW5jdGlvbiAoUGxhY2VtZW50VHlwZXMpIHtcclxuICAgIFBsYWNlbWVudFR5cGVzW1BsYWNlbWVudFR5cGVzW1widG9wXCJdID0gJ3RvcCddID0gXCJ0b3BcIjtcclxuICAgIFBsYWNlbWVudFR5cGVzW1BsYWNlbWVudFR5cGVzW1wiYm90dG9tXCJdID0gJ2JvdHRvbSddID0gXCJib3R0b21cIjtcclxuICAgIFBsYWNlbWVudFR5cGVzW1BsYWNlbWVudFR5cGVzW1wibGVmdFwiXSA9ICdsZWZ0J10gPSBcImxlZnRcIjtcclxuICAgIFBsYWNlbWVudFR5cGVzW1BsYWNlbWVudFR5cGVzW1wicmlnaHRcIl0gPSAncmlnaHQnXSA9IFwicmlnaHRcIjtcclxufSkoUGxhY2VtZW50VHlwZXMgfHwgKFBsYWNlbWVudFR5cGVzID0ge30pKTtcclxuXHJcbnZhciBjYXJldE9mZnNldCA9IDc7XHJcbmZ1bmN0aW9uIHZlcnRpY2FsUG9zaXRpb24oZWxEaW1lbnNpb25zLCBwb3BvdmVyRGltZW5zaW9ucywgYWxpZ25tZW50KSB7XHJcbiAgICBpZiAoYWxpZ25tZW50ID09PSAndG9wJykge1xyXG4gICAgICAgIHJldHVybiBlbERpbWVuc2lvbnMudG9wIC0gY2FyZXRPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBpZiAoYWxpZ25tZW50ID09PSAnYm90dG9tJykge1xyXG4gICAgICAgIHJldHVybiBlbERpbWVuc2lvbnMudG9wICsgZWxEaW1lbnNpb25zLmhlaWdodCAtIHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodCArIGNhcmV0T2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgaWYgKGFsaWdubWVudCA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICByZXR1cm4gZWxEaW1lbnNpb25zLnRvcCArIGVsRGltZW5zaW9ucy5oZWlnaHQgLyAyIC0gcG9wb3ZlckRpbWVuc2lvbnMuaGVpZ2h0IC8gMjtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gaG9yaXpvbnRhbFBvc2l0aW9uKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIGFsaWdubWVudCkge1xyXG4gICAgaWYgKGFsaWdubWVudCA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsRGltZW5zaW9ucy5sZWZ0IC0gY2FyZXRPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBpZiAoYWxpZ25tZW50ID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsRGltZW5zaW9ucy5sZWZ0ICsgZWxEaW1lbnNpb25zLndpZHRoIC0gcG9wb3ZlckRpbWVuc2lvbnMud2lkdGggKyBjYXJldE9mZnNldDtcclxuICAgIH1cclxuICAgIGlmIChhbGlnbm1lbnQgPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsRGltZW5zaW9ucy5sZWZ0ICsgZWxEaW1lbnNpb25zLndpZHRoIC8gMiAtIHBvcG92ZXJEaW1lbnNpb25zLndpZHRoIC8gMjtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIFBvc2l0aW9uIGhlbHBlciBmb3IgdGhlIHBvcG92ZXIgZGlyZWN0aXZlLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBjbGFzcyBQb3NpdGlvbkhlbHBlclxyXG4gKi9cclxudmFyIFBvc2l0aW9uSGVscGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG9zaXRpb25IZWxwZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB2ZXJ0aWNhbCBhbGlnbm1lbnQgcG9zaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gZWxEaW1lbnNpb25zXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gcG9wb3ZlckRpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSB7YW55fSBhbGlnbm1lbnRcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIFBvc2l0aW9uSGVscGVyXHJcbiAgICAgKi9cclxuICAgIFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZVZlcnRpY2FsQWxpZ25tZW50ID0gZnVuY3Rpb24gKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIGFsaWdubWVudCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB2ZXJ0aWNhbFBvc2l0aW9uKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIGFsaWdubWVudCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCArIHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBwb3BvdmVyRGltZW5zaW9ucy5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdmVydGljYWwgY2FyZXQgcG9zaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gZWxEaW1lbnNpb25zXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gcG9wb3ZlckRpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSB7YW55fSBjYXJldERpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSB7YW55fSBhbGlnbm1lbnRcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIFBvc2l0aW9uSGVscGVyXHJcbiAgICAgKi9cclxuICAgIFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZVZlcnRpY2FsQ2FyZXQgPSBmdW5jdGlvbiAoZWxEaW1lbnNpb25zLCBwb3BvdmVyRGltZW5zaW9ucywgY2FyZXREaW1lbnNpb25zLCBhbGlnbm1lbnQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIGlmIChhbGlnbm1lbnQgPT09ICd0b3AnKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGVsRGltZW5zaW9ucy5oZWlnaHQgLyAyIC0gY2FyZXREaW1lbnNpb25zLmhlaWdodCAvIDIgKyBjYXJldE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsaWdubWVudCA9PT0gJ2JvdHRvbScpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcG9wb3ZlckRpbWVuc2lvbnMuaGVpZ2h0IC0gZWxEaW1lbnNpb25zLmhlaWdodCAvIDIgLSBjYXJldERpbWVuc2lvbnMuaGVpZ2h0IC8gMiAtIGNhcmV0T2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxpZ25tZW50ID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBwb3BvdmVyRGltZW5zaW9ucy5oZWlnaHQgLyAyIC0gY2FyZXREaW1lbnNpb25zLmhlaWdodCAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb3BvdmVyUG9zaXRpb24gPSB2ZXJ0aWNhbFBvc2l0aW9uKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIGFsaWdubWVudCk7XHJcbiAgICAgICAgaWYgKHBvcG92ZXJQb3NpdGlvbiArIHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gKHBvcG92ZXJQb3NpdGlvbiArIHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgaG9yeiBhbGlnbm1lbnQgcG9zaXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gZWxEaW1lbnNpb25zXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gcG9wb3ZlckRpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSB7YW55fSBhbGlnbm1lbnRcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIFBvc2l0aW9uSGVscGVyXHJcbiAgICAgKi9cclxuICAgIFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZUhvcml6b250YWxBbGlnbm1lbnQgPSBmdW5jdGlvbiAoZWxEaW1lbnNpb25zLCBwb3BvdmVyRGltZW5zaW9ucywgYWxpZ25tZW50KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGhvcml6b250YWxQb3NpdGlvbihlbERpbWVuc2lvbnMsIHBvcG92ZXJEaW1lbnNpb25zLCBhbGlnbm1lbnQpO1xyXG4gICAgICAgIGlmIChyZXN1bHQgKyBwb3BvdmVyRGltZW5zaW9ucy53aWR0aCA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gcG9wb3ZlckRpbWVuc2lvbnMud2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgaG9yeiBjYXJldCBwb3NpdGlvblxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7YW55fSBlbERpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSB7YW55fSBwb3BvdmVyRGltZW5zaW9uc1xyXG4gICAgICogQHBhcmFtIHthbnl9IGNhcmV0RGltZW5zaW9uc1xyXG4gICAgICogQHBhcmFtIHthbnl9IGFsaWdubWVudFxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgUG9zaXRpb25IZWxwZXJcclxuICAgICAqL1xyXG4gICAgUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlSG9yaXpvbnRhbENhcmV0ID0gZnVuY3Rpb24gKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIGNhcmV0RGltZW5zaW9ucywgYWxpZ25tZW50KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICBpZiAoYWxpZ25tZW50ID09PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZWxEaW1lbnNpb25zLndpZHRoIC8gMiAtIGNhcmV0RGltZW5zaW9ucy53aWR0aCAvIDIgKyBjYXJldE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsaWdubWVudCA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBwb3BvdmVyRGltZW5zaW9ucy53aWR0aCAtIGVsRGltZW5zaW9ucy53aWR0aCAvIDIgLSBjYXJldERpbWVuc2lvbnMud2lkdGggLyAyIC0gY2FyZXRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbGlnbm1lbnQgPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHBvcG92ZXJEaW1lbnNpb25zLndpZHRoIC8gMiAtIGNhcmV0RGltZW5zaW9ucy53aWR0aCAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb3BvdmVyUG9zaXRpb24gPSBob3Jpem9udGFsUG9zaXRpb24oZWxEaW1lbnNpb25zLCBwb3BvdmVyRGltZW5zaW9ucywgYWxpZ25tZW50KTtcclxuICAgICAgICBpZiAocG9wb3ZlclBvc2l0aW9uICsgcG9wb3ZlckRpbWVuc2lvbnMud2lkdGggPiB3aW5kb3cuaW5uZXJXaWR0aCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gKHBvcG92ZXJQb3NpdGlvbiArIHBvcG92ZXJEaW1lbnNpb25zLndpZHRoIC0gd2luZG93LmlubmVyV2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBlbGVtZW50J3MgcG9zaXRpb24gc2hvdWxkIGJlIGZsaXBwZWRcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gZWxEaW1lbnNpb25zXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gcG9wb3ZlckRpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSB7YW55fSBwbGFjZW1lbnRcclxuICAgICAqIEBwYXJhbSB7YW55fSBzcGFjaW5nXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgUG9zaXRpb25IZWxwZXJcclxuICAgICAqL1xyXG4gICAgUG9zaXRpb25IZWxwZXIuc2hvdWxkRmxpcCA9IGZ1bmN0aW9uIChlbERpbWVuc2lvbnMsIHBvcG92ZXJEaW1lbnNpb25zLCBwbGFjZW1lbnQsIHNwYWNpbmcpIHtcclxuICAgICAgICB2YXIgZmxpcCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChwbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgaWYgKGVsRGltZW5zaW9ucy5sZWZ0ICsgZWxEaW1lbnNpb25zLndpZHRoICsgcG9wb3ZlckRpbWVuc2lvbnMud2lkdGggKyBzcGFjaW5nID4gd2luZG93LmlubmVyV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGZsaXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgICBpZiAoZWxEaW1lbnNpb25zLmxlZnQgLSBwb3BvdmVyRGltZW5zaW9ucy53aWR0aCAtIHNwYWNpbmcgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBmbGlwID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGxhY2VtZW50ID09PSAndG9wJykge1xyXG4gICAgICAgICAgICBpZiAoZWxEaW1lbnNpb25zLnRvcCAtIHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodCAtIHNwYWNpbmcgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBmbGlwID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGxhY2VtZW50ID09PSAnYm90dG9tJykge1xyXG4gICAgICAgICAgICBpZiAoZWxEaW1lbnNpb25zLnRvcCArIGVsRGltZW5zaW9ucy5oZWlnaHQgKyBwb3BvdmVyRGltZW5zaW9ucy5oZWlnaHQgKyBzcGFjaW5nID4gd2luZG93LmlubmVySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBmbGlwID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmxpcDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9uIGNhcmV0XHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHthbnl9IHBsYWNlbWVudFxyXG4gICAgICogQHBhcmFtIHthbnl9IGVsbURpbVxyXG4gICAgICogQHBhcmFtIHthbnl9IGhvc3REaW1cclxuICAgICAqIEBwYXJhbSB7YW55fSBjYXJldERpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSB7YW55fSBhbGlnbm1lbnRcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBQb3NpdGlvbkhlbHBlclxyXG4gICAgICovXHJcbiAgICBQb3NpdGlvbkhlbHBlci5wb3NpdGlvbkNhcmV0ID0gZnVuY3Rpb24gKHBsYWNlbWVudCwgZWxtRGltLCBob3N0RGltLCBjYXJldERpbWVuc2lvbnMsIGFsaWdubWVudCkge1xyXG4gICAgICAgIHZhciB0b3AgPSAwO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gMDtcclxuICAgICAgICBpZiAocGxhY2VtZW50ID09PSBQbGFjZW1lbnRUeXBlcy5yaWdodCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gLTc7XHJcbiAgICAgICAgICAgIHRvcCA9IFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZVZlcnRpY2FsQ2FyZXQoaG9zdERpbSwgZWxtRGltLCBjYXJldERpbWVuc2lvbnMsIGFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMubGVmdCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gZWxtRGltLndpZHRoO1xyXG4gICAgICAgICAgICB0b3AgPSBQb3NpdGlvbkhlbHBlci5jYWxjdWxhdGVWZXJ0aWNhbENhcmV0KGhvc3REaW0sIGVsbURpbSwgY2FyZXREaW1lbnNpb25zLCBhbGlnbm1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLnRvcCkge1xyXG4gICAgICAgICAgICB0b3AgPSBlbG1EaW0uaGVpZ2h0O1xyXG4gICAgICAgICAgICBsZWZ0ID0gUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlSG9yaXpvbnRhbENhcmV0KGhvc3REaW0sIGVsbURpbSwgY2FyZXREaW1lbnNpb25zLCBhbGlnbm1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLmJvdHRvbSkge1xyXG4gICAgICAgICAgICB0b3AgPSAtNztcclxuICAgICAgICAgICAgbGVmdCA9IFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZUhvcml6b250YWxDYXJldChob3N0RGltLCBlbG1EaW0sIGNhcmV0RGltZW5zaW9ucywgYWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9uIGNvbnRlbnRcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gcGxhY2VtZW50XHJcbiAgICAgKiBAcGFyYW0ge2FueX0gZWxtRGltXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gaG9zdERpbVxyXG4gICAgICogQHBhcmFtIHthbnl9IHNwYWNpbmdcclxuICAgICAqIEBwYXJhbSB7YW55fSBhbGlnbm1lbnRcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBQb3NpdGlvbkhlbHBlclxyXG4gICAgICovXHJcbiAgICBQb3NpdGlvbkhlbHBlci5wb3NpdGlvbkNvbnRlbnQgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBlbG1EaW0sIGhvc3REaW0sIHNwYWNpbmcsIGFsaWdubWVudCkge1xyXG4gICAgICAgIHZhciB0b3AgPSAwO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gMDtcclxuICAgICAgICBpZiAocGxhY2VtZW50ID09PSBQbGFjZW1lbnRUeXBlcy5yaWdodCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gaG9zdERpbS5sZWZ0ICsgaG9zdERpbS53aWR0aCArIHNwYWNpbmc7XHJcbiAgICAgICAgICAgIHRvcCA9IFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZVZlcnRpY2FsQWxpZ25tZW50KGhvc3REaW0sIGVsbURpbSwgYWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGxhY2VtZW50ID09PSBQbGFjZW1lbnRUeXBlcy5sZWZ0KSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBob3N0RGltLmxlZnQgLSBlbG1EaW0ud2lkdGggLSBzcGFjaW5nO1xyXG4gICAgICAgICAgICB0b3AgPSBQb3NpdGlvbkhlbHBlci5jYWxjdWxhdGVWZXJ0aWNhbEFsaWdubWVudChob3N0RGltLCBlbG1EaW0sIGFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMudG9wKSB7XHJcbiAgICAgICAgICAgIHRvcCA9IGhvc3REaW0udG9wIC0gZWxtRGltLmhlaWdodCAtIHNwYWNpbmc7XHJcbiAgICAgICAgICAgIGxlZnQgPSBQb3NpdGlvbkhlbHBlci5jYWxjdWxhdGVIb3Jpem9udGFsQWxpZ25tZW50KGhvc3REaW0sIGVsbURpbSwgYWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGxhY2VtZW50ID09PSBQbGFjZW1lbnRUeXBlcy5ib3R0b20pIHtcclxuICAgICAgICAgICAgdG9wID0gaG9zdERpbS50b3AgKyBob3N0RGltLmhlaWdodCArIHNwYWNpbmc7XHJcbiAgICAgICAgICAgIGxlZnQgPSBQb3NpdGlvbkhlbHBlci5jYWxjdWxhdGVIb3Jpem9udGFsQWxpZ25tZW50KGhvc3REaW0sIGVsbURpbSwgYWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZSBwbGFjZW1lbnQgYmFzZWQgb24gZmxpcFxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7YW55fSBwbGFjZW1lbnRcclxuICAgICAqIEBwYXJhbSB7YW55fSBlbG1EaW1cclxuICAgICAqIEBwYXJhbSB7YW55fSBob3N0RGltXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gc3BhY2luZ1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIFBvc2l0aW9uSGVscGVyXHJcbiAgICAgKi9cclxuICAgIFBvc2l0aW9uSGVscGVyLmRldGVybWluZVBsYWNlbWVudCA9IGZ1bmN0aW9uIChwbGFjZW1lbnQsIGVsbURpbSwgaG9zdERpbSwgc3BhY2luZykge1xyXG4gICAgICAgIHZhciBzaG91bGRGbGlwID0gUG9zaXRpb25IZWxwZXIuc2hvdWxkRmxpcChob3N0RGltLCBlbG1EaW0sIHBsYWNlbWVudCwgc3BhY2luZyk7XHJcbiAgICAgICAgaWYgKHNob3VsZEZsaXApIHtcclxuICAgICAgICAgICAgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbGFjZW1lbnRUeXBlcy5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsYWNlbWVudFR5cGVzLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMudG9wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGxhY2VtZW50VHlwZXMuYm90dG9tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMuYm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGxhY2VtZW50VHlwZXMudG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwbGFjZW1lbnQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBvc2l0aW9uSGVscGVyO1xyXG59KCkpO1xyXG5cclxudmFyIFN0eWxlVHlwZXM7XHJcbihmdW5jdGlvbiAoU3R5bGVUeXBlcykge1xyXG4gICAgU3R5bGVUeXBlc1tTdHlsZVR5cGVzW1wicG9wb3ZlclwiXSA9ICdwb3BvdmVyJ10gPSBcInBvcG92ZXJcIjtcclxuICAgIFN0eWxlVHlwZXNbU3R5bGVUeXBlc1tcInRvb2x0aXBcIl0gPSAndG9vbHRpcCddID0gXCJ0b29sdGlwXCI7XHJcbn0pKFN0eWxlVHlwZXMgfHwgKFN0eWxlVHlwZXMgPSB7fSkpO1xyXG5cclxudmFyIEFsaWdubWVudFR5cGVzO1xyXG4oZnVuY3Rpb24gKEFsaWdubWVudFR5cGVzKSB7XHJcbiAgICBBbGlnbm1lbnRUeXBlc1tBbGlnbm1lbnRUeXBlc1tcImxlZnRcIl0gPSAnbGVmdCddID0gXCJsZWZ0XCI7XHJcbiAgICBBbGlnbm1lbnRUeXBlc1tBbGlnbm1lbnRUeXBlc1tcImNlbnRlclwiXSA9ICdjZW50ZXInXSA9IFwiY2VudGVyXCI7XHJcbiAgICBBbGlnbm1lbnRUeXBlc1tBbGlnbm1lbnRUeXBlc1tcInJpZ2h0XCJdID0gJ3JpZ2h0J10gPSBcInJpZ2h0XCI7XHJcbn0pKEFsaWdubWVudFR5cGVzIHx8IChBbGlnbm1lbnRUeXBlcyA9IHt9KSk7XHJcblxyXG52YXIgU2hvd1R5cGVzO1xyXG4oZnVuY3Rpb24gKFNob3dUeXBlcykge1xyXG4gICAgU2hvd1R5cGVzW1Nob3dUeXBlc1tcImFsbFwiXSA9ICdhbGwnXSA9IFwiYWxsXCI7XHJcbiAgICBTaG93VHlwZXNbU2hvd1R5cGVzW1wiZm9jdXNcIl0gPSAnZm9jdXMnXSA9IFwiZm9jdXNcIjtcclxuICAgIFNob3dUeXBlc1tTaG93VHlwZXNbXCJtb3VzZW92ZXJcIl0gPSAnbW91c2VvdmVyJ10gPSBcIm1vdXNlb3ZlclwiO1xyXG59KShTaG93VHlwZXMgfHwgKFNob3dUeXBlcyA9IHt9KSk7XHJcblxyXG4vKipcclxuICogSW5qZWN0aW9uIHNlcnZpY2UgaXMgYSBoZWxwZXIgdG8gYXBwZW5kIGNvbXBvbmVudHNcclxuICogZHluYW1pY2FsbHkgdG8gYSBrbm93biBsb2NhdGlvbiBpbiB0aGUgRE9NLCBtb3N0XHJcbiAqIG5vdGVhYmx5IGZvciBkaWFsb2dzL3Rvb2x0aXBzIGFwcGVuZGluZyB0byBib2R5LlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBjbGFzcyBJbmplY3Rpb25TZXJ2aWNlXHJcbiAqL1xyXG52YXIgSW5qZWN0aW9uU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEluamVjdGlvblNlcnZpY2UoYXBwbGljYXRpb25SZWYsIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgaW5qZWN0b3IpIHtcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uUmVmID0gYXBwbGljYXRpb25SZWY7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XHJcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xyXG4gICAgfVxyXG4gICAgSW5qZWN0aW9uU2VydmljZV8xID0gSW5qZWN0aW9uU2VydmljZTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIGRlZmF1bHQgZ2xvYmFsIHJvb3QgdmlldyBjb250YWluZXIuIFRoaXMgaXMgdXNlZnVsIGZvclxyXG4gICAgICogdGhpbmdzIGxpa2UgbmdVcGdyYWRlIHRoYXQgZG9lc24ndCBoYXZlIGEgQXBwbGljYXRpb25SZWYgcm9vdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyXHJcbiAgICAgKi9cclxuICAgIEluamVjdGlvblNlcnZpY2Uuc2V0R2xvYmFsUm9vdFZpZXdDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgSW5qZWN0aW9uU2VydmljZV8xLmdsb2JhbFJvb3RWaWV3Q29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcm9vdCB2aWV3IGNvbnRhaW5lciB0byBpbmplY3QgdGhlIGNvbXBvbmVudCB0by5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50UmVmPGFueT59XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIEluamVjdGlvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgSW5qZWN0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Um9vdFZpZXdDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJvb3RDb21wb25lbnRzID0gdGhpcy5hcHBsaWNhdGlvblJlZi5jb21wb25lbnRzO1xyXG4gICAgICAgIC8vIGZpeCBjYW5ub3QgcmVhZCBsZW5ndGggb2YgdW5kZWZpbmVkXHJcbiAgICAgICAgaWYgKHJvb3RDb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIGlmIChyb290Q29tcG9uZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdENvbXBvbmVudHNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcbiAgICAgICAgaWYgKEluamVjdGlvblNlcnZpY2VfMS5nbG9iYWxSb290Vmlld0NvbnRhaW5lcilcclxuICAgICAgICAgICAgcmV0dXJuIEluamVjdGlvblNlcnZpY2VfMS5nbG9iYWxSb290Vmlld0NvbnRhaW5lcjtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpZXcgQ29udGFpbmVyIG5vdCBmb3VuZCEgbmdVcGdyYWRlIG5lZWRzIHRvIG1hbnVhbGx5IHNldCB0aGlzIHZpYSBzZXRSb290Vmlld0NvbnRhaW5lci4nKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCByb290IHZpZXcgY29udGFpbmVyLiBUaGlzIGlzIHVzZWZ1bCBmb3JcclxuICAgICAqIHRoaW5ncyBsaWtlIG5nVXBncmFkZSB0aGF0IGRvZXNuJ3QgaGF2ZSBhIEFwcGxpY2F0aW9uUmVmIHJvb3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHthbnl9IGNvbnRhaW5lclxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBJbmplY3Rpb25TZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIEluamVjdGlvblNlcnZpY2UucHJvdG90eXBlLnNldFJvb3RWaWV3Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGh0bWwgZWxlbWVudCBmb3IgYSBjb21wb25lbnQgcmVmLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Q29tcG9uZW50UmVmPGFueT59IGNvbXBvbmVudFJlZlxyXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBJbmplY3Rpb25TZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIEluamVjdGlvblNlcnZpY2UucHJvdG90eXBlLmdldENvbXBvbmVudFJvb3ROb2RlID0gZnVuY3Rpb24gKGNvbXBvbmVudFJlZikge1xyXG4gICAgICAgIC8vIHRoZSB0b3AgbW9zdCBjb21wb25lbnQgcm9vdCBub2RlIGhhcyBubyBgaG9zdFZpZXdgXHJcbiAgICAgICAgaWYgKCFjb21wb25lbnRSZWYuaG9zdFZpZXcpXHJcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xyXG4gICAgICAgIHJldHVybiBjb21wb25lbnRSZWYuaG9zdFZpZXcucm9vdE5vZGVzWzBdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcm9vdCBjb21wb25lbnQgY29udGFpbmVyIGh0bWwgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIEluamVjdGlvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgSW5qZWN0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Um9vdFZpZXdDb250YWluZXJOb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudFJvb3ROb2RlKHRoaXMuZ2V0Um9vdFZpZXdDb250YWluZXIoKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9qZWN0cyB0aGUgYmluZGluZ3Mgb250byB0aGUgY29tcG9uZW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtDb21wb25lbnRSZWY8YW55Pn0gY29tcG9uZW50XHJcbiAgICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtDb21wb25lbnRSZWY8YW55Pn1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgSW5qZWN0aW9uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBJbmplY3Rpb25TZXJ2aWNlLnByb3RvdHlwZS5wcm9qZWN0Q29tcG9uZW50QmluZGluZ3MgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBiaW5kaW5ncykge1xyXG4gICAgICAgIGlmIChiaW5kaW5ncykge1xyXG4gICAgICAgICAgICBpZiAoYmluZGluZ3MuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJpbmRpbmdzLmlucHV0cyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGJpbmRpbmdLZXlzXzEgPSBiaW5kaW5nS2V5czsgX2kgPCBiaW5kaW5nS2V5c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nTmFtZSA9IGJpbmRpbmdLZXlzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pbnN0YW5jZVtiaW5kaW5nTmFtZV0gPSBiaW5kaW5ncy5pbnB1dHNbYmluZGluZ05hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChiaW5kaW5ncy5vdXRwdXRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiaW5kaW5ncy5vdXRwdXRzKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgZXZlbnRLZXlzXzEgPSBldmVudEtleXM7IF9hIDwgZXZlbnRLZXlzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50S2V5c18xW19hXTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaW5zdGFuY2VbZXZlbnROYW1lXSA9IGJpbmRpbmdzLm91dHB1dHNbZXZlbnROYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBhIGNvbXBvbmVudCB0byBhIGFkamFjZW50IGxvY2F0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7VHlwZTxUPn0gY29tcG9uZW50Q2xhc3NcclxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnM9e31dXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtsb2NhdGlvbj10aGlzLmdldFJvb3RWaWV3Q29udGFpbmVyTm9kZSgpXVxyXG4gICAgICogQHJldHVybnMge0NvbXBvbmVudFJlZjxhbnk+fVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBJbmplY3Rpb25TZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIEluamVjdGlvblNlcnZpY2UucHJvdG90eXBlLmFwcGVuZENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcywgYmluZGluZ3MsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgaWYgKGJpbmRpbmdzID09PSB2b2lkIDApIHsgYmluZGluZ3MgPSB7fTsgfVxyXG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gdm9pZCAwKSB7IGxvY2F0aW9uID0gdGhpcy5nZXRSb290Vmlld0NvbnRhaW5lck5vZGUoKTsgfVxyXG4gICAgICAgIHZhciBjb21wb25lbnRGYWN0b3J5ID0gdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50Q2xhc3MpO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRSZWYgPSBjb21wb25lbnRGYWN0b3J5LmNyZWF0ZSh0aGlzLmluamVjdG9yKTtcclxuICAgICAgICB2YXIgYXBwUmVmID0gdGhpcy5hcHBsaWNhdGlvblJlZjtcclxuICAgICAgICB2YXIgY29tcG9uZW50Um9vdE5vZGUgPSB0aGlzLmdldENvbXBvbmVudFJvb3ROb2RlKGNvbXBvbmVudFJlZik7XHJcbiAgICAgICAgLy8gcHJvamVjdCB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZVxyXG4gICAgICAgIHRoaXMucHJvamVjdENvbXBvbmVudEJpbmRpbmdzKGNvbXBvbmVudFJlZiwgYmluZGluZ3MpO1xyXG4gICAgICAgIGFwcFJlZi5hdHRhY2hWaWV3KGNvbXBvbmVudFJlZi5ob3N0Vmlldyk7XHJcbiAgICAgICAgY29tcG9uZW50UmVmLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGFwcFJlZi5kZXRhY2hWaWV3KGNvbXBvbmVudFJlZi5ob3N0Vmlldyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gdXNlIHRoZSByZW5kZXJlciB0byBhcHBlbmQgdGhlIGVsZW1lbnQgZm9yIHVuaXZzZXJhbCBzdXBwb3J0XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gY29tcG9uZW50UmVmLmluc3RhbmNlLnJlbmRlcmVyO1xyXG4gICAgICAgIHJlbmRlcmVyLmFwcGVuZENoaWxkKGxvY2F0aW9uLCBjb21wb25lbnRSb290Tm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZjtcclxuICAgIH07XHJcbiAgICB2YXIgSW5qZWN0aW9uU2VydmljZV8xLCBfYSwgX2IsIF9jO1xyXG4gICAgSW5qZWN0aW9uU2VydmljZS5nbG9iYWxSb290Vmlld0NvbnRhaW5lciA9IG51bGw7XHJcbiAgICBJbmplY3Rpb25TZXJ2aWNlID0gSW5qZWN0aW9uU2VydmljZV8xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBBcHBsaWNhdGlvblJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBBcHBsaWNhdGlvblJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0LCB0eXBlb2YgKF9iID0gdHlwZW9mIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdCwgdHlwZW9mIChfYyA9IHR5cGVvZiBJbmplY3RvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBJbmplY3RvcikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0XSlcclxuICAgIF0sIEluamVjdGlvblNlcnZpY2UpO1xyXG4gICAgcmV0dXJuIEluamVjdGlvblNlcnZpY2U7XHJcbn0oKSk7XHJcblxyXG52YXIgSW5qZWN0aW9uUmVnaXN0ZXJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW5qZWN0aW9uUmVnaXN0ZXJ5KGluamVjdGlvblNlcnZpY2UpIHtcclxuICAgICAgICB0aGlzLmluamVjdGlvblNlcnZpY2UgPSBpbmplY3Rpb25TZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdHMgPSB7fTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmdldEJ5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gdGhpcy50eXBlOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5nZXQodHlwZSk7XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0aW9uUmVnaXN0ZXJ5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoYmluZGluZ3MpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVCeVR5cGUodGhpcy50eXBlLCBiaW5kaW5ncyk7XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0aW9uUmVnaXN0ZXJ5LnByb3RvdHlwZS5jcmVhdGVCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSwgYmluZGluZ3MpIHtcclxuICAgICAgICBiaW5kaW5ncyA9IHRoaXMuYXNzaWduRGVmYXVsdHMoYmluZGluZ3MpO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmluamVjdENvbXBvbmVudCh0eXBlLCBiaW5kaW5ncyk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih0eXBlLCBjb21wb25lbnQpO1xyXG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0aW9uUmVnaXN0ZXJ5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgICAgICAgdmFyIGNvbXBzQnlUeXBlID0gdGhpcy5jb21wb25lbnRzLmdldChpbnN0YW5jZS5jb21wb25lbnRUeXBlKTtcclxuICAgICAgICBpZiAoY29tcHNCeVR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGlkeCA9IGNvbXBzQnlUeXBlLmluZGV4T2YoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBjb21wc0J5VHlwZVtpZHhdO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIGNvbXBzQnlUeXBlLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEluamVjdGlvblJlZ2lzdGVyeS5wcm90b3R5cGUuZGVzdHJveUFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lCeVR5cGUodGhpcy50eXBlKTtcclxuICAgIH07XHJcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmRlc3Ryb3lCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciBjb21wcyA9IHRoaXMuY29tcG9uZW50cy5nZXQodHlwZSk7XHJcbiAgICAgICAgaWYgKGNvbXBzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY29tcHNfMSA9IGNvbXBzOyBfaSA8IGNvbXBzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcCA9IGNvbXBzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KGNvbXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEluamVjdGlvblJlZ2lzdGVyeS5wcm90b3R5cGUuYXNzaWduRGVmYXVsdHMgPSBmdW5jdGlvbiAoYmluZGluZ3MpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLmRlZmF1bHRzLCBpbnB1dHMgPSBfYS5pbnB1dHMsIG91dHB1dHMgPSBfYS5vdXRwdXRzO1xyXG4gICAgICAgIGlmICghYmluZGluZ3MuaW5wdXRzICYmICFiaW5kaW5ncy5vdXRwdXRzKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmdzID0geyBpbnB1dHM6IGJpbmRpbmdzIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnB1dHMpIHtcclxuICAgICAgICAgICAgYmluZGluZ3MuaW5wdXRzID0gT2JqZWN0LmFzc2lnbihpbnB1dHMsIGJpbmRpbmdzLmlucHV0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdXRwdXRzKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmdzLm91dHB1dHMgPSBPYmplY3QuYXNzaWduKG91dHB1dHMsIGJpbmRpbmdzLm91dHB1dHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmluZGluZ3M7XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0aW9uUmVnaXN0ZXJ5LnByb3RvdHlwZS5pbmplY3RDb21wb25lbnQgPSBmdW5jdGlvbiAodHlwZSwgYmluZGluZ3MpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmplY3Rpb25TZXJ2aWNlLmFwcGVuZENvbXBvbmVudCh0eXBlLCBiaW5kaW5ncyk7XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0aW9uUmVnaXN0ZXJ5LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uICh0eXBlLCBjb21wb25lbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50cy5oYXModHlwZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzLnNldCh0eXBlLCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0eXBlcyA9IHRoaXMuY29tcG9uZW50cy5nZXQodHlwZSk7XHJcbiAgICAgICAgdHlwZXMucHVzaChjb21wb25lbnQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbmplY3Rpb25SZWdpc3Rlcnk7XHJcbn0oKSk7XHJcblxyXG4vKipcclxuICogVGhyb3R0bGUgYSBmdW5jdGlvblxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7Kn0gICAgICBmdW5jXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0XHJcbiAqIEBwYXJhbSB7Kn0gICAgICBbb3B0aW9uc11cclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgdmFyIGNvbnRleHQ7XHJcbiAgICB2YXIgYXJncztcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XHJcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xyXG4gICAgZnVuY3Rpb24gbGF0ZXIoKSB7XHJcbiAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6ICtuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub3cgPSArbmV3IERhdGUoKTtcclxuICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcclxuICAgICAgICBjb250ZXh0ID0gdGhpcztcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcclxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBUaHJvdHRsZSBkZWNvcmF0b3JcclxuICpcclxuICogIGNsYXNzIE15Q2xhc3Mge1xyXG4gKiAgICB0aHJvdHRsZWFibGUoMTApXHJcbiAqICAgIG15Rm4oKSB7IC4uLiB9XHJcbiAqICB9XHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdXHJcbiAqIEByZXR1cm5zXHJcbiAqL1xyXG5mdW5jdGlvbiB0aHJvdHRsZWFibGUoZHVyYXRpb24sIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBpbm5lckRlY29yYXRvcih0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldHRlcigpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aHJvdHRsZShkZXNjcmlwdG9yLnZhbHVlLCBkdXJhdGlvbiwgb3B0aW9ucylcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcblxyXG52YXIgVG9vbHRpcENvbnRlbnRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUb29sdGlwQ29udGVudENvbXBvbmVudChlbGVtZW50LCByZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjc3NDbGFzc2VzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNseiA9ICduZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudCc7XHJcbiAgICAgICAgICAgIGNseiArPSBcIiBwb3NpdGlvbi1cIiArIHRoaXMucGxhY2VtZW50O1xyXG4gICAgICAgICAgICBjbHogKz0gXCIgdHlwZS1cIiArIHRoaXMudHlwZTtcclxuICAgICAgICAgICAgY2x6ICs9IFwiIFwiICsgdGhpcy5jc3NDbGFzcztcclxuICAgICAgICAgICAgcmV0dXJuIGNsejtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnBvc2l0aW9uLmJpbmQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBuYXRpdmVFbG0gPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcclxuICAgICAgICB2YXIgaG9zdERpbSA9IHRoaXMuaG9zdC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGlmICghaG9zdERpbS5oZWlnaHQgJiYgIWhvc3REaW0ud2lkdGgpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgZWxtRGltID0gbmF0aXZlRWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tGbGlwKGhvc3REaW0sIGVsbURpbSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbkNvbnRlbnQobmF0aXZlRWxtLCBob3N0RGltLCBlbG1EaW0pO1xyXG4gICAgICAgIGlmICh0aGlzLnNob3dDYXJldCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uQ2FyZXQoaG9zdERpbSwgZWxtRGltKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhuYXRpdmVFbG0sICdhbmltYXRlJyk7IH0sIDEpO1xyXG4gICAgfTtcclxuICAgIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZS5wb3NpdGlvbkNvbnRlbnQgPSBmdW5jdGlvbiAobmF0aXZlRWxtLCBob3N0RGltLCBlbG1EaW0pIHtcclxuICAgICAgICB2YXIgX2EgPSBQb3NpdGlvbkhlbHBlci5wb3NpdGlvbkNvbnRlbnQodGhpcy5wbGFjZW1lbnQsIGVsbURpbSwgaG9zdERpbSwgdGhpcy5zcGFjaW5nLCB0aGlzLmFsaWdubWVudCksIHRvcCA9IF9hLnRvcCwgbGVmdCA9IF9hLmxlZnQ7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShuYXRpdmVFbG0sICd0b3AnLCB0b3AgKyBcInB4XCIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUobmF0aXZlRWxtLCAnbGVmdCcsIGxlZnQgKyBcInB4XCIpO1xyXG4gICAgfTtcclxuICAgIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZS5wb3NpdGlvbkNhcmV0ID0gZnVuY3Rpb24gKGhvc3REaW0sIGVsbURpbSkge1xyXG4gICAgICAgIHZhciBjYXJldEVsbSA9IHRoaXMuY2FyZXRFbG0ubmF0aXZlRWxlbWVudDtcclxuICAgICAgICB2YXIgY2FyZXREaW1lbnNpb25zID0gY2FyZXRFbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgdmFyIF9hID0gUG9zaXRpb25IZWxwZXIucG9zaXRpb25DYXJldCh0aGlzLnBsYWNlbWVudCwgZWxtRGltLCBob3N0RGltLCBjYXJldERpbWVuc2lvbnMsIHRoaXMuYWxpZ25tZW50KSwgdG9wID0gX2EudG9wLCBsZWZ0ID0gX2EubGVmdDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGNhcmV0RWxtLCAndG9wJywgdG9wICsgXCJweFwiKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGNhcmV0RWxtLCAnbGVmdCcsIGxlZnQgKyBcInB4XCIpO1xyXG4gICAgfTtcclxuICAgIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZS5jaGVja0ZsaXAgPSBmdW5jdGlvbiAoaG9zdERpbSwgZWxtRGltKSB7XHJcbiAgICAgICAgdGhpcy5wbGFjZW1lbnQgPSBQb3NpdGlvbkhlbHBlci5kZXRlcm1pbmVQbGFjZW1lbnQodGhpcy5wbGFjZW1lbnQsIGVsbURpbSwgaG9zdERpbSwgdGhpcy5zcGFjaW5nKTtcclxuICAgIH07XHJcbiAgICBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUub25XaW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbigpO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9zdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93Q2FyZXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgU3R5bGVUeXBlcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTdHlsZVR5cGVzKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBQbGFjZW1lbnRUeXBlcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBQbGFjZW1lbnRUeXBlcykgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlbWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBBbGlnbm1lbnRUeXBlcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBBbGlnbm1lbnRUeXBlcykgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcImFsaWdubWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjc3NDbGFzc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwidGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBWaWV3Q2hpbGQoJ2NhcmV0RWxtJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2FyZXRFbG1cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RCaW5kaW5nKCdjbGFzcycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjc3NDbGFzc2VzXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCd3aW5kb3c6cmVzaXplJyksXHJcbiAgICAgICAgdGhyb3R0bGVhYmxlKDEwMCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwib25XaW5kb3dSZXNpemVcIiwgbnVsbCk7XHJcbiAgICBUb29sdGlwQ29udGVudENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LXRvb2x0aXAtY29udGVudCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8ZGl2PlxcbiAgICAgIDxzcGFuICNjYXJldEVsbSBbaGlkZGVuXT1cXFwiIXNob3dDYXJldFxcXCIgY2xhc3M9XFxcInRvb2x0aXAtY2FyZXQgcG9zaXRpb24te3sgdGhpcy5wbGFjZW1lbnQgfX1cXFwiPiA8L3NwYW4+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1jb250ZW50XFxcIj5cXG4gICAgICAgIDxzcGFuICpuZ0lmPVxcXCIhdGl0bGVcXFwiPlxcbiAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVxcXCJ0ZW1wbGF0ZVxcXCIgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cXFwieyBtb2RlbDogY29udGV4dCB9XFxcIj4gPC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgIDwvc3Bhbj5cXG4gICAgICAgIDxzcGFuICpuZ0lmPVxcXCJ0aXRsZVxcXCIgW2lubmVySFRNTF09XFxcInRpdGxlXFxcIj4gPC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIFwiLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudHtwb3NpdGlvbjpmaXhlZDtib3JkZXItcmFkaXVzOjNweDt6LWluZGV4OjUwMDA7ZGlzcGxheTpibG9jaztmb250LXdlaWdodDo0MDA7b3BhY2l0eTowO3BvaW50ZXItZXZlbnRzOm5vbmUhaW1wb3J0YW50fS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC50eXBlLXBvcG92ZXJ7YmFja2dyb3VuZDojZmZmO2NvbG9yOiMwNjA3MDk7Ym9yZGVyOjFweCBzb2xpZCAjNzI4MDliO2JveC1zaGFkb3c6MCAxcHggM3B4IDAgcmdiYSgwLDAsMCwuMiksMCAxcHggMXB4IDAgcmdiYSgwLDAsMCwuMTQpLDAgMnB4IDFweCAtMXB4IHJnYmEoMCwwLDAsLjEyKTtmb250LXNpemU6MTNweDtwYWRkaW5nOjRweH0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQudHlwZS1wb3BvdmVyIC50b29sdGlwLWNhcmV0e3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6NTAwMTt3aWR0aDowO2hlaWdodDowfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC50eXBlLXBvcG92ZXIgLnRvb2x0aXAtY2FyZXQucG9zaXRpb24tbGVmdHtib3JkZXItdG9wOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdDo3cHggc29saWQgI2ZmZn0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQudHlwZS1wb3BvdmVyIC50b29sdGlwLWNhcmV0LnBvc2l0aW9uLXRvcHtib3JkZXItbGVmdDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItdG9wOjdweCBzb2xpZCAjZmZmfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC50eXBlLXBvcG92ZXIgLnRvb2x0aXAtY2FyZXQucG9zaXRpb24tcmlnaHR7Ym9yZGVyLXRvcDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCAjZmZmfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC50eXBlLXBvcG92ZXIgLnRvb2x0aXAtY2FyZXQucG9zaXRpb24tYm90dG9te2JvcmRlci1sZWZ0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206N3B4IHNvbGlkICNmZmZ9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnR5cGUtdG9vbHRpcHtjb2xvcjojZmZmO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuNzUpO2ZvbnQtc2l6ZToxMnB4O3BhZGRpbmc6MCAxMHB4O3RleHQtYWxpZ246Y2VudGVyO3BvaW50ZXItZXZlbnRzOmF1dG99Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnR5cGUtdG9vbHRpcCAudG9vbHRpcC1jYXJldC5wb3NpdGlvbi1sZWZ0e2JvcmRlci10b3A6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjdweCBzb2xpZCByZ2JhKDAsMCwwLC43NSl9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnR5cGUtdG9vbHRpcCAudG9vbHRpcC1jYXJldC5wb3NpdGlvbi10b3B7Ym9yZGVyLWxlZnQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcDo3cHggc29saWQgcmdiYSgwLDAsMCwuNzUpfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC50eXBlLXRvb2x0aXAgLnRvb2x0aXAtY2FyZXQucG9zaXRpb24tcmlnaHR7Ym9yZGVyLXRvcDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCByZ2JhKDAsMCwwLC43NSl9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnR5cGUtdG9vbHRpcCAudG9vbHRpcC1jYXJldC5wb3NpdGlvbi1ib3R0b217Ym9yZGVyLWxlZnQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgcmdiYSgwLDAsMCwuNzUpfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudCAudG9vbHRpcC1sYWJlbHtkaXNwbGF5OmJsb2NrO2xpbmUtaGVpZ2h0OjFlbTtwYWRkaW5nOjhweCA1cHggNXB4IDVweDtmb250LXNpemU6MWVtfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudCAudG9vbHRpcC12YWx7ZGlzcGxheTpibG9jaztmb250LXNpemU6MS4zZW07bGluZS1oZWlnaHQ6MWVtO3BhZGRpbmc6MCA1cHggOHB4IDVweH0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQgLnRvb2x0aXAtY2FyZXR7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo1MDAxO3dpZHRoOjA7aGVpZ2h0OjB9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnBvc2l0aW9uLXJpZ2h0e3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgxMHB4LDAsMCl9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnBvc2l0aW9uLWxlZnR7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKC0xMHB4LDAsMCl9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnBvc2l0aW9uLXRvcHt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwtMTBweCwwKX0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQucG9zaXRpb24tYm90dG9te3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDEwcHgsMCl9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LmFuaW1hdGV7b3BhY2l0eToxO3RyYW5zaXRpb246b3BhY2l0eSAuM3MsdHJhbnNmb3JtIC4zczt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDApO3BvaW50ZXItZXZlbnRzOmF1dG99LmFyZWEtdG9vbHRpcC1jb250YWluZXJ7cGFkZGluZzo1cHggMDtwb2ludGVyLWV2ZW50czpub25lfS50b29sdGlwLWl0ZW17dGV4dC1hbGlnbjpsZWZ0O2xpbmUtaGVpZ2h0OjEuMmVtO3BhZGRpbmc6NXB4IDB9LnRvb2x0aXAtaXRlbSAudG9vbHRpcC1pdGVtLWNvbG9ye2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDoxMnB4O3dpZHRoOjEycHg7bWFyZ2luLXJpZ2h0OjVweDtjb2xvcjojNWI2NDZiO2JvcmRlci1yYWRpdXM6M3B4fVwiXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfZCA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdCwgdHlwZW9mIChfZSA9IHR5cGVvZiBSZW5kZXJlcjIgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVuZGVyZXIyKSA9PT0gXCJmdW5jdGlvblwiID8gX2UgOiBPYmplY3RdKVxyXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFRvb2x0aXBDb250ZW50Q29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIFRvb2x0aXBTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRvb2x0aXBTZXJ2aWNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVG9vbHRpcFNlcnZpY2UoaW5qZWN0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluamVjdGlvblNlcnZpY2UpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaW5qZWN0aW9uU2VydmljZSA9IGluamVjdGlvblNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMudHlwZSA9IFRvb2x0aXBDb250ZW50Q29tcG9uZW50O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHZhciBfYTtcclxuICAgIFRvb2x0aXBTZXJ2aWNlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBJbmplY3Rpb25TZXJ2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIEluamVjdGlvblNlcnZpY2UpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXHJcbiAgICBdLCBUb29sdGlwU2VydmljZSk7XHJcbiAgICByZXR1cm4gVG9vbHRpcFNlcnZpY2U7XHJcbn0oSW5qZWN0aW9uUmVnaXN0ZXJ5KSk7XHJcblxyXG52YXIgVG9vbHRpcERpcmVjdGl2ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRvb2x0aXBEaXJlY3RpdmUodG9vbHRpcFNlcnZpY2UsIHZpZXdDb250YWluZXJSZWYsIHJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy50b29sdGlwU2VydmljZSA9IHRvb2x0aXBTZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcENzc0NsYXNzID0gJyc7XHJcbiAgICAgICAgdGhpcy50b29sdGlwVGl0bGUgPSAnJztcclxuICAgICAgICB0aGlzLnRvb2x0aXBBcHBlbmRUb0JvZHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFNwYWNpbmcgPSAxMDtcclxuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFNob3dDYXJldCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50b29sdGlwUGxhY2VtZW50ID0gUGxhY2VtZW50VHlwZXMudG9wO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcEFsaWdubWVudCA9IEFsaWdubWVudFR5cGVzLmNlbnRlcjtcclxuICAgICAgICB0aGlzLnRvb2x0aXBUeXBlID0gU3R5bGVUeXBlcy5wb3BvdmVyO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcENsb3NlT25DbGlja091dHNpZGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcENsb3NlT25Nb3VzZUxlYXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRvb2x0aXBIaWRlVGltZW91dCA9IDMwMDtcclxuICAgICAgICB0aGlzLnRvb2x0aXBTaG93VGltZW91dCA9IDEwMDtcclxuICAgICAgICB0aGlzLnRvb2x0aXBTaG93RXZlbnQgPSBTaG93VHlwZXMuYWxsO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcEltbWVkaWF0ZUV4aXQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNob3cgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5oaWRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImxpc3RlbnNGb3JGb2N1c1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvb2x0aXBTaG93RXZlbnQgPT09IFNob3dUeXBlcy5hbGwgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcFNob3dFdmVudCA9PT0gU2hvd1R5cGVzLmZvY3VzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImxpc3RlbnNGb3JIb3ZlclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvb2x0aXBTaG93RXZlbnQgPT09IFNob3dUeXBlcy5hbGwgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcFNob3dFdmVudCA9PT0gU2hvd1R5cGVzLm1vdXNlb3ZlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGlkZVRvb2x0aXAodHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUub25Gb2N1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0ZW5zRm9yRm9jdXMpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93VG9vbHRpcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZS5vbkJsdXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuc0ZvckZvY3VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZVRvb2x0aXAodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLm9uTW91c2VFbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0ZW5zRm9ySG92ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93VG9vbHRpcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZS5vbk1vdXNlTGVhdmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuc0ZvckhvdmVyICYmIHRoaXMudG9vbHRpcENsb3NlT25Nb3VzZUxlYXZlKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50RG9tID0gdGhpcy5jb21wb25lbnQuaW5zdGFuY2UuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5zID0gY29udGVudERvbS5jb250YWlucyh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhpZGVUb29sdGlwKHRoaXMudG9vbHRpcEltbWVkaWF0ZUV4aXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZS5vbk1vdXNlQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuc0ZvckhvdmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZVRvb2x0aXAodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLnNob3dUb29sdGlwID0gZnVuY3Rpb24gKGltbWVkaWF0ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50IHx8IHRoaXMudG9vbHRpcERpc2FibGVkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIHRpbWUgPSBpbW1lZGlhdGUgPyAwIDogdGhpcy50b29sdGlwU2hvd1RpbWVvdXQ7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XHJcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRvb2x0aXBTZXJ2aWNlLmRlc3Ryb3lBbGwoKTtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5jcmVhdGVCb3VuZE9wdGlvbnMoKTtcclxuICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50ID0gX3RoaXMudG9vbHRpcFNlcnZpY2UuY3JlYXRlKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAvLyBhZGQgYSB0aW55IHRpbWVvdXQgdG8gYXZvaWQgZXZlbnQgcmUtdHJpZ2dlcnNcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkSGlkZUxpc3RlbmVycyhfdGhpcy5jb21wb25lbnQuaW5zdGFuY2UuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMTApO1xyXG4gICAgICAgICAgICBfdGhpcy5zaG93LmVtaXQodHJ1ZSk7XHJcbiAgICAgICAgfSwgdGltZSk7XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUuYWRkSGlkZUxpc3RlbmVycyA9IGZ1bmN0aW9uICh0b29sdGlwKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBvbiBtb3VzZSBlbnRlciwgY2FuY2VsIHRoZSBoaWRlIHRyaWdnZXJlZCBieSB0aGUgbGVhdmVcclxuICAgICAgICB0aGlzLm1vdXNlRW50ZXJDb250ZW50RXZlbnQgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0b29sdGlwLCAnbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNvbnRlbnQgbW91c2UgbGVhdmUgbGlzdGVuZXJcclxuICAgICAgICBpZiAodGhpcy50b29sdGlwQ2xvc2VPbk1vdXNlTGVhdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZUxlYXZlQ29udGVudEV2ZW50ID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odG9vbHRpcCwgJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oaWRlVG9vbHRpcChfdGhpcy50b29sdGlwSW1tZWRpYXRlRXhpdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb250ZW50IGNsb3NlIG9uIGNsaWNrIG91dHNpZGVcclxuICAgICAgICBpZiAodGhpcy50b29sdGlwQ2xvc2VPbkNsaWNrT3V0c2lkZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tFdmVudCA9IHRoaXMucmVuZGVyZXIubGlzdGVuKGRvY3VtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQkJDEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250YWlucyA9IHRvb2x0aXAuY29udGFpbnMoZXZlbnQkJDEudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGFpbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGlkZVRvb2x0aXAoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLmhpZGVUb29sdGlwID0gZnVuY3Rpb24gKGltbWVkaWF0ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGltbWVkaWF0ZSA9PT0gdm9pZCAwKSB7IGltbWVkaWF0ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBkZXN0cm95Rm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBldmVudHNcclxuICAgICAgICAgICAgaWYgKF90aGlzLm1vdXNlTGVhdmVDb250ZW50RXZlbnQpXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5tb3VzZUxlYXZlQ29udGVudEV2ZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5tb3VzZUVudGVyQ29udGVudEV2ZW50KVxyXG4gICAgICAgICAgICAgICAgX3RoaXMubW91c2VFbnRlckNvbnRlbnRFdmVudCgpO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuZG9jdW1lbnRDbGlja0V2ZW50KVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZG9jdW1lbnRDbGlja0V2ZW50KCk7XHJcbiAgICAgICAgICAgIC8vIGVtaXQgZXZlbnRzXHJcbiAgICAgICAgICAgIF90aGlzLmhpZGUuZW1pdCh0cnVlKTtcclxuICAgICAgICAgICAgLy8gZGVzdHJveSBjb21wb25lbnRcclxuICAgICAgICAgICAgX3RoaXMudG9vbHRpcFNlcnZpY2UuZGVzdHJveShfdGhpcy5jb21wb25lbnQpO1xyXG4gICAgICAgICAgICBfdGhpcy5jb21wb25lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcclxuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlc3Ryb3lGbiwgdGhpcy50b29sdGlwSGlkZVRpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVzdHJveUZuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLmNyZWF0ZUJvdW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0aXRsZTogdGhpcy50b29sdGlwVGl0bGUsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLnRvb2x0aXBUZW1wbGF0ZSxcclxuICAgICAgICAgICAgaG9zdDogdGhpcy52aWV3Q29udGFpbmVyUmVmLmVsZW1lbnQsXHJcbiAgICAgICAgICAgIHBsYWNlbWVudDogdGhpcy50b29sdGlwUGxhY2VtZW50LFxyXG4gICAgICAgICAgICBhbGlnbm1lbnQ6IHRoaXMudG9vbHRpcEFsaWdubWVudCxcclxuICAgICAgICAgICAgdHlwZTogdGhpcy50b29sdGlwVHlwZSxcclxuICAgICAgICAgICAgc2hvd0NhcmV0OiB0aGlzLnRvb2x0aXBTaG93Q2FyZXQsXHJcbiAgICAgICAgICAgIGNzc0NsYXNzOiB0aGlzLnRvb2x0aXBDc3NDbGFzcyxcclxuICAgICAgICAgICAgc3BhY2luZzogdGhpcy50b29sdGlwU3BhY2luZyxcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcy50b29sdGlwQ29udGV4dFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcENzc0NsYXNzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwQXBwZW5kVG9Cb2R5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwU3BhY2luZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBTaG93Q2FyZXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgUGxhY2VtZW50VHlwZXMgIT09IFwidW5kZWZpbmVkXCIgJiYgUGxhY2VtZW50VHlwZXMpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBQbGFjZW1lbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgQWxpZ25tZW50VHlwZXMgIT09IFwidW5kZWZpbmVkXCIgJiYgQWxpZ25tZW50VHlwZXMpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBBbGlnbm1lbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgU3R5bGVUeXBlcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTdHlsZVR5cGVzKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBDbG9zZU9uQ2xpY2tPdXRzaWRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcENsb3NlT25Nb3VzZUxlYXZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwSGlkZVRpbWVvdXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBTaG93VGltZW91dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9kID0gdHlwZW9mIFNob3dUeXBlcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTaG93VHlwZXMpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBTaG93RXZlbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBDb250ZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcEltbWVkaWF0ZUV4aXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzaG93XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaGlkZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdmb2N1c2luJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdibHVyJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uTW91c2VFbnRlclwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScsIFsnJGV2ZW50LnRhcmdldCddKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uTW91c2VMZWF2ZVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignY2xpY2snKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uTW91c2VDbGlja1wiLCBudWxsKTtcclxuICAgIFRvb2x0aXBEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tuZ3gtdG9vbHRpcF0nIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfZSA9IHR5cGVvZiBUb29sdGlwU2VydmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUb29sdGlwU2VydmljZSkgPT09IFwiZnVuY3Rpb25cIiA/IF9lIDogT2JqZWN0LCB0eXBlb2YgKF9mID0gdHlwZW9mIFZpZXdDb250YWluZXJSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVmlld0NvbnRhaW5lclJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9mIDogT2JqZWN0LCB0eXBlb2YgKF9nID0gdHlwZW9mIFJlbmRlcmVyMiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZW5kZXJlcjIpID09PSBcImZ1bmN0aW9uXCIgPyBfZyA6IE9iamVjdF0pXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlKTtcclxuICAgIHJldHVybiBUb29sdGlwRGlyZWN0aXZlO1xyXG59KCkpO1xyXG5cclxudmFyIFRvb2x0aXBNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUb29sdGlwTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgVG9vbHRpcE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbVG9vbHRpcENvbnRlbnRDb21wb25lbnQsIFRvb2x0aXBEaXJlY3RpdmVdLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtJbmplY3Rpb25TZXJ2aWNlLCBUb29sdGlwU2VydmljZV0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtUb29sdGlwQ29udGVudENvbXBvbmVudCwgVG9vbHRpcERpcmVjdGl2ZV0sXHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxyXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtUb29sdGlwQ29udGVudENvbXBvbmVudF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgVG9vbHRpcE1vZHVsZSk7XHJcbiAgICByZXR1cm4gVG9vbHRpcE1vZHVsZTtcclxufSgpKTtcclxuXHJcbnZhciBDaGFydENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENoYXJ0Q29tcG9uZW50KHZjciwgdG9vbHRpcFNlcnZpY2UpIHtcclxuICAgICAgICB0aGlzLnZjciA9IHZjcjtcclxuICAgICAgICB0aGlzLnRvb2x0aXBTZXJ2aWNlID0gdG9vbHRpcFNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5zaG93TGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxlZ2VuZExhYmVsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRMYWJlbEFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kTGFiZWxEZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFNlcnZpY2UuaW5qZWN0aW9uU2VydmljZS5zZXRSb290Vmlld0NvbnRhaW5lcih0aGlzLnZjcik7XHJcbiAgICB9XHJcbiAgICBDaGFydENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGVnZW5kQ29sdW1ucyA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0xlZ2VuZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZFR5cGUgPSB0aGlzLmdldExlZ2VuZFR5cGUoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmxlZ2VuZE9wdGlvbnMgfHwgdGhpcy5sZWdlbmRPcHRpb25zLnBvc2l0aW9uID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWdlbmRUeXBlID09PSAnc2NhbGVMZWdlbmQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kQ29sdW1ucyA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWdlbmRDb2x1bW5zID0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2hhcnRDb2x1bW5zID0gMTIgLSBsZWdlbmRDb2x1bW5zO1xyXG4gICAgICAgIHRoaXMuY2hhcnRXaWR0aCA9IE1hdGguZmxvb3IoKHRoaXMudmlld1swXSAqIGNoYXJ0Q29sdW1ucyAvIDEyLjApKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZFdpZHRoID0gKCF0aGlzLmxlZ2VuZE9wdGlvbnMgfHwgdGhpcy5sZWdlbmRPcHRpb25zLnBvc2l0aW9uID09PSAncmlnaHQnKVxyXG4gICAgICAgICAgICA/IE1hdGguZmxvb3IoKHRoaXMudmlld1swXSAqIGxlZ2VuZENvbHVtbnMgLyAxMi4wKSlcclxuICAgICAgICAgICAgOiB0aGlzLmNoYXJ0V2lkdGg7XHJcbiAgICB9O1xyXG4gICAgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZFR5cGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVnZW5kT3B0aW9ucy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnc2NhbGVMZWdlbmQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdsZWdlbmQnO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInZpZXdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93TGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kT3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmREYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kTGFiZWxDbGlja1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZExhYmVsQWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRMYWJlbERlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIENoYXJ0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbVG9vbHRpcFNlcnZpY2VdLFxyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtY2hhcnQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdlxcbiAgICAgIGNsYXNzPVxcXCJuZ3gtY2hhcnRzLW91dGVyXFxcIlxcbiAgICAgIFtzdHlsZS53aWR0aC5weF09XFxcInZpZXdbMF1cXFwiXFxuICAgICAgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIlxcbiAgICAgIFtALmRpc2FibGVkXT1cXFwiIWFuaW1hdGlvbnNcXFwiPlxcbiAgICAgIDxzdmdcXG4gICAgICAgIGNsYXNzPVxcXCJuZ3gtY2hhcnRzXFxcIlxcbiAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJjaGFydFdpZHRoXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwidmlld1sxXVxcXCI+XFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgPC9zdmc+XFxuICAgICAgPG5neC1jaGFydHMtc2NhbGUtbGVnZW5kXFxuICAgICAgICAqbmdJZj1cXFwic2hvd0xlZ2VuZCAmJiBsZWdlbmRUeXBlID09PSAnc2NhbGVMZWdlbmQnXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcImNoYXJ0LWxlZ2VuZFxcXCJcXG4gICAgICAgIFtob3Jpem9udGFsXT1cXFwibGVnZW5kT3B0aW9ucyAmJiBsZWdlbmRPcHRpb25zLnBvc2l0aW9uID09PSAnYmVsb3cnXFxcIlxcbiAgICAgICAgW3ZhbHVlUmFuZ2VdPVxcXCJsZWdlbmRPcHRpb25zLmRvbWFpblxcXCJcXG4gICAgICAgIFtjb2xvcnNdPVxcXCJsZWdlbmRPcHRpb25zLmNvbG9yc1xcXCJcXG4gICAgICAgIFtoZWlnaHRdPVxcXCJ2aWV3WzFdXFxcIlxcbiAgICAgICAgW3dpZHRoXT1cXFwibGVnZW5kV2lkdGhcXFwiPlxcbiAgICAgIDwvbmd4LWNoYXJ0cy1zY2FsZS1sZWdlbmQ+XFxuICAgICAgPG5neC1jaGFydHMtbGVnZW5kXFxuICAgICAgICAqbmdJZj1cXFwic2hvd0xlZ2VuZCAmJiBsZWdlbmRUeXBlID09PSAnbGVnZW5kJ1xcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJjaGFydC1sZWdlbmRcXFwiXFxuICAgICAgICBbaG9yaXpvbnRhbF09XFxcImxlZ2VuZE9wdGlvbnMgJiYgbGVnZW5kT3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JlbG93J1xcXCJcXG4gICAgICAgIFtkYXRhXT1cXFwibGVnZW5kT3B0aW9ucy5kb21haW5cXFwiXFxuICAgICAgICBbdGl0bGVdPVxcXCJsZWdlbmRPcHRpb25zLnRpdGxlXFxcIlxcbiAgICAgICAgW2NvbG9yc109XFxcImxlZ2VuZE9wdGlvbnMuY29sb3JzXFxcIlxcbiAgICAgICAgW2hlaWdodF09XFxcInZpZXdbMV1cXFwiXFxuICAgICAgICBbd2lkdGhdPVxcXCJsZWdlbmRXaWR0aFxcXCJcXG4gICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgIChsYWJlbENsaWNrKT1cXFwibGVnZW5kTGFiZWxDbGljay5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICAobGFiZWxBY3RpdmF0ZSk9XFxcImxlZ2VuZExhYmVsQWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgKGxhYmVsRGVhY3RpdmF0ZSk9XFxcImxlZ2VuZExhYmVsRGVhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiPlxcbiAgICAgIDwvbmd4LWNoYXJ0cy1sZWdlbmQ+XFxuICAgIDwvZGl2PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHsgb3BhY2l0eTogMCB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgnNTAwbXMgMTAwbXMnLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2QgPSB0eXBlb2YgVmlld0NvbnRhaW5lclJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBWaWV3Q29udGFpbmVyUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2QgOiBPYmplY3QsIHR5cGVvZiAoX2UgPSB0eXBlb2YgVG9vbHRpcFNlcnZpY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgVG9vbHRpcFNlcnZpY2UpID09PSBcImZ1bmN0aW9uXCIgPyBfZSA6IE9iamVjdF0pXHJcbiAgICBdLCBDaGFydENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQ2hhcnRDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG4vKipcclxuICogRm9ybWF0cyBhIGxhYmVsIGdpdmVuIGEgZGF0ZSwgbnVtYmVyIG9yIHN0cmluZy5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0geyp9IGxhYmVsXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JtYXRMYWJlbChsYWJlbCkge1xyXG4gICAgaWYgKGxhYmVsIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgIGxhYmVsID0gbGFiZWwudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsYWJlbCA9IGxhYmVsLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGFiZWw7XHJcbn1cclxuXHJcbnZhciBMZWdlbmRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMZWdlbmRDb21wb25lbnQoY2QpIHtcclxuICAgICAgICB0aGlzLmNkID0gY2Q7XHJcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sYWJlbENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMubGFiZWxBY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmxhYmVsRGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZEVudHJpZXMgPSBbXTtcclxuICAgIH1cclxuICAgIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZEVudHJpZXMgPSB0aGlzLmdldExlZ2VuZEVudHJpZXMoKTtcclxuICAgIH07XHJcbiAgICBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZEVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwpO1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gaXRlbXMuZmluZEluZGV4KGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCA9PT0gZm9ybWF0dGVkTGFiZWw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZExhYmVsOiBmb3JtYXR0ZWRMYWJlbCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpc18xLmNvbG9ycy5nZXRDb2xvcihsYWJlbClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5kYXRhOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIF9sb29wXzEobGFiZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICB9O1xyXG4gICAgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkubGFiZWwgPT09IGQubmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHRoaXMubGFiZWxBY3RpdmF0ZS5lbWl0KGl0ZW0pO1xyXG4gICAgfTtcclxuICAgIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5sYWJlbERlYWN0aXZhdGUuZW1pdChpdGVtKTtcclxuICAgIH07XHJcbiAgICBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5sYWJlbDtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImhvcml6b250YWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxDbGlja1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsRGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgTGVnZW5kQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWxlZ2VuZCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8ZGl2IFtzdHlsZS53aWR0aC5weF09XFxcIndpZHRoXFxcIj5cXG4gICAgICA8aGVhZGVyIGNsYXNzPVxcXCJsZWdlbmQtdGl0bGVcXFwiICpuZ0lmPVxcXCJ0aXRsZT8ubGVuZ3RoID4gMFxcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGVnZW5kLXRpdGxlLXRleHRcXFwiPnt7dGl0bGV9fTwvc3Bhbj5cXG4gICAgICA8L2hlYWRlcj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJsZWdlbmQtd3JhcFxcXCI+XFxuICAgICAgICA8dWwgY2xhc3M9XFxcImxlZ2VuZC1sYWJlbHNcXFwiXFxuICAgICAgICAgICAgW2NsYXNzLmhvcml6b250YWwtbGVnZW5kXT1cXFwiaG9yaXpvbnRhbFxcXCJcXG4gICAgICAgICAgW3N0eWxlLm1heC1oZWlnaHQucHhdPVxcXCJoZWlnaHQgLSA0NVxcXCI+XFxuICAgICAgICAgIDxsaVxcbiAgICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGVudHJ5IG9mIGxlZ2VuZEVudHJpZXM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcImxlZ2VuZC1sYWJlbFxcXCI+XFxuICAgICAgICAgICAgPG5neC1jaGFydHMtbGVnZW5kLWVudHJ5XFxuICAgICAgICAgICAgICBbbGFiZWxdPVxcXCJlbnRyeS5sYWJlbFxcXCJcXG4gICAgICAgICAgICAgIFtmb3JtYXR0ZWRMYWJlbF09XFxcImVudHJ5LmZvcm1hdHRlZExhYmVsXFxcIlxcbiAgICAgICAgICAgICAgW2NvbG9yXT1cXFwiZW50cnkuY29sb3JcXFwiXFxuICAgICAgICAgICAgICBbaXNBY3RpdmVdPVxcXCJpc0FjdGl2ZShlbnRyeSlcXFwiXFxuICAgICAgICAgICAgICAoc2VsZWN0KT1cXFwibGFiZWxDbGljay5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJkZWFjdGl2YXRlKCRldmVudClcXFwiPlxcbiAgICAgICAgICAgIDwvbmd4LWNoYXJ0cy1sZWdlbmQtZW50cnk+XFxuICAgICAgICAgIDwvbGk+XFxuICAgICAgICA8L3VsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIFwiLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5jaGFydC1sZWdlbmR7ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzowO3dpZHRoOmF1dG8haW1wb3J0YW50fS5jaGFydC1sZWdlbmQgLmxlZ2VuZC10aXRsZXt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVuO21hcmdpbi1sZWZ0OjEwcHg7bWFyZ2luLWJvdHRvbTo1cHg7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6NzAwfS5jaGFydC1sZWdlbmQgbGksLmNoYXJ0LWxlZ2VuZCB1bHtwYWRkaW5nOjA7bWFyZ2luOjA7bGlzdC1zdHlsZTpub25lfS5jaGFydC1sZWdlbmQgLmhvcml6b250YWwtbGVnZW5kIGxpe2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5jaGFydC1sZWdlbmQgLmxlZ2VuZC13cmFwe3dpZHRoOmNhbGMoMTAwJSAtIDEwcHgpfS5jaGFydC1sZWdlbmQgLmxlZ2VuZC1sYWJlbHN7bGluZS1oZWlnaHQ6ODUlO2xpc3Qtc3R5bGU6bm9uZTt0ZXh0LWFsaWduOmxlZnQ7ZmxvYXQ6bGVmdDt3aWR0aDoxMDAlO2JvcmRlci1yYWRpdXM6M3B4O292ZXJmbG93LXk6YXV0bztvdmVyZmxvdy14OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXA7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4wNSl9LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLWxhYmVse2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZTo5MCU7bWFyZ2luOjhweDtjb2xvcjojYWZiN2M4fS5jaGFydC1sZWdlbmQgLmxlZ2VuZC1sYWJlbDpob3Zlcntjb2xvcjojMDAwOy13ZWJraXQtdHJhbnNpdGlvbjouMnM7LW1vei10cmFuc2l0aW9uOi4yczt0cmFuc2l0aW9uOi4yc30uY2hhcnQtbGVnZW5kIC5sZWdlbmQtbGFiZWwgLmFjdGl2ZSAubGVnZW5kLWxhYmVsLXRleHR7Y29sb3I6IzAwMH0uY2hhcnQtbGVnZW5kIC5sZWdlbmQtbGFiZWwtY29sb3J7ZGlzcGxheTppbmxpbmUtYmxvY2s7aGVpZ2h0OjE1cHg7d2lkdGg6MTVweDttYXJnaW4tcmlnaHQ6NXB4O2NvbG9yOiM1YjY0NmI7Ym9yZGVyLXJhZGl1czozcHh9LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLWxhYmVsLXRleHR7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO2xpbmUtaGVpZ2h0OjE1cHg7Zm9udC1zaXplOjEycHg7d2lkdGg6Y2FsYygxMDAlIC0gMjBweCk7dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6aGlkZGVufS5jaGFydC1sZWdlbmQgLmxlZ2VuZC10aXRsZS10ZXh0e3ZlcnRpY2FsLWFsaWduOmJvdHRvbTtkaXNwbGF5OmlubGluZS1ibG9jaztsaW5lLWhlaWdodDoxNnB4O292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXA7dGV4dC1vdmVyZmxvdzplbGxpcHNpc31cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9kID0gdHlwZW9mIENoYW5nZURldGVjdG9yUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIENoYW5nZURldGVjdG9yUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2QgOiBPYmplY3RdKVxyXG4gICAgXSwgTGVnZW5kQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBMZWdlbmRDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgU2NhbGVMZWdlbmRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTY2FsZUxlZ2VuZENvbXBvbmVudChzYW5pdGl6ZXIpIHtcclxuICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcclxuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIFNjYWxlTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIGdyYWRpZW50VmFsdWVzID0gdGhpcy5ncmFkaWVudFN0cmluZyh0aGlzLmNvbG9ycy5yYW5nZSgpLCB0aGlzLmNvbG9ycy5kb21haW4oKSk7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9ICh0aGlzLmhvcml6b250YWwpID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0U3R5bGUoXCJsaW5lYXItZ3JhZGllbnQodG8gXCIgKyBkaXJlY3Rpb24gKyBcIiwgXCIgKyBncmFkaWVudFZhbHVlcyArIFwiKVwiKTtcclxuICAgIH07XHJcbiAgICBTY2FsZUxlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUuZ3JhZGllbnRTdHJpbmcgPSBmdW5jdGlvbiAoY29sb3JzLCBzcGxpdHMpIHtcclxuICAgICAgICBzcGxpdHMucHVzaCgxKTtcclxuICAgICAgICB2YXIgcGFpcnMgPSBbXTtcclxuICAgICAgICBjb2xvcnMucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHtcclxuICAgICAgICAgICAgcGFpcnMucHVzaChjICsgXCIgXCIgKyBNYXRoLnJvdW5kKHNwbGl0c1tpXSAqIDEwMCkgKyBcIiVcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHBhaXJzLmpvaW4oJywgJyk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2NhbGVMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlUmFuZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNjYWxlTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNjYWxlTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNjYWxlTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2NhbGVMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImhvcml6b250YWxcIiwgdm9pZCAwKTtcclxuICAgIFNjYWxlTGVnZW5kQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLXNjYWxlLWxlZ2VuZCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8ZGl2XFxuICAgICAgY2xhc3M9XFxcInNjYWxlLWxlZ2VuZFxcXCJcXG4gICAgICBbY2xhc3MuaG9yaXpvbnRhbC1sZWdlbmRdPVxcXCJob3Jpem9udGFsXFxcIlxcbiAgICAgIFtzdHlsZS5oZWlnaHQucHhdPVxcXCJob3Jpem9udGFsID8gdW5kZWZpbmVkIDogaGVpZ2h0XFxcIlxcbiAgICAgIFtzdHlsZS53aWR0aC5weF09XFxcIndpZHRoXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJzY2FsZS1sZWdlbmQtbGFiZWxcXFwiPlxcbiAgICAgICAgPHNwYW4+e3sgdmFsdWVSYW5nZVsxXS50b0xvY2FsZVN0cmluZygpIH19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJzY2FsZS1sZWdlbmQtd3JhcFxcXCJcXG4gICAgICAgIFtzdHlsZS5iYWNrZ3JvdW5kXT1cXFwiZ3JhZGllbnRcXFwiPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInNjYWxlLWxlZ2VuZC1sYWJlbFxcXCI+XFxuICAgICAgICA8c3Bhbj57eyB2YWx1ZVJhbmdlWzBdLnRvTG9jYWxlU3RyaW5nKCkgfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLmNoYXJ0LWxlZ2VuZHtkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjA7d2lkdGg6YXV0byFpbXBvcnRhbnR9LmNoYXJ0LWxlZ2VuZCAuc2NhbGUtbGVnZW5ke3RleHQtYWxpZ246Y2VudGVyO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LmNoYXJ0LWxlZ2VuZCAuc2NhbGUtbGVnZW5kLXdyYXB7ZGlzcGxheTppbmxpbmUtYmxvY2s7ZmxleDoxO3dpZHRoOjMwcHg7Ym9yZGVyLXJhZGl1czo1cHg7bWFyZ2luOjAgYXV0b30uY2hhcnQtbGVnZW5kIC5zY2FsZS1sZWdlbmQtbGFiZWx7Zm9udC1zaXplOjEycHh9LmNoYXJ0LWxlZ2VuZCAuaG9yaXpvbnRhbC1sZWdlbmQuc2NhbGUtbGVnZW5ke2ZsZXgtZGlyZWN0aW9uOnJvd30uY2hhcnQtbGVnZW5kIC5ob3Jpem9udGFsLWxlZ2VuZCAuc2NhbGUtbGVnZW5kLXdyYXB7d2lkdGg6YXV0bztoZWlnaHQ6MzBweDttYXJnaW46MCAxNnB4fVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgRG9tU2FuaXRpemVyICE9PSBcInVuZGVmaW5lZFwiICYmIERvbVNhbml0aXplcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcclxuICAgIF0sIFNjYWxlTGVnZW5kQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBTY2FsZUxlZ2VuZENvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBMZWdlbmRFbnRyeUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExlZ2VuZEVudHJ5Q29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLnRvZ2dsZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbW1lZExhYmVsXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkTGFiZWwgfHwgJyhlbXB0eSknO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLm9uTW91c2VFbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyBuYW1lOiB0aGlzLmxhYmVsIH0pO1xyXG4gICAgfTtcclxuICAgIExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZS5vbk1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyBuYW1lOiB0aGlzLmxhYmVsIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0dGVkTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNBY3RpdmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9kID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdClcclxuICAgIF0sIExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b2dnbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLCBcIm9uTW91c2VFbnRlclwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLCBcIm9uTW91c2VMZWF2ZVwiLCBudWxsKTtcclxuICAgIExlZ2VuZEVudHJ5Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWxlZ2VuZC1lbnRyeScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3BhbiBcXG4gICAgICBbdGl0bGVdPVxcXCJmb3JtYXR0ZWRMYWJlbFxcXCJcXG4gICAgICB0YWJpbmRleD1cXFwiLTFcXFwiXFxuICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlXFxcIlxcbiAgICAgIChjbGljayk9XFxcInNlbGVjdC5lbWl0KGZvcm1hdHRlZExhYmVsKVxcXCI+XFxuICAgICAgPHNwYW5cXG4gICAgICAgIGNsYXNzPVxcXCJsZWdlbmQtbGFiZWwtY29sb3JcXFwiXFxuICAgICAgICBbc3R5bGUuYmFja2dyb3VuZC1jb2xvcl09XFxcImNvbG9yXFxcIlxcbiAgICAgICAgKGNsaWNrKT1cXFwidG9nZ2xlLmVtaXQoZm9ybWF0dGVkTGFiZWwpXFxcIj5cXG4gICAgICA8L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImxlZ2VuZC1sYWJlbC10ZXh0XFxcIj5cXG4gICAgICAgIHt7dHJpbW1lZExhYmVsfX1cXG4gICAgICA8L3NwYW4+XFxuICAgIDwvc3Bhbj5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTGVnZW5kRW50cnlDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG5mdW5jdGlvbiB0cmltTGFiZWwocywgbWF4JCQxKSB7XHJcbiAgICBpZiAobWF4JCQxID09PSB2b2lkIDApIHsgbWF4JCQxID0gMTY7IH1cclxuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzICsgJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcyA9IHMudHJpbSgpO1xyXG4gICAgaWYgKHMubGVuZ3RoIDw9IG1heCQkMSkge1xyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHMuc2xpY2UoMCwgbWF4JCQxKSArIFwiLi4uXCI7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBBZHZhbmNlZExlZ2VuZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMubGFiZWwgPSAnVG90YWwnO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRJdGVtcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubGFiZWxGb3JtYXR0aW5nID0gZnVuY3Rpb24gKGxhYmVsKSB7IHJldHVybiBsYWJlbDsgfTtcclxuICAgICAgICB0aGlzLnBlcmNlbnRhZ2VGb3JtYXR0aW5nID0gZnVuY3Rpb24gKHBlcmNlbnRhZ2UpIHsgcmV0dXJuIHBlcmNlbnRhZ2U7IH07XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWVGb3JtYXR0aW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS50b0xvY2FsZVN0cmluZygpOyB9O1xyXG4gICAgfVxyXG4gICAgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUb3RhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIHN1bSArIGQ7IH0sIDApO1xyXG4gICAgfTtcclxuICAgIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50b3RhbCA9IHRoaXMuZ2V0VG90YWwoKTtcclxuICAgICAgICB0aGlzLnJvdW5kZWRUb3RhbCA9IHRoaXMudG90YWw7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRJdGVtcyA9IHRoaXMuZ2V0TGVnZW5kSXRlbXMoKTtcclxuICAgIH07XHJcbiAgICBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kSXRlbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBmb3JtYXRMYWJlbChkLm5hbWUpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkLnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IobGFiZWwpO1xyXG4gICAgICAgICAgICB2YXIgcGVyY2VudGFnZSA9IF90aGlzLnRvdGFsID4gMCA/ICh2YWx1ZSAvIF90aGlzLnRvdGFsKSAqIDEwMCA6IDA7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRMYWJlbCA9IHR5cGVvZiBfdGhpcy5sYWJlbEZvcm1hdHRpbmcgPT09ICdmdW5jdGlvbicgPyBfdGhpcy5sYWJlbEZvcm1hdHRpbmcobGFiZWwpIDogbGFiZWw7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBfdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogZCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBmb3JtYXR0ZWRMYWJlbCxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlMYWJlbDogdHJpbUxhYmVsKGZvcm1hdHRlZExhYmVsLCAyMCksXHJcbiAgICAgICAgICAgICAgICBvcmlnaWFsTGFiZWw6IGQubmFtZSxcclxuICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2U6IF90aGlzLnBlcmNlbnRhZ2VGb3JtYXR0aW5nID8gX3RoaXMucGVyY2VudGFnZUZvcm1hdHRpbmcocGVyY2VudGFnZSkgOiBwZXJjZW50YWdlLnRvTG9jYWxlU3RyaW5nKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0uZm9ybWF0dGVkTGFiZWw7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcInBlcmNlbnRhZ2VGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBBZHZhbmNlZExlZ2VuZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1hZHZhbmNlZC1sZWdlbmQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdiBjbGFzcz1cXFwiYWR2YW5jZWQtcGllLWxlZ2VuZFxcXCIgW3N0eWxlLndpZHRoLnB4XT1cXFwid2lkdGhcXFwiPlxcbiAgICAgIDxkaXZcXG4gICAgICAgICpuZ0lmPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcInRvdGFsLXZhbHVlXFxcIlxcbiAgICAgICAgbmd4LWNoYXJ0cy1jb3VudC11cFxcbiAgICAgICAgW2NvdW50VG9dPVxcXCJyb3VuZGVkVG90YWxcXFwiXFxuICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgID48L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJ0b3RhbC12YWx1ZVxcXCIgKm5nSWY9XFxcIiFhbmltYXRpb25zXFxcIj5cXG4gICAgICAgIHt7IHZhbHVlRm9ybWF0dGluZyA/IHZhbHVlRm9ybWF0dGluZyhyb3VuZGVkVG90YWwpIDogZGVmYXVsdFZhbHVlRm9ybWF0dGluZyhyb3VuZGVkVG90YWwpIH19XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwidG90YWwtbGFiZWxcXFwiPlxcbiAgICAgICAge3sgbGFiZWwgfX1cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJsZWdlbmQtaXRlbXMtY29udGFpbmVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImxlZ2VuZC1pdGVtc1xcXCI+XFxuICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAqbmdGb3I9XFxcImxldCBsZWdlbmRJdGVtIG9mIGxlZ2VuZEl0ZW1zOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgICAgICAgIHRhYmluZGV4PVxcXCItMVxcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwibGVnZW5kLWl0ZW1cXFwiXFxuICAgICAgICAgICAgKG1vdXNlZW50ZXIpPVxcXCJhY3RpdmF0ZS5lbWl0KGxlZ2VuZEl0ZW0uZGF0YSlcXFwiXFxuICAgICAgICAgICAgKG1vdXNlbGVhdmUpPVxcXCJkZWFjdGl2YXRlLmVtaXQobGVnZW5kSXRlbS5kYXRhKVxcXCJcXG4gICAgICAgICAgICAoY2xpY2spPVxcXCJzZWxlY3QuZW1pdChsZWdlbmRJdGVtLmRhdGEpXFxcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbS1jb2xvclxcXCIgW3N0eWxlLmJvcmRlci1sZWZ0LWNvbG9yXT1cXFwibGVnZW5kSXRlbS5jb2xvclxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgKm5nSWY9XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgICBjbGFzcz1cXFwiaXRlbS12YWx1ZVxcXCJcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtY291bnQtdXBcXG4gICAgICAgICAgICAgIFtjb3VudFRvXT1cXFwibGVnZW5kSXRlbS5fdmFsdWVcXFwiXFxuICAgICAgICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICAgID48L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCIhYW5pbWF0aW9uc1xcXCIgY2xhc3M9XFxcIml0ZW0tdmFsdWVcXFwiPlxcbiAgICAgICAgICAgICAge3sgdmFsdWVGb3JtYXR0aW5nID8gdmFsdWVGb3JtYXR0aW5nKGxlZ2VuZEl0ZW0udmFsdWUpIDogZGVmYXVsdFZhbHVlRm9ybWF0dGluZyhsZWdlbmRJdGVtLnZhbHVlKSB9fVxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0tbGFiZWxcXFwiPnt7IGxlZ2VuZEl0ZW0uZGlzcGxheUxhYmVsIH19PC9kaXY+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgKm5nSWY9XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgICBjbGFzcz1cXFwiaXRlbS1wZXJjZW50XFxcIlxcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1jb3VudC11cFxcbiAgICAgICAgICAgICAgW2NvdW50VG9dPVxcXCJsZWdlbmRJdGVtLnBlcmNlbnRhZ2VcXFwiXFxuICAgICAgICAgICAgICBbY291bnRTdWZmaXhdPVxcXCInJSdcXFwiXFxuICAgICAgICAgICAgPjwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XFxcIiFhbmltYXRpb25zXFxcIiBjbGFzcz1cXFwiaXRlbS1wZXJjZW50XFxcIj57eyBsZWdlbmRJdGVtLnBlcmNlbnRhZ2UudG9Mb2NhbGVTdHJpbmcoKSB9fSU8L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIuYWR2YW5jZWQtcGllLWxlZ2VuZHtmbG9hdDpsZWZ0O3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgwLC01MCUpfS5hZHZhbmNlZC1waWUtbGVnZW5kIC50b3RhbC12YWx1ZXtmb250LXNpemU6MzZweH0uYWR2YW5jZWQtcGllLWxlZ2VuZCAudG90YWwtbGFiZWx7Zm9udC1zaXplOjI0cHg7bWFyZ2luLWJvdHRvbToxOXB4fS5hZHZhbmNlZC1waWUtbGVnZW5kIC5sZWdlbmQtaXRlbXMtY29udGFpbmVye3dpZHRoOjEwMCV9LmFkdmFuY2VkLXBpZS1sZWdlbmQgLmxlZ2VuZC1pdGVtcy1jb250YWluZXIgLmxlZ2VuZC1pdGVtc3t3aGl0ZS1zcGFjZTpub3dyYXA7b3ZlcmZsb3c6YXV0b30uYWR2YW5jZWQtcGllLWxlZ2VuZCAubGVnZW5kLWl0ZW1zLWNvbnRhaW5lciAubGVnZW5kLWl0ZW1zIC5sZWdlbmQtaXRlbXttYXJnaW4tcmlnaHQ6MjBweDtkaXNwbGF5OmlubGluZS1ibG9jaztjdXJzb3I6cG9pbnRlcn0uYWR2YW5jZWQtcGllLWxlZ2VuZCAubGVnZW5kLWl0ZW1zLWNvbnRhaW5lciAubGVnZW5kLWl0ZW1zIC5sZWdlbmQtaXRlbTpmb2N1c3tvdXRsaW5lOjB9LmFkdmFuY2VkLXBpZS1sZWdlbmQgLmxlZ2VuZC1pdGVtcy1jb250YWluZXIgLmxlZ2VuZC1pdGVtcyAubGVnZW5kLWl0ZW06aG92ZXJ7Y29sb3I6IzAwMDstd2Via2l0LXRyYW5zaXRpb246LjJzOy1tb3otdHJhbnNpdGlvbjouMnM7dHJhbnNpdGlvbjouMnN9LmFkdmFuY2VkLXBpZS1sZWdlbmQgLmxlZ2VuZC1pdGVtcy1jb250YWluZXIgLmxlZ2VuZC1pdGVtcyAubGVnZW5kLWl0ZW0gLml0ZW0tdmFsdWV7Zm9udC1zaXplOjI0cHg7bWFyZ2luLXRvcDotNnB4O21hcmdpbi1sZWZ0OjExcHh9LmFkdmFuY2VkLXBpZS1sZWdlbmQgLmxlZ2VuZC1pdGVtcy1jb250YWluZXIgLmxlZ2VuZC1pdGVtcyAubGVnZW5kLWl0ZW0gLml0ZW0tbGFiZWx7Zm9udC1zaXplOjE0cHg7b3BhY2l0eTouNzttYXJnaW4tbGVmdDoxMXB4O21hcmdpbi10b3A6LTZweH0uYWR2YW5jZWQtcGllLWxlZ2VuZCAubGVnZW5kLWl0ZW1zLWNvbnRhaW5lciAubGVnZW5kLWl0ZW1zIC5sZWdlbmQtaXRlbSAuaXRlbS1wZXJjZW50e2ZvbnQtc2l6ZToyNHB4O29wYWNpdHk6Ljc7bWFyZ2luLWxlZnQ6MTFweH0uYWR2YW5jZWQtcGllLWxlZ2VuZCAubGVnZW5kLWl0ZW1zLWNvbnRhaW5lciAubGVnZW5kLWl0ZW1zIC5sZWdlbmQtaXRlbSAuaXRlbS1jb2xvcntib3JkZXItbGVmdDo0cHggc29saWQ7d2lkdGg6NHB4O2hlaWdodDo0MnB4O2Zsb2F0OmxlZnQ7bWFyZ2luLXJpZ2h0OjdweH1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBBZHZhbmNlZExlZ2VuZENvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBjYWNoZSA9IHt9O1xyXG4vKipcclxuICogR2VuZXJhdGVzIGEgc2hvcnQgaWQuXHJcbiAqXHJcbiAqIERlc2NyaXB0aW9uOlxyXG4gKiAgIEEgNC1jaGFyYWN0ZXIgYWxwaGFudW1lcmljIHNlcXVlbmNlICgzNjQgPSAxLjYgbWlsbGlvbilcclxuICogICBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIEphdmFTY3JpcHQgc3BlY2lmaWMgbW9kZWxzLlxyXG4gKiAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjI0ODY2Ni9ob3ctdG8tZ2VuZXJhdGUtc2hvcnQtdWlkLWxpa2UtYXg0ajl6LWluLWpzXHJcbiAqXHJcbiAqICAgRXhhbXBsZTogYGViZ2ZgXHJcbiAqL1xyXG5mdW5jdGlvbiBpZCgpIHtcclxuICAgIHZhciBuZXdJZCA9ICgnMDAwMCcgKyAoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDM2LCA0KSA8PCAwKS50b1N0cmluZygzNikpLnNsaWNlKC00KTtcclxuICAgIC8vIGFwcGVuZCBhICdhJyBiZWNhdXNlIG5lbyBnZXRzIG1hZFxyXG4gICAgbmV3SWQgPSBcImFcIiArIG5ld0lkO1xyXG4gICAgLy8gZW5zdXJlIG5vdCBhbHJlYWR5IHVzZWRcclxuICAgIGlmICghY2FjaGVbbmV3SWRdKSB7XHJcbiAgICAgICAgY2FjaGVbbmV3SWRdID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gbmV3SWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaWQoKTtcclxufVxyXG5cclxudmFyIGNvbG9yU2V0cyA9IFtcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAndml2aWQnLFxyXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXHJcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyM2NDdjOGEnLCAnIzNmNTFiNScsICcjMjE5NmYzJywgJyMwMGI4NjInLCAnI2FmZGYwYScsICcjYTdiNjFhJywgJyNmM2U1NjInLCAnI2ZmOTgwMCcsICcjZmY1NzIyJywgJyNmZjQ1MTQnXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnbmF0dXJhbCcsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxyXG4gICAgICAgIGRvbWFpbjogW1xyXG4gICAgICAgICAgICAnI2JmOWQ3NicsICcjZTk5NDUwJywgJyNkODlmNTknLCAnI2YyZGZhNycsICcjYTVkN2M2JywgJyM3Nzk0YjEnLCAnI2FmYWZhZicsICcjNzA3MTYwJywgJyNiYTkzODMnLCAnI2Q5ZDVjMydcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdjb29sJyxcclxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdyb3VwOiAnT3JkaW5hbCcsXHJcbiAgICAgICAgZG9tYWluOiBbXHJcbiAgICAgICAgICAgICcjYTgzODVkJywgJyM3YWEzZTUnLCAnI2EyN2VhOCcsICcjYWFlM2Y1JywgJyNhZGNkZWQnLCAnI2E5NTk2MycsICcjODc5NmMwJywgJyM3ZWQzZWQnLCAnIzUwYWJjYycsICcjYWQ2ODg2J1xyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2ZpcmUnLFxyXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXHJcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyNmZjNkMDAnLCAnI2JmMzYwYycsICcjZmY4ZjAwJywgJyNmZjZmMDAnLCAnI2ZmNTcyMicsICcjZTY1MTAwJywgJyNmZmNhMjgnLCAnI2ZmYWIwMCdcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdzb2xhcicsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICBncm91cDogJ0NvbnRpbnVvdXMnLFxyXG4gICAgICAgIGRvbWFpbjogW1xyXG4gICAgICAgICAgICAnI2ZmZjhlMScsICcjZmZlY2IzJywgJyNmZmUwODInLCAnI2ZmZDU0ZicsICcjZmZjYTI4JywgJyNmZmMxMDcnLCAnI2ZmYjMwMCcsICcjZmZhMDAwJywgJyNmZjhmMDAnLCAnI2ZmNmYwMCdcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdhaXInLFxyXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXHJcbiAgICAgICAgZ3JvdXA6ICdDb250aW51b3VzJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyNlMWY1ZmUnLCAnI2IzZTVmYycsICcjODFkNGZhJywgJyM0ZmMzZjcnLCAnIzI5YjZmNicsICcjMDNhOWY0JywgJyMwMzliZTUnLCAnIzAyODhkMScsICcjMDI3N2JkJywgJyMwMTU3OWInXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnYXF1YScsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICBncm91cDogJ0NvbnRpbnVvdXMnLFxyXG4gICAgICAgIGRvbWFpbjogW1xyXG4gICAgICAgICAgICAnI2UwZjdmYScsICcjYjJlYmYyJywgJyM4MGRlZWEnLCAnIzRkZDBlMScsICcjMjZjNmRhJywgJyMwMGJjZDQnLCAnIzAwYWNjMScsICcjMDA5N2E3JywgJyMwMDgzOGYnLCAnIzAwNjA2NCdcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdmbGFtZScsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyNBMTBBMjgnLCAnI0QzMzQyRCcsICcjRUY2RDQ5JywgJyNGQUFENjcnLCAnI0ZEREU5MCcsICcjREJFRDkxJywgJyNBOUQ3NzAnLCAnIzZDQkE2NycsICcjMkM5NjUzJywgJyMxNDY3MzgnXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnb2NlYW4nLFxyXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxyXG4gICAgICAgIGdyb3VwOiAnT3JkaW5hbCcsXHJcbiAgICAgICAgZG9tYWluOiBbXHJcbiAgICAgICAgICAgICcjMUQ2OEZCJywgJyMzM0MwRkMnLCAnIzRBRkZGRScsICcjQUZGRkZGJywgJyNGRkZDNjMnLCAnI0ZEQkQyRCcsICcjRkM4QTI1JywgJyNGQTRGMUUnLCAnI0ZBMTQxQicsICcjQkEzOEQxJ1xyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2ZvcmVzdCcsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyM1NUMyMkQnLCAnI0MxRjMzRCcsICcjM0NDMDk5JywgJyNBRkZGRkYnLCAnIzhDRkM5RCcsICcjNzZDRkZBJywgJyNCQTYwRkInLCAnI0VFNjQ5MCcsICcjQzQyQTFDJywgJyNGQzlGMzInXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnaG9yaXpvbicsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyMyNTk3RkInLCAnIzY1RUJGRCcsICcjOTlGREQwJywgJyNGQ0VFNEInLCAnI0ZFRkNGQScsICcjRkRENkUzJywgJyNGQ0IxQTgnLCAnI0VGNkY3QicsICcjQ0I5NkU4JywgJyNFRkRFRTAnXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnbmVvbnMnLFxyXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxyXG4gICAgICAgIGdyb3VwOiAnT3JkaW5hbCcsXHJcbiAgICAgICAgZG9tYWluOiBbXHJcbiAgICAgICAgICAgICcjRkYzMzMzJywgJyNGRjMzRkYnLCAnI0NDMzNGRicsICcjMDAwMEZGJywgJyMzM0NDRkYnLCAnIzMzRkZGRicsICcjMzNGRjY2JywgJyNDQ0ZGMzMnLCAnI0ZGQ0MwMCcsICcjRkY2NjAwJ1xyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ3BpY25pYycsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyNGQUM1MUQnLCAnIzY2QkQ2RCcsICcjRkFBMDI2JywgJyMyOUJCOUMnLCAnI0U5NkI1NicsICcjNTVBQ0QyJywgJyNCNzMzMkYnLCAnIzJDODNDOScsICcjOTE2NkI4JywgJyM5MkU3RTgnXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnbmlnaHQnLFxyXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxyXG4gICAgICAgIGdyb3VwOiAnT3JkaW5hbCcsXHJcbiAgICAgICAgZG9tYWluOiBbXHJcbiAgICAgICAgICAgICcjMkIxQjVBJywgJyM1MDEzNTYnLCAnIzE4MzM1NicsICcjMjgyMDNGJywgJyMzOTFCM0MnLCAnIzFFMkIzQycsICcjMTIwNjM0JyxcclxuICAgICAgICAgICAgJyMyRDA0MzInLCAnIzA1MTkzMicsICcjNDUzMDgwJywgJyM3NTI2N0QnLCAnIzJDNTA3RCcsICcjNEIzODgwJywgJyM3NTJGN0QnLCAnIzM1NTQ3RCdcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICduaWdodExpZ2h0cycsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyM0ZTMxYTUnLCAnIzljMjVhNycsICcjMzA2NWFiJywgJyM1NzQ2OGInLCAnIzkwNDQ5NycsICcjNDY2NDhiJyxcclxuICAgICAgICAgICAgJyMzMjExOGQnLCAnI2EwMGZiMycsICcjMTA1MmEyJywgJyM2ZTUxYmQnLCAnI2I2M2NjMycsICcjNmM5N2NiJywgJyM4NjcxYzEnLCAnI2I0NTViZScsICcjNzQ5NmMzJ1xyXG4gICAgICAgIF1cclxuICAgIH1cclxuXTtcclxuXHJcbmZ1bmN0aW9uIHNvcnRMaW5lYXIoZGF0YSwgcHJvcGVydHksIGRpcmVjdGlvbikge1xyXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdm9pZCAwKSB7IGRpcmVjdGlvbiA9ICdhc2MnOyB9XHJcbiAgICByZXR1cm4gZGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2FzYycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFbcHJvcGVydHldIC0gYltwcm9wZXJ0eV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYltwcm9wZXJ0eV0gLSBhW3Byb3BlcnR5XTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzb3J0QnlEb21haW4oZGF0YSwgcHJvcGVydHksIGRpcmVjdGlvbiwgZG9tYWluKSB7XHJcbiAgICBpZiAoZGlyZWN0aW9uID09PSB2b2lkIDApIHsgZGlyZWN0aW9uID0gJ2FzYyc7IH1cclxuICAgIHJldHVybiBkYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgYVZhbCA9IGFbcHJvcGVydHldO1xyXG4gICAgICAgIHZhciBiVmFsID0gYltwcm9wZXJ0eV07XHJcbiAgICAgICAgdmFyIGFJZHggPSBkb21haW4uaW5kZXhPZihhVmFsKTtcclxuICAgICAgICB2YXIgYklkeCA9IGRvbWFpbi5pbmRleE9mKGJWYWwpO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdhc2MnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhSWR4IC0gYklkeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiSWR4IC0gYUlkeDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzb3J0QnlUaW1lKGRhdGEsIHByb3BlcnR5LCBkaXJlY3Rpb24pIHtcclxuICAgIGlmIChkaXJlY3Rpb24gPT09IHZvaWQgMCkgeyBkaXJlY3Rpb24gPSAnYXNjJzsgfVxyXG4gICAgcmV0dXJuIGRhdGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciBhRGF0ZSA9IGFbcHJvcGVydHldLmdldFRpbWUoKTtcclxuICAgICAgICB2YXIgYkRhdGUgPSBiW3Byb3BlcnR5XS5nZXRUaW1lKCk7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2FzYycpIHtcclxuICAgICAgICAgICAgaWYgKGFEYXRlID4gYkRhdGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgaWYgKGJEYXRlID4gYURhdGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGFEYXRlID4gYkRhdGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIGlmIChiRGF0ZSA+IGFEYXRlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQWNjZXB0cyBhIGNvbG9yIChzdHJpbmcpIGFuZCByZXR1cm5zIGEgaW52ZXJ0ZWQgaGV4IGNvbG9yIChzdHJpbmcpXHJcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTYwMDI5NS9hdXRvbWF0aWNhbGx5LWNoYW5nZS10ZXh0LWNvbG9yLXRvLWFzc3VyZS1yZWFkYWJpbGl0eVxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gaW52ZXJ0Q29sb3IodmFsdWUpIHtcclxuICAgIHZhciBjb2xvciA9IHJnYih2YWx1ZSk7XHJcbiAgICB2YXIgciA9IGNvbG9yLnIsIGcgPSBjb2xvci5nLCBiID0gY29sb3IuYiwgb3BhY2l0eSA9IGNvbG9yLm9wYWNpdHk7XHJcbiAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjb2xvci50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgdmFyIHlpcSA9ICgociAqIDI5OSkgKyAoZyAqIDU4NykgKyAoYiAqIDExNCkpIC8gMTAwMDtcclxuICAgIHZhciBkZXB0aCA9ICh5aXEgPj0gMTI4KSA/IC0uOCA6IC44O1xyXG4gICAgcmV0dXJuIHNoYWRlUkdCQ29sb3IoY29sb3IsIGRlcHRoKTtcclxufVxyXG4vKipcclxuICogR2l2ZW4gYSByZ2IsIGl0IHdpbGwgZGFya2VuL2xpZ2h0ZW5cclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NTYwMjQ4L3Byb2dyYW1tYXRpY2FsbHktbGlnaHRlbi1vci1kYXJrZW4tYS1oZXgtY29sb3Itb3ItcmdiLWFuZC1ibGVuZC1jb2xvcnNcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge2FueX0geyByLCBnLCBiIH1cclxuICogQHBhcmFtIHthbnl9IHBlcmNlbnRcclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIHNoYWRlUkdCQ29sb3IoX2EsIHBlcmNlbnQpIHtcclxuICAgIHZhciByID0gX2EuciwgZyA9IF9hLmcsIGIgPSBfYS5iO1xyXG4gICAgdmFyIHQgPSBwZXJjZW50IDwgMCA/IDAgOiAyNTU7XHJcbiAgICB2YXIgcCA9IHBlcmNlbnQgPCAwID8gcGVyY2VudCAqIC0xIDogcGVyY2VudDtcclxuICAgIHIgPSAoTWF0aC5yb3VuZCgodCAtIHIpICogcCkgKyByKTtcclxuICAgIGcgPSAoTWF0aC5yb3VuZCgodCAtIGcpICogcCkgKyBnKTtcclxuICAgIGIgPSAoTWF0aC5yb3VuZCgodCAtIGIpICogcCkgKyBiKTtcclxuICAgIHJldHVybiBcInJnYihcIiArIHIgKyBcIiwgXCIgKyBnICsgXCIsIFwiICsgYiArIFwiKVwiO1xyXG59XHJcblxyXG4vKipcclxuICogVmlzaWJpbGl0eSBPYnNlcnZlclxyXG4gKi9cclxudmFyIFZpc2liaWxpdHlPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZpc2liaWxpdHlPYnNlcnZlcihlbGVtZW50LCB6b25lKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucnVuQ2hlY2soKTtcclxuICAgIH1cclxuICAgIFZpc2liaWxpdHlPYnNlcnZlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcclxuICAgIH07XHJcbiAgICBWaXNpYmlsaXR5T2JzZXJ2ZXIucHJvdG90eXBlLm9uVmlzaWJpbGl0eUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIHRyaWdnZXIgem9uZSByZWNhbGMgZm9yIGNvbHVtbnNcclxuICAgICAgICB0aGlzLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgX3RoaXMudmlzaWJsZS5lbWl0KHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFZpc2liaWxpdHlPYnNlcnZlci5wcm90b3R5cGUucnVuQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghX3RoaXMuZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL29mZnNldGhlaWdodC12aXNpYmlsaXR5XHJcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgb2Zmc2V0SGVpZ2h0ID0gX2Eub2Zmc2V0SGVpZ2h0LCBvZmZzZXRXaWR0aCA9IF9hLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0SGVpZ2h0ICYmIG9mZnNldFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vblZpc2liaWxpdHlDaGFuZ2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoZWNrKCk7IH0sIDEwMCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hlY2soKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgVmlzaWJpbGl0eU9ic2VydmVyLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XHJcbiAgICByZXR1cm4gVmlzaWJpbGl0eU9ic2VydmVyO1xyXG59KCkpO1xyXG5cclxuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJztcclxufVxyXG5cclxudmFyIEJhc2VDaGFydENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhc2VDaGFydENvbXBvbmVudChjaGFydEVsZW1lbnQsIHpvbmUsIGNkKSB7XHJcbiAgICAgICAgdGhpcy5jaGFydEVsZW1lbnQgPSBjaGFydEVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcclxuICAgICAgICB0aGlzLmNkID0gY2Q7XHJcbiAgICAgICAgdGhpcy5zY2hlbWUgPSAnY29vbCc7XHJcbiAgICAgICAgdGhpcy5zY2hlbWVUeXBlID0gJ29yZGluYWwnO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJpbmRXaW5kb3dSZXNpemVFdmVudCgpO1xyXG4gICAgICAgIC8vIGxpc3RlbiBmb3IgdmlzaWJpbGl0eSBvZiB0aGUgZWxlbWVudCBmb3IgaGlkZGVuIGJ5IGRlZmF1bHQgc2NlbmFyaW9cclxuICAgICAgICB0aGlzLnZpc2liaWxpdHlPYnNlcnZlciA9IG5ldyBWaXNpYmlsaXR5T2JzZXJ2ZXIodGhpcy5jaGFydEVsZW1lbnQsIHRoaXMuem9uZSk7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5T2JzZXJ2ZXIudmlzaWJsZS5zdWJzY3JpYmUodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xyXG4gICAgICAgIGlmICh0aGlzLnZpc2liaWxpdHlPYnNlcnZlcikge1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlPYnNlcnZlci52aXNpYmxlLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eU9ic2VydmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cyA9IHRoaXMuY2xvbmVEYXRhKHRoaXMucmVzdWx0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmlldykge1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy52aWV3WzBdO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMudmlld1sxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBkaW1zID0gdGhpcy5nZXRDb250YWluZXJEaW1zKCk7XHJcbiAgICAgICAgICAgIGlmIChkaW1zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gZGltcy53aWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZGltcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZXMgaWYgd2lkdGggb3IgaGVpZ2h0IGFyZSAwIG9yIHVuZGVmaW5lZFxyXG4gICAgICAgIGlmICghdGhpcy53aWR0aCkge1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gNjAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gNDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5mbG9vcih0aGlzLndpZHRoKTtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGguZmxvb3IodGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIGlmICh0aGlzLmNkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q29udGFpbmVyRGltcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgd2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodDtcclxuICAgICAgICB2YXIgaG9zdEVsZW0gPSB0aGlzLmNoYXJ0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xyXG4gICAgICAgIGlmIChob3N0RWxlbS5wYXJlbnROb2RlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY29udGFpbmVyIGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgdmFyIGRpbXMgPSBob3N0RWxlbS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGg7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGRpbXMuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhbGwgZGF0ZSBvYmplY3RzIHRoYXQgYXBwZWFyIGFzIG5hbWVcclxuICAgICAqIGludG8gZm9ybWF0dGVkIGRhdGUgc3RyaW5nc1xyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmZvcm1hdERhdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZXN1bHRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBnID0gdGhpcy5yZXN1bHRzW2ldO1xyXG4gICAgICAgICAgICBnLmxhYmVsID0gZy5uYW1lO1xyXG4gICAgICAgICAgICBpZiAoZy5sYWJlbCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgICAgIGcubGFiZWwgPSBnLmxhYmVsLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChnLnNlcmllcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnLnNlcmllcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gZy5zZXJpZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgZC5sYWJlbCA9IGQubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZC5sYWJlbCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZC5sYWJlbCA9IGQubGFiZWwudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUudW5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZVN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmJpbmRXaW5kb3dSZXNpemVFdmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBmcm9tRXZlbnQod2luZG93LCAncmVzaXplJyk7XHJcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5waXBlKGRlYm91bmNlVGltZSgyMDApKS5zdWJzY3JpYmUoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgX3RoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jZCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlc2l6ZVN1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsb25lcyB0aGUgZGF0YSBpbnRvIGEgbmV3IG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gZGF0YVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIEJhc2VDaGFydFxyXG4gICAgICovXHJcbiAgICBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmNsb25lRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGRhdGFfMSA9IGRhdGE7IF9pIDwgZGF0YV8xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IGRhdGFfMVtfaV07XHJcbiAgICAgICAgICAgIHZhciBjb3B5ID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogaXRlbVsnbmFtZSddXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChpdGVtWyd2YWx1ZSddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvcHlbJ3ZhbHVlJ10gPSBpdGVtWyd2YWx1ZSddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpdGVtWydzZXJpZXMnXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb3B5WydzZXJpZXMnXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IGl0ZW1bJ3NlcmllcyddOyBfYSA8IF9iLmxlbmd0aDsgX2ErKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJpZXNJdGVtID0gX2JbX2FdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJpZXNJdGVtQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIHNlcmllc0l0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcHlbJ3NlcmllcyddLnB1c2goc2VyaWVzSXRlbUNvcHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpdGVtWydleHRyYSddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvcHlbJ2V4dHJhJ10gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGl0ZW1bJ2V4dHJhJ10pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goY29weSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXN1bHRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidmlld1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXN0b21Db2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgQmFzZUNoYXJ0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdiYXNlLWNoYXJ0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxkaXY+PC9kaXY+XFxuICBcIlxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdCwgdHlwZW9mIChfYiA9IHR5cGVvZiBOZ1pvbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgTmdab25lKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QsIHR5cGVvZiAoX2MgPSB0eXBlb2YgQ2hhbmdlRGV0ZWN0b3JSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgQ2hhbmdlRGV0ZWN0b3JSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdF0pXHJcbiAgICBdLCBCYXNlQ2hhcnRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEJhc2VDaGFydENvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBBeGlzTGFiZWxDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBeGlzTGFiZWxDb21wb25lbnQoZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IDI1O1xyXG4gICAgICAgIHRoaXMubWFyZ2luID0gNTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBBeGlzTGFiZWxDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAnMC4wMSc7XHJcbiAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ21pZGRsZSc7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSAnJztcclxuICAgICAgICBzd2l0Y2ggKHRoaXMub3JpZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB0aGlzLm9mZnNldDtcclxuICAgICAgICAgICAgICAgIHRoaXMueCA9IHRoaXMud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB0aGlzLm9mZnNldDtcclxuICAgICAgICAgICAgICAgIHRoaXMueCA9IHRoaXMud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0gLSh0aGlzLm9mZnNldCArIHRoaXMudGV4dEhlaWdodCArIHRoaXMubWFyZ2luKTtcclxuICAgICAgICAgICAgICAgIHRoaXMueCA9IC10aGlzLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9ICdyb3RhdGUoMjcwKSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5vZmZzZXQgKyB0aGlzLm1hcmdpbjtcclxuICAgICAgICAgICAgICAgIHRoaXMueCA9IC10aGlzLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9ICdyb3RhdGUoMjcwKSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXhpc0xhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcmllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwib2Zmc2V0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBeGlzTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBeGlzTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgQXhpc0xhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtYXhpcy1sYWJlbF0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2Zzp0ZXh0XFxuICAgICAgW2F0dHIuc3Ryb2tlLXdpZHRoXT1cXFwic3Ryb2tlV2lkdGhcXFwiXFxuICAgICAgW2F0dHIueF09XFxcInhcXFwiXFxuICAgICAgW2F0dHIueV09XFxcInlcXFwiXFxuICAgICAgW2F0dHIudGV4dC1hbmNob3JdPVxcXCJ0ZXh0QW5jaG9yXFxcIlxcbiAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCI+XFxuICAgICAge3tsYWJlbH19XFxuICAgIDwvc3ZnOnRleHQ+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxyXG4gICAgXSwgQXhpc0xhYmVsQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBBeGlzTGFiZWxDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG5mdW5jdGlvbiByZWR1Y2VUaWNrcyh0aWNrcywgbWF4VGlja3MpIHtcclxuICAgIGlmICh0aWNrcy5sZW5ndGggPiBtYXhUaWNrcykge1xyXG4gICAgICAgIHZhciByZWR1Y2VkID0gW107XHJcbiAgICAgICAgdmFyIG1vZHVsdXMgPSBNYXRoLmZsb29yKHRpY2tzLmxlbmd0aCAvIG1heFRpY2tzKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpICUgbW9kdWx1cyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVkdWNlZC5wdXNoKHRpY2tzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aWNrcyA9IHJlZHVjZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGlja3M7XHJcbn1cclxuXHJcbnZhciBYQXhpc1RpY2tzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gWEF4aXNUaWNrc0NvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLnRpY2tBcmd1bWVudHMgPSBbNV07XHJcbiAgICAgICAgdGhpcy50aWNrU3Ryb2tlID0gJyNjY2MnO1xyXG4gICAgICAgIHRoaXMudHJpbVRpY2tzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm1heFRpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICB0aGlzLnNob3dHcmlkTGluZXMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJvdGF0ZVRpY2tzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMudmVydGljYWxTcGFjaW5nID0gMjA7XHJcbiAgICAgICAgdGhpcy5yb3RhdGVMYWJlbHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlubmVyVGlja1NpemUgPSA2O1xyXG4gICAgICAgIHRoaXMub3V0ZXJUaWNrU2l6ZSA9IDY7XHJcbiAgICAgICAgdGhpcy50aWNrUGFkZGluZyA9IDM7XHJcbiAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ21pZGRsZSc7XHJcbiAgICAgICAgdGhpcy5tYXhUaWNrc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5tYXhBbGxvd2VkTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgfVxyXG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGVEaW1zKCk7IH0pO1xyXG4gICAgfTtcclxuICAgIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZURpbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VJbnQodGhpcy50aWNrc0VsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsIDEwKTtcclxuICAgICAgICBpZiAoaGVpZ2h0ICE9PSB0aGlzLmhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZC5lbWl0KHsgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlRGltcygpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcclxuICAgICAgICB0aGlzLnRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xyXG4gICAgICAgIGlmICh0aGlzLnRpY2tGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlja0Zvcm1hdCA9IHRoaXMudGlja0Zvcm1hdHRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNjYWxlLnRpY2tGb3JtYXQpIHtcclxuICAgICAgICAgICAgdGhpcy50aWNrRm9ybWF0ID0gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGhpcy50aWNrQXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRGF0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC50b0xvY2FsZURhdGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBkLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhbmdsZSA9IHRoaXMucm90YXRlVGlja3MgPyB0aGlzLmdldFJvdGF0aW9uQW5nbGUodGhpcy50aWNrcykgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuYWRqdXN0ZWRTY2FsZSA9IHRoaXMuc2NhbGUuYmFuZHdpZHRoXHJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlKGQpICsgdGhpcy5zY2FsZS5iYW5kd2lkdGgoKSAqIDAuNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgdGhpcy50ZXh0VHJhbnNmb3JtID0gJyc7XHJcbiAgICAgICAgaWYgKGFuZ2xlICYmIGFuZ2xlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dFRyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgYW5nbGUgKyBcIilcIjtcclxuICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ2VuZCc7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljYWxTcGFjaW5nID0gMTA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnbWlkZGxlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGVEaW1zKCk7IH0pO1xyXG4gICAgfTtcclxuICAgIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLmdldFJvdGF0aW9uQW5nbGUgPSBmdW5jdGlvbiAodGlja3MpIHtcclxuICAgICAgICB2YXIgYW5nbGUgPSAwO1xyXG4gICAgICAgIHRoaXMubWF4VGlja3NMZW5ndGggPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHRpY2sgPSB0aGlzLnRpY2tGb3JtYXQodGlja3NbaV0pLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHZhciB0aWNrTGVuZ3RoID0gdGljay5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyaW1UaWNrcykge1xyXG4gICAgICAgICAgICAgICAgdGlja0xlbmd0aCA9IHRoaXMudGlja1RyaW0odGljaykubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aWNrTGVuZ3RoID4gdGhpcy5tYXhUaWNrc0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhUaWNrc0xlbmd0aCA9IHRpY2tMZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHRoaXMubWF4VGlja3NMZW5ndGgsIHRoaXMubWF4QWxsb3dlZExlbmd0aCk7XHJcbiAgICAgICAgdmFyIGNoYXJXaWR0aCA9IDg7IC8vIG5lZWQgdG8gbWVhc3VyZSB0aGlzXHJcbiAgICAgICAgdmFyIHdvcmRXaWR0aCA9IGxlbiAqIGNoYXJXaWR0aDtcclxuICAgICAgICB2YXIgYmFzZVdpZHRoID0gd29yZFdpZHRoO1xyXG4gICAgICAgIHZhciBtYXhCYXNlV2lkdGggPSBNYXRoLmZsb29yKHRoaXMud2lkdGggLyB0aWNrcy5sZW5ndGgpO1xyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBvcHRpbWFsIGFuZ2xlXHJcbiAgICAgICAgd2hpbGUgKGJhc2VXaWR0aCA+IG1heEJhc2VXaWR0aCAmJiBhbmdsZSA+IC05MCkge1xyXG4gICAgICAgICAgICBhbmdsZSAtPSAzMDtcclxuICAgICAgICAgICAgYmFzZVdpZHRoID0gTWF0aC5jb3MoYW5nbGUgKiAoTWF0aC5QSSAvIDE4MCkpICogd29yZFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYW5nbGU7XHJcbiAgICB9O1xyXG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0VGlja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRpY2tzO1xyXG4gICAgICAgIHZhciBtYXhUaWNrcyA9IHRoaXMuZ2V0TWF4VGlja3MoMjApO1xyXG4gICAgICAgIHZhciBtYXhTY2FsZVRpY2tzID0gdGhpcy5nZXRNYXhUaWNrcygxMDApO1xyXG4gICAgICAgIGlmICh0aGlzLnRpY2tWYWx1ZXMpIHtcclxuICAgICAgICAgICAgdGlja3MgPSB0aGlzLnRpY2tWYWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGUudGlja3MpIHtcclxuICAgICAgICAgICAgdGlja3MgPSB0aGlzLnNjYWxlLnRpY2tzLmFwcGx5KHRoaXMuc2NhbGUsIFttYXhTY2FsZVRpY2tzXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aWNrcyA9IHRoaXMuc2NhbGUuZG9tYWluKCk7XHJcbiAgICAgICAgICAgIHRpY2tzID0gcmVkdWNlVGlja3ModGlja3MsIG1heFRpY2tzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRpY2tzO1xyXG4gICAgfTtcclxuICAgIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLmdldE1heFRpY2tzID0gZnVuY3Rpb24gKHRpY2tXaWR0aCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMud2lkdGggLyB0aWNrV2lkdGgpO1xyXG4gICAgfTtcclxuICAgIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnRpY2tUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodGljaykge1xyXG4gICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB0aGlzLmFkanVzdGVkU2NhbGUodGljaykgKyAnLCcgKyB0aGlzLnZlcnRpY2FsU3BhY2luZyArICcpJztcclxuICAgIH07XHJcbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5ncmlkTGluZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIiArICgtdGhpcy52ZXJ0aWNhbFNwYWNpbmcgLSA1KSArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnRpY2tUcmltID0gZnVuY3Rpb24gKGxhYmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpbVRpY2tzID8gdHJpbUxhYmVsKGxhYmVsLCB0aGlzLm1heFRpY2tMZW5ndGgpIDogbGFiZWw7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja0FyZ3VtZW50c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrVmFsdWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrU3Ryb2tlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVRpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JpZExpbmVIZWlnaHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1lbnNpb25zQ2hhbmdlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVmlld0NoaWxkKCd0aWNrc2VsJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja3NFbGVtZW50XCIsIHZvaWQgMCk7XHJcbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMteC1heGlzLXRpY2tzXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgI3RpY2tzZWw+XFxuICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHRpY2sgb2YgdGlja3NcXFwiIGNsYXNzPVxcXCJ0aWNrXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0aWNrVHJhbnNmb3JtKHRpY2spXFxcIj5cXG4gICAgICAgIDx0aXRsZT57eyB0aWNrRm9ybWF0KHRpY2spIH19PC90aXRsZT5cXG4gICAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgICBzdHJva2Utd2lkdGg9XFxcIjAuMDFcXFwiXFxuICAgICAgICAgIFthdHRyLnRleHQtYW5jaG9yXT1cXFwidGV4dEFuY2hvclxcXCJcXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidGV4dFRyYW5zZm9ybVxcXCJcXG4gICAgICAgICAgW3N0eWxlLmZvbnQtc2l6ZV09XFxcIicxMnB4J1xcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAge3sgdGlja1RyaW0odGlja0Zvcm1hdCh0aWNrKSkgfX1cXG4gICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG5cXG4gICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHRpY2sgb2YgdGlja3NcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRpY2tUcmFuc2Zvcm0odGljaylcXFwiPlxcbiAgICAgIDxzdmc6ZyAqbmdJZj1cXFwic2hvd0dyaWRMaW5lc1xcXCIgW2F0dHIudHJhbnNmb3JtXT1cXFwiZ3JpZExpbmVUcmFuc2Zvcm0oKVxcXCI+XFxuICAgICAgICA8c3ZnOmxpbmUgY2xhc3M9XFxcImdyaWRsaW5lLXBhdGggZ3JpZGxpbmUtcGF0aC12ZXJ0aWNhbFxcXCIgW2F0dHIueTFdPVxcXCItZ3JpZExpbmVIZWlnaHRcXFwiIHkyPVxcXCIwXFxcIiAvPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gWEF4aXNUaWNrc0NvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBYQXhpc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFhBeGlzQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMucm90YXRlVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2hvd0dyaWRMaW5lcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMueE9yaWVudCA9ICdib3R0b20nO1xyXG4gICAgICAgIHRoaXMueEF4aXNPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuZGltZW5zaW9uc0NoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy54QXhpc0NsYXNzTmFtZSA9ICd4IGF4aXMnO1xyXG4gICAgICAgIHRoaXMubGFiZWxPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuZmlsbCA9ICdub25lJztcclxuICAgICAgICB0aGlzLnN0cm9rZSA9ICdzdHJva2UnO1xyXG4gICAgICAgIHRoaXMudGlja1N0cm9rZSA9ICcjY2NjJztcclxuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gJ25vbmUnO1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IDU7XHJcbiAgICB9XHJcbiAgICBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKDAsXCIgKyAodGhpcy54QXhpc09mZnNldCArIHRoaXMucGFkZGluZyArIHRoaXMuZGltcy5oZWlnaHQpICsgXCIpXCI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnhBeGlzVGlja0NvdW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnRpY2tBcmd1bWVudHMgPSBbdGhpcy54QXhpc1RpY2tDb3VudF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5lbWl0VGlja3NIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIG5ld0xhYmVsT2Zmc2V0ID0gaGVpZ2h0ICsgMjUgKyA1O1xyXG4gICAgICAgIGlmIChuZXdMYWJlbE9mZnNldCAhPT0gdGhpcy5sYWJlbE9mZnNldCkge1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gbmV3TGFiZWxPZmZzZXQ7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGltZW5zaW9uc0NoYW5nZWQuZW1pdCh7IGhlaWdodDogaGVpZ2h0IH0pO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcImRpbXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVRpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVRpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4VGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tJbnRlcnZhbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0NvdW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieE9yaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzT2Zmc2V0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcImRpbWVuc2lvbnNDaGFuZ2VkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBWaWV3Q2hpbGQoWEF4aXNUaWNrc0NvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFhBeGlzVGlja3NDb21wb25lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgWEF4aXNUaWNrc0NvbXBvbmVudCkgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tzQ29tcG9uZW50XCIsIHZvaWQgMCk7XHJcbiAgICBYQXhpc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXgtYXhpc10nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIFthdHRyLmNsYXNzXT1cXFwieEF4aXNDbGFzc05hbWVcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCI+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpcy10aWNrc1xcbiAgICAgICAgKm5nSWY9XFxcInhTY2FsZVxcXCJcXG4gICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltVGlja3NcXFwiXFxuICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVUaWNrc1xcXCJcXG4gICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4VGlja0xlbmd0aFxcXCJcXG4gICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInRpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgW3RpY2tBcmd1bWVudHNdPVxcXCJ0aWNrQXJndW1lbnRzXFxcIlxcbiAgICAgICAgW3RpY2tTdHJva2VdPVxcXCJ0aWNrU3Ryb2tlXFxcIlxcbiAgICAgICAgW3NjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgW29yaWVudF09XFxcInhPcmllbnRcXFwiXFxuICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICBbZ3JpZExpbmVIZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgIFt3aWR0aF09XFxcImRpbXMud2lkdGhcXFwiXFxuICAgICAgICBbdGlja1ZhbHVlc109XFxcInRpY2tzXFxcIlxcbiAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwiZW1pdFRpY2tzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgLz5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtYXhpcy1sYWJlbFxcbiAgICAgICAgKm5nSWY9XFxcInNob3dMYWJlbFxcXCJcXG4gICAgICAgIFtsYWJlbF09XFxcImxhYmVsVGV4dFxcXCJcXG4gICAgICAgIFtvZmZzZXRdPVxcXCJsYWJlbE9mZnNldFxcXCJcXG4gICAgICAgIFtvcmllbnRdPVxcXCInYm90dG9tJ1xcXCJcXG4gICAgICAgIFtoZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgIFt3aWR0aF09XFxcImRpbXMud2lkdGhcXFwiXFxuICAgICAgPjwvc3ZnOmc+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFhBeGlzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHJvdW5kZWQgcmVjdGFuZ2xhciBwYXRoXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHsqfSB4LCB5LCB3LCBoLCByLCB0bCwgdHIsIGJsLCBiclxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gcm91bmRlZFJlY3QoeCwgeSwgdywgaCwgciwgX2EpIHtcclxuICAgIHZhciB0bCA9IF9hWzBdLCB0ciA9IF9hWzFdLCBibCA9IF9hWzJdLCBiciA9IF9hWzNdO1xyXG4gICAgdmFyIHJldHZhbCA9ICcnO1xyXG4gICAgdyA9IE1hdGguZmxvb3Iodyk7XHJcbiAgICBoID0gTWF0aC5mbG9vcihoKTtcclxuICAgIHcgPSB3ID09PSAwID8gMSA6IHc7XHJcbiAgICBoID0gaCA9PT0gMCA/IDEgOiBoO1xyXG4gICAgcmV0dmFsID0gXCJNXCIgKyBbeCArIHIsIHldO1xyXG4gICAgcmV0dmFsICs9IFwiaFwiICsgKHcgLSAyICogcik7XHJcbiAgICBpZiAodHIpIHtcclxuICAgICAgICByZXR2YWwgKz0gXCJhXCIgKyBbciwgcl0gKyBcIiAwIDAgMSBcIiArIFtyLCByXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHZhbCArPSBcImhcIiArIHIgKyBcInZcIiArIHI7XHJcbiAgICB9XHJcbiAgICByZXR2YWwgKz0gXCJ2XCIgKyAoaCAtIDIgKiByKTtcclxuICAgIGlmIChicikge1xyXG4gICAgICAgIHJldHZhbCArPSBcImFcIiArIFtyLCByXSArIFwiIDAgMCAxIFwiICsgWy1yLCByXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHZhbCArPSBcInZcIiArIHIgKyBcImhcIiArIC1yO1xyXG4gICAgfVxyXG4gICAgcmV0dmFsICs9IFwiaFwiICsgKDIgKiByIC0gdyk7XHJcbiAgICBpZiAoYmwpIHtcclxuICAgICAgICByZXR2YWwgKz0gXCJhXCIgKyBbciwgcl0gKyBcIiAwIDAgMSBcIiArIFstciwgLXJdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dmFsICs9IFwiaFwiICsgLXIgKyBcInZcIiArIC1yO1xyXG4gICAgfVxyXG4gICAgcmV0dmFsICs9IFwidlwiICsgKDIgKiByIC0gaCk7XHJcbiAgICBpZiAodGwpIHtcclxuICAgICAgICByZXR2YWwgKz0gXCJhXCIgKyBbciwgcl0gKyBcIiAwIDAgMSBcIiArIFtyLCAtcl07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR2YWwgKz0gXCJ2XCIgKyAtciArIFwiaFwiICsgcjtcclxuICAgIH1cclxuICAgIHJldHZhbCArPSBcInpcIjtcclxuICAgIHJldHVybiByZXR2YWw7XHJcbn1cclxuXHJcbnZhciBZQXhpc1RpY2tzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gWUF4aXNUaWNrc0NvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLnRpY2tBcmd1bWVudHMgPSBbNV07XHJcbiAgICAgICAgdGhpcy50aWNrU3Ryb2tlID0gJyNjY2MnO1xyXG4gICAgICAgIHRoaXMudHJpbVRpY2tzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm1heFRpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICB0aGlzLnNob3dHcmlkTGluZXMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNob3dSZWZMYWJlbHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNob3dSZWZMaW5lcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGltZW5zaW9uc0NoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbm5lclRpY2tTaXplID0gNjtcclxuICAgICAgICB0aGlzLnRpY2tQYWRkaW5nID0gMztcclxuICAgICAgICB0aGlzLnZlcnRpY2FsU3BhY2luZyA9IDIwO1xyXG4gICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdtaWRkbGUnO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMub3V0ZXJUaWNrU2l6ZSA9IDY7XHJcbiAgICAgICAgdGhpcy5yb3RhdGVMYWJlbHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlZmVyZW5jZUxpbmVMZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGVEaW1zKCk7IH0pO1xyXG4gICAgfTtcclxuICAgIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZURpbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgd2lkdGggPSBwYXJzZUludCh0aGlzLnRpY2tzRWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLCAxMCk7XHJcbiAgICAgICAgaWYgKHdpZHRoICE9PSB0aGlzLndpZHRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZC5lbWl0KHsgd2lkdGg6IHdpZHRoIH0pO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZURpbXMoKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzY2FsZTtcclxuICAgICAgICB2YXIgc2lnbiA9IHRoaXMub3JpZW50ID09PSAndG9wJyB8fCB0aGlzLm9yaWVudCA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcclxuICAgICAgICB0aGlzLnRpY2tTcGFjaW5nID0gTWF0aC5tYXgodGhpcy5pbm5lclRpY2tTaXplLCAwKSArIHRoaXMudGlja1BhZGRpbmc7XHJcbiAgICAgICAgc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgIHRoaXMudGlja3MgPSB0aGlzLmdldFRpY2tzKCk7XHJcbiAgICAgICAgaWYgKHRoaXMudGlja0Zvcm1hdHRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy50aWNrRm9ybWF0ID0gdGhpcy50aWNrRm9ybWF0dGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2NhbGUudGlja0Zvcm1hdCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpY2tGb3JtYXQgPSBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aGlzLnRpY2tBcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdEYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGp1c3RlZFNjYWxlID0gc2NhbGUuYmFuZHdpZHRoXHJcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZShkKSArIHNjYWxlLmJhbmR3aWR0aCgpICogMC41O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogc2NhbGU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd1JlZkxpbmVzICYmIHRoaXMucmVmZXJlbmNlTGluZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRSZWZlcmVuY2VsaW5lcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKHRoaXMub3JpZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0aWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHRoaXMuYWRqdXN0ZWRTY2FsZSh0aWNrKSArICcsMCknO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdtaWRkbGUnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHRoaXMuaW5uZXJUaWNrU2l6ZSAqIHNpZ247XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0gdGhpcy50aWNrU3BhY2luZyAqIHNpZ247XHJcbiAgICAgICAgICAgICAgICB0aGlzLmR5ID0gc2lnbiA8IDAgPyAnMGVtJyA6ICcuNzFlbSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gZnVuY3Rpb24gKHRpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgdGhpcy5hZGp1c3RlZFNjYWxlKHRpY2spICsgJywwKSc7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ21pZGRsZSc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkyID0gdGhpcy5pbm5lclRpY2tTaXplICogc2lnbjtcclxuICAgICAgICAgICAgICAgIHRoaXMueTEgPSB0aGlzLnRpY2tTcGFjaW5nICogc2lnbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHkgPSBzaWduIDwgMCA/ICcwZW0nIDogJy43MWVtJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gZnVuY3Rpb24gKHRpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCcgKyB0aGlzLmFkanVzdGVkU2NhbGUodGljaykgKyAnKSc7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ2VuZCc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLngyID0gdGhpcy5pbm5lclRpY2tTaXplICogLXNpZ247XHJcbiAgICAgICAgICAgICAgICB0aGlzLngxID0gdGhpcy50aWNrU3BhY2luZyAqIC1zaWduO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5keSA9ICcuMzJlbSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArIHRoaXMuYWRqdXN0ZWRTY2FsZSh0aWNrKSArICcpJztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnc3RhcnQnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy54MiA9IHRoaXMuaW5uZXJUaWNrU2l6ZSAqIC1zaWduO1xyXG4gICAgICAgICAgICAgICAgdGhpcy54MSA9IHRoaXMudGlja1NwYWNpbmcgKiAtc2lnbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHkgPSAnLjMyZW0nO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlRGltcygpOyB9KTtcclxuICAgIH07XHJcbiAgICBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5zZXRSZWZlcmVuY2VsaW5lcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlZk1pbiA9IHRoaXMuYWRqdXN0ZWRTY2FsZShNYXRoLm1pbi5hcHBseShudWxsLCB0aGlzLnJlZmVyZW5jZUxpbmVzLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS52YWx1ZTsgfSkpKTtcclxuICAgICAgICB0aGlzLnJlZk1heCA9IHRoaXMuYWRqdXN0ZWRTY2FsZShNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLnJlZmVyZW5jZUxpbmVzLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS52YWx1ZTsgfSkpKTtcclxuICAgICAgICB0aGlzLnJlZmVyZW5jZUxpbmVMZW5ndGggPSB0aGlzLnJlZmVyZW5jZUxpbmVzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnJlZmVyZW5jZUFyZWFQYXRoID0gcm91bmRlZFJlY3QoMCwgdGhpcy5yZWZNYXgsIHRoaXMuZ3JpZExpbmVXaWR0aCwgdGhpcy5yZWZNaW4gLSB0aGlzLnJlZk1heCwgMCwgW1xyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgIF0pO1xyXG4gICAgfTtcclxuICAgIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLmdldFRpY2tzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aWNrcztcclxuICAgICAgICB2YXIgbWF4VGlja3MgPSB0aGlzLmdldE1heFRpY2tzKDIwKTtcclxuICAgICAgICB2YXIgbWF4U2NhbGVUaWNrcyA9IHRoaXMuZ2V0TWF4VGlja3MoNTApO1xyXG4gICAgICAgIGlmICh0aGlzLnRpY2tWYWx1ZXMpIHtcclxuICAgICAgICAgICAgdGlja3MgPSB0aGlzLnRpY2tWYWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGUudGlja3MpIHtcclxuICAgICAgICAgICAgdGlja3MgPSB0aGlzLnNjYWxlLnRpY2tzLmFwcGx5KHRoaXMuc2NhbGUsIFttYXhTY2FsZVRpY2tzXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aWNrcyA9IHRoaXMuc2NhbGUuZG9tYWluKCk7XHJcbiAgICAgICAgICAgIHRpY2tzID0gcmVkdWNlVGlja3ModGlja3MsIG1heFRpY2tzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRpY2tzO1xyXG4gICAgfTtcclxuICAgIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLmdldE1heFRpY2tzID0gZnVuY3Rpb24gKHRpY2tIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLmhlaWdodCAvIHRpY2tIZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnRpY2tUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodGljaykge1xyXG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHRoaXMuYWRqdXN0ZWRTY2FsZSh0aWNrKSArIFwiLFwiICsgdGhpcy52ZXJ0aWNhbFNwYWNpbmcgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5ncmlkTGluZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoNSwwKVwiO1xyXG4gICAgfTtcclxuICAgIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnRpY2tUcmltID0gZnVuY3Rpb24gKGxhYmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpbVRpY2tzID8gdHJpbUxhYmVsKGxhYmVsLCB0aGlzLm1heFRpY2tMZW5ndGgpIDogbGFiZWw7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja0FyZ3VtZW50c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrVmFsdWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrU3Ryb2tlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVRpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JpZExpbmVXaWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWZlcmVuY2VMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dSZWZMYWJlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93UmVmTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1lbnNpb25zQ2hhbmdlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVmlld0NoaWxkKCd0aWNrc2VsJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja3NFbGVtZW50XCIsIHZvaWQgMCk7XHJcbiAgICBZQXhpc1RpY2tzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMteS1heGlzLXRpY2tzXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgI3RpY2tzZWw+XFxuICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHRpY2sgb2YgdGlja3NcXFwiIGNsYXNzPVxcXCJ0aWNrXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm0odGljaylcXFwiPlxcbiAgICAgICAgPHRpdGxlPnt7IHRpY2tGb3JtYXQodGljaykgfX08L3RpdGxlPlxcbiAgICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICAgIHN0cm9rZS13aWR0aD1cXFwiMC4wMVxcXCJcXG4gICAgICAgICAgW2F0dHIuZHldPVxcXCJkeVxcXCJcXG4gICAgICAgICAgW2F0dHIueF09XFxcIngxXFxcIlxcbiAgICAgICAgICBbYXR0ci55XT1cXFwieTFcXFwiXFxuICAgICAgICAgIFthdHRyLnRleHQtYW5jaG9yXT1cXFwidGV4dEFuY2hvclxcXCJcXG4gICAgICAgICAgW3N0eWxlLmZvbnQtc2l6ZV09XFxcIicxMnB4J1xcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAge3sgdGlja1RyaW0odGlja0Zvcm1hdCh0aWNrKSkgfX1cXG4gICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG5cXG4gICAgPHN2ZzpwYXRoXFxuICAgICAgKm5nSWY9XFxcInJlZmVyZW5jZUxpbmVMZW5ndGggPiAxICYmIHJlZk1heCAmJiByZWZNaW4gJiYgc2hvd1JlZkxpbmVzXFxcIlxcbiAgICAgIGNsYXNzPVxcXCJyZWZlcmVuY2UtYXJlYVxcXCJcXG4gICAgICBbYXR0ci5kXT1cXFwicmVmZXJlbmNlQXJlYVBhdGhcXFwiXFxuICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiZ3JpZExpbmVUcmFuc2Zvcm0oKVxcXCJcXG4gICAgLz5cXG4gICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHRpY2sgb2YgdGlja3NcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybSh0aWNrKVxcXCI+XFxuICAgICAgPHN2ZzpnICpuZ0lmPVxcXCJzaG93R3JpZExpbmVzXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJncmlkTGluZVRyYW5zZm9ybSgpXFxcIj5cXG4gICAgICAgIDxzdmc6bGluZVxcbiAgICAgICAgICAqbmdJZj1cXFwib3JpZW50ID09PSAnbGVmdCdcXFwiXFxuICAgICAgICAgIGNsYXNzPVxcXCJncmlkbGluZS1wYXRoIGdyaWRsaW5lLXBhdGgtaG9yaXpvbnRhbFxcXCJcXG4gICAgICAgICAgeDE9XFxcIjBcXFwiXFxuICAgICAgICAgIFthdHRyLngyXT1cXFwiZ3JpZExpbmVXaWR0aFxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8c3ZnOmxpbmVcXG4gICAgICAgICAgKm5nSWY9XFxcIm9yaWVudCA9PT0gJ3JpZ2h0J1xcXCJcXG4gICAgICAgICAgY2xhc3M9XFxcImdyaWRsaW5lLXBhdGggZ3JpZGxpbmUtcGF0aC1ob3Jpem9udGFsXFxcIlxcbiAgICAgICAgICB4MT1cXFwiMFxcXCJcXG4gICAgICAgICAgW2F0dHIueDJdPVxcXCItZ3JpZExpbmVXaWR0aFxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG5cXG4gICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHJlZkxpbmUgb2YgcmVmZXJlbmNlTGluZXNcXFwiPlxcbiAgICAgIDxzdmc6ZyAqbmdJZj1cXFwic2hvd1JlZkxpbmVzXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm0ocmVmTGluZS52YWx1ZSlcXFwiPlxcbiAgICAgICAgPHN2ZzpsaW5lXFxuICAgICAgICAgIGNsYXNzPVxcXCJyZWZsaW5lLXBhdGggZ3JpZGxpbmUtcGF0aC1ob3Jpem9udGFsXFxcIlxcbiAgICAgICAgICB4MT1cXFwiMFxcXCJcXG4gICAgICAgICAgW2F0dHIueDJdPVxcXCJncmlkTGluZVdpZHRoXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJncmlkTGluZVRyYW5zZm9ybSgpXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxzdmc6ZyAqbmdJZj1cXFwic2hvd1JlZkxhYmVsc1xcXCI+XFxuICAgICAgICAgIDx0aXRsZT57eyB0aWNrVHJpbSh0aWNrRm9ybWF0KHJlZkxpbmUudmFsdWUpKSB9fTwvdGl0bGU+XFxuICAgICAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJyZWZsaW5lLWxhYmVsXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmR5XT1cXFwiZHlcXFwiXFxuICAgICAgICAgICAgW2F0dHIueV09XFxcIi02XFxcIlxcbiAgICAgICAgICAgIFthdHRyLnhdPVxcXCJncmlkTGluZVdpZHRoXFxcIlxcbiAgICAgICAgICAgIFthdHRyLnRleHQtYW5jaG9yXT1cXFwidGV4dEFuY2hvclxcXCJcXG4gICAgICAgICAgPlxcbiAgICAgICAgICAgIHt7IHJlZkxpbmUubmFtZSB9fVxcbiAgICAgICAgICA8L3N2Zzp0ZXh0PlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFlBeGlzVGlja3NDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgWUF4aXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBZQXhpc0NvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLnNob3dHcmlkTGluZXMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnlPcmllbnQgPSAnbGVmdCc7XHJcbiAgICAgICAgdGhpcy55QXhpc09mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLnlBeGlzQ2xhc3NOYW1lID0gJ3kgYXhpcyc7XHJcbiAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IDE1O1xyXG4gICAgICAgIHRoaXMuZmlsbCA9ICdub25lJztcclxuICAgICAgICB0aGlzLnN0cm9rZSA9ICcjQ0NDJztcclxuICAgICAgICB0aGlzLnRpY2tTdHJva2UgPSAnI0NDQyc7XHJcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XHJcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gNTtcclxuICAgIH1cclxuICAgIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gLSh0aGlzLnlBeGlzT2Zmc2V0ICsgdGhpcy5wYWRkaW5nKTtcclxuICAgICAgICBpZiAodGhpcy55T3JpZW50ID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFiZWxPZmZzZXQgPSA2NTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArICh0aGlzLm9mZnNldCArIHRoaXMuZGltcy53aWR0aCkgKyBcIiAsIDApXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5vZmZzZXQgKyBcIiAsIDApXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnlBeGlzVGlja0NvdW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy50aWNrQXJndW1lbnRzID0gW3RoaXMueUF4aXNUaWNrQ291bnRdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUuZW1pdFRpY2tzV2lkdGggPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgICAgIGlmICh3aWR0aCAhPT0gdGhpcy5sYWJlbE9mZnNldCAmJiB0aGlzLnlPcmllbnQgPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IHdpZHRoICsgdGhpcy5sYWJlbE9mZnNldDtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kaW1lbnNpb25zQ2hhbmdlZC5lbWl0KHsgd2lkdGg6IHdpZHRoIH0pO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAod2lkdGggIT09IHRoaXMubGFiZWxPZmZzZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IHdpZHRoO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnNDaGFuZ2VkLmVtaXQoeyB3aWR0aDogd2lkdGggfSk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0ludGVydmFsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrQ291bnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5T3JpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwicmVmZXJlbmNlTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93UmVmTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93UmVmTGFiZWxzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNPZmZzZXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltZW5zaW9uc0NoYW5nZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFZpZXdDaGlsZChZQXhpc1RpY2tzQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgWUF4aXNUaWNrc0NvbXBvbmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBZQXhpc1RpY2tzQ29tcG9uZW50KSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja3NDb21wb25lbnRcIiwgdm9pZCAwKTtcclxuICAgIFlBeGlzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMteS1heGlzXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgW2F0dHIuY2xhc3NdPVxcXCJ5QXhpc0NsYXNzTmFtZVxcXCIgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIj5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMteS1heGlzLXRpY2tzXFxuICAgICAgICAqbmdJZj1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1UaWNrc1xcXCJcXG4gICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4VGlja0xlbmd0aFxcXCJcXG4gICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInRpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgW3RpY2tBcmd1bWVudHNdPVxcXCJ0aWNrQXJndW1lbnRzXFxcIlxcbiAgICAgICAgW3RpY2tWYWx1ZXNdPVxcXCJ0aWNrc1xcXCJcXG4gICAgICAgIFt0aWNrU3Ryb2tlXT1cXFwidGlja1N0cm9rZVxcXCJcXG4gICAgICAgIFtzY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgIFtvcmllbnRdPVxcXCJ5T3JpZW50XFxcIlxcbiAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgW2dyaWRMaW5lV2lkdGhdPVxcXCJkaW1zLndpZHRoXFxcIlxcbiAgICAgICAgW3JlZmVyZW5jZUxpbmVzXT1cXFwicmVmZXJlbmNlTGluZXNcXFwiXFxuICAgICAgICBbc2hvd1JlZkxpbmVzXT1cXFwic2hvd1JlZkxpbmVzXFxcIlxcbiAgICAgICAgW3Nob3dSZWZMYWJlbHNdPVxcXCJzaG93UmVmTGFiZWxzXFxcIlxcbiAgICAgICAgW2hlaWdodF09XFxcImRpbXMuaGVpZ2h0XFxcIlxcbiAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwiZW1pdFRpY2tzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAvPlxcblxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1heGlzLWxhYmVsXFxuICAgICAgICAqbmdJZj1cXFwic2hvd0xhYmVsXFxcIlxcbiAgICAgICAgW2xhYmVsXT1cXFwibGFiZWxUZXh0XFxcIlxcbiAgICAgICAgW29mZnNldF09XFxcImxhYmVsT2Zmc2V0XFxcIlxcbiAgICAgICAgW29yaWVudF09XFxcInlPcmllbnRcXFwiXFxuICAgICAgICBbaGVpZ2h0XT1cXFwiZGltcy5oZWlnaHRcXFwiXFxuICAgICAgICBbd2lkdGhdPVxcXCJkaW1zLndpZHRoXFxcIlxcbiAgICAgID48L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBZQXhpc0NvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBBeGVzTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXhlc01vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIEF4ZXNNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtBeGlzTGFiZWxDb21wb25lbnQsIFhBeGlzQ29tcG9uZW50LCBYQXhpc1RpY2tzQ29tcG9uZW50LCBZQXhpc0NvbXBvbmVudCwgWUF4aXNUaWNrc0NvbXBvbmVudF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtBeGlzTGFiZWxDb21wb25lbnQsIFhBeGlzQ29tcG9uZW50LCBYQXhpc1RpY2tzQ29tcG9uZW50LCBZQXhpc0NvbXBvbmVudCwgWUF4aXNUaWNrc0NvbXBvbmVudF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQXhlc01vZHVsZSk7XHJcbiAgICByZXR1cm4gQXhlc01vZHVsZTtcclxufSgpKTtcclxuXHJcbnZhciBDb2xvckhlbHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbG9ySGVscGVyKHNjaGVtZSwgdHlwZSwgZG9tYWluLCBjdXN0b21Db2xvcnMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgc2NoZW1lID0gY29sb3JTZXRzLmZpbmQoZnVuY3Rpb24gKGNzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3MubmFtZSA9PT0gc2NoZW1lO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb2xvckRvbWFpbiA9IHNjaGVtZS5kb21haW47XHJcbiAgICAgICAgdGhpcy5zY2FsZVR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gZG9tYWluO1xyXG4gICAgICAgIHRoaXMuY3VzdG9tQ29sb3JzID0gY3VzdG9tQ29sb3JzO1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSB0aGlzLmdlbmVyYXRlQ29sb3JTY2hlbWUoc2NoZW1lLCB0eXBlLCB0aGlzLmRvbWFpbik7XHJcbiAgICB9XHJcbiAgICBDb2xvckhlbHBlci5wcm90b3R5cGUuZ2VuZXJhdGVDb2xvclNjaGVtZSA9IGZ1bmN0aW9uIChzY2hlbWUsIHR5cGUsIGRvbWFpbikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBzY2hlbWUgPSBjb2xvclNldHMuZmluZChmdW5jdGlvbiAoY3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcy5uYW1lID09PSBzY2hlbWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29sb3JTY2FsZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3F1YW50aWxlJykge1xyXG4gICAgICAgICAgICBjb2xvclNjYWxlID0gc2NhbGVRdWFudGlsZSgpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2Uoc2NoZW1lLmRvbWFpbilcclxuICAgICAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2NhbGUgPSBzY2FsZU9yZGluYWwoKVxyXG4gICAgICAgICAgICAgICAgLnJhbmdlKHNjaGVtZS5kb21haW4pXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIC8vIGxpbmVhciBzY2hlbWVzIG11c3QgaGF2ZSBhdCBsZWFzdCAyIGNvbG9yc1xyXG4gICAgICAgICAgICB2YXIgY29sb3JEb21haW4gPSBzY2hlbWUuZG9tYWluLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIGlmIChjb2xvckRvbWFpbi5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yRG9tYWluLnB1c2goY29sb3JEb21haW5bMF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvckRvbWFpbiA9IGNvbG9yRG9tYWluO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSByYW5nZSgwLCAxLCAxLjAgLyBjb2xvckRvbWFpbi5sZW5ndGgpO1xyXG4gICAgICAgICAgICBjb2xvclNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbihwb2ludHMpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoY29sb3JEb21haW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29sb3JTY2FsZTtcclxuICAgIH07XHJcbiAgICBDb2xvckhlbHBlci5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGNhbiBub3QgYmUgbnVsbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZVNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbih0aGlzLmRvbWFpbilcclxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgMV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZVNjYWxlKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY3VzdG9tQ29sb3JzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21Db2xvcnModmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZV8xID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdmFyIGZvdW5kID0gdm9pZCAwOyAvLyB0b2RvIHR5cGUgY3VzdG9tQ29sb3JzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbUNvbG9ycyAmJiB0aGlzLmN1c3RvbUNvbG9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRoaXMuY3VzdG9tQ29sb3JzLmZpbmQoZnVuY3Rpb24gKG1hcHBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwcGluZy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IGZvcm1hdHRlZFZhbHVlXzEudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbG9ySGVscGVyLnByb3RvdHlwZS5nZXRMaW5lYXJHcmFkaWVudFN0b3BzID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCkge1xyXG4gICAgICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5kb21haW5bMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZVNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMuZG9tYWluKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzAsIDFdKTtcclxuICAgICAgICB2YXIgY29sb3JWYWx1ZVNjYWxlID0gc2NhbGVCYW5kKClcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLmNvbG9yRG9tYWluKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzAsIDFdKTtcclxuICAgICAgICB2YXIgZW5kQ29sb3IgPSB0aGlzLmdldENvbG9yKHZhbHVlKTtcclxuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgc3RvcHNcclxuICAgICAgICB2YXIgc3RhcnRWYWwgPSB2YWx1ZVNjYWxlKHN0YXJ0KTtcclxuICAgICAgICB2YXIgc3RhcnRDb2xvciA9IHRoaXMuZ2V0Q29sb3Ioc3RhcnQpO1xyXG4gICAgICAgIHZhciBlbmRWYWwgPSB2YWx1ZVNjYWxlKHZhbHVlKTtcclxuICAgICAgICB2YXIgaSA9IDE7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRWYWwgPSBzdGFydFZhbDtcclxuICAgICAgICB2YXIgc3RvcHMgPSBbXTtcclxuICAgICAgICBzdG9wcy5wdXNoKHtcclxuICAgICAgICAgICAgY29sb3I6IHN0YXJ0Q29sb3IsXHJcbiAgICAgICAgICAgIG9mZnNldDogc3RhcnRWYWwsXHJcbiAgICAgICAgICAgIG9yaWdpbmFsT2Zmc2V0OiBzdGFydFZhbCxcclxuICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50VmFsIDwgZW5kVmFsICYmIGkgPCB0aGlzLmNvbG9yRG9tYWluLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yRG9tYWluW2ldO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gY29sb3JWYWx1ZVNjYWxlKGNvbG9yKTtcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA8PSBzdGFydFZhbCkge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9mZnNldC50b0ZpeGVkKDQpID49IChlbmRWYWwgLSBjb2xvclZhbHVlU2NhbGUuYmFuZHdpZHRoKCkpLnRvRml4ZWQoNCkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0b3BzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjdXJyZW50VmFsID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdG9wc1tzdG9wcy5sZW5ndGggLSAxXS5vZmZzZXQgPCAxMDApIHtcclxuICAgICAgICAgICAgc3RvcHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogZW5kQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGVuZFZhbCxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRWYWwgPT09IHN0YXJ0VmFsKSB7XHJcbiAgICAgICAgICAgIHN0b3BzWzBdLm9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHN0b3BzWzFdLm9mZnNldCA9IDEwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgb2Zmc2V0cyBpbnRvIHBlcmNlbnRhZ2VzXHJcbiAgICAgICAgICAgIGlmIChzdG9wc1tzdG9wcy5sZW5ndGggLSAxXS5vZmZzZXQgIT09IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzdG9wc18xID0gc3RvcHM7IF9pIDwgc3RvcHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHN0b3BzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHMub2Zmc2V0ID0gKChzLm9mZnNldCAtIHN0YXJ0VmFsKSAvIChlbmRWYWwgLSBzdGFydFZhbCkpICogMTAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdG9wcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29sb3JIZWxwZXI7XHJcbn0oKSk7XHJcblxyXG52YXIgQ2lyY2xlU2VyaWVzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2lyY2xlU2VyaWVzQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdzdGFuZGFyZCc7XHJcbiAgICAgICAgdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmJhclZpc2libGUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudElkID0gJ2dyYWQnICsgaWQoKS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnRGaWxsID0gXCJ1cmwoI1wiICsgdGhpcy5ncmFkaWVudElkICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNpcmNsZSA9IHRoaXMuZ2V0QWN0aXZlQ2lyY2xlKCk7XHJcbiAgICB9O1xyXG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRBY3RpdmVDaXJjbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgaW5kZXhBY3RpdmVEYXRhUG9pbnQgPSB0aGlzLmRhdGEuc2VyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkLm5hbWU7XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbCAmJiBfdGhpcy52aXNpYmxlVmFsdWUgJiYgbGFiZWwudG9TdHJpbmcoKSA9PT0gX3RoaXMudmlzaWJsZVZhbHVlLnRvU3RyaW5nKCkgJiYgZC52YWx1ZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpbmRleEFjdGl2ZURhdGFQb2ludCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gTm8gdmFsaWQgcG9pbnQgaXMgJ2FjdGl2ZS9ob3ZlcmVkIG92ZXInIGF0IHRoaXMgbW9tZW50LlxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tYXBEYXRhUG9pbnRUb0NpcmNsZSh0aGlzLmRhdGEuc2VyaWVzW2luZGV4QWN0aXZlRGF0YVBvaW50XSwgaW5kZXhBY3RpdmVEYXRhUG9pbnQpO1xyXG4gICAgfTtcclxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubWFwRGF0YVBvaW50VG9DaXJjbGUgPSBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgIHZhciBzZXJpZXNOYW1lID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZC52YWx1ZTtcclxuICAgICAgICB2YXIgbGFiZWwgPSBkLm5hbWU7XHJcbiAgICAgICAgdmFyIHRvb2x0aXBMYWJlbCA9IGZvcm1hdExhYmVsKGxhYmVsKTtcclxuICAgICAgICB2YXIgY3g7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgY3ggPSB0aGlzLnhTY2FsZShsYWJlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICBjeCA9IHRoaXMueFNjYWxlKE51bWJlcihsYWJlbCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3ggPSB0aGlzLnhTY2FsZShsYWJlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjeSA9IHRoaXMueVNjYWxlKHRoaXMudHlwZSA9PT0gJ3N0YW5kYXJkJyA/IHZhbHVlIDogZC5kMSk7XHJcbiAgICAgICAgdmFyIHJhZGl1cyA9IDU7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMueVNjYWxlLnJhbmdlKClbMF0gLSBjeTtcclxuICAgICAgICB2YXIgb3BhY2l0eSA9IDE7XHJcbiAgICAgICAgdmFyIGNvbG9yO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdGFuZGFyZCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3IodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcihkLmQxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcihzZXJpZXNOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBkLCB7XHJcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzTmFtZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICBuYW1lOiBsYWJlbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtcImNpcmNsZS1kYXRhLVwiICsgaV0sXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICBjeDogY3gsXHJcbiAgICAgICAgICAgIGN5OiBjeSxcclxuICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICB0b29sdGlwTGFiZWw6IHRvb2x0aXBMYWJlbCxcclxuICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxyXG4gICAgICAgICAgICBzZXJpZXNOYW1lOiBzZXJpZXNOYW1lLFxyXG4gICAgICAgICAgICBncmFkaWVudFN0b3BzOiB0aGlzLmdldEdyYWRpZW50U3RvcHMoY29sb3IpLFxyXG4gICAgICAgICAgICBtaW46IGQubWluLFxyXG4gICAgICAgICAgICBtYXg6IGQubWF4XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFRvb2x0aXBUZXh0ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHRvb2x0aXBMYWJlbCA9IF9hLnRvb2x0aXBMYWJlbCwgdmFsdWUgPSBfYS52YWx1ZSwgc2VyaWVzTmFtZSA9IF9hLnNlcmllc05hbWUsIG1pbiQkMSA9IF9hLm1pbiwgbWF4JCQxID0gX2EubWF4O1xyXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIHNlcmllc05hbWUgKyBcIiBcXHUyMDIyIFwiICsgdG9vbHRpcExhYmVsICsgXCI8L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtdmFsXFxcIj5cIiArIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCkgKyB0aGlzLmdldFRvb2x0aXBNaW5NYXhUZXh0KG1pbiQkMSwgbWF4JCQxKSArIFwiPC9zcGFuPlxcbiAgICBcIjtcclxuICAgIH07XHJcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFRvb2x0aXBNaW5NYXhUZXh0ID0gZnVuY3Rpb24gKG1pbiQkMSwgbWF4JCQxKSB7XHJcbiAgICAgICAgaWYgKG1pbiQkMSAhPT0gdW5kZWZpbmVkIHx8IG1heCQkMSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAnICgnO1xyXG4gICAgICAgICAgICBpZiAobWluJCQxICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXgkJDEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAn4omlJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBtaW4kJDEudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXgkJDEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnIC0gJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtYXgkJDEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICfiiaQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXgkJDEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG1heCQkMS50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnKSc7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JhZGllbnRTdG9wcyA9IGZ1bmN0aW9uIChjb2xvcikge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwMCxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWUgPT09IGQubmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuYWN0aXZhdGVDaXJjbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5iYXJWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyBuYW1lOiB0aGlzLmRhdGEubmFtZSB9KTtcclxuICAgIH07XHJcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmRlYWN0aXZhdGVDaXJjbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5iYXJWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jaXJjbGUub3BhY2l0eSA9IDA7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyBuYW1lOiB0aGlzLmRhdGEubmFtZSB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBDb2xvckhlbHBlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBDb2xvckhlbHBlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInZpc2libGVWYWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWNpcmNsZS1zZXJpZXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyAqbmdJZj1cXFwiY2lyY2xlXFxcIj5cXG4gICAgICA8ZGVmcz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXN2Zy1saW5lYXItZ3JhZGllbnRcXG4gICAgICAgICAgb3JpZW50YXRpb249XFxcInZlcnRpY2FsXFxcIlxcbiAgICAgICAgICBbbmFtZV09XFxcImdyYWRpZW50SWRcXFwiXFxuICAgICAgICAgIFtzdG9wc109XFxcImNpcmNsZS5ncmFkaWVudFN0b3BzXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L2RlZnM+XFxuICAgICAgPHN2ZzpyZWN0XFxuICAgICAgICAqbmdJZj1cXFwiYmFyVmlzaWJsZSAmJiB0eXBlID09PSAnc3RhbmRhcmQnXFxcIlxcbiAgICAgICAgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIlxcbiAgICAgICAgW2F0dHIueF09XFxcImNpcmNsZS5jeCAtIGNpcmNsZS5yYWRpdXNcXFwiXFxuICAgICAgICBbYXR0ci55XT1cXFwiY2lyY2xlLmN5XFxcIlxcbiAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJjaXJjbGUucmFkaXVzICogMlxcXCJcXG4gICAgICAgIFthdHRyLmhlaWdodF09XFxcImNpcmNsZS5oZWlnaHRcXFwiXFxuICAgICAgICBbYXR0ci5maWxsXT1cXFwiZ3JhZGllbnRGaWxsXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcInRvb2x0aXAtYmFyXFxcIlxcbiAgICAgIC8+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLWNpcmNsZVxcbiAgICAgICAgY2xhc3M9XFxcImNpcmNsZVxcXCJcXG4gICAgICAgIFtjeF09XFxcImNpcmNsZS5jeFxcXCJcXG4gICAgICAgIFtjeV09XFxcImNpcmNsZS5jeVxcXCJcXG4gICAgICAgIFtyXT1cXFwiY2lyY2xlLnJhZGl1c1xcXCJcXG4gICAgICAgIFtmaWxsXT1cXFwiY2lyY2xlLmNvbG9yXFxcIlxcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlKHsgbmFtZTogY2lyY2xlLnNlcmllc05hbWUgfSlcXFwiXFxuICAgICAgICBbcG9pbnRlckV2ZW50c109XFxcImNpcmNsZS52YWx1ZSA9PT0gMCA/ICdub25lJyA6ICdhbGwnXFxcIlxcbiAgICAgICAgW2RhdGFdPVxcXCJjaXJjbGUudmFsdWVcXFwiXFxuICAgICAgICBbY2xhc3NOYW1lc109XFxcImNpcmNsZS5jbGFzc05hbWVzXFxcIlxcbiAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soY2lyY2xlLmRhdGEpXFxcIlxcbiAgICAgICAgKGFjdGl2YXRlKT1cXFwiYWN0aXZhdGVDaXJjbGUoKVxcXCJcXG4gICAgICAgIChkZWFjdGl2YXRlKT1cXFwiZGVhY3RpdmF0ZUNpcmNsZSgpXFxcIlxcbiAgICAgICAgbmd4LXRvb2x0aXBcXG4gICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwiJ3Rvb2x0aXAnXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IGdldFRvb2x0aXBUZXh0KGNpcmNsZSlcXFwiXFxuICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBDb250ZXh0XT1cXFwiY2lyY2xlLmRhdGFcXFwiXFxuICAgICAgLz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQ2lyY2xlU2VyaWVzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIENpcmNsZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENpcmNsZUNvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZS5vbk1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHRoaXMuZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZS5vbk1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQodGhpcy5kYXRhKTtcclxuICAgIH07XHJcbiAgICBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLmNsYXNzTmFtZXMgPSBBcnJheS5pc0FycmF5KHRoaXMuY2xhc3NOYW1lcykgP1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZXMuam9pbignICcpIDpcclxuICAgICAgICAgICAgJyc7XHJcbiAgICAgICAgdGhpcy5jbGFzc05hbWVzICs9ICdjaXJjbGUnO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY3hcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY3lcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcInN0cm9rZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcImNsYXNzTmFtZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2lyY2xlT3BhY2l0eVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb2ludGVyRXZlbnRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ2NsaWNrJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcIm9uQ2xpY2tcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUVudGVyXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcIm9uTW91c2VMZWF2ZVwiLCBudWxsKTtcclxuICAgIENpcmNsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWNpcmNsZV0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpjaXJjbGVcXG4gICAgICBbYXR0ci5jeF09XFxcImN4XFxcIlxcbiAgICAgIFthdHRyLmN5XT1cXFwiY3lcXFwiXFxuICAgICAgW2F0dHIucl09XFxcInJcXFwiXFxuICAgICAgW2F0dHIuZmlsbF09XFxcImZpbGxcXFwiXFxuICAgICAgW2F0dHIuc3Ryb2tlXT1cXFwic3Ryb2tlXFxcIlxcbiAgICAgIFthdHRyLm9wYWNpdHldPVxcXCJjaXJjbGVPcGFjaXR5XFxcIlxcbiAgICAgIFthdHRyLmNsYXNzXT1cXFwiY2xhc3NOYW1lc1xcXCJcXG4gICAgICBbYXR0ci5wb2ludGVyLWV2ZW50c109XFxcInBvaW50ZXJFdmVudHNcXFwiXFxuICAgIC8+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBDaXJjbGVDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgR3JpZFBhbmVsQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR3JpZFBhbmVsQ29tcG9uZW50KCkge1xyXG4gICAgfVxyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR3JpZFBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYXRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHcmlkUGFuZWxDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHcmlkUGFuZWxDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR3JpZFBhbmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHcmlkUGFuZWxDb21wb25lbnQucHJvdG90eXBlLCBcInlcIiwgdm9pZCAwKTtcclxuICAgIEdyaWRQYW5lbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWdyaWQtcGFuZWxdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6cmVjdFxcbiAgICAgIFthdHRyLmhlaWdodF09XFxcImhlaWdodFxcXCJcXG4gICAgICBbYXR0ci53aWR0aF09XFxcIndpZHRoXFxcIlxcbiAgICAgIFthdHRyLnhdPVxcXCJ4XFxcIlxcbiAgICAgIFthdHRyLnldPVxcXCJ5XFxcIlxcbiAgICAgIHN0cm9rZT1cXFwibm9uZVxcXCJcXG4gICAgICBjbGFzcz1cXFwiZ3JpZHBhbmVsXFxcIlxcbiAgICAvPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEdyaWRQYW5lbENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gR3JpZFBhbmVsQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudCgpIHtcclxuICAgIH1cclxuICAgIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ncmlkUGFuZWxzID0gdGhpcy5nZXRHcmlkUGFuZWxzKCk7XHJcbiAgICB9O1xyXG4gICAgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRHcmlkUGFuZWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldDtcclxuICAgICAgICAgICAgdmFyIHdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgeDtcclxuICAgICAgICAgICAgdmFyIHk7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAnb2RkJztcclxuICAgICAgICAgICAgaWYgKF90aGlzLm9yaWVudCA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gX3RoaXMueFNjYWxlKGQubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25JbmRleCA9IE51bWJlci5wYXJzZUludCgocG9zaXRpb24gLyBfdGhpcy54U2NhbGUuc3RlcCgpKS50b1N0cmluZygpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25JbmRleCAlIDIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSAnZXZlbic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfdGhpcy54U2NhbGUuYmFuZHdpZHRoKCkgKiBfdGhpcy54U2NhbGUucGFkZGluZ0lubmVyKCk7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IF90aGlzLnhTY2FsZS5iYW5kd2lkdGgoKSArIG9mZnNldDtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IF90aGlzLmRpbXMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgeCA9IF90aGlzLnhTY2FsZShkLm5hbWUpIC0gb2Zmc2V0IC8gMjtcclxuICAgICAgICAgICAgICAgIHkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm9yaWVudCA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBfdGhpcy55U2NhbGUoZC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbkluZGV4ID0gTnVtYmVyLnBhcnNlSW50KChwb3NpdGlvbiAvIF90aGlzLnlTY2FsZS5zdGVwKCkpLnRvU3RyaW5nKCksIDEwKTtcclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbkluZGV4ICUgMiA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9ICdldmVuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IF90aGlzLnlTY2FsZS5iYW5kd2lkdGgoKSAqIF90aGlzLnlTY2FsZS5wYWRkaW5nSW5uZXIoKTtcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gX3RoaXMuZGltcy53aWR0aDtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IF90aGlzLnlTY2FsZS5iYW5kd2lkdGgoKSArIG9mZnNldDtcclxuICAgICAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgeSA9IF90aGlzLnlTY2FsZShkLm5hbWUpIC0gb2Zmc2V0IC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogZC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgY2xhc3M6IGNsYXNzTmFtZSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgIHk6IHlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudFwiLCB2b2lkIDApO1xyXG4gICAgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtZ3JpZC1wYW5lbC1zZXJpZXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLWdyaWQtcGFuZWwgKm5nRm9yPVxcXCJsZXQgZ3JpZFBhbmVsIG9mIGdyaWRQYW5lbHNcXFwiXFxuICAgICAgW2hlaWdodF09XFxcImdyaWRQYW5lbC5oZWlnaHRcXFwiXFxuICAgICAgW3dpZHRoXT1cXFwiZ3JpZFBhbmVsLndpZHRoXFxcIlxcbiAgICAgIFt4XT1cXFwiZ3JpZFBhbmVsLnhcXFwiXFxuICAgICAgW3ldPVxcXCJncmlkUGFuZWwueVxcXCJcXG4gICAgICBbY2xhc3MuZ3JpZC1wYW5lbF09XFxcInRydWVcXFwiXFxuICAgICAgW2NsYXNzLm9kZF09XFxcImdyaWRQYW5lbC5jbGFzcyA9PT0gJ29kZCdcXFwiXFxuICAgICAgW2NsYXNzLmV2ZW5dPVxcXCJncmlkUGFuZWwuY2xhc3MgPT09ICdldmVuJ1xcXCI+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgU3ZnTGluZWFyR3JhZGllbnRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTdmdMaW5lYXJHcmFkaWVudENvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJztcclxuICAgIH1cclxuICAgIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy54MSA9ICcwJSc7XHJcbiAgICAgICAgdGhpcy54MiA9ICcwJSc7XHJcbiAgICAgICAgdGhpcy55MSA9ICcwJSc7XHJcbiAgICAgICAgdGhpcy55MiA9ICcwJSc7XHJcbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgICAgICB0aGlzLngyID0gJzEwMCUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgICAgIHRoaXMueTEgPSAnMTAwJSc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvcmllbnRhdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU3ZnTGluZWFyR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgU3ZnTGluZWFyR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcInN0b3BzXCIsIHZvaWQgMCk7XHJcbiAgICBTdmdMaW5lYXJHcmFkaWVudENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXN2Zy1saW5lYXItZ3JhZGllbnRdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6bGluZWFyR3JhZGllbnRcXG4gICAgICBbaWRdPVxcXCJuYW1lXFxcIlxcbiAgICAgIFthdHRyLngxXT1cXFwieDFcXFwiXFxuICAgICAgW2F0dHIueTFdPVxcXCJ5MVxcXCJcXG4gICAgICBbYXR0ci54Ml09XFxcIngyXFxcIlxcbiAgICAgIFthdHRyLnkyXT1cXFwieTJcXFwiPlxcbiAgICAgIDxzdmc6c3RvcCAqbmdGb3I9XFxcImxldCBzdG9wIG9mIHN0b3BzXFxcIlxcbiAgICAgICAgW2F0dHIub2Zmc2V0XT1cXFwic3RvcC5vZmZzZXQgKyAnJSdcXFwiXFxuICAgICAgICBbc3R5bGUuc3RvcC1jb2xvcl09XFxcInN0b3AuY29sb3JcXFwiXFxuICAgICAgICBbc3R5bGUuc3RvcC1vcGFjaXR5XT1cXFwic3RvcC5vcGFjaXR5XFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmxpbmVhckdyYWRpZW50PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50KTtcclxuICAgIHJldHVybiBTdmdMaW5lYXJHcmFkaWVudENvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMuZW5kT3BhY2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5jeCA9IDA7XHJcbiAgICAgICAgdGhpcy5jeSA9IDA7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcInN0b3BzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcHNJbnB1dCB8fCB0aGlzLnN0b3BzRGVmYXVsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcHNJbnB1dCA9IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnIgPSAnMzAlJztcclxuICAgICAgICBpZiAoKCdjb2xvcicgaW4gY2hhbmdlcykgfHxcclxuICAgICAgICAgICAgKCdzdGFydE9wYWNpdHknIGluIGNoYW5nZXMpIHx8XHJcbiAgICAgICAgICAgICgnZW5kT3BhY2l0eScgaW4gY2hhbmdlcykpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wc0RlZmF1bHQgPSBbe1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLnN0YXJ0T3BhY2l0eVxyXG4gICAgICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogMTAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMuZW5kT3BhY2l0eVxyXG4gICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydE9wYWNpdHlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJlbmRPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3hcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjeVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXldKVxyXG4gICAgXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcInN0b3BzXCIsIG51bGwpO1xyXG4gICAgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1zdmctcmFkaWFsLWdyYWRpZW50XScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOnJhZGlhbEdyYWRpZW50XFxuICAgICAgW2lkXT1cXFwibmFtZVxcXCJcXG4gICAgICBbYXR0ci5jeF09XFxcImN4XFxcIlxcbiAgICAgIFthdHRyLmN5XT1cXFwiY3lcXFwiXFxuICAgICAgW2F0dHIucl09XFxcInJcXFwiXFxuICAgICAgZ3JhZGllbnRVbml0cz1cXFwidXNlclNwYWNlT25Vc2VcXFwiPlxcbiAgICAgIDxzdmc6c3RvcCAqbmdGb3I9XFxcImxldCBzdG9wIG9mIHN0b3BzXFxcIlxcbiAgICAgICAgW2F0dHIub2Zmc2V0XT1cXFwic3RvcC5vZmZzZXQgKyAnJSdcXFwiXFxuICAgICAgICBbc3R5bGUuc3RvcC1jb2xvcl09XFxcInN0b3AuY29sb3JcXFwiXFxuICAgICAgICBbc3R5bGUuc3RvcC1vcGFjaXR5XT1cXFwic3RvcC5vcGFjaXR5XFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOnJhZGlhbEdyYWRpZW50PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50KTtcclxuICAgIHJldHVybiBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBUaW1lbGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRpbWVsaW5lKGVsZW1lbnQsIGNkKSB7XHJcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gNTA7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5vbkRvbWFpbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudC5uYXRpdmVFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgVGltZWxpbmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEJydXNoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaW1lbGluZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGltcyA9IHRoaXMuZ2V0RGltcygpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5kaW1zLmhlaWdodDtcclxuICAgICAgICB2YXIgb2Zmc2V0WSA9IHRoaXMudmlld1sxXSAtIHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xyXG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcclxuICAgICAgICBpZiAodGhpcy5icnVzaCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJydXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoMCAsIFwiICsgb2Zmc2V0WSArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMuZmlsdGVySWQgPSAnZmlsdGVyJyArIGlkKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmZpbHRlciA9IFwidXJsKCNcIiArIHRoaXMuZmlsdGVySWQgKyBcIilcIjtcclxuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgfTtcclxuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHJlc3VsdHMuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyhkLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICBkb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gTnVtYmVyKHYpOyB9KTtcclxuICAgICAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICBkb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdmFsdWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgfTtcclxuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVUaW1lKClcclxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcclxuICAgICAgICAgICAgICAgIC5kb21haW4odGhpcy54RG9tYWluKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCB0aGlzLmRpbXMud2lkdGhdKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbih0aGlzLnhEb21haW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVQb2ludCgpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuZGltcy53aWR0aF0pXHJcbiAgICAgICAgICAgICAgICAucGFkZGluZygwLjEpXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKHRoaXMueERvbWFpbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBUaW1lbGluZS5wcm90b3R5cGUuYWRkQnJ1c2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5icnVzaClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnZpZXdbMF07XHJcbiAgICAgICAgdGhpcy5icnVzaCA9IGJydXNoWCgpXHJcbiAgICAgICAgICAgIC5leHRlbnQoW1swLCAwXSwgW3dpZHRoLCBoZWlnaHRdXSlcclxuICAgICAgICAgICAgLm9uKCdicnVzaCBlbmQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBldmVudC5zZWxlY3Rpb24gfHwgX3RoaXMueFNjYWxlLnJhbmdlKCk7XHJcbiAgICAgICAgICAgIHZhciBuZXdEb21haW4gPSBzZWxlY3Rpb24ubWFwKF90aGlzLnhTY2FsZS5pbnZlcnQpO1xyXG4gICAgICAgICAgICBfdGhpcy5vbkRvbWFpbkNoYW5nZS5lbWl0KG5ld0RvbWFpbik7XHJcbiAgICAgICAgICAgIF90aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNlbGVjdCh0aGlzLmVsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoJy5icnVzaCcpXHJcbiAgICAgICAgICAgIC5jYWxsKHRoaXMuYnJ1c2gpO1xyXG4gICAgfTtcclxuICAgIFRpbWVsaW5lLnByb3RvdHlwZS51cGRhdGVCcnVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYnJ1c2gpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy52aWV3WzBdO1xyXG4gICAgICAgIHRoaXMuYnJ1c2guZXh0ZW50KFtbMCwgMF0sIFt3aWR0aCwgaGVpZ2h0XV0pO1xyXG4gICAgICAgIHNlbGVjdCh0aGlzLmVsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZWxlY3QoJy5icnVzaCcpXHJcbiAgICAgICAgICAgIC5jYWxsKHRoaXMuYnJ1c2gpO1xyXG4gICAgICAgIHNlbGVjdCh0aGlzLmVsZW1lbnQpLnNlbGVjdCgnLnNlbGVjdGlvbicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgdW5kZWZpbmVkKTtcclxuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgfTtcclxuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5nZXREaW1zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMudmlld1swXTtcclxuICAgICAgICB2YXIgZGltcyA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gZGltcztcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcInZpZXdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcInJlc3VsdHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJzY2hlbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJjdXN0b21Db2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJtaW5pQ2hhcnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJhdXRvU2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJzY2FsZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUaW1lbGluZS5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcIm9uRG9tYWluQ2hhbmdlXCIsIHZvaWQgMCk7XHJcbiAgICBUaW1lbGluZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXRpbWVsaW5lXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmdcXG4gICAgICBjbGFzcz1cXFwidGltZWxpbmVcXFwiXFxuICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIj5cXG4gICAgICA8c3ZnOmZpbHRlciBbYXR0ci5pZF09XFxcImZpbHRlcklkXFxcIj5cXG4gICAgICAgIDxzdmc6ZmVDb2xvck1hdHJpeCBpbj1cXFwiU291cmNlR3JhcGhpY1xcXCJcXG4gICAgICAgICAgICB0eXBlPVxcXCJtYXRyaXhcXFwiXFxuICAgICAgICAgICAgdmFsdWVzPVxcXCIwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwIDAgMCAxIDBcXFwiIC8+XFxuICAgICAgPC9zdmc6ZmlsdGVyPlxcbiAgICAgIDxzdmc6ZyBjbGFzcz1cXFwiZW1iZWRkZWQtY2hhcnRcXFwiPlxcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgICAgPHN2ZzpyZWN0IHg9XFxcIjBcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcInZpZXdbMF1cXFwiXFxuICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiaGVpZ2h0XFxcIlxcbiAgICAgICAgY2xhc3M9XFxcImJydXNoLWJhY2tncm91bmRcXFwiXFxuICAgICAgLz5cXG4gICAgICA8c3ZnOmcgY2xhc3M9XFxcImJydXNoXFxcIj48L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLnRpbWVsaW5lIC5icnVzaC1iYWNrZ3JvdW5ke2ZpbGw6cmdiYSgwLDAsMCwuMDUpfS50aW1lbGluZSAuYnJ1c2ggLnNlbGVjdGlvbntmaWxsOnJnYmEoMCwwLDAsLjEpO3N0cm9rZS13aWR0aDoxcHg7c3Ryb2tlOiM4ODh9LnRpbWVsaW5lIC5icnVzaCAuaGFuZGxle2ZpbGwtb3BhY2l0eTowfS50aW1lbGluZSAuZW1iZWRkZWQtY2hhcnR7b3BhY2l0eTouNn1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0LCB0eXBlb2YgKF9iID0gdHlwZW9mIENoYW5nZURldGVjdG9yUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIENoYW5nZURldGVjdG9yUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3RdKVxyXG4gICAgXSwgVGltZWxpbmUpO1xyXG4gICAgcmV0dXJuIFRpbWVsaW5lO1xyXG59KCkpO1xyXG5cclxudmFyIEFyZWFDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBcmVhQ29tcG9uZW50KGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMuc3RhcnRPcGFjaXR5ID0gMC41O1xyXG4gICAgICAgIHRoaXMuZW5kT3BhY2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaGFzR3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBBcmVhQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZEFuaW1hdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFyZWFDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmdyYWRpZW50SWQgPSAnZ3JhZCcgKyBpZCgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudEZpbGwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcclxuICAgICAgICBpZiAodGhpcy5ncmFkaWVudCB8fCB0aGlzLnN0b3BzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IHRoaXMuZ2V0R3JhZGllbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlUGF0aEVsKCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUubG9hZEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFyZWFQYXRoID0gdGhpcy5zdGFydGluZ1BhdGg7XHJcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpLCAxMDApO1xyXG4gICAgfTtcclxuICAgIEFyZWFDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVBhdGhFbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpLnNlbGVjdCgnLmFyZWEnKTtcclxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25zKSB7XHJcbiAgICAgICAgICAgIG5vZGUudHJhbnNpdGlvbigpLmR1cmF0aW9uKDc1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgdGhpcy5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUuYXR0cignZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFyZWFDb21wb25lbnQucHJvdG90eXBlLmdldEdyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0b3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3BzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5maWxsLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5zdGFydE9wYWNpdHlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxMDAsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5maWxsLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5lbmRPcGFjaXR5XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcInBhdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXJ0aW5nUGF0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlbmRPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcInN0b3BzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgQXJlYUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWFyZWFdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZGVmcyAqbmdJZj1cXFwiZ3JhZGllbnRcXFwiPlxcbiAgICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLXN2Zy1saW5lYXItZ3JhZGllbnRcXG4gICAgICAgIG9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCJcXG4gICAgICAgIFtuYW1lXT1cXFwiZ3JhZGllbnRJZFxcXCJcXG4gICAgICAgIFtzdG9wc109XFxcImdyYWRpZW50U3RvcHNcXFwiXFxuICAgICAgLz5cXG4gICAgPC9zdmc6ZGVmcz5cXG4gICAgPHN2ZzpwYXRoXFxuICAgICAgY2xhc3M9XFxcImFyZWFcXFwiXFxuICAgICAgW2F0dHIuZF09XFxcImFyZWFQYXRoXFxcIlxcbiAgICAgIFthdHRyLmZpbGxdPVxcXCJncmFkaWVudCA/IGdyYWRpZW50RmlsbCA6IGZpbGxcXFwiXFxuICAgICAgW3N0eWxlLm9wYWNpdHldPVxcXCJvcGFjaXR5XFxcIlxcbiAgICAvPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcclxuICAgIF0sIEFyZWFDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEFyZWFDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG4vLyBJZiB3ZSBkb24ndCBjaGVjayB3aGV0aGVyICd3aW5kb3cnIGFuZCAnZ2xvYmFsJyB2YXJpYWJsZXMgYXJlIGRlZmluZWQsXHJcbi8vIGNvZGUgd2lsbCBmYWlsIGluIGJyb3dzZXIvbm9kZSB3aXRoICd2YXJpYWJsZSBpcyB1bmRlZmluZWQnIGVycm9yLlxyXG52YXIgcm9vdDtcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByb290ID0gd2luZG93O1xyXG59XHJcbmVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByb290ID0gZ2xvYmFsO1xyXG59XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lXHJcbnZhciBNb3VzZUV2ZW50ID0gcm9vdC5Nb3VzZUV2ZW50O1xyXG5mdW5jdGlvbiBjcmVhdGVNb3VzZUV2ZW50KG5hbWUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHtcclxuICAgIGlmIChidWJibGVzID09PSB2b2lkIDApIHsgYnViYmxlcyA9IGZhbHNlOyB9XHJcbiAgICBpZiAoY2FuY2VsYWJsZSA9PT0gdm9pZCAwKSB7IGNhbmNlbGFibGUgPSB0cnVlOyB9XHJcbiAgICAvLyBDYWxsaW5nIG5ldyBvZiBhbiBldmVudCBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSBvbiBJRS4gVGhlIGZvbGxvd2luZyBpcyBhIHRlc3RlZCB3b3JrYXJvdW5kXHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjcxNzY5ODMvZGlzcGF0Y2hldmVudC1ub3Qtd29ya2luZy1pbi1pZTExXHJcbiAgICBpZiAodHlwZW9mIChNb3VzZUV2ZW50KSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIFNhbmUgYnJvd3NlcnNcclxuICAgICAgICByZXR1cm4gbmV3IE1vdXNlRXZlbnQobmFtZSwgeyBidWJibGVzOiBidWJibGVzLCBjYW5jZWxhYmxlOiBjYW5jZWxhYmxlIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gSUVcclxuICAgICAgICB2YXIgZXZlbnQkJDEgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xyXG4gICAgICAgIGV2ZW50JCQxLmluaXRFdmVudChuYW1lLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcclxuICAgICAgICByZXR1cm4gZXZlbnQkJDE7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBUb29sdGlwQXJlYSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRvb2x0aXBBcmVhKCkge1xyXG4gICAgICAgIHRoaXMuYW5jaG9yT3BhY2l0eSA9IDA7XHJcbiAgICAgICAgdGhpcy5hbmNob3JQb3MgPSAtMTtcclxuICAgICAgICB0aGlzLmFuY2hvclZhbHVlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc2hvd1BlcmNlbnRhZ2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaG92ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBUb29sdGlwQXJlYS5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKHhWYWwpIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBncm91cC5zZXJpZXMuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lLnRvU3RyaW5nKCkgPT09IHhWYWwudG9TdHJpbmcoKTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBncm91cE5hbWUgPSBncm91cC5uYW1lO1xyXG4gICAgICAgICAgICBpZiAoZ3JvdXBOYW1lIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBOYW1lID0gZ3JvdXBOYW1lLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gaXRlbS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3dQZXJjZW50YWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gKGl0ZW0uZDEgLSBpdGVtLmQwKS50b0ZpeGVkKDIpICsgJyUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5kMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gaXRlbS5kMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcih2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3IoZ3JvdXAubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0sIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGxhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlcmllczogZ3JvdXBOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbjogaXRlbS5taW4sXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBpdGVtLm1heCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxuICAgIFRvb2x0aXBBcmVhLnByb3RvdHlwZS5tb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQkJDEpIHtcclxuICAgICAgICB2YXIgeFBvcyA9IGV2ZW50JCQxLnBhZ2VYIC0gZXZlbnQkJDEudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XHJcbiAgICAgICAgdmFyIGNsb3Nlc3RJbmRleCA9IHRoaXMuZmluZENsb3Nlc3RQb2ludEluZGV4KHhQb3MpO1xyXG4gICAgICAgIHZhciBjbG9zZXN0UG9pbnQgPSB0aGlzLnhTZXRbY2xvc2VzdEluZGV4XTtcclxuICAgICAgICB0aGlzLmFuY2hvclBvcyA9IHRoaXMueFNjYWxlKGNsb3Nlc3RQb2ludCk7XHJcbiAgICAgICAgdGhpcy5hbmNob3JQb3MgPSBNYXRoLm1heCgwLCB0aGlzLmFuY2hvclBvcyk7XHJcbiAgICAgICAgdGhpcy5hbmNob3JQb3MgPSBNYXRoLm1pbih0aGlzLmRpbXMud2lkdGgsIHRoaXMuYW5jaG9yUG9zKTtcclxuICAgICAgICB0aGlzLmFuY2hvclZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKGNsb3Nlc3RQb2ludCk7XHJcbiAgICAgICAgaWYgKHRoaXMuYW5jaG9yUG9zICE9PSB0aGlzLmxhc3RBbmNob3JQb3MpIHtcclxuICAgICAgICAgICAgdmFyIGV2ID0gY3JlYXRlTW91c2VFdmVudCgnbW91c2VsZWF2ZScpO1xyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBBbmNob3IubmF0aXZlRWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2KTtcclxuICAgICAgICAgICAgdGhpcy5hbmNob3JPcGFjaXR5ID0gMC43O1xyXG4gICAgICAgICAgICB0aGlzLmhvdmVyLmVtaXQoe1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNsb3Nlc3RQb2ludFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zaG93VG9vbHRpcCgpO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RBbmNob3JQb3MgPSB0aGlzLmFuY2hvclBvcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcEFyZWEucHJvdG90eXBlLmZpbmRDbG9zZXN0UG9pbnRJbmRleCA9IGZ1bmN0aW9uICh4UG9zKSB7XHJcbiAgICAgICAgdmFyIG1pbkluZGV4ID0gMDtcclxuICAgICAgICB2YXIgbWF4SW5kZXggPSB0aGlzLnhTZXQubGVuZ3RoIC0gMTtcclxuICAgICAgICB2YXIgbWluRGlmZiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgdmFyIGNsb3Nlc3RJbmRleCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50SW5kZXggPSAoKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMikgfCAwO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSB0aGlzLnhTY2FsZSh0aGlzLnhTZXRbY3VycmVudEluZGV4XSk7XHJcbiAgICAgICAgICAgIHZhciBjdXJEaWZmID0gTWF0aC5hYnMoY3VycmVudEVsZW1lbnQgLSB4UG9zKTtcclxuICAgICAgICAgICAgaWYgKGN1ckRpZmYgPCBtaW5EaWZmKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5EaWZmID0gY3VyRGlmZjtcclxuICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGN1cnJlbnRJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudEVsZW1lbnQgPCB4UG9zKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudEVsZW1lbnQgPiB4UG9zKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtaW5EaWZmID0gMDtcclxuICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGN1cnJlbnRJbmRleDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9zZXN0SW5kZXg7XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcEFyZWEucHJvdG90eXBlLnNob3dUb29sdGlwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBldmVudCQkMSA9IGNyZWF0ZU1vdXNlRXZlbnQoJ21vdXNlZW50ZXInKTtcclxuICAgICAgICB0aGlzLnRvb2x0aXBBbmNob3IubmF0aXZlRWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50JCQxKTtcclxuICAgIH07XHJcbiAgICBUb29sdGlwQXJlYS5wcm90b3R5cGUuaGlkZVRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50JCQxID0gY3JlYXRlTW91c2VFdmVudCgnbW91c2VsZWF2ZScpO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcEFuY2hvci5uYXRpdmVFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQkJDEpO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yT3BhY2l0eSA9IDA7XHJcbiAgICAgICAgdGhpcy5sYXN0QW5jaG9yUG9zID0gLTE7XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcEFyZWEucHJvdG90eXBlLmdldFRvb2xUaXBUZXh0ID0gZnVuY3Rpb24gKHRvb2x0aXBJdGVtKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIGlmICh0b29sdGlwSXRlbS5zZXJpZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gdG9vbHRpcEl0ZW0uc2VyaWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICc/Pz8nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgKz0gJzogJztcclxuICAgICAgICBpZiAodG9vbHRpcEl0ZW0udmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gdG9vbHRpcEl0ZW0udmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvb2x0aXBJdGVtLm1pbiAhPT0gdW5kZWZpbmVkIHx8IHRvb2x0aXBJdGVtLm1heCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnICgnO1xyXG4gICAgICAgICAgICBpZiAodG9vbHRpcEl0ZW0ubWluICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwSXRlbS5tYXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAn4omlJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0b29sdGlwSXRlbS5taW4udG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwSXRlbS5tYXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnIC0gJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0b29sdGlwSXRlbS5tYXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICfiiaQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0b29sdGlwSXRlbS5tYXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRvb2x0aXBJdGVtLm1heC50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnKSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcEFyZWEucHJvdG90eXBlLCBcImRpbXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBBcmVhLnByb3RvdHlwZSwgXCJ4U2V0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwieFNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwicmVzdWx0c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcEFyZWEucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFRvb2x0aXBBcmVhLnByb3RvdHlwZSwgXCJzaG93UGVyY2VudGFnZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFRvb2x0aXBBcmVhLnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBBcmVhLnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwiaG92ZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFZpZXdDaGlsZCgndG9vbHRpcEFuY2hvcicsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcEFyZWEucHJvdG90eXBlLCBcInRvb2x0aXBBbmNob3JcIiwgdm9pZCAwKTtcclxuICAgIFRvb2x0aXBBcmVhID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtdG9vbHRpcC1hcmVhXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmc+XFxuICAgICAgPHN2ZzpyZWN0XFxuICAgICAgICBjbGFzcz1cXFwidG9vbHRpcC1hcmVhXFxcIlxcbiAgICAgICAgW2F0dHIueF09XFxcIjBcXFwiXFxuICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJkaW1zLndpZHRoXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiZGltcy5oZWlnaHRcXFwiXFxuICAgICAgICBzdHlsZT1cXFwib3BhY2l0eTogMDsgY3Vyc29yOiAnYXV0byc7XFxcIlxcbiAgICAgICAgKG1vdXNlbW92ZSk9XFxcIm1vdXNlTW92ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgKG1vdXNlbGVhdmUpPVxcXCJoaWRlVG9vbHRpcCgpXFxcIlxcbiAgICAgIC8+XFxuICAgICAgPHhodG1sOm5nLXRlbXBsYXRlICNkZWZhdWx0VG9vbHRpcFRlbXBsYXRlIGxldC1tb2RlbD1cXFwibW9kZWxcXFwiPlxcbiAgICAgICAgPHhodG1sOmRpdiBjbGFzcz1cXFwiYXJlYS10b29sdGlwLWNvbnRhaW5lclxcXCI+XFxuICAgICAgICAgIDx4aHRtbDpkaXYgKm5nRm9yPVxcXCJsZXQgdG9vbHRpcEl0ZW0gb2YgbW9kZWxcXFwiIGNsYXNzPVxcXCJ0b29sdGlwLWl0ZW1cXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWl0ZW0tY29sb3JcXFwiIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cXFwidG9vbHRpcEl0ZW0uY29sb3JcXFwiPiA8L3NwYW4+XFxuICAgICAgICAgICAge3sgZ2V0VG9vbFRpcFRleHQodG9vbHRpcEl0ZW0pIH19XFxuICAgICAgICAgIDwveGh0bWw6ZGl2PlxcbiAgICAgICAgPC94aHRtbDpkaXY+XFxuICAgICAgPC94aHRtbDpuZy10ZW1wbGF0ZT5cXG4gICAgICA8c3ZnOnJlY3RcXG4gICAgICAgICN0b29sdGlwQW5jaG9yXFxuICAgICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiYW5jaG9yT3BhY2l0eSAhPT0gMCA/ICdhY3RpdmUnIDogJ2luYWN0aXZlJ1xcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJ0b29sdGlwLWFuY2hvclxcXCJcXG4gICAgICAgIFthdHRyLnhdPVxcXCJhbmNob3JQb3NcXFwiXFxuICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgW2F0dHIud2lkdGhdPVxcXCIxXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiZGltcy5oZWlnaHRcXFwiXFxuICAgICAgICBbc3R5bGUub3BhY2l0eV09XFxcImFuY2hvck9wYWNpdHlcXFwiXFxuICAgICAgICBbc3R5bGUucG9pbnRlci1ldmVudHNdPVxcXCInbm9uZSdcXFwiXFxuICAgICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cXFwiJ3JpZ2h0J1xcXCJcXG4gICAgICAgIFt0b29sdGlwVHlwZV09XFxcIid0b29sdGlwJ1xcXCJcXG4gICAgICAgIFt0b29sdGlwU3BhY2luZ109XFxcIjE1XFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZSA/IHRvb2x0aXBUZW1wbGF0ZSA6IGRlZmF1bHRUb29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJhbmNob3JWYWx1ZXNcXFwiXFxuICAgICAgICBbdG9vbHRpcEltbWVkaWF0ZUV4aXRdPVxcXCJ0cnVlXFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ2luYWN0aXZlID0+IGFjdGl2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgyNTAsIHN0eWxlKHsgb3BhY2l0eTogMC43IH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ2FjdGl2ZSA9PiBpbmFjdGl2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC43XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFRvb2x0aXBBcmVhKTtcclxuICAgIHJldHVybiBUb29sdGlwQXJlYTtcclxufSgpKTtcclxuXHJcbi8vIFJvYmVydCBQZW5uZXIncyBlYXNlT3V0RXhwb1xyXG5mdW5jdGlvbiBlYXNlT3V0RXhwbyh0LCBiLCBjLCBkKSB7XHJcbiAgICByZXR1cm4gKGMgKiAoLU1hdGgucG93KDIsICgtMTAgKiB0KSAvIGQpICsgMSkgKiAxMDI0KSAvIDEwMjMgKyBiO1xyXG59XHJcbi8qKlxyXG4gKiBDb3VudHMgZnJvbSBhIG51bWJlciB0byB0aGUgZW5kIGluY3JlbWVudGFsbHkuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHthbnl9IGNvdW50RnJvbVxyXG4gKiBAcGFyYW0ge2FueX0gY291bnRUb1xyXG4gKiBAcGFyYW0ge2FueX0gY291bnREZWNpbWFsc1xyXG4gKiBAcGFyYW0ge2FueX0gY291bnREdXJhdGlvblxyXG4gKiBAcGFyYW0ge2FueX0gY2FsbGJhY2tcclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIGNvdW50KGNvdW50RnJvbSwgY291bnRUbywgY291bnREZWNpbWFscywgY291bnREdXJhdGlvbiwgY2FsbGJhY2spIHtcclxuICAgIHZhciBzdGFydFZhbCA9IE51bWJlcihjb3VudEZyb20pO1xyXG4gICAgdmFyIGVuZFZhbCA9IE51bWJlcihjb3VudFRvKTtcclxuICAgIHZhciBjb3VudERvd24gPSBzdGFydFZhbCA+IGVuZFZhbDtcclxuICAgIHZhciBkZWNpbWFscyA9IE1hdGgubWF4KDAsIGNvdW50RGVjaW1hbHMpO1xyXG4gICAgdmFyIGRlYyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XHJcbiAgICB2YXIgZHVyYXRpb24gPSBOdW1iZXIoY291bnREdXJhdGlvbikgKiAxMDAwO1xyXG4gICAgdmFyIHN0YXJ0VGltZTtcclxuICAgIGZ1bmN0aW9uIHJ1bkNvdW50KHRpbWVzdGFtcCkge1xyXG4gICAgICAgIHZhciBmcmFtZVZhbDtcclxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB0aW1lc3RhbXAgLSBzdGFydFRpbWU7XHJcbiAgICAgICAgaWYgKGNvdW50RG93bikge1xyXG4gICAgICAgICAgICBmcmFtZVZhbCA9IHN0YXJ0VmFsIC0gZWFzZU91dEV4cG8ocHJvZ3Jlc3MsIDAsIHN0YXJ0VmFsIC0gZW5kVmFsLCBkdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmcmFtZVZhbCA9IGVhc2VPdXRFeHBvKHByb2dyZXNzLCBzdGFydFZhbCwgZW5kVmFsIC0gc3RhcnRWYWwsIGR1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvdW50RG93bikge1xyXG4gICAgICAgICAgICBmcmFtZVZhbCA9IGZyYW1lVmFsIDwgZW5kVmFsID8gZW5kVmFsIDogZnJhbWVWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmcmFtZVZhbCA9IGZyYW1lVmFsID4gZW5kVmFsID8gZW5kVmFsIDogZnJhbWVWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZyYW1lVmFsID0gTWF0aC5yb3VuZChmcmFtZVZhbCAqIGRlYykgLyBkZWM7XHJcbiAgICAgICAgdmFyIHRpY2sgPSBwcm9ncmVzcyA8IGR1cmF0aW9uO1xyXG4gICAgICAgIGNhbGxiYWNrKHtcclxuICAgICAgICAgICAgdmFsdWU6IGZyYW1lVmFsLFxyXG4gICAgICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxyXG4gICAgICAgICAgICBmaW5pc2hlZDogIXRpY2tcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGljaykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHJ1bkNvdW50KHZhbCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xyXG4gICAgICAgIHN0YXJ0VGltZSA9IHRpbWVzdGFtcDtcclxuICAgICAgICByZXR1cm4gcnVuQ291bnQodGltZXN0YW1wKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgZGVjaW1hbHMgcGxhY2VzXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHthbnl9IGNvdW50VG9cclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIGRlY2ltYWxDaGVja2VyKGNvdW50VG8pIHtcclxuICAgIHZhciBlbmRWYWwgPSBOdW1iZXIoY291bnRUbyk7XHJcbiAgICBpZiAoZW5kVmFsICUgMSAhPT0gMCAmJiBNYXRoLmFicyhlbmRWYWwpIDw9IDEwKSB7XHJcbiAgICAgICAgcmV0dXJuIDI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvdW50IHVwIGNvbXBvbmVudFxyXG4gKlxyXG4gKiBMb29zZWx5IGluc3BpcmVkIGJ5OlxyXG4gKiAgLSBodHRwczovL2dpdGh1Yi5jb20vaXp1cGV0L2FuZ3VsYXIyLWNvdW50b1xyXG4gKiAgLSBodHRwczovL2lub3JnYW5pay5naXRodWIuaW8vY291bnRVcC5qcy9cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgQ291bnRVcERpcmVjdGl2ZVxyXG4gKi9cclxudmFyIENvdW50VXBEaXJlY3RpdmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb3VudFVwRGlyZWN0aXZlKGNkLCBlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xyXG4gICAgICAgIHRoaXMuY291bnREdXJhdGlvbiA9IDE7XHJcbiAgICAgICAgdGhpcy5jb3VudFByZWZpeCA9ICcnO1xyXG4gICAgICAgIHRoaXMuY291bnRTdWZmaXggPSAnJztcclxuICAgICAgICB0aGlzLmNvdW50Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuY291bnRGaW5pc2ggPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xyXG4gICAgICAgIHRoaXMuX2NvdW50RGVjaW1hbHMgPSAwO1xyXG4gICAgICAgIHRoaXMuX2NvdW50VG8gPSAwO1xyXG4gICAgICAgIHRoaXMuX2NvdW50RnJvbSA9IDA7XHJcbiAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50ID0gZWxlbWVudC5uYXRpdmVFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvdW50RGVjaW1hbHNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY291bnREZWNpbWFscylcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb3VudERlY2ltYWxzO1xyXG4gICAgICAgICAgICByZXR1cm4gZGVjaW1hbENoZWNrZXIodGhpcy5jb3VudFRvKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb3VudERlY2ltYWxzID0gdmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvdW50VG9cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY291bnRUbztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb3VudFRvID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnRGcm9tXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50RnJvbTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb3VudEZyb20gPSBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uUmVxKTtcclxuICAgIH07XHJcbiAgICBDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uUmVxKTtcclxuICAgICAgICB2YXIgdmFsdWVGb3JtYXR0aW5nID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcgfHwgKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gXCJcIiArIF90aGlzLmNvdW50UHJlZml4ICsgdmFsdWUudG9Mb2NhbGVTdHJpbmcoKSArIF90aGlzLmNvdW50U3VmZml4OyB9KTtcclxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWUsIHByb2dyZXNzID0gX2EucHJvZ3Jlc3MsIGZpbmlzaGVkID0gX2EuZmluaXNoZWQ7XHJcbiAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWVGb3JtYXR0aW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgX3RoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgICAgICAgIGlmICghZmluaXNoZWQpXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jb3VudENoYW5nZS5lbWl0KHsgdmFsdWU6IF90aGlzLnZhbHVlLCBwcm9ncmVzczogcHJvZ3Jlc3MgfSk7XHJcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZClcclxuICAgICAgICAgICAgICAgIF90aGlzLmNvdW50RmluaXNoLmVtaXQoeyB2YWx1ZTogX3RoaXMudmFsdWUsIHByb2dyZXNzOiBwcm9ncmVzcyB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uUmVxID0gY291bnQodGhpcy5jb3VudEZyb20sIHRoaXMuY291bnRUbywgdGhpcy5jb3VudERlY2ltYWxzLCB0aGlzLmNvdW50RHVyYXRpb24sIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnREdXJhdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnRQcmVmaXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvdW50U3VmZml4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxyXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnREZWNpbWFsc1wiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxyXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnRUb1wiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxyXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnRGcm9tXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvdW50Q2hhbmdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnRGaW5pc2hcIiwgdm9pZCAwKTtcclxuICAgIENvdW50VXBEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ3gtY2hhcnRzLWNvdW50LXVwXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcInt7dmFsdWV9fVwiXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIENoYW5nZURldGVjdG9yUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIENoYW5nZURldGVjdG9yUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3RdKVxyXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZSk7XHJcbiAgICByZXR1cm4gQ291bnRVcERpcmVjdGl2ZTtcclxufSgpKTtcclxuXHJcbnZhciBDT01QT05FTlRTID0gW1xyXG4gICAgQXJlYUNvbXBvbmVudCxcclxuICAgIEJhc2VDaGFydENvbXBvbmVudCxcclxuICAgIENvdW50VXBEaXJlY3RpdmUsXHJcbiAgICBUb29sdGlwQXJlYSxcclxuICAgIENoYXJ0Q29tcG9uZW50LFxyXG4gICAgTGVnZW5kQ29tcG9uZW50LFxyXG4gICAgTGVnZW5kRW50cnlDb21wb25lbnQsXHJcbiAgICBTY2FsZUxlZ2VuZENvbXBvbmVudCxcclxuICAgIENpcmNsZUNvbXBvbmVudCxcclxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudCxcclxuICAgIEdyaWRQYW5lbENvbXBvbmVudCxcclxuICAgIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudCxcclxuICAgIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50LFxyXG4gICAgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQsXHJcbiAgICBUaW1lbGluZSxcclxuICAgIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50XHJcbl07XHJcbnZhciBDaGFydENvbW1vbk1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENoYXJ0Q29tbW9uTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgQ2hhcnRDb21tb25Nb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcclxuICAgICAgICAgICAgICAgIEF4ZXNNb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBUb29sdGlwTW9kdWxlXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogQ09NUE9ORU5UUy5zbGljZSgpLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBBeGVzTW9kdWxlLFxyXG4gICAgICAgICAgICAgICAgVG9vbHRpcE1vZHVsZVxyXG4gICAgICAgICAgICBdLmNvbmNhdChDT01QT05FTlRTKVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBDaGFydENvbW1vbk1vZHVsZSk7XHJcbiAgICByZXR1cm4gQ2hhcnRDb21tb25Nb2R1bGU7XHJcbn0oKSk7XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyhfYSkge1xyXG4gICAgdmFyIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodCwgbWFyZ2lucyA9IF9hLm1hcmdpbnMsIF9iID0gX2Euc2hvd1hBeGlzLCBzaG93WEF4aXMgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgX2MgPSBfYS5zaG93WUF4aXMsIHNob3dZQXhpcyA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IF9hLnhBeGlzSGVpZ2h0LCB4QXhpc0hlaWdodCA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsIF9lID0gX2EueUF4aXNXaWR0aCwgeUF4aXNXaWR0aCA9IF9lID09PSB2b2lkIDAgPyAwIDogX2UsIF9mID0gX2Euc2hvd1hMYWJlbCwgc2hvd1hMYWJlbCA9IF9mID09PSB2b2lkIDAgPyBmYWxzZSA6IF9mLCBfZyA9IF9hLnNob3dZTGFiZWwsIHNob3dZTGFiZWwgPSBfZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZywgX2ggPSBfYS5zaG93TGVnZW5kLCBzaG93TGVnZW5kID0gX2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX2gsIF9qID0gX2EubGVnZW5kVHlwZSwgbGVnZW5kVHlwZSA9IF9qID09PSB2b2lkIDAgPyAnb3JkaW5hbCcgOiBfaiwgX2sgPSBfYS5sZWdlbmRQb3NpdGlvbiwgbGVnZW5kUG9zaXRpb24gPSBfayA9PT0gdm9pZCAwID8gJ3JpZ2h0JyA6IF9rLCBfbCA9IF9hLmNvbHVtbnMsIGNvbHVtbnMgPSBfbCA9PT0gdm9pZCAwID8gMTIgOiBfbDtcclxuICAgIHZhciB4T2Zmc2V0ID0gbWFyZ2luc1szXTtcclxuICAgIHZhciBjaGFydFdpZHRoID0gd2lkdGg7XHJcbiAgICB2YXIgY2hhcnRIZWlnaHQgPSBoZWlnaHQgLSBtYXJnaW5zWzBdIC0gbWFyZ2luc1syXTtcclxuICAgIGlmIChzaG93TGVnZW5kICYmIGxlZ2VuZFBvc2l0aW9uID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgaWYgKGxlZ2VuZFR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBjb2x1bW5zIC09IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb2x1bW5zIC09IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2hhcnRXaWR0aCA9IGNoYXJ0V2lkdGggKiBjb2x1bW5zIC8gMTI7XHJcbiAgICBjaGFydFdpZHRoID0gY2hhcnRXaWR0aCAtIG1hcmdpbnNbMV0gLSBtYXJnaW5zWzNdO1xyXG4gICAgaWYgKHNob3dYQXhpcykge1xyXG4gICAgICAgIGNoYXJ0SGVpZ2h0IC09IDU7XHJcbiAgICAgICAgY2hhcnRIZWlnaHQgLT0geEF4aXNIZWlnaHQ7XHJcbiAgICAgICAgaWYgKHNob3dYTGFiZWwpIHtcclxuICAgICAgICAgICAgLy8gdGV4dCBoZWlnaHQgKyBzcGFjaW5nIGJldHdlZW4gYXhpcyBsYWJlbCBhbmQgdGljayBsYWJlbHNcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDI1ICsgNTtcclxuICAgICAgICAgICAgY2hhcnRIZWlnaHQgLT0gb2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzaG93WUF4aXMpIHtcclxuICAgICAgICBjaGFydFdpZHRoIC09IDU7XHJcbiAgICAgICAgY2hhcnRXaWR0aCAtPSB5QXhpc1dpZHRoO1xyXG4gICAgICAgIHhPZmZzZXQgKz0geUF4aXNXaWR0aDtcclxuICAgICAgICB4T2Zmc2V0ICs9IDEwO1xyXG4gICAgICAgIGlmIChzaG93WUxhYmVsKSB7XHJcbiAgICAgICAgICAgIC8vIHRleHQgaGVpZ2h0ICsgc3BhY2luZyBiZXR3ZWVuIGF4aXMgbGFiZWwgYW5kIHRpY2sgbGFiZWxzXHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAyNSArIDU7XHJcbiAgICAgICAgICAgIGNoYXJ0V2lkdGggLT0gb2Zmc2V0O1xyXG4gICAgICAgICAgICB4T2Zmc2V0ICs9IG9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjaGFydFdpZHRoID0gTWF0aC5tYXgoMCwgY2hhcnRXaWR0aCk7XHJcbiAgICBjaGFydEhlaWdodCA9IE1hdGgubWF4KDAsIGNoYXJ0SGVpZ2h0KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgd2lkdGg6IE1hdGguZmxvb3IoY2hhcnRXaWR0aCksXHJcbiAgICAgICAgaGVpZ2h0OiBNYXRoLmZsb29yKGNoYXJ0SGVpZ2h0KSxcclxuICAgICAgICB4T2Zmc2V0OiBNYXRoLmZsb29yKHhPZmZzZXQpXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQmFzZWQgb24gdGhlIGRhdGEsIHJldHVybiBhbiBhcnJheSB3aXRoIHVuaXF1ZSB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHJldHVybnMgYXJyYXlcclxuICogQHBhcmFtIHJlc3VsdHNcclxuICovXHJcbmZ1bmN0aW9uIGdldFVuaXF1ZVhEb21haW5WYWx1ZXMocmVzdWx0cykge1xyXG4gICAgdmFyIHZhbHVlU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCByZXN1bHRzXzEgPSByZXN1bHRzOyBfaSA8IHJlc3VsdHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0c18xW19pXTtcclxuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gcmVzdWx0LnNlcmllczsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICAgICAgdmFyIGQgPSBfYltfYV07XHJcbiAgICAgICAgICAgIHZhbHVlU2V0LmFkZChkLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlU2V0KTtcclxufVxyXG4vKipcclxuICogR2V0IHRoZSBzY2FsZVR5cGUgb2YgZW51bWVyYWJsZSBvZiB2YWx1ZXMuXHJcbiAqIEBwYXJhbSB2YWx1ZXNcclxuICogQHJldHVybnMge3N0cmluZ30gJ3RpbWUnLCAnbGluZWFyJyBvciAnb3JkaW5hbCdcclxuICovXHJcbmZ1bmN0aW9uIGdldFNjYWxlVHlwZSh2YWx1ZXMsIGNoZWNrRGF0ZVR5cGUpIHtcclxuICAgIGlmIChjaGVja0RhdGVUeXBlID09PSB2b2lkIDApIHsgY2hlY2tEYXRlVHlwZSA9IHRydWU7IH1cclxuICAgIGlmIChjaGVja0RhdGVUeXBlKSB7XHJcbiAgICAgICAgdmFyIGFsbERhdGVzID0gdmFsdWVzLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlOyB9KTtcclxuICAgICAgICBpZiAoYWxsRGF0ZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd0aW1lJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgYWxsTnVtYmVycyA9IHZhbHVlcy5ldmVyeShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7IH0pO1xyXG4gICAgaWYgKGFsbE51bWJlcnMpIHtcclxuICAgICAgICByZXR1cm4gJ2xpbmVhcic7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ29yZGluYWwnO1xyXG59XHJcblxyXG52YXIgQXJlYUNoYXJ0Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFyZWFDaGFydENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFyZWFDaGFydENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy5iYXNlVmFsdWUgPSAnYXV0byc7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuY3VydmUgPSBjdXJ2ZUxpbmVhcjtcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xyXG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xyXG4gICAgICAgIF90aGlzLnRpbWVsaW5lSGVpZ2h0ID0gNTA7XHJcbiAgICAgICAgX3RoaXMudGltZWxpbmVQYWRkaW5nID0gMTA7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5kaW1zLmhlaWdodCAtPSB0aGlzLnRpbWVsaW5lSGVpZ2h0ICsgdGhpcy5tYXJnaW5bMl0gKyB0aGlzLnRpbWVsaW5lUGFkZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWREb21haW4pIHtcclxuICAgICAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5maWx0ZXJlZERvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy55RG9tYWluID0gdGhpcy5nZXRZRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5zZXJpZXNEb21haW4gPSB0aGlzLmdldFNlcmllc0RvbWFpbigpO1xyXG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUodGhpcy54RG9tYWluLCB0aGlzLmRpbXMud2lkdGgpO1xyXG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUodGhpcy55RG9tYWluLCB0aGlzLmRpbXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVsaW5lKCk7XHJcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMuY2xpcFBhdGhJZCA9ICdjbGlwJyArIGlkKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmNsaXBQYXRoID0gXCJ1cmwoI1wiICsgdGhpcy5jbGlwUGF0aElkICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVUaW1lbGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lbGluZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lV2lkdGggPSB0aGlzLmRpbXMud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVYRG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVYU2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnRpbWVsaW5lWERvbWFpbiwgdGhpcy50aW1lbGluZVdpZHRoKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy50aW1lbGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIsIFwiICsgLXRoaXMubWFyZ2luWzJdICsgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0VW5pcXVlWERvbWFpblZhbHVlcyh0aGlzLnJlc3VsdHMpO1xyXG4gICAgICAgIHRoaXMuc2NhbGVUeXBlID0gZ2V0U2NhbGVUeXBlKHZhbHVlcyk7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gTnVtYmVyKHYpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pbiQkMTtcclxuICAgICAgICB2YXIgbWF4JCQxO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnIHx8IHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICBtaW4kJDEgPSB0aGlzLnhTY2FsZU1pbiA/IHRoaXMueFNjYWxlTWluIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgbWF4JCQxID0gdGhpcy54U2NhbGVNYXggPyB0aGlzLnhTY2FsZU1heCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IFtuZXcgRGF0ZShtaW4kJDEpLCBuZXcgRGF0ZShtYXgkJDEpXTtcclxuICAgICAgICAgICAgdGhpcy54U2V0ID0gdmFsdWVzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFEYXRlID0gYS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYkRhdGUgPSBiLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChhRGF0ZSA+IGJEYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJEYXRlID4gYURhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgICAgICAgICAgdGhpcy54U2V0ID0gdmFsdWVzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdmFsdWVzO1xyXG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRZRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHJlc3VsdHMuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBkb21haW4uc2xpY2UoKTtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0b1NjYWxlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5iYXNlVmFsdWUgIT09ICdhdXRvJykge1xyXG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmJhc2VWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaW4kJDEgPSB0aGlzLnlTY2FsZU1pbiA/IHRoaXMueVNjYWxlTWluIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy55U2NhbGVNYXggPyB0aGlzLnlTY2FsZU1heCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRTZXJpZXNEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZTsgfSk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCB3aWR0aCkge1xyXG4gICAgICAgIHZhciBzY2FsZTtcclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlVGltZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZUxpbmVhcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVQb2ludCgpLnBhZGRpbmcoMC4xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2NhbGUucmFuZ2UoWzAsIHdpZHRoXSkuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRZU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCBoZWlnaHQpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSlcclxuICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2NhbGVUeXBlID0gZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgIHZhciBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB2YXIgbnVtID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHZhbHVlc18xID0gdmFsdWVzOyBfaSA8IHZhbHVlc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNfMVtfaV07XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RhdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIG51bSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndGltZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChudW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuICdsaW5lYXInO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ29yZGluYWwnO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUuaXNEYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlRG9tYWluID0gZnVuY3Rpb24gKGRvbWFpbikge1xyXG4gICAgICAgIHRoaXMuZmlsdGVyZWREb21haW4gPSBkb21haW47XHJcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5maWx0ZXJlZERvbWFpbjtcclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMueERvbWFpbiwgdGhpcy5kaW1zLndpZHRoKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZUhvdmVyZWRWZXJ0aWNhbCA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5ob3ZlcmVkVmVydGljYWwgPSBpdGVtLnZhbHVlO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUFsbCgpO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUuaGlkZUNpcmNsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ob3ZlcmVkVmVydGljYWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUFsbCgpO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXMpIHtcclxuICAgICAgICBpZiAoc2VyaWVzKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc2VyaWVzID0gc2VyaWVzLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnNlcmllc0RvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMueURvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGRvbWFpbjogW10sXHJcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuc2VyaWVzRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy55RG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVlBeGlzV2lkdGggPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZGVhY3RpdmF0ZUFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5hY3RpdmVFbnRyaWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGVudHJ5LCBlbnRyaWVzOiBbXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFzZVZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImF1dG9TY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidGltZWxpbmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFlBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZU1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCdzZXJpZXNUb29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2QgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VyaWVzVG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGlkZUNpcmNsZXNcIiwgbnVsbCk7XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYXJlYS1jaGFydCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZGVmcz5cXG4gICAgICAgIDxzdmc6Y2xpcFBhdGggW2F0dHIuaWRdPVxcXCJjbGlwUGF0aElkXFxcIj5cXG4gICAgICAgICAgPHN2ZzpyZWN0XFxuICAgICAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJkaW1zLndpZHRoICsgMTBcXFwiXFxuICAgICAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiZGltcy5oZWlnaHQgKyAxMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCIndHJhbnNsYXRlKC01LCAtNSknXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Y2xpcFBhdGg+XFxuICAgICAgPC9zdmc6ZGVmcz5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYXJlYS1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhZQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInlBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnIFthdHRyLmNsaXAtcGF0aF09XFxcImNsaXBQYXRoXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtYXJlYS1zZXJpZXNcXG4gICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW2Jhc2VWYWx1ZV09XFxcImJhc2VWYWx1ZVxcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICAgIFtjdXJ2ZV09XFxcImN1cnZlXFxcIlxcbiAgICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuXFxuICAgICAgICAgIDxzdmc6ZyAqbmdJZj1cXFwiIXRvb2x0aXBEaXNhYmxlZFxcXCIgKG1vdXNlbGVhdmUpPVxcXCJoaWRlQ2lyY2xlcygpXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtdG9vbHRpcC1hcmVhXFxuICAgICAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgICAgICBbeFNldF09XFxcInhTZXRcXFwiXFxuICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFtyZXN1bHRzXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInNlcmllc1Rvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgIChob3Zlcik9XFxcInVwZGF0ZUhvdmVyZWRWZXJ0aWNhbCgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIC8+XFxuXFxuICAgICAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzXFxcIj5cXG4gICAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgICBuZ3gtY2hhcnRzLWNpcmNsZS1zZXJpZXNcXG4gICAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICAgICAgW3Zpc2libGVWYWx1ZV09XFxcImhvdmVyZWRWZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50LCBzZXJpZXMpXFxcIlxcbiAgICAgICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLXRpbWVsaW5lXFxuICAgICAgICAqbmdJZj1cXFwidGltZWxpbmUgJiYgc2NhbGVUeXBlICE9ICdvcmRpbmFsJ1xcXCJcXG4gICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRpbWVsaW5lVHJhbnNmb3JtXFxcIlxcbiAgICAgICAgW3Jlc3VsdHNdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgW3ZpZXddPVxcXCJbdGltZWxpbmVXaWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICAgIFtoZWlnaHRdPVxcXCJ0aW1lbGluZUhlaWdodFxcXCJcXG4gICAgICAgIFtzY2hlbWVdPVxcXCJzY2hlbWVcXFwiXFxuICAgICAgICBbY3VzdG9tQ29sb3JzXT1cXFwiY3VzdG9tQ29sb3JzXFxcIlxcbiAgICAgICAgW2xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAob25Eb21haW5DaGFuZ2UpPVxcXCJ1cGRhdGVEb21haW4oJGV2ZW50KVxcXCJcXG4gICAgICA+XFxuICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLWFyZWEtc2VyaWVzXFxuICAgICAgICAgICAgW3hTY2FsZV09XFxcInRpbWVsaW5lWFNjYWxlXFxcIlxcbiAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ0aW1lbGluZVlTY2FsZVxcXCJcXG4gICAgICAgICAgICBbYmFzZVZhbHVlXT1cXFwiYmFzZVZhbHVlXFxcIlxcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICBbY3VydmVdPVxcXCJjdXJ2ZVxcXCJcXG4gICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEFyZWFDaGFydENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xyXG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmN1cnZlID0gY3VydmVMaW5lYXI7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICBfdGhpcy50aW1lbGluZUhlaWdodCA9IDUwO1xyXG4gICAgICAgIF90aGlzLnRpbWVsaW5lUGFkZGluZyA9IDEwO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXHJcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcclxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxyXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcclxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxyXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcclxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGltcy5oZWlnaHQgLT0gdGhpcy50aW1lbGluZUhlaWdodCArIHRoaXMubWFyZ2luWzJdICsgdGhpcy50aW1lbGluZVBhZGRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmVkRG9tYWluKSB7XHJcbiAgICAgICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZmlsdGVyZWREb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueURvbWFpbiA9IHRoaXMuZ2V0WURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzRG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oKTtcclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMueERvbWFpbiwgdGhpcy5kaW1zLndpZHRoKTtcclxuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy5kaW1zLmhlaWdodCk7XHJcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpc18xLnhTZXRbaV07XHJcbiAgICAgICAgICAgIHZhciBkMCA9IDA7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzXzEucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gZ3JvdXAuc2VyaWVzLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGEudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYi52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXNfMS5yZXN1bHRzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBncm91cC5zZXJpZXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gYS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5kMCA9IGQwO1xyXG4gICAgICAgICAgICAgICAgICAgIGQuZDEgPSBkMCArIGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZDAgKz0gZC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQwOiBkMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZDE6IGQwXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBncm91cC5zZXJpZXMucHVzaChkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b3RhbCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkLmQwID0gKGQuZDAgKiAxMDApIC8gdG90YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5kMSA9IChkLmQxICogMTAwKSAvIHRvdGFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5kMCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5kMSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy54U2V0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlVGltZWxpbmUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiICwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMuY2xpcFBhdGhJZCA9ICdjbGlwJyArIGlkKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmNsaXBQYXRoID0gXCJ1cmwoI1wiICsgdGhpcy5jbGlwUGF0aElkICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlVGltZWxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVdpZHRoID0gdGhpcy5kaW1zLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lWERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lWFNjYWxlID0gdGhpcy5nZXRYU2NhbGUodGhpcy50aW1lbGluZVhEb21haW4sIHRoaXMudGltZWxpbmVXaWR0aCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVZU2NhbGUgPSB0aGlzLmdldFlTY2FsZSh0aGlzLnlEb21haW4sIHRoaXMudGltZWxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lVHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiLCBcIiArIC10aGlzLm1hcmdpblsyXSArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRVbmlxdWVYRG9tYWluVmFsdWVzKHRoaXMucmVzdWx0cyk7XHJcbiAgICAgICAgdGhpcy5zY2FsZVR5cGUgPSBnZXRTY2FsZVR5cGUodmFsdWVzKTtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICBkb21haW4gPSBbbmV3IERhdGUobWluJCQxKSwgbmV3IERhdGUobWF4JCQxKV07XHJcbiAgICAgICAgICAgIHRoaXMueFNldCA9IHZhbHVlcy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhRGF0ZSA9IGEuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJEYXRlID0gYi5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYURhdGUgPiBiRGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIGlmIChiRGF0ZSA+IGFEYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIE51bWJlcih2KTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICB2YXIgbWF4JCQxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgZG9tYWluID0gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgICAgICAgICAgdGhpcy54U2V0ID0gdmFsdWVzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdmFsdWVzO1xyXG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gWzAsIDEwMF07XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2VyaWVzRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWU7IH0pO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIHdpZHRoKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVUaW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlTGluZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVBvaW50KCkucGFkZGluZygwLjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzY2FsZS5yYW5nZShbMCwgd2lkdGhdKS5kb21haW4oZG9tYWluKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCBoZWlnaHQpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSlcclxuICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZURvbWFpbiA9IGZ1bmN0aW9uIChkb21haW4pIHtcclxuICAgICAgICB0aGlzLmZpbHRlcmVkRG9tYWluID0gZG9tYWluO1xyXG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZmlsdGVyZWREb21haW47XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHRoaXMuZGltcy53aWR0aCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlSG92ZXJlZFZlcnRpY2FsID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLmhvdmVyZWRWZXJ0aWNhbCA9IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuaGlkZUNpcmNsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ob3ZlcmVkVmVydGljYWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUFsbCgpO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzKSB7XHJcbiAgICAgICAgaWYgKHNlcmllcykge1xyXG4gICAgICAgICAgICBkYXRhLnNlcmllcyA9IHNlcmllcy5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnNlcmllc0RvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMueURvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkb21haW46IFtdLFxyXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnNlcmllc0RvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcclxuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMueURvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdHM7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbaXRlbV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcyk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZGVhY3RpdmF0ZUFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5hY3RpdmVFbnRyaWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGVudHJ5LCBlbnRyaWVzOiBbXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aW1lbGluZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXJ2ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgnc2VyaWVzVG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9kID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2QgOiBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXJpZXNUb29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGlkZUNpcmNsZXNcIiwgbnVsbCk7XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWFyZWEtY2hhcnQtbm9ybWFsaXplZCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZGVmcz5cXG4gICAgICAgIDxzdmc6Y2xpcFBhdGggW2F0dHIuaWRdPVxcXCJjbGlwUGF0aElkXFxcIj5cXG4gICAgICAgICAgPHN2ZzpyZWN0XFxuICAgICAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJkaW1zLndpZHRoICsgMTBcXFwiXFxuICAgICAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiZGltcy5oZWlnaHQgKyAxMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCIndHJhbnNsYXRlKC01LCAtNSknXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Y2xpcFBhdGg+XFxuICAgICAgPC9zdmc6ZGVmcz5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYXJlYS1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhZQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInlBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnIFthdHRyLmNsaXAtcGF0aF09XFxcImNsaXBQYXRoXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtYXJlYS1zZXJpZXNcXG4gICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgICAgbm9ybWFsaXplZD1cXFwidHJ1ZVxcXCJcXG4gICAgICAgICAgICAgIFtjdXJ2ZV09XFxcImN1cnZlXFxcIlxcbiAgICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuXFxuICAgICAgICAgIDxzdmc6ZyAqbmdJZj1cXFwiIXRvb2x0aXBEaXNhYmxlZFxcXCIgKG1vdXNlbGVhdmUpPVxcXCJoaWRlQ2lyY2xlcygpXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtdG9vbHRpcC1hcmVhXFxuICAgICAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgICAgICBbeFNldF09XFxcInhTZXRcXFwiXFxuICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFtyZXN1bHRzXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbc2hvd1BlcmNlbnRhZ2VdPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJzZXJpZXNUb29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICAoaG92ZXIpPVxcXCJ1cGRhdGVIb3ZlcmVkVmVydGljYWwoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAvPlxcblxcbiAgICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0c1xcXCI+XFxuICAgICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1jaXJjbGUtc2VyaWVzXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcInN0YWNrZWRcXFwiXFxuICAgICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICAgIFt2aXNpYmxlVmFsdWVdPVxcXCJob3ZlcmVkVmVydGljYWxcXFwiXFxuICAgICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudCwgc2VyaWVzKVxcXCJcXG4gICAgICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy10aW1lbGluZVxcbiAgICAgICAgKm5nSWY9XFxcInRpbWVsaW5lICYmIHNjYWxlVHlwZSAhPSAnb3JkaW5hbCdcXFwiXFxuICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0aW1lbGluZVRyYW5zZm9ybVxcXCJcXG4gICAgICAgIFtyZXN1bHRzXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgIFt2aWV3XT1cXFwiW3RpbWVsaW5lV2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgICBbaGVpZ2h0XT1cXFwidGltZWxpbmVIZWlnaHRcXFwiXFxuICAgICAgICBbc2NoZW1lXT1cXFwic2NoZW1lXFxcIlxcbiAgICAgICAgW2N1c3RvbUNvbG9yc109XFxcImN1c3RvbUNvbG9yc1xcXCJcXG4gICAgICAgIFtsZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgKG9uRG9tYWluQ2hhbmdlKT1cXFwidXBkYXRlRG9tYWluKCRldmVudClcXFwiXFxuICAgICAgPlxcbiAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIj5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1hcmVhLXNlcmllc1xcbiAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ0aW1lbGluZVhTY2FsZVxcXCJcXG4gICAgICAgICAgICBbeVNjYWxlXT1cXFwidGltZWxpbmVZU2NhbGVcXFwiXFxuICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ9XFxcInRydWVcXFwiXFxuICAgICAgICAgICAgW2N1cnZlXT1cXFwiY3VydmVcXFwiXFxuICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcclxuICAgICAgICB9KVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xyXG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmN1cnZlID0gY3VydmVMaW5lYXI7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICBfdGhpcy50aW1lbGluZUhlaWdodCA9IDUwO1xyXG4gICAgICAgIF90aGlzLnRpbWVsaW5lUGFkZGluZyA9IDEwO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXHJcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcclxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxyXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcclxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxyXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcclxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGltcy5oZWlnaHQgLT0gdGhpcy50aW1lbGluZUhlaWdodCArIHRoaXMubWFyZ2luWzJdICsgdGhpcy50aW1lbGluZVBhZGRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmVkRG9tYWluKSB7XHJcbiAgICAgICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZmlsdGVyZWREb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueURvbWFpbiA9IHRoaXMuZ2V0WURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzRG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oKTtcclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMueERvbWFpbiwgdGhpcy5kaW1zLndpZHRoKTtcclxuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy5kaW1zLmhlaWdodCk7XHJcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpc18xLnhTZXRbaV07XHJcbiAgICAgICAgICAgIHZhciBkMCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzXzEucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gZ3JvdXAuc2VyaWVzLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGEudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYi52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGQuZDAgPSBkMDtcclxuICAgICAgICAgICAgICAgICAgICBkLmQxID0gZDAgKyBkLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGQwICs9IGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB2YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkMDogZDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQxOiBkMFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuc2VyaWVzLnB1c2goZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy54U2V0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlVGltZWxpbmUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiICwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMuY2xpcFBhdGhJZCA9ICdjbGlwJyArIGlkKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmNsaXBQYXRoID0gXCJ1cmwoI1wiICsgdGhpcy5jbGlwUGF0aElkICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlVGltZWxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVdpZHRoID0gdGhpcy5kaW1zLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lWERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lWFNjYWxlID0gdGhpcy5nZXRYU2NhbGUodGhpcy50aW1lbGluZVhEb21haW4sIHRoaXMudGltZWxpbmVXaWR0aCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVZU2NhbGUgPSB0aGlzLmdldFlTY2FsZSh0aGlzLnlEb21haW4sIHRoaXMudGltZWxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lVHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiLCBcIiArIC10aGlzLm1hcmdpblsyXSArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRVbmlxdWVYRG9tYWluVmFsdWVzKHRoaXMucmVzdWx0cyk7XHJcbiAgICAgICAgdGhpcy5zY2FsZVR5cGUgPSBnZXRTY2FsZVR5cGUodmFsdWVzKTtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBOdW1iZXIodik7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWluJCQxO1xyXG4gICAgICAgIHZhciBtYXgkJDE7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScgfHwgdGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIG1pbiQkMSA9IHRoaXMueFNjYWxlTWluID8gdGhpcy54U2NhbGVNaW4gOiBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICBtYXgkJDEgPSB0aGlzLnhTY2FsZU1heCA/IHRoaXMueFNjYWxlTWF4IDogTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gW25ldyBEYXRlKG1pbiQkMSksIG5ldyBEYXRlKG1heCQkMSldO1xyXG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYURhdGUgPSBhLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBiRGF0ZSA9IGIuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFEYXRlID4gYkRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYkRhdGUgPiBhRGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21haW4gPSB2YWx1ZXM7XHJcbiAgICAgICAgICAgIHRoaXMueFNldCA9IHZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXNfMi54U2V0W2ldO1xyXG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXNfMi5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBncm91cC5zZXJpZXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gYS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG9tYWluLnB1c2goc3VtKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0aGlzXzIgPSB0aGlzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy54U2V0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9sb29wXzIoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaW4kJDEgPSB0aGlzLnlTY2FsZU1pbiA/IHRoaXMueVNjYWxlTWluIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgWzBdLmNvbmNhdChkb21haW4pKTtcclxuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy55U2NhbGVNYXggPyB0aGlzLnlTY2FsZU1heCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIGRvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2VyaWVzRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWU7IH0pO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIHdpZHRoKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVUaW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlTGluZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVBvaW50KCkucGFkZGluZygwLjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzY2FsZS5yYW5nZShbMCwgd2lkdGhdKS5kb21haW4oZG9tYWluKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCBoZWlnaHQpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSlcclxuICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZURvbWFpbiA9IGZ1bmN0aW9uIChkb21haW4pIHtcclxuICAgICAgICB0aGlzLmZpbHRlcmVkRG9tYWluID0gZG9tYWluO1xyXG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZmlsdGVyZWREb21haW47XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHRoaXMuZGltcy53aWR0aCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlSG92ZXJlZFZlcnRpY2FsID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLmhvdmVyZWRWZXJ0aWNhbCA9IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuaGlkZUNpcmNsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ob3ZlcmVkVmVydGljYWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUFsbCgpO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSwgc2VyaWVzKSB7XHJcbiAgICAgICAgaWYgKHNlcmllcykge1xyXG4gICAgICAgICAgICBkYXRhLnNlcmllcyA9IHNlcmllcy5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnNlcmllc0RvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMueURvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkb21haW46IFtdLFxyXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnNlcmllc0RvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcclxuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMueURvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdHM7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbaXRlbV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcyk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZGVhY3RpdmF0ZUFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5hY3RpdmVFbnRyaWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGVudHJ5LCBlbnRyaWVzOiBbXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aW1lbGluZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXJ2ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZU1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCdzZXJpZXNUb29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2QgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc1Rvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoaWRlQ2lyY2xlc1wiLCBudWxsKTtcclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYXJlYS1jaGFydC1zdGFja2VkJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpkZWZzPlxcbiAgICAgICAgPHN2ZzpjbGlwUGF0aCBbYXR0ci5pZF09XFxcImNsaXBQYXRoSWRcXFwiPlxcbiAgICAgICAgICA8c3ZnOnJlY3RcXG4gICAgICAgICAgICBbYXR0ci53aWR0aF09XFxcImRpbXMud2lkdGggKyAxMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJkaW1zLmhlaWdodCArIDEwXFxcIlxcbiAgICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcIid0cmFuc2xhdGUoLTUsIC01KSdcXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpjbGlwUGF0aD5cXG4gICAgICA8L3N2ZzpkZWZzPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJhcmVhLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmcgW2F0dHIuY2xpcC1wYXRoXT1cXFwiY2xpcFBhdGhcXFwiPlxcbiAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1hcmVhLXNlcmllc1xcbiAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgICBzdGFja2VkPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgICAgICAgW2N1cnZlXT1cXFwiY3VydmVcXFwiXFxuICAgICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0lmPVxcXCIhdG9vbHRpcERpc2FibGVkXFxcIiAobW91c2VsZWF2ZSk9XFxcImhpZGVDaXJjbGVzKClcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy10b29sdGlwLWFyZWFcXG4gICAgICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgICAgIFt4U2V0XT1cXFwieFNldFxcXCJcXG4gICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3Jlc3VsdHNdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwic2VyaWVzVG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgKGhvdmVyKT1cXFwidXBkYXRlSG92ZXJlZFZlcnRpY2FsKCRldmVudClcXFwiXFxuICAgICAgICAgICAgLz5cXG5cXG4gICAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiPlxcbiAgICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICAgIG5neC1jaGFydHMtY2lyY2xlLXNlcmllc1xcbiAgICAgICAgICAgICAgICB0eXBlPVxcXCJzdGFja2VkXFxcIlxcbiAgICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgICAgICBbdmlzaWJsZVZhbHVlXT1cXFwiaG92ZXJlZFZlcnRpY2FsXFxcIlxcbiAgICAgICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQsIHNlcmllcylcXFwiXFxuICAgICAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtdGltZWxpbmVcXG4gICAgICAgICpuZ0lmPVxcXCJ0aW1lbGluZSAmJiBzY2FsZVR5cGUgIT0gJ29yZGluYWwnXFxcIlxcbiAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidGltZWxpbmVUcmFuc2Zvcm1cXFwiXFxuICAgICAgICBbcmVzdWx0c109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICBbdmlld109XFxcIlt0aW1lbGluZVdpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgICAgW2hlaWdodF09XFxcInRpbWVsaW5lSGVpZ2h0XFxcIlxcbiAgICAgICAgW3NjaGVtZV09XFxcInNjaGVtZVxcXCJcXG4gICAgICAgIFtjdXN0b21Db2xvcnNdPVxcXCJjdXN0b21Db2xvcnNcXFwiXFxuICAgICAgICBbbGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgIChvbkRvbWFpbkNoYW5nZSk9XFxcInVwZGF0ZURvbWFpbigkZXZlbnQpXFxcIlxcbiAgICAgID5cXG4gICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0czsgdHJhY2tCeTogdHJhY2tCeVxcXCI+XFxuICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgIG5neC1jaGFydHMtYXJlYS1zZXJpZXNcXG4gICAgICAgICAgICBbeFNjYWxlXT1cXFwidGltZWxpbmVYU2NhbGVcXFwiXFxuICAgICAgICAgICAgW3lTY2FsZV09XFxcInRpbWVsaW5lWVNjYWxlXFxcIlxcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICBzdGFja2VkPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgICAgIFtjdXJ2ZV09XFxcImN1cnZlXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgQXJlYVNlcmllc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFyZWFTZXJpZXNDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy5iYXNlVmFsdWUgPSAnYXV0byc7XHJcbiAgICAgICAgdGhpcy5zdGFja2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMudXBkYXRlR3JhZGllbnQoKTtcclxuICAgICAgICB2YXIgY3VycmVudEFyZWE7XHJcbiAgICAgICAgdmFyIHN0YXJ0aW5nQXJlYTtcclxuICAgICAgICB2YXIgeFByb3BlcnR5ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gZC5uYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMueFNjYWxlKGxhYmVsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLnN0YWNrZWQgfHwgdGhpcy5ub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcmVhID0gYXJlYSgpXHJcbiAgICAgICAgICAgICAgICAueCh4UHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIF90aGlzLnlTY2FsZShkLmQwKTsgfSlcclxuICAgICAgICAgICAgICAgIC55MShmdW5jdGlvbiAoZCwgaSkgeyByZXR1cm4gX3RoaXMueVNjYWxlKGQuZDEpOyB9KTtcclxuICAgICAgICAgICAgc3RhcnRpbmdBcmVhID0gYXJlYSgpXHJcbiAgICAgICAgICAgICAgICAueCh4UHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLnlTY2FsZS5yYW5nZSgpWzBdOyB9KVxyXG4gICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy55U2NhbGUucmFuZ2UoKVswXTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50QXJlYSA9IGFyZWEoKVxyXG4gICAgICAgICAgICAgICAgLngoeFByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgLnkwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmJhc2VWYWx1ZSA9PT0gJ2F1dG8nID8gX3RoaXMueVNjYWxlLnJhbmdlKClbMF0gOiBfdGhpcy55U2NhbGUoX3RoaXMuYmFzZVZhbHVlKTsgfSlcclxuICAgICAgICAgICAgICAgIC55MShmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMueVNjYWxlKGQudmFsdWUpOyB9KTtcclxuICAgICAgICAgICAgc3RhcnRpbmdBcmVhID0gYXJlYSgpXHJcbiAgICAgICAgICAgICAgICAueCh4UHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLmJhc2VWYWx1ZSA9PT0gJ2F1dG8nID8gX3RoaXMueVNjYWxlLnJhbmdlKClbMF0gOiBfdGhpcy55U2NhbGUoX3RoaXMuYmFzZVZhbHVlKTsgfSlcclxuICAgICAgICAgICAgICAgIC55MShmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMuYmFzZVZhbHVlID09PSAnYXV0bycgPyBfdGhpcy55U2NhbGUucmFuZ2UoKVswXSA6IF90aGlzLnlTY2FsZShfdGhpcy5iYXNlVmFsdWUpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEFyZWEuY3VydmUodGhpcy5jdXJ2ZSk7XHJcbiAgICAgICAgc3RhcnRpbmdBcmVhLmN1cnZlKHRoaXMuY3VydmUpO1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IC44O1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLnNlcmllcztcclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBzb3J0TGluZWFyKGRhdGEsICduYW1lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHNvcnRCeVRpbWUoZGF0YSwgJ25hbWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBzb3J0QnlEb21haW4oZGF0YSwgJ25hbWUnLCAnYXNjJywgdGhpcy54U2NhbGUuZG9tYWluKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhdGggPSBjdXJyZW50QXJlYShkYXRhKTtcclxuICAgICAgICB0aGlzLnN0YXJ0aW5nUGF0aCA9IHN0YXJ0aW5nQXJlYShkYXRhKTtcclxuICAgIH07XHJcbiAgICBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVHcmFkaWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb2xvcnMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tlZCB8fCB0aGlzLm5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkMHZhbHVlcyA9IHRoaXMuZGF0YS5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmQwOyB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBkMXZhbHVlcyA9IHRoaXMuZGF0YS5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmQxOyB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBkMXZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgZDB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhtYXgkJDEsIG1pbiQkMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5kYXRhLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB0aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKG1heCQkMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzR3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNJbmFjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzIHx8IHRoaXMuYWN0aXZlRW50cmllcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFzZVZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNjYWxlVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInN0YWNrZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub3JtYWxpemVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VydmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIEFyZWFTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1hcmVhLXNlcmllc10nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIG5neC1jaGFydHMtYXJlYVxcbiAgICAgIGNsYXNzPVxcXCJhcmVhLXNlcmllc1xcXCJcXG4gICAgICBbZGF0YV09XFxcImRhdGFcXFwiXFxuICAgICAgW3BhdGhdPVxcXCJwYXRoXFxcIlxcbiAgICAgIFtmaWxsXT1cXFwiY29sb3JzLmdldENvbG9yKGRhdGEubmFtZSlcXFwiXFxuICAgICAgW3N0b3BzXT1cXFwiZ3JhZGllbnRTdG9wc1xcXCJcXG4gICAgICBbc3RhcnRpbmdQYXRoXT1cXFwic3RhcnRpbmdQYXRoXFxcIlxcbiAgICAgIFtvcGFjaXR5XT1cXFwib3BhY2l0eVxcXCJcXG4gICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudCB8fCBoYXNHcmFkaWVudFxcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlKGRhdGEpXFxcIlxcbiAgICAgIFtjbGFzcy5pbmFjdGl2ZV09XFxcImlzSW5hY3RpdmUoZGF0YSlcXFwiXFxuICAgIC8+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQXJlYVNlcmllc0NvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBBcmVhQ2hhcnRNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBcmVhQ2hhcnRNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBBcmVhQ2hhcnRNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDaGFydENvbW1vbk1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgQXJlYUNoYXJ0Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBBcmVhU2VyaWVzQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIEFyZWFDaGFydENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQXJlYVNlcmllc0NvbXBvbmVudFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEFyZWFDaGFydE1vZHVsZSk7XHJcbiAgICByZXR1cm4gQXJlYUNoYXJ0TW9kdWxlO1xyXG59KCkpO1xyXG5cclxudmFyIEJhckNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhckNvbXBvbmVudChlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5yb3VuZEVkZ2VzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmdyYWRpZW50ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaGFzR3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmhpZGVCYXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudElkID0gJ2dyYWQnICsgaWQoKS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnRGaWxsID0gXCJ1cmwoI1wiICsgdGhpcy5ncmFkaWVudElkICsgXCIpXCI7XHJcbiAgICAgICAgaWYgKHRoaXMuZ3JhZGllbnQgfHwgdGhpcy5zdG9wcykge1xyXG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB0aGlzLmdldEdyYWRpZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzR3JhZGllbnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZVBhdGhFbCgpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tUb0hpZGVCYXIoKTtcclxuICAgIH07XHJcbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLmxvYWRBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gdGhpcy5nZXRTdGFydGluZ1BhdGgoKTtcclxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudXBkYXRlLmJpbmQodGhpcyksIDEwMCk7XHJcbiAgICB9O1xyXG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVQYXRoRWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3QodGhpcy5lbGVtZW50KS5zZWxlY3QoJy5iYXInKTtcclxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuZ2V0UGF0aCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbnMpIHtcclxuICAgICAgICAgICAgbm9kZVxyXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLmF0dHIoJ2QnLCBwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdG9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9wcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuZmlsbCxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMuZ2V0U3RhcnRPcGFjaXR5KClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxMDAsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5maWxsLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLmdldFN0YXJ0aW5nUGF0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYW5pbWF0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLmdldFJhZGl1cygpO1xyXG4gICAgICAgIHZhciBwYXRoO1xyXG4gICAgICAgIGlmICh0aGlzLnJvdW5kRWRnZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IE1hdGgubWluKHRoaXMuaGVpZ2h0LCByYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHJvdW5kZWRSZWN0KHRoaXMueCwgdGhpcy55ICsgdGhpcy5oZWlnaHQsIHRoaXMud2lkdGgsIDEsIDAsIHRoaXMuZWRnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gTWF0aC5taW4odGhpcy53aWR0aCwgcmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIHBhdGggPSByb3VuZGVkUmVjdCh0aGlzLngsIHRoaXMueSwgMSwgdGhpcy5oZWlnaHQsIDAsIHRoaXMuZWRnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHJvdW5kZWRSZWN0KHRoaXMueCwgdGhpcy55ICsgdGhpcy5oZWlnaHQsIHRoaXMud2lkdGgsIDEsIDAsIHRoaXMuZWRnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHJvdW5kZWRSZWN0KHRoaXMueCwgdGhpcy55LCAxLCB0aGlzLmhlaWdodCwgMCwgdGhpcy5lZGdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9O1xyXG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLmdldFJhZGl1cygpO1xyXG4gICAgICAgIHZhciBwYXRoO1xyXG4gICAgICAgIGlmICh0aGlzLnJvdW5kRWRnZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IE1hdGgubWluKHRoaXMuaGVpZ2h0LCByYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHJvdW5kZWRSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgcmFkaXVzLCB0aGlzLmVkZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IE1hdGgubWluKHRoaXMud2lkdGgsIHJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcm91bmRlZFJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCByYWRpdXMsIHRoaXMuZWRnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRoID0gcm91bmRlZFJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCByYWRpdXMsIHRoaXMuZWRnZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLmdldFJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmFkaXVzID0gMDtcclxuICAgICAgICBpZiAodGhpcy5yb3VuZEVkZ2VzICYmIHRoaXMuaGVpZ2h0ID4gNSAmJiB0aGlzLndpZHRoID4gNSkge1xyXG4gICAgICAgICAgICByYWRpdXMgPSBNYXRoLmZsb29yKE1hdGgubWluKDUsIHRoaXMuaGVpZ2h0IC8gMiwgdGhpcy53aWR0aCAvIDIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJhZGl1cztcclxuICAgIH07XHJcbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLmdldFN0YXJ0T3BhY2l0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5yb3VuZEVkZ2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwLjI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMC41O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlZGdlc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlZGdlcyA9IFtmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJvdW5kRWRnZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS52YWx1ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXMgPSBbdHJ1ZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gW2ZhbHNlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS52YWx1ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXMgPSBbZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gW3RydWUsIGZhbHNlLCB0cnVlLCBmYWxzZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlZGdlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUub25Nb3VzZUVudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh0aGlzLmRhdGEpO1xyXG4gICAgfTtcclxuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUub25Nb3VzZUxlYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHRoaXMuZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS5jaGVja1RvSGlkZUJhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhpZGVCYXIgPVxyXG4gICAgICAgICAgICB0aGlzLm5vQmFyV2hlblplcm8gJiZcclxuICAgICAgICAgICAgICAgICgodGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiB0aGlzLmhlaWdodCA9PT0gMCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIHRoaXMud2lkdGggPT09IDApKTtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImZpbGxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwieFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZEVkZ2VzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImlzQWN0aXZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RvcHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYXJpYUxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub0JhcldoZW5aZXJvXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUVudGVyXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9uTW91c2VMZWF2ZVwiLCBudWxsKTtcclxuICAgIEJhckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWJhcl0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpkZWZzICpuZ0lmPVxcXCJoYXNHcmFkaWVudFxcXCI+XFxuICAgICAgPHN2ZzpnIG5neC1jaGFydHMtc3ZnLWxpbmVhci1ncmFkaWVudCBbb3JpZW50YXRpb25dPVxcXCJvcmllbnRhdGlvblxcXCIgW25hbWVdPVxcXCJncmFkaWVudElkXFxcIiBbc3RvcHNdPVxcXCJncmFkaWVudFN0b3BzXFxcIiAvPlxcbiAgICA8L3N2ZzpkZWZzPlxcbiAgICA8c3ZnOnBhdGhcXG4gICAgICBjbGFzcz1cXFwiYmFyXFxcIlxcbiAgICAgIHN0cm9rZT1cXFwibm9uZVxcXCJcXG4gICAgICByb2xlPVxcXCJpbWdcXFwiXFxuICAgICAgdGFiSW5kZXg9XFxcIi0xXFxcIlxcbiAgICAgIFtjbGFzcy5hY3RpdmVdPVxcXCJpc0FjdGl2ZVxcXCJcXG4gICAgICBbY2xhc3MuaGlkZGVuXT1cXFwiaGlkZUJhclxcXCJcXG4gICAgICBbYXR0ci5kXT1cXFwicGF0aFxcXCJcXG4gICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cXFwiYXJpYUxhYmVsXFxcIlxcbiAgICAgIFthdHRyLmZpbGxdPVxcXCJoYXNHcmFkaWVudCA/IGdyYWRpZW50RmlsbCA6IGZpbGxcXFwiXFxuICAgICAgKGNsaWNrKT1cXFwic2VsZWN0LmVtaXQoZGF0YSlcXFwiXFxuICAgIC8+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxyXG4gICAgXSwgQmFyQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBCYXJDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgQmFySG9yaXpvbnRhbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCYXJIb3Jpem9udGFsQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmFySG9yaXpvbnRhbENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5iYXJQYWRkaW5nID0gODtcclxuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5yb3VuZEVkZ2VzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5zaG93RGF0YUxhYmVsID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICBfdGhpcy5kYXRhTGFiZWxNYXhXaWR0aCA9IHsgbmVnYXRpdmU6IDAsIHBvc2l0aXZlOiAwIH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3dEYXRhTGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aCA9IHsgbmVnYXRpdmU6IDAsIHBvc2l0aXZlOiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFyZ2luID0gWzEwLCAyMCArIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgucG9zaXRpdmUsIDEwLCAyMCArIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmVdO1xyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxyXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXHJcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcclxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXHJcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcclxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiICwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmdldFhEb21haW4oKTtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnhEb21haW4pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnlEb21haW4gPSB0aGlzLmdldFlEb21haW4oKTtcclxuICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMueURvbWFpbi5sZW5ndGggLyAodGhpcy5kaW1zLmhlaWdodCAvIHRoaXMuYmFyUGFkZGluZyArIDEpO1xyXG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5kaW1zLmhlaWdodF0pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnlEb21haW4pO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLmdldFhEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pO1xyXG4gICAgICAgIHZhciBtaW4kJDEgPSB0aGlzLnhTY2FsZU1pbiA/IE1hdGgubWluLmFwcGx5KE1hdGgsIFt0aGlzLnhTY2FsZU1pbl0uY29uY2F0KHZhbHVlcykpIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgWzBdLmNvbmNhdCh2YWx1ZXMpKTtcclxuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy54U2NhbGVNYXggPyBNYXRoLm1heC5hcHBseShNYXRoLCBbdGhpcy54U2NhbGVNYXhdLmNvbmNhdCh2YWx1ZXMpKSA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIFswXS5jb25jYXQodmFsdWVzKSk7XHJcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5sYWJlbDsgfSk7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbjtcclxuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy55RG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy54RG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGRvbWFpbjogW10sXHJcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMueURvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcclxuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMueERvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdHM7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS5vbkRhdGFMYWJlbE1heFdpZHRoQ2hhbmdlZCA9IGZ1bmN0aW9uIChldmVudCQkMSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGV2ZW50JCQxLnNpemUubmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZSA9IE1hdGgubWF4KHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmUsIGV2ZW50JCQxLnNpemUud2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5wb3NpdGl2ZSA9IE1hdGgubWF4KHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgucG9zaXRpdmUsIGV2ZW50JCQxLnNpemUud2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnQkJDEuaW5kZXggPT09IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlKCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbaXRlbV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcyk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0cy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWUgJiYgZC5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFlBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcImJhclBhZGRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZERvbWFpbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZEVkZ2VzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZU1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dEYXRhTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFMYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub0JhcldoZW5aZXJvXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1iYXItaG9yaXpvbnRhbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB0cnVlKVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJiYXItY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3lBeGlzT2Zmc2V0XT1cXFwiZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmVcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtc2VyaWVzLWhvcml6b250YWxcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgW3Nlcmllc109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgW3JvdW5kRWRnZXNdPVxcXCJyb3VuZEVkZ2VzXFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIFtzaG93RGF0YUxhYmVsXT1cXFwic2hvd0RhdGFMYWJlbFxcXCJcXG4gICAgICAgICAgW2RhdGFMYWJlbEZvcm1hdHRpbmddPVxcXCJkYXRhTGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGRhdGFMYWJlbFdpZHRoQ2hhbmdlZCk9XFxcIm9uRGF0YUxhYmVsTWF4V2lkdGhDaGFuZ2VkKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcclxuICAgICAgICB9KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQmFySG9yaXpvbnRhbENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy50cmltWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLm1heFhBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLmdyb3VwUGFkZGluZyA9IDE2O1xyXG4gICAgICAgIF90aGlzLmJhclBhZGRpbmcgPSA4O1xyXG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnJvdW5kRWRnZXMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnNob3dEYXRhTGFiZWwgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5ub0JhcldoZW5aZXJvID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xyXG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xyXG4gICAgICAgIF90aGlzLmRhdGFMYWJlbE1heFdpZHRoID0geyBuZWdhdGl2ZTogMCwgcG9zaXRpdmU6IDAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICghdGhpcy5zaG93RGF0YUxhYmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGggPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hcmdpbiA9IFsxMCwgMjAgKyB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLnBvc2l0aXZlLCAxMCwgMjAgKyB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLm5lZ2F0aXZlXTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5mb3JtYXREYXRlcygpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBEb21haW4gPSB0aGlzLmdldEdyb3VwRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5pbm5lckRvbWFpbiA9IHRoaXMuZ2V0SW5uZXJEb21haW4oKTtcclxuICAgICAgICB0aGlzLnZhbHVlc0RvbWFpbiA9IHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcclxuICAgICAgICB0aGlzLmdyb3VwU2NhbGUgPSB0aGlzLmdldEdyb3VwU2NhbGUoKTtcclxuICAgICAgICB0aGlzLmlubmVyU2NhbGUgPSB0aGlzLmdldElubmVyU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnZhbHVlU2NhbGUgPSB0aGlzLmdldFZhbHVlU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiICwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMuZ3JvdXBEb21haW4ubGVuZ3RoIC8gKHRoaXMuZGltcy5oZWlnaHQgLyB0aGlzLmdyb3VwUGFkZGluZyArIDEpO1xyXG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5kaW1zLmhlaWdodF0pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcclxuICAgICAgICAgICAgLnBhZGRpbmdPdXRlcihzcGFjaW5nIC8gMilcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLmdyb3VwRG9tYWluKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLmdldElubmVyU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ3JvdXBTY2FsZS5iYW5kd2lkdGgoKTtcclxuICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMuaW5uZXJEb21haW4ubGVuZ3RoIC8gKGhlaWdodCAvIHRoaXMuYmFyUGFkZGluZyArIDEpO1xyXG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgaGVpZ2h0XSlcclxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcihzcGFjaW5nKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMuaW5uZXJEb21haW4pO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnZhbHVlc0RvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRHcm91cERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhncm91cC5sYWJlbCkpIHtcclxuICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGdyb3VwLmxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5uZXJEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC5sYWJlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLmxhYmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgWzBdLmNvbmNhdChkb21haW4pKTtcclxuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy54U2NhbGVNYXggPyBNYXRoLm1heC5hcHBseShNYXRoLCBbdGhpcy54U2NhbGVNYXhdLmNvbmNhdChkb21haW4pKSA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIFswXS5jb25jYXQoZG9tYWluKSk7XHJcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5ncm91cFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZSgwLCBcIiArIHRoaXMuZ3JvdXBTY2FsZShncm91cC5sYWJlbCkgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSwgZ3JvdXApIHtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbjtcclxuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMudmFsdWVzRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB7XHJcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZG9tYWluOiBbXSxcclxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcclxuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMudmFsdWVzRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVlBeGlzV2lkdGggPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLm9uRGF0YUxhYmVsTWF4V2lkdGhDaGFuZ2VkID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cEluZGV4KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZXZlbnQkJDEuc2l6ZS5uZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLm5lZ2F0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZSwgZXZlbnQkJDEuc2l6ZS53aWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLnBvc2l0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5wb3NpdGl2ZSwgZXZlbnQkJDEuc2l6ZS53aWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChncm91cEluZGV4ID09PSB0aGlzLnJlc3VsdHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5yZXN1bHRzXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGcpIHsgcmV0dXJuIGcuc2VyaWVzOyB9KVxyXG4gICAgICAgICAgICAuZmxhdCgpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gaXRlbXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgIT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhKGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImdyb3VwUGFkZGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJQYWRkaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZERvbWFpbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRWRnZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93RGF0YUxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFMYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcIm5vQmFyV2hlblplcm9cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYmFyLWhvcml6b250YWwtMmQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImJhci1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1ncmlkLXBhbmVsLXNlcmllc1xcbiAgICAgICAgICBbeFNjYWxlXT1cXFwidmFsdWVTY2FsZVxcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcImdyb3VwU2NhbGVcXFwiXFxuICAgICAgICAgIFtkYXRhXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBvcmllbnQ9XFxcImhvcml6b250YWxcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ2YWx1ZVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcImdyb3VwU2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3lBeGlzT2Zmc2V0XT1cXFwiZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmVcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGdyb3VwIG9mIHJlc3VsdHM7IGxldCBpbmRleCA9IGluZGV4OyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcImdyb3VwVHJhbnNmb3JtKGdyb3VwKVxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1zZXJpZXMtaG9yaXpvbnRhbFxcbiAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ2YWx1ZVNjYWxlXFxcIlxcbiAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICBbeVNjYWxlXT1cXFwiaW5uZXJTY2FsZVxcXCJcXG4gICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgIFtzZXJpZXNdPVxcXCJncm91cC5zZXJpZXNcXFwiXFxuICAgICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICBbc2VyaWVzTmFtZV09XFxcImdyb3VwLm5hbWVcXFwiXFxuICAgICAgICAgICAgW3JvdW5kRWRnZXNdPVxcXCJyb3VuZEVkZ2VzXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICBbc2hvd0RhdGFMYWJlbF09XFxcInNob3dEYXRhTGFiZWxcXFwiXFxuICAgICAgICAgICAgW2RhdGFMYWJlbEZvcm1hdHRpbmddPVxcXCJkYXRhTGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICAgIFtub0JhcldoZW5aZXJvXT1cXFwibm9CYXJXaGVuWmVyb1xcXCJcXG4gICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChkYXRhTGFiZWxXaWR0aENoYW5nZWQpPVxcXCJvbkRhdGFMYWJlbE1heFdpZHRoQ2hhbmdlZCgkZXZlbnQsIGluZGV4KVxcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICcqJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiAnc2NhbGUoMCknIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMuYmFyUGFkZGluZyA9IDg7XHJcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXHJcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcclxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxyXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcclxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxyXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcclxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcclxuICAgICAgICB0aGlzLmdyb3VwRG9tYWluID0gdGhpcy5nZXRHcm91cERvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuaW5uZXJEb21haW4gPSB0aGlzLmdldElubmVyRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZURvbWFpbiA9IHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldEdyb3VwRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGdyb3VwLmxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZ3JvdXAubGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldElubmVyRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGQubGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5sYWJlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFswLCAxMDBdO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLmdyb3VwRG9tYWluLmxlbmd0aCAvICh0aGlzLmRpbXMuaGVpZ2h0IC8gdGhpcy5iYXJQYWRkaW5nICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB0aGlzLmRpbXMuaGVpZ2h0XSlcclxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcihzcGFjaW5nKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMuZ3JvdXBEb21haW4pO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuZGltcy53aWR0aF0pXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy52YWx1ZURvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdyb3VwVHJhbnNmb3JtID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsIFwiICsgdGhpcy55U2NhbGUoZ3JvdXAubmFtZSkgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhLCBncm91cCkge1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgICBkYXRhLnNlcmllcyA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbjtcclxuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMudmFsdWVEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGRvbWFpbjogW10sXHJcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuaW5uZXJEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnM7XHJcbiAgICAgICAgICAgIG9wdHMudGl0bGUgPSB0aGlzLmxlZ2VuZFRpdGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnZhbHVlRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVhBeGlzSGVpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnJlc3VsdHNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZykgeyByZXR1cm4gZy5zZXJpZXM7IH0pXHJcbiAgICAgICAgICAgIC5mbGF0KClcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBpdGVtcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXAsIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQkJDEpO1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsICE9PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIShpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJQYWRkaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub0JhcldoZW5aZXJvXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYmFyLWhvcml6b250YWwtbm9ybWFsaXplZCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYmFyLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhZQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInlBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGdyb3VwIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiZ3JvdXBUcmFuc2Zvcm0oZ3JvdXApXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLXNlcmllcy1ob3Jpem9udGFsXFxuICAgICAgICAgICAgdHlwZT1cXFwibm9ybWFsaXplZFxcXCJcXG4gICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgW3Nlcmllc109XFxcImdyb3VwLnNlcmllc1xcXCJcXG4gICAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgIFtzZXJpZXNOYW1lXT1cXFwiZ3JvdXAubmFtZVxcXCJcXG4gICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAnKidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3NjYWxlKDApJyB9KSlcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5iYXJQYWRkaW5nID0gODtcclxuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zaG93RGF0YUxhYmVsID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICBfdGhpcy5kYXRhTGFiZWxNYXhXaWR0aCA9IHsgbmVnYXRpdmU6IDAsIHBvc2l0aXZlOiAwIH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICghdGhpcy5zaG93RGF0YUxhYmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGggPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hcmdpbiA9IFsxMCwgMjAgKyB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLnBvc2l0aXZlLCAxMCwgMjAgKyB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLm5lZ2F0aXZlXTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5mb3JtYXREYXRlcygpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBEb21haW4gPSB0aGlzLmdldEdyb3VwRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5pbm5lckRvbWFpbiA9IHRoaXMuZ2V0SW5uZXJEb21haW4oKTtcclxuICAgICAgICB0aGlzLnZhbHVlRG9tYWluID0gdGhpcy5nZXRWYWx1ZURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiAsIFwiICsgdGhpcy5tYXJnaW5bMF0gKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZ3JvdXAubGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBkb21haW4ucHVzaChncm91cC5sYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5uZXJEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC5sYWJlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLmxhYmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgdmFyIHNtYWxsZXN0ID0gMDtcclxuICAgICAgICB2YXIgYmlnZ2VzdCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB2YXIgc21hbGxlc3RTdW0gPSAwO1xyXG4gICAgICAgICAgICB2YXIgYmlnZ2VzdFN1bSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmIChkLnZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0U3VtICs9IGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiaWdnZXN0U3VtICs9IGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzbWFsbGVzdCA9IGQudmFsdWUgPCBzbWFsbGVzdCA/IGQudmFsdWUgOiBzbWFsbGVzdDtcclxuICAgICAgICAgICAgICAgIGJpZ2dlc3QgPSBkLnZhbHVlID4gYmlnZ2VzdCA/IGQudmFsdWUgOiBiaWdnZXN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRvbWFpbi5wdXNoKHNtYWxsZXN0U3VtKTtcclxuICAgICAgICAgICAgZG9tYWluLnB1c2goYmlnZ2VzdFN1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvbWFpbi5wdXNoKHNtYWxsZXN0KTtcclxuICAgICAgICBkb21haW4ucHVzaChiaWdnZXN0KTtcclxuICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgWzBdLmNvbmNhdChkb21haW4pKTtcclxuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy54U2NhbGVNYXggPyBNYXRoLm1heC5hcHBseShNYXRoLCBbdGhpcy54U2NhbGVNYXhdLmNvbmNhdChkb21haW4pKSA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIGRvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMuZ3JvdXBEb21haW4ubGVuZ3RoIC8gKHRoaXMuZGltcy5oZWlnaHQgLyB0aGlzLmJhclBhZGRpbmcgKyAxKTtcclxuICAgICAgICByZXR1cm4gc2NhbGVCYW5kKClcclxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHRoaXMuZGltcy5oZWlnaHRdKVxyXG4gICAgICAgICAgICAucGFkZGluZ0lubmVyKHNwYWNpbmcpXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy5ncm91cERvbWFpbik7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnZhbHVlRG9tYWluKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ3JvdXBUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCwgXCIgKyB0aGlzLnlTY2FsZShncm91cC5uYW1lKSArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIGdyb3VwKSB7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy52YWx1ZURvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB7XHJcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZG9tYWluOiBbXSxcclxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcclxuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMudmFsdWVEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRzO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUub25EYXRhTGFiZWxNYXhXaWR0aENoYW5nZWQgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwSW5kZXgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChldmVudCQkMS5zaXplLm5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heFdpZHRoLm5lZ2F0aXZlLCBldmVudCQkMS5zaXplLndpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgucG9zaXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heFdpZHRoLnBvc2l0aXZlLCBldmVudCQkMS5zaXplLndpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPT09IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlKCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXAsIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQkJDEpO1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMucmVzdWx0c1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChnKSB7IHJldHVybiBnLnNlcmllczsgfSlcclxuICAgICAgICAgICAgLmZsYXQoKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IGl0ZW1zLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgIT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhKGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImJhclBhZGRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dEYXRhTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhTGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm5vQmFyV2hlblplcm9cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1iYXItaG9yaXpvbnRhbC1zdGFja2VkJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgdW5kZWZpbmVkLCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgdW5kZWZpbmVkLCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJiYXItY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3lBeGlzT2Zmc2V0XT1cXFwiZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmVcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGdyb3VwIG9mIHJlc3VsdHM7IGxldCBpbmRleCA9IGluZGV4OyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcImdyb3VwVHJhbnNmb3JtKGdyb3VwKVxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1zZXJpZXMtaG9yaXpvbnRhbFxcbiAgICAgICAgICAgIHR5cGU9XFxcInN0YWNrZWRcXFwiXFxuICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgW3Nlcmllc109XFxcImdyb3VwLnNlcmllc1xcXCJcXG4gICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICBbc2VyaWVzTmFtZV09XFxcImdyb3VwLm5hbWVcXFwiXFxuICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIFtzaG93RGF0YUxhYmVsXT1cXFwic2hvd0RhdGFMYWJlbFxcXCJcXG4gICAgICAgICAgICBbZGF0YUxhYmVsRm9ybWF0dGluZ109XFxcImRhdGFMYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgICAgW25vQmFyV2hlblplcm9dPVxcXCJub0JhcldoZW5aZXJvXFxcIlxcbiAgICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGRhdGFMYWJlbFdpZHRoQ2hhbmdlZCk9XFxcIm9uRGF0YUxhYmVsTWF4V2lkdGhDaGFuZ2VkKCRldmVudCwgaW5kZXgpXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJyonXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEJhclZlcnRpY2FsQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJhclZlcnRpY2FsQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmFyVmVydGljYWxDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMuYmFyUGFkZGluZyA9IDg7XHJcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMucm91bmRFZGdlcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuc2hvd0RhdGFMYWJlbCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLm5vQmFyV2hlblplcm8gPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcclxuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XHJcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XHJcbiAgICAgICAgX3RoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0ID0geyBuZWdhdGl2ZTogMCwgcG9zaXRpdmU6IDAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3dEYXRhTGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQgPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hcmdpbiA9IFsxMCArIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0LnBvc2l0aXZlLCAyMCwgMTAgKyB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZSwgMjBdO1xyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxyXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXHJcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcclxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXHJcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcclxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0RhdGFMYWJlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpbXMuaGVpZ2h0IC09IHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArICh0aGlzLm1hcmdpblswXSArIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlKSArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XHJcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLnhEb21haW4ubGVuZ3RoIC8gKHRoaXMuZGltcy53aWR0aCAvIHRoaXMuYmFyUGFkZGluZyArIDEpO1xyXG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuZGltcy53aWR0aF0pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnhEb21haW4pO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy55RG9tYWluID0gdGhpcy5nZXRZRG9tYWluKCk7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAucmFuZ2UoW3RoaXMuZGltcy5oZWlnaHQsIDBdKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMueURvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLmdldFhEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubGFiZWw7IH0pO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcclxuICAgICAgICB2YXIgbWluJCQxID0gdGhpcy55U2NhbGVNaW4gPyBNYXRoLm1pbi5hcHBseShNYXRoLCBbdGhpcy55U2NhbGVNaW5dLmNvbmNhdCh2YWx1ZXMpKSA6IE1hdGgubWluLmFwcGx5KE1hdGgsIFswXS5jb25jYXQodmFsdWVzKSk7XHJcbiAgICAgICAgaWYgKHRoaXMueUF4aXNUaWNrcyAmJiAhdGhpcy55QXhpc1RpY2tzLnNvbWUoaXNOYU4pKSB7XHJcbiAgICAgICAgICAgIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIFttaW4kJDFdLmNvbmNhdCh0aGlzLnlBeGlzVGlja3MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1heCQkMSA9IHRoaXMueVNjYWxlTWF4ID8gTWF0aC5tYXguYXBwbHkoTWF0aCwgW3RoaXMueVNjYWxlTWF4XS5jb25jYXQodmFsdWVzKSkgOiBNYXRoLm1heC5hcHBseShNYXRoLCBbMF0uY29uY2F0KHZhbHVlcykpO1xyXG4gICAgICAgIGlmICh0aGlzLnlBeGlzVGlja3MgJiYgIXRoaXMueUF4aXNUaWNrcy5zb21lKGlzTmFOKSkge1xyXG4gICAgICAgICAgICBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBbbWF4JCQxXS5jb25jYXQodGhpcy55QXhpc1RpY2tzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbjtcclxuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy54RG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy55RG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkb21haW46IFtdLFxyXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnhEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnM7XHJcbiAgICAgICAgICAgIG9wdHMudGl0bGUgPSB0aGlzLmxlZ2VuZFRpdGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnlEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRzO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUub25EYXRhTGFiZWxNYXhIZWlnaHRDaGFuZ2VkID0gZnVuY3Rpb24gKGV2ZW50JCQxKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZXZlbnQkJDEuc2l6ZS5uZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZSA9IE1hdGgubWF4KHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlLCBldmVudCQkMS5zaXplLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5wb3NpdGl2ZSA9IE1hdGgubWF4KHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0LnBvc2l0aXZlLCBldmVudCQkMS5zaXplLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudCQkMS5pbmRleCA9PT0gdGhpcy5yZXN1bHRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGUoKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbaXRlbV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcyk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJQYWRkaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZEVkZ2VzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dEYXRhTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhTGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcIm5vQmFyV2hlblplcm9cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1iYXItdmVydGljYWwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgdHJ1ZSlcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYmFyLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3hBeGlzT2Zmc2V0XT1cXFwiZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1zZXJpZXMtdmVydGljYWxcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgW3Nlcmllc109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgIFtzaG93RGF0YUxhYmVsXT1cXFwic2hvd0RhdGFMYWJlbFxcXCJcXG4gICAgICAgICAgW2RhdGFMYWJlbEZvcm1hdHRpbmddPVxcXCJkYXRhTGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgIFtyb3VuZEVkZ2VzXT1cXFwicm91bmRFZGdlc1xcXCJcXG4gICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGRhdGFMYWJlbEhlaWdodENoYW5nZWQpPVxcXCJvbkRhdGFMYWJlbE1heEhlaWdodENoYW5nZWQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQmFyVmVydGljYWxDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgQmFyVmVydGljYWwyRENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmFyVmVydGljYWwyRENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zY2FsZVR5cGUgPSAnb3JkaW5hbCc7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMuZ3JvdXBQYWRkaW5nID0gMTY7XHJcbiAgICAgICAgX3RoaXMuYmFyUGFkZGluZyA9IDg7XHJcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMucm91bmRFZGdlcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuc2hvd0RhdGFMYWJlbCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLm5vQmFyV2hlblplcm8gPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcclxuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XHJcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XHJcbiAgICAgICAgX3RoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0ID0geyBuZWdhdGl2ZTogMCwgcG9zaXRpdmU6IDAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvd0RhdGFMYWJlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heEhlaWdodCA9IHsgbmVnYXRpdmU6IDAsIHBvc2l0aXZlOiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFyZ2luID0gWzEwICsgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQucG9zaXRpdmUsIDIwLCAxMCArIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlLCAyMF07XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXHJcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcclxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxyXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcclxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxyXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcclxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLnNob3dEYXRhTGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kaW1zLmhlaWdodCAtPSB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mb3JtYXREYXRlcygpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBEb21haW4gPSB0aGlzLmdldEdyb3VwRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5pbm5lckRvbWFpbiA9IHRoaXMuZ2V0SW5uZXJEb21haW4oKTtcclxuICAgICAgICB0aGlzLnZhbHVlc0RvbWFpbiA9IHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcclxuICAgICAgICB0aGlzLmdyb3VwU2NhbGUgPSB0aGlzLmdldEdyb3VwU2NhbGUoKTtcclxuICAgICAgICB0aGlzLmlubmVyU2NhbGUgPSB0aGlzLmdldElubmVyU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnZhbHVlU2NhbGUgPSB0aGlzLmdldFZhbHVlU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiICwgXCIgKyAodGhpcy5tYXJnaW5bMF0gKyB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZSkgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5vbkRhdGFMYWJlbE1heEhlaWdodENoYW5nZWQgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwSW5kZXgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChldmVudCQkMS5zaXplLm5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUsIGV2ZW50JCQxLnNpemUuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0LnBvc2l0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQucG9zaXRpdmUsIGV2ZW50JCQxLnNpemUuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPT09IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlKCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRHcm91cFNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5ncm91cERvbWFpbi5sZW5ndGggLyAodGhpcy5kaW1zLmhlaWdodCAvIHRoaXMuZ3JvdXBQYWRkaW5nICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB0aGlzLmRpbXMud2lkdGhdKVxyXG4gICAgICAgICAgICAucGFkZGluZ0lubmVyKHNwYWNpbmcpXHJcbiAgICAgICAgICAgIC5wYWRkaW5nT3V0ZXIoc3BhY2luZyAvIDIpXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy5ncm91cERvbWFpbik7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5uZXJTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdyb3VwU2NhbGUuYmFuZHdpZHRoKCk7XHJcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLmlubmVyRG9tYWluLmxlbmd0aCAvICh3aWR0aCAvIHRoaXMuYmFyUGFkZGluZyArIDEpO1xyXG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgd2lkdGhdKVxyXG4gICAgICAgICAgICAucGFkZGluZ0lubmVyKHNwYWNpbmcpXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy5pbm5lckRvbWFpbik7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbdGhpcy5kaW1zLmhlaWdodCwgMF0pXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy52YWx1ZXNEb21haW4pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLmdldEdyb3VwRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGdyb3VwLmxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZ3JvdXAubGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5uZXJEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC5sYWJlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLmxhYmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIFswXS5jb25jYXQoZG9tYWluKSk7XHJcbiAgICAgICAgdmFyIG1heCQkMSA9IHRoaXMueVNjYWxlTWF4ID8gTWF0aC5tYXguYXBwbHkoTWF0aCwgW3RoaXMueVNjYWxlTWF4XS5jb25jYXQoZG9tYWluKSkgOiBNYXRoLm1heC5hcHBseShNYXRoLCBbMF0uY29uY2F0KGRvbWFpbikpO1xyXG4gICAgICAgIHJldHVybiBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLmdyb3VwVHJhbnNmb3JtID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy5ncm91cFNjYWxlKGdyb3VwLmxhYmVsKSArIFwiLCAwKVwiO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSwgZ3JvdXApIHtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy52YWx1ZXNEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB7XHJcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZG9tYWluOiBbXSxcclxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcclxuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMudmFsdWVzRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnJlc3VsdHNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZykgeyByZXR1cm4gZy5zZXJpZXM7IH0pXHJcbiAgICAgICAgICAgIC5mbGF0KClcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBpdGVtcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgIT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhKGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNjYWxlVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBQYWRkaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJQYWRkaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmRFZGdlc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0RhdGFMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YUxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcIm5vQmFyV2hlblplcm9cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWJhci12ZXJ0aWNhbC0yZCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYmFyLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWdyaWQtcGFuZWwtc2VyaWVzXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJncm91cFNjYWxlXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwidmFsdWVTY2FsZVxcXCJcXG4gICAgICAgICAgW2RhdGFdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIG9yaWVudD1cXFwidmVydGljYWxcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJncm91cFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFt4QXhpc09mZnNldF09XFxcImRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZVxcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInZhbHVlU2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXNlcmllcy12ZXJ0aWNhbFxcbiAgICAgICAgICAqbmdGb3I9XFxcImxldCBncm91cCBvZiByZXN1bHRzOyBsZXQgaW5kZXggPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeVxcXCJcXG4gICAgICAgICAgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJncm91cFRyYW5zZm9ybShncm91cClcXFwiXFxuICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcImlubmVyU2NhbGVcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ2YWx1ZVNjYWxlXFxcIlxcbiAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICBbc2VyaWVzXT1cXFwiZ3JvdXAuc2VyaWVzXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICBbc2hvd0RhdGFMYWJlbF09XFxcInNob3dEYXRhTGFiZWxcXFwiXFxuICAgICAgICAgIFtkYXRhTGFiZWxGb3JtYXR0aW5nXT1cXFwiZGF0YUxhYmVsRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3Nlcmllc05hbWVdPVxcXCJncm91cC5uYW1lXFxcIlxcbiAgICAgICAgICBbcm91bmRFZGdlc109XFxcInJvdW5kRWRnZXNcXFwiXFxuICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgW25vQmFyV2hlblplcm9dPVxcXCJub0JhcldoZW5aZXJvXFxcIlxcbiAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgIChkYXRhTGFiZWxIZWlnaHRDaGFuZ2VkKT1cXFwib25EYXRhTGFiZWxNYXhIZWlnaHRDaGFuZ2VkKCRldmVudCwgaW5kZXgpXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJyonXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQmFyVmVydGljYWwyRENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy50cmltWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLm1heFhBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLmJhclBhZGRpbmcgPSA4O1xyXG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLm5vQmFyV2hlblplcm8gPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcclxuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XHJcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5mb3JtYXREYXRlcygpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBEb21haW4gPSB0aGlzLmdldEdyb3VwRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5pbm5lckRvbWFpbiA9IHRoaXMuZ2V0SW5uZXJEb21haW4oKTtcclxuICAgICAgICB0aGlzLnZhbHVlRG9tYWluID0gdGhpcy5nZXRWYWx1ZURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiAsIFwiICsgdGhpcy5tYXJnaW5bMF0gKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldEdyb3VwRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGdyb3VwLmxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZ3JvdXAubGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRJbm5lckRvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZ3JvdXAuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLmxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gWzAsIDEwMF07XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLmdyb3VwRG9tYWluLmxlbmd0aCAvICh0aGlzLmRpbXMud2lkdGggLyB0aGlzLmJhclBhZGRpbmcgKyAxKTtcclxuICAgICAgICByZXR1cm4gc2NhbGVCYW5kKClcclxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHRoaXMuZGltcy53aWR0aF0pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLmdyb3VwRG9tYWluKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbdGhpcy5kaW1zLmhlaWdodCwgMF0pXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy52YWx1ZURvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5ncm91cFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHRoaXMueFNjYWxlKGdyb3VwLm5hbWUpICsgXCIsIDApXCI7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIGdyb3VwKSB7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW47XHJcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuaW5uZXJEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnZhbHVlRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB7XHJcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZG9tYWluOiBbXSxcclxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcclxuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMudmFsdWVEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRzO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXAsIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQkJDEpO1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMucmVzdWx0c1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChnKSB7IHJldHVybiBnLnNlcmllczsgfSlcclxuICAgICAgICAgICAgLmZsYXQoKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IGl0ZW1zLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXAsIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQkJDEpO1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsICE9PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIShpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFlBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJQYWRkaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZERvbWFpbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm5vQmFyV2hlblplcm9cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYmFyLXZlcnRpY2FsLW5vcm1hbGl6ZWQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImJhci1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAqbmdGb3I9XFxcImxldCBncm91cCBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcImdyb3VwVHJhbnNmb3JtKGdyb3VwKVxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1zZXJpZXMtdmVydGljYWxcXG4gICAgICAgICAgICB0eXBlPVxcXCJub3JtYWxpemVkXFxcIlxcbiAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICBbc2VyaWVzXT1cXFwiZ3JvdXAuc2VyaWVzXFxcIlxcbiAgICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgW3Nlcmllc05hbWVdPVxcXCJncm91cC5uYW1lXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICcqJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiAnc2NhbGUoMCknIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMuYmFyUGFkZGluZyA9IDg7XHJcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuc2hvd0RhdGFMYWJlbCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLm5vQmFyV2hlblplcm8gPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcclxuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XHJcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XHJcbiAgICAgICAgX3RoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0ID0geyBuZWdhdGl2ZTogMCwgcG9zaXRpdmU6IDAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICghdGhpcy5zaG93RGF0YUxhYmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0ID0geyBuZWdhdGl2ZTogMCwgcG9zaXRpdmU6IDAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXJnaW4gPSBbMTAgKyB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5wb3NpdGl2ZSwgMjAsIDEwICsgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUsIDIwXTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0RhdGFMYWJlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpbXMuaGVpZ2h0IC09IHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cERvbWFpbiA9IHRoaXMuZ2V0R3JvdXBEb21haW4oKTtcclxuICAgICAgICB0aGlzLmlubmVyRG9tYWluID0gdGhpcy5nZXRJbm5lckRvbWFpbigpO1xyXG4gICAgICAgIHRoaXMudmFsdWVEb21haW4gPSB0aGlzLmdldFZhbHVlRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiICwgXCIgKyAodGhpcy5tYXJnaW5bMF0gKyB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZSkgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldEdyb3VwRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGdyb3VwLmxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZ3JvdXAubGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRJbm5lckRvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZ3JvdXAuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLmxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgdmFyIHNtYWxsZXN0ID0gMDtcclxuICAgICAgICB2YXIgYmlnZ2VzdCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB2YXIgc21hbGxlc3RTdW0gPSAwO1xyXG4gICAgICAgICAgICB2YXIgYmlnZ2VzdFN1bSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmIChkLnZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0U3VtICs9IGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiaWdnZXN0U3VtICs9IGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzbWFsbGVzdCA9IGQudmFsdWUgPCBzbWFsbGVzdCA/IGQudmFsdWUgOiBzbWFsbGVzdDtcclxuICAgICAgICAgICAgICAgIGJpZ2dlc3QgPSBkLnZhbHVlID4gYmlnZ2VzdCA/IGQudmFsdWUgOiBiaWdnZXN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRvbWFpbi5wdXNoKHNtYWxsZXN0U3VtKTtcclxuICAgICAgICAgICAgZG9tYWluLnB1c2goYmlnZ2VzdFN1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvbWFpbi5wdXNoKHNtYWxsZXN0KTtcclxuICAgICAgICBkb21haW4ucHVzaChiaWdnZXN0KTtcclxuICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgWzBdLmNvbmNhdChkb21haW4pKTtcclxuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy55U2NhbGVNYXggPyBNYXRoLm1heC5hcHBseShNYXRoLCBbdGhpcy55U2NhbGVNYXhdLmNvbmNhdChkb21haW4pKSA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIGRvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLmdyb3VwRG9tYWluLmxlbmd0aCAvICh0aGlzLmRpbXMud2lkdGggLyB0aGlzLmJhclBhZGRpbmcgKyAxKTtcclxuICAgICAgICByZXR1cm4gc2NhbGVCYW5kKClcclxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHRoaXMuZGltcy53aWR0aF0pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLmdyb3VwRG9tYWluKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbdGhpcy5kaW1zLmhlaWdodCwgMF0pXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy52YWx1ZURvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkRhdGFMYWJlbE1heEhlaWdodENoYW5nZWQgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwSW5kZXgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChldmVudCQkMS5zaXplLm5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUsIGV2ZW50JCQxLnNpemUuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0LnBvc2l0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQucG9zaXRpdmUsIGV2ZW50JCQxLnNpemUuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPT09IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlKCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdyb3VwVHJhbnNmb3JtID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy54U2NhbGUoZ3JvdXAubmFtZSkgKyBcIiwgMClcIjtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSwgZ3JvdXApIHtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbjtcclxuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMudmFsdWVEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkb21haW46IFtdLFxyXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy52YWx1ZURvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdHM7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVhBeGlzSGVpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5yZXN1bHRzXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGcpIHsgcmV0dXJuIGcuc2VyaWVzOyB9KVxyXG4gICAgICAgICAgICAuZmxhdCgpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gaXRlbXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgIT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhKGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImJhclBhZGRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dEYXRhTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YUxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1iYXItdmVydGljYWwtc3RhY2tlZCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYmFyLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3hBeGlzT2Zmc2V0XT1cXFwiZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgKm5nRm9yPVxcXCJsZXQgZ3JvdXAgb2YgcmVzdWx0czsgbGV0IGluZGV4ID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiZ3JvdXBUcmFuc2Zvcm0oZ3JvdXApXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLXNlcmllcy12ZXJ0aWNhbFxcbiAgICAgICAgICAgIHR5cGU9XFxcInN0YWNrZWRcXFwiXFxuICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgIFtzZXJpZXNdPVxcXCJncm91cC5zZXJpZXNcXFwiXFxuICAgICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICBbc2hvd0RhdGFMYWJlbF09XFxcInNob3dEYXRhTGFiZWxcXFwiXFxuICAgICAgICAgICAgW2RhdGFMYWJlbEZvcm1hdHRpbmddPVxcXCJkYXRhTGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICAgIFtzZXJpZXNOYW1lXT1cXFwiZ3JvdXAubmFtZVxcXCJcXG4gICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgW25vQmFyV2hlblplcm9dPVxcXCJub0JhcldoZW5aZXJvXFxcIlxcbiAgICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGRhdGFMYWJlbEhlaWdodENoYW5nZWQpPVxcXCJvbkRhdGFMYWJlbE1heEhlaWdodENoYW5nZWQoJGV2ZW50LCBpbmRleClcXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAnKidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3NjYWxlKDApJyB9KSlcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBEMFR5cGVzO1xyXG4oZnVuY3Rpb24gKEQwVHlwZXMpIHtcclxuICAgIEQwVHlwZXNbXCJwb3NpdGl2ZVwiXSA9IFwicG9zaXRpdmVcIjtcclxuICAgIEQwVHlwZXNbXCJuZWdhdGl2ZVwiXSA9IFwibmVnYXRpdmVcIjtcclxufSkoRDBUeXBlcyB8fCAoRDBUeXBlcyA9IHt9KSk7XHJcbnZhciBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdzdGFuZGFyZCc7XHJcbiAgICAgICAgdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2hvd0RhdGFMYWJlbCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kYXRhTGFiZWxIZWlnaHRDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYmFyc0ZvckRhdGFMYWJlbHMgPSBbXTtcclxuICAgIH1cclxuICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFNldHRpbmdzKCk7XHJcbiAgICAgICAgdmFyIHdpZHRoO1xyXG4gICAgICAgIGlmICh0aGlzLnNlcmllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgd2lkdGggPSB0aGlzLnhTY2FsZS5iYW5kd2lkdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcclxuICAgICAgICB2YXIgeVNjYWxlTWluID0gTWF0aC5tYXgodGhpcy55U2NhbGUuZG9tYWluKClbMF0sIDApO1xyXG4gICAgICAgIHZhciBkMCA9IChfYSA9IHt9LFxyXG4gICAgICAgICAgICBfYVtEMFR5cGVzLnBvc2l0aXZlXSA9IDAsXHJcbiAgICAgICAgICAgIF9hW0QwVHlwZXMubmVnYXRpdmVdID0gMCxcclxuICAgICAgICAgICAgX2EpO1xyXG4gICAgICAgIHZhciBkMFR5cGUgPSBEMFR5cGVzLnBvc2l0aXZlO1xyXG4gICAgICAgIHZhciB0b3RhbDtcclxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbm9ybWFsaXplZCcpIHtcclxuICAgICAgICAgICAgdG90YWwgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBkKSB7IHJldHVybiBzdW0gKyBkOyB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5iYXJzID0gdGhpcy5zZXJpZXMubWFwKGZ1bmN0aW9uIChkLCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkLnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBfdGhpcy5nZXRMYWJlbChkKTtcclxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwpO1xyXG4gICAgICAgICAgICB2YXIgcm91bmRFZGdlcyA9IF90aGlzLnJvdW5kRWRnZXM7XHJcbiAgICAgICAgICAgIGQwVHlwZSA9IHZhbHVlID4gMCA/IEQwVHlwZXMucG9zaXRpdmUgOiBEMFR5cGVzLm5lZ2F0aXZlO1xyXG4gICAgICAgICAgICB2YXIgYmFyID0ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxyXG4gICAgICAgICAgICAgICAgcm91bmRFZGdlczogcm91bmRFZGdlcyxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGQsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRMYWJlbDogZm9ybWF0dGVkTGFiZWwsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMudHlwZSA9PT0gJ3N0YW5kYXJkJykge1xyXG4gICAgICAgICAgICAgICAgYmFyLmhlaWdodCA9IE1hdGguYWJzKF90aGlzLnlTY2FsZSh2YWx1ZSkgLSBfdGhpcy55U2NhbGUoeVNjYWxlTWluKSk7XHJcbiAgICAgICAgICAgICAgICBiYXIueCA9IF90aGlzLnhTY2FsZShsYWJlbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFyLnkgPSBfdGhpcy55U2NhbGUoMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXIueSA9IF90aGlzLnlTY2FsZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMudHlwZSA9PT0gJ3N0YWNrZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MCA9IGQwW2QwVHlwZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MSA9IG9mZnNldDAgKyB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGQwW2QwVHlwZV0gKz0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBiYXIuaGVpZ2h0ID0gX3RoaXMueVNjYWxlKG9mZnNldDApIC0gX3RoaXMueVNjYWxlKG9mZnNldDEpO1xyXG4gICAgICAgICAgICAgICAgYmFyLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgYmFyLnkgPSBfdGhpcy55U2NhbGUob2Zmc2V0MSk7XHJcbiAgICAgICAgICAgICAgICBiYXIub2Zmc2V0MCA9IG9mZnNldDA7XHJcbiAgICAgICAgICAgICAgICBiYXIub2Zmc2V0MSA9IG9mZnNldDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMudHlwZSA9PT0gJ25vcm1hbGl6ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MCA9IGQwW2QwVHlwZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MSA9IG9mZnNldDAgKyB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGQwW2QwVHlwZV0gKz0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodG90YWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MCA9IChvZmZzZXQwICogMTAwKSAvIHRvdGFsO1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDEgPSAob2Zmc2V0MSAqIDEwMCkgLyB0b3RhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDAgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDEgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYmFyLmhlaWdodCA9IF90aGlzLnlTY2FsZShvZmZzZXQwKSAtIF90aGlzLnlTY2FsZShvZmZzZXQxKTtcclxuICAgICAgICAgICAgICAgIGJhci54ID0gMDtcclxuICAgICAgICAgICAgICAgIGJhci55ID0gX3RoaXMueVNjYWxlKG9mZnNldDEpO1xyXG4gICAgICAgICAgICAgICAgYmFyLm9mZnNldDAgPSBvZmZzZXQwO1xyXG4gICAgICAgICAgICAgICAgYmFyLm9mZnNldDEgPSBvZmZzZXQxO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAob2Zmc2V0MSAtIG9mZnNldDApLnRvRml4ZWQoMikgKyAnJSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF90aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICAgICAgYmFyLmNvbG9yID0gX3RoaXMuY29sb3JzLmdldENvbG9yKGxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50eXBlID09PSAnc3RhbmRhcmQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFyLmNvbG9yID0gX3RoaXMuY29sb3JzLmdldENvbG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBiYXIuZ3JhZGllbnRTdG9wcyA9IF90aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhci5jb2xvciA9IF90aGlzLmNvbG9ycy5nZXRDb2xvcihiYXIub2Zmc2V0MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFyLmdyYWRpZW50U3RvcHMgPSBfdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhiYXIub2Zmc2V0MSwgYmFyLm9mZnNldDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0b29sdGlwTGFiZWwgPSBmb3JtYXR0ZWRMYWJlbDtcclxuICAgICAgICAgICAgYmFyLmFyaWFMYWJlbCA9IGZvcm1hdHRlZExhYmVsICsgJyAnICsgdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnNlcmllc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBMYWJlbCA9IF90aGlzLnNlcmllc05hbWUgKyBcIiBcXHUyMDIyIFwiICsgZm9ybWF0dGVkTGFiZWw7XHJcbiAgICAgICAgICAgICAgICBiYXIuZGF0YS5zZXJpZXMgPSBfdGhpcy5zZXJpZXNOYW1lO1xyXG4gICAgICAgICAgICAgICAgYmFyLmFyaWFMYWJlbCA9IF90aGlzLnNlcmllc05hbWUgKyAnICcgKyBiYXIuYXJpYUxhYmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJhci50b29sdGlwVGV4dCA9IF90aGlzLnRvb2x0aXBEaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIDogXCJcXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIHRvb2x0aXBMYWJlbCArIFwiPC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtdmFsXFxcIj5cIiArIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCkgKyBcIjwvc3Bhbj5cXG4gICAgICBcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGJhcjtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZURhdGFMYWJlbHMoKTtcclxuICAgIH07XHJcbiAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlRGF0YUxhYmVscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdGFja2VkJykge1xyXG4gICAgICAgICAgICB0aGlzLmJhcnNGb3JEYXRhTGFiZWxzID0gW107XHJcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0ge307XHJcbiAgICAgICAgICAgIHNlY3Rpb24uc2VyaWVzID0gdGhpcy5zZXJpZXNOYW1lO1xyXG4gICAgICAgICAgICB2YXIgdG90YWxQb3NpdGl2ZSA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIChkID4gMCA/IHN1bSArIGQgOiBzdW0pOyB9LCAwKTtcclxuICAgICAgICAgICAgdmFyIHRvdGFsTmVnYXRpdmUgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBkKSB7IHJldHVybiAoZCA8IDAgPyBzdW0gKyBkIDogc3VtKTsgfSwgMCk7XHJcbiAgICAgICAgICAgIHNlY3Rpb24udG90YWwgPSB0b3RhbFBvc2l0aXZlICsgdG90YWxOZWdhdGl2ZTtcclxuICAgICAgICAgICAgc2VjdGlvbi54ID0gMDtcclxuICAgICAgICAgICAgc2VjdGlvbi55ID0gMDtcclxuICAgICAgICAgICAgaWYgKHNlY3Rpb24udG90YWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLmhlaWdodCA9IHRoaXMueVNjYWxlKHRvdGFsUG9zaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5oZWlnaHQgPSB0aGlzLnlTY2FsZSh0b3RhbE5lZ2F0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWN0aW9uLndpZHRoID0gdGhpcy54U2NhbGUuYmFuZHdpZHRoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmFyc0ZvckRhdGFMYWJlbHMucHVzaChzZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFyc0ZvckRhdGFMYWJlbHMgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWN0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnNlcmllcyA9IF90aGlzLnNlcmllc05hbWUgPyBfdGhpcy5zZXJpZXNOYW1lIDogZC5sYWJlbDtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb24udG90YWwgPSBkLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi54ID0gX3RoaXMueFNjYWxlKGQubGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi55ID0gX3RoaXMueVNjYWxlKDApO1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5oZWlnaHQgPSBfdGhpcy55U2NhbGUoc2VjdGlvbi50b3RhbCkgLSBfdGhpcy55U2NhbGUoMCk7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLndpZHRoID0gX3RoaXMueFNjYWxlLmJhbmR3aWR0aCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlVG9vbHRpcFNldHRpbmdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFBsYWNlbWVudCA9IHRoaXMudG9vbHRpcERpc2FibGVkID8gdW5kZWZpbmVkIDogJ3RvcCc7XHJcbiAgICAgICAgdGhpcy50b29sdGlwVHlwZSA9IHRoaXMudG9vbHRpcERpc2FibGVkID8gdW5kZWZpbmVkIDogJ3Rvb2x0aXAnO1xyXG4gICAgfTtcclxuICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lICYmIGVudHJ5LnNlcmllcyA9PT0gZC5zZXJpZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICBpZiAoZGF0YUl0ZW0ubGFiZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGFJdGVtLmxhYmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YUl0ZW0ubmFtZTtcclxuICAgIH07XHJcbiAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgYmFyKSB7XHJcbiAgICAgICAgcmV0dXJuIGJhci5sYWJlbDtcclxuICAgIH07XHJcbiAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tEYXRhTGFiZWxCeSA9IGZ1bmN0aW9uIChpbmRleCwgYmFyTGFiZWwpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXggKyAnIycgKyBiYXJMYWJlbC5zZXJpZXMgKyAnIycgKyBiYXJMYWJlbC50b3RhbDtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXJpZXNOYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZEVkZ2VzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0RhdGFMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFMYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhTGFiZWxIZWlnaHRDaGFuZ2VkXCIsIHZvaWQgMCk7XHJcbiAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXNlcmllcy12ZXJ0aWNhbF0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnXFxuICAgICAgbmd4LWNoYXJ0cy1iYXJcXG4gICAgICAqbmdGb3I9XFxcImxldCBiYXIgb2YgYmFyczsgdHJhY2tCeTogdHJhY2tCeVxcXCJcXG4gICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgW0AuZGlzYWJsZWRdPVxcXCIhYW5pbWF0aW9uc1xcXCJcXG4gICAgICBbd2lkdGhdPVxcXCJiYXIud2lkdGhcXFwiXFxuICAgICAgW2hlaWdodF09XFxcImJhci5oZWlnaHRcXFwiXFxuICAgICAgW3hdPVxcXCJiYXIueFxcXCJcXG4gICAgICBbeV09XFxcImJhci55XFxcIlxcbiAgICAgIFtmaWxsXT1cXFwiYmFyLmNvbG9yXFxcIlxcbiAgICAgIFtzdG9wc109XFxcImJhci5ncmFkaWVudFN0b3BzXFxcIlxcbiAgICAgIFtkYXRhXT1cXFwiYmFyLmRhdGFcXFwiXFxuICAgICAgW29yaWVudGF0aW9uXT1cXFwiJ3ZlcnRpY2FsJ1xcXCJcXG4gICAgICBbcm91bmRFZGdlc109XFxcImJhci5yb3VuZEVkZ2VzXFxcIlxcbiAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgIFthcmlhTGFiZWxdPVxcXCJiYXIuYXJpYUxhYmVsXFxcIlxcbiAgICAgIFtpc0FjdGl2ZV09XFxcImlzQWN0aXZlKGJhci5kYXRhKVxcXCJcXG4gICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgIG5neC10b29sdGlwXFxuICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcInRvb2x0aXBQbGFjZW1lbnRcXFwiXFxuICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwidG9vbHRpcFR5cGVcXFwiXFxuICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IGJhci50b29sdGlwVGV4dFxcXCJcXG4gICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImJhci5kYXRhXFxcIlxcbiAgICAgIFtub0JhcldoZW5aZXJvXT1cXFwibm9CYXJXaGVuWmVyb1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgID48L3N2ZzpnPlxcbiAgICA8c3ZnOmcgKm5nSWY9XFxcInNob3dEYXRhTGFiZWxcXFwiPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1iYXItbGFiZWxcXG4gICAgICAgICpuZ0Zvcj1cXFwibGV0IGIgb2YgYmFyc0ZvckRhdGFMYWJlbHM7IGxldCBpID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrRGF0YUxhYmVsQnlcXFwiXFxuICAgICAgICBbYmFyWF09XFxcImIueFxcXCJcXG4gICAgICAgIFtiYXJZXT1cXFwiYi55XFxcIlxcbiAgICAgICAgW2JhcldpZHRoXT1cXFwiYi53aWR0aFxcXCJcXG4gICAgICAgIFtiYXJIZWlnaHRdPVxcXCJiLmhlaWdodFxcXCJcXG4gICAgICAgIFt2YWx1ZV09XFxcImIudG90YWxcXFwiXFxuICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwiZGF0YUxhYmVsRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgIFtvcmllbnRhdGlvbl09XFxcIid2ZXJ0aWNhbCdcXFwiXFxuICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJkYXRhTGFiZWxIZWlnaHRDaGFuZ2VkLmVtaXQoeyBzaXplOiAkZXZlbnQsIGluZGV4OiBpIH0pXFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSlcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gU2VyaWVzVmVydGljYWxDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgU2VyaWVzSG9yaXpvbnRhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNlcmllc0hvcml6b250YWwoKSB7XHJcbiAgICAgICAgdGhpcy5iYXJzRm9yRGF0YUxhYmVscyA9IFtdO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdzdGFuZGFyZCc7XHJcbiAgICAgICAgdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2hvd0RhdGFMYWJlbCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kYXRhTGFiZWxXaWR0aENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwU2V0dGluZ3MoKTtcclxuICAgICAgICB2YXIgZDAgPSAoX2EgPSB7fSxcclxuICAgICAgICAgICAgX2FbRDBUeXBlcy5wb3NpdGl2ZV0gPSAwLFxyXG4gICAgICAgICAgICBfYVtEMFR5cGVzLm5lZ2F0aXZlXSA9IDAsXHJcbiAgICAgICAgICAgIF9hKTtcclxuICAgICAgICB2YXIgZDBUeXBlO1xyXG4gICAgICAgIGQwVHlwZSA9IEQwVHlwZXMucG9zaXRpdmU7XHJcbiAgICAgICAgdmFyIHRvdGFsO1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdub3JtYWxpemVkJykge1xyXG4gICAgICAgICAgICB0b3RhbCA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIHN1bSArIGQ7IH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgeFNjYWxlTWluID0gTWF0aC5tYXgodGhpcy54U2NhbGUuZG9tYWluKClbMF0sIDApO1xyXG4gICAgICAgIHRoaXMuYmFycyA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZC52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gX3RoaXMuZ2V0TGFiZWwoZCk7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRMYWJlbCA9IGZvcm1hdExhYmVsKGxhYmVsKTtcclxuICAgICAgICAgICAgdmFyIHJvdW5kRWRnZXMgPSBfdGhpcy5yb3VuZEVkZ2VzO1xyXG4gICAgICAgICAgICBkMFR5cGUgPSB2YWx1ZSA+IDAgPyBEMFR5cGVzLnBvc2l0aXZlIDogRDBUeXBlcy5uZWdhdGl2ZTtcclxuICAgICAgICAgICAgdmFyIGJhciA9IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcclxuICAgICAgICAgICAgICAgIHJvdW5kRWRnZXM6IHJvdW5kRWRnZXMsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkTGFiZWw6IGZvcm1hdHRlZExhYmVsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGJhci5oZWlnaHQgPSBfdGhpcy55U2NhbGUuYmFuZHdpZHRoKCk7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy50eXBlID09PSAnc3RhbmRhcmQnKSB7XHJcbiAgICAgICAgICAgICAgICBiYXIud2lkdGggPSBNYXRoLmFicyhfdGhpcy54U2NhbGUodmFsdWUpIC0gX3RoaXMueFNjYWxlKHhTY2FsZU1pbikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhci54ID0gX3RoaXMueFNjYWxlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhci54ID0gX3RoaXMueFNjYWxlKHhTY2FsZU1pbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBiYXIueSA9IF90aGlzLnlTY2FsZShsYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMudHlwZSA9PT0gJ3N0YWNrZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MCA9IGQwW2QwVHlwZV07XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0MSA9IG9mZnNldDAgKyB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGQwW2QwVHlwZV0gKz0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBiYXIud2lkdGggPSBfdGhpcy54U2NhbGUob2Zmc2V0MSkgLSBfdGhpcy54U2NhbGUob2Zmc2V0MCk7XHJcbiAgICAgICAgICAgICAgICBiYXIueCA9IF90aGlzLnhTY2FsZShvZmZzZXQwKTtcclxuICAgICAgICAgICAgICAgIGJhci55ID0gMDtcclxuICAgICAgICAgICAgICAgIGJhci5vZmZzZXQwID0gb2Zmc2V0MDtcclxuICAgICAgICAgICAgICAgIGJhci5vZmZzZXQxID0gb2Zmc2V0MTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy50eXBlID09PSAnbm9ybWFsaXplZCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQwID0gZDBbZDBUeXBlXTtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQxID0gb2Zmc2V0MCArIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZDBbZDBUeXBlXSArPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0b3RhbCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQwID0gKG9mZnNldDAgKiAxMDApIC8gdG90YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MSA9IChvZmZzZXQxICogMTAwKSAvIHRvdGFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBiYXIud2lkdGggPSBfdGhpcy54U2NhbGUob2Zmc2V0MSkgLSBfdGhpcy54U2NhbGUob2Zmc2V0MCk7XHJcbiAgICAgICAgICAgICAgICBiYXIueCA9IF90aGlzLnhTY2FsZShvZmZzZXQwKTtcclxuICAgICAgICAgICAgICAgIGJhci55ID0gMDtcclxuICAgICAgICAgICAgICAgIGJhci5vZmZzZXQwID0gb2Zmc2V0MDtcclxuICAgICAgICAgICAgICAgIGJhci5vZmZzZXQxID0gb2Zmc2V0MTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gKG9mZnNldDEgLSBvZmZzZXQwKS50b0ZpeGVkKDIpICsgJyUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb2xvcnMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgICAgIGJhci5jb2xvciA9IF90aGlzLmNvbG9ycy5nZXRDb2xvcihsYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudHlwZSA9PT0gJ3N0YW5kYXJkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhci5jb2xvciA9IF90aGlzLmNvbG9ycy5nZXRDb2xvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFyLmdyYWRpZW50U3RvcHMgPSBfdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXIuY29sb3IgPSBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IoYmFyLm9mZnNldDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhci5ncmFkaWVudFN0b3BzID0gX3RoaXMuY29sb3JzLmdldExpbmVhckdyYWRpZW50U3RvcHMoYmFyLm9mZnNldDEsIGJhci5vZmZzZXQwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdG9vbHRpcExhYmVsID0gZm9ybWF0dGVkTGFiZWw7XHJcbiAgICAgICAgICAgIGJhci5hcmlhTGFiZWwgPSBmb3JtYXR0ZWRMYWJlbCArICcgJyArIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5zZXJpZXNOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwTGFiZWwgPSBfdGhpcy5zZXJpZXNOYW1lICsgXCIgXFx1MjAyMiBcIiArIGZvcm1hdHRlZExhYmVsO1xyXG4gICAgICAgICAgICAgICAgYmFyLmRhdGEuc2VyaWVzID0gX3RoaXMuc2VyaWVzTmFtZTtcclxuICAgICAgICAgICAgICAgIGJhci5hcmlhTGFiZWwgPSBfdGhpcy5zZXJpZXNOYW1lICsgJyAnICsgYmFyLmFyaWFMYWJlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiYXIudG9vbHRpcFRleHQgPSBfdGhpcy50b29sdGlwRGlzYWJsZWRcclxuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA6IFwiXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC1sYWJlbFxcXCI+XCIgKyB0b29sdGlwTGFiZWwgKyBcIjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWx1ZS50b0xvY2FsZVN0cmluZygpICsgXCI8L3NwYW4+XFxuICAgICAgXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBiYXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhTGFiZWxzKCk7XHJcbiAgICB9O1xyXG4gICAgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUudXBkYXRlRGF0YUxhYmVscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzdGFja2VkJykge1xyXG4gICAgICAgICAgICB0aGlzLmJhcnNGb3JEYXRhTGFiZWxzID0gW107XHJcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0ge307XHJcbiAgICAgICAgICAgIHNlY3Rpb24uc2VyaWVzID0gdGhpcy5zZXJpZXNOYW1lO1xyXG4gICAgICAgICAgICB2YXIgdG90YWxQb3NpdGl2ZSA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIChkID4gMCA/IHN1bSArIGQgOiBzdW0pOyB9LCAwKTtcclxuICAgICAgICAgICAgdmFyIHRvdGFsTmVnYXRpdmUgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBkKSB7IHJldHVybiAoZCA8IDAgPyBzdW0gKyBkIDogc3VtKTsgfSwgMCk7XHJcbiAgICAgICAgICAgIHNlY3Rpb24udG90YWwgPSB0b3RhbFBvc2l0aXZlICsgdG90YWxOZWdhdGl2ZTtcclxuICAgICAgICAgICAgc2VjdGlvbi54ID0gMDtcclxuICAgICAgICAgICAgc2VjdGlvbi55ID0gMDtcclxuICAgICAgICAgICAgLy8gaWYgdG90YWwgaXMgcG9zaXRpdmUgdGhlbiB3ZSBzaG93IGl0IG9uIHRoZSByaWdodCwgb3RoZXJ3aXNlIG9uIHRoZSBsZWZ0XHJcbiAgICAgICAgICAgIGlmIChzZWN0aW9uLnRvdGFsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi53aWR0aCA9IHRoaXMueFNjYWxlKHRvdGFsUG9zaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi53aWR0aCA9IHRoaXMueFNjYWxlKHRvdGFsTmVnYXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlY3Rpb24uaGVpZ2h0ID0gdGhpcy55U2NhbGUuYmFuZHdpZHRoKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmFyc0ZvckRhdGFMYWJlbHMucHVzaChzZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFyc0ZvckRhdGFMYWJlbHMgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWN0aW9uID0ge307XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnNlcmllcyA9IF90aGlzLnNlcmllc05hbWUgPyBfdGhpcy5zZXJpZXNOYW1lIDogZC5sYWJlbDtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb24udG90YWwgPSBkLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi54ID0gX3RoaXMueFNjYWxlKDApO1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi55ID0gX3RoaXMueVNjYWxlKGQubGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi53aWR0aCA9IF90aGlzLnhTY2FsZShzZWN0aW9uLnRvdGFsKSAtIF90aGlzLnhTY2FsZSgwKTtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb24uaGVpZ2h0ID0gX3RoaXMueVNjYWxlLmJhbmR3aWR0aCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlY3Rpb247XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS51cGRhdGVUb29sdGlwU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50b29sdGlwUGxhY2VtZW50ID0gdGhpcy50b29sdGlwRGlzYWJsZWQgPyB1bmRlZmluZWQgOiAndG9wJztcclxuICAgICAgICB0aGlzLnRvb2x0aXBUeXBlID0gdGhpcy50b29sdGlwRGlzYWJsZWQgPyB1bmRlZmluZWQgOiAndG9vbHRpcCc7XHJcbiAgICB9O1xyXG4gICAgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWUgPT09IGQubmFtZSAmJiBlbnRyeS5zZXJpZXMgPT09IGQuc2VyaWVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiAoZGF0YUl0ZW0pIHtcclxuICAgICAgICBpZiAoZGF0YUl0ZW0ubGFiZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGFJdGVtLmxhYmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YUl0ZW0ubmFtZTtcclxuICAgIH07XHJcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBiYXIpIHtcclxuICAgICAgICByZXR1cm4gYmFyLmxhYmVsO1xyXG4gICAgfTtcclxuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLnRyYWNrRGF0YUxhYmVsQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGJhckxhYmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ICsgJyMnICsgYmFyTGFiZWwuc2VyaWVzICsgJyMnICsgYmFyTGFiZWwudG90YWw7XHJcbiAgICB9O1xyXG4gICAgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUuY2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwic2VyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwic2VyaWVzTmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwicm91bmRFZGdlc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJzaG93RGF0YUxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJkYXRhTGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcImRhdGFMYWJlbFdpZHRoQ2hhbmdlZFwiLCB2b2lkIDApO1xyXG4gICAgU2VyaWVzSG9yaXpvbnRhbCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXNlcmllcy1ob3Jpem9udGFsXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmdcXG4gICAgICBuZ3gtY2hhcnRzLWJhclxcbiAgICAgICpuZ0Zvcj1cXFwibGV0IGJhciBvZiBiYXJzOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICBbd2lkdGhdPVxcXCJiYXIud2lkdGhcXFwiXFxuICAgICAgW2hlaWdodF09XFxcImJhci5oZWlnaHRcXFwiXFxuICAgICAgW3hdPVxcXCJiYXIueFxcXCJcXG4gICAgICBbeV09XFxcImJhci55XFxcIlxcbiAgICAgIFtmaWxsXT1cXFwiYmFyLmNvbG9yXFxcIlxcbiAgICAgIFtzdG9wc109XFxcImJhci5ncmFkaWVudFN0b3BzXFxcIlxcbiAgICAgIFtkYXRhXT1cXFwiYmFyLmRhdGFcXFwiXFxuICAgICAgW29yaWVudGF0aW9uXT1cXFwiJ2hvcml6b250YWwnXFxcIlxcbiAgICAgIFtyb3VuZEVkZ2VzXT1cXFwiYmFyLnJvdW5kRWRnZXNcXFwiXFxuICAgICAgKHNlbGVjdCk9XFxcImNsaWNrKCRldmVudClcXFwiXFxuICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgW2lzQWN0aXZlXT1cXFwiaXNBY3RpdmUoYmFyLmRhdGEpXFxcIlxcbiAgICAgIFthcmlhTGFiZWxdPVxcXCJiYXIuYXJpYUxhYmVsXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgKGRlYWN0aXZhdGUpPVxcXCJkZWFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVxcXCJ0b29sdGlwUGxhY2VtZW50XFxcIlxcbiAgICAgIFt0b29sdGlwVHlwZV09XFxcInRvb2x0aXBUeXBlXFxcIlxcbiAgICAgIFt0b29sdGlwVGl0bGVdPVxcXCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiBiYXIudG9vbHRpcFRleHRcXFwiXFxuICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJiYXIuZGF0YVxcXCJcXG4gICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgID48L3N2ZzpnPlxcbiAgICA8c3ZnOmcgKm5nSWY9XFxcInNob3dEYXRhTGFiZWxcXFwiPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1iYXItbGFiZWxcXG4gICAgICAgICpuZ0Zvcj1cXFwibGV0IGIgb2YgYmFyc0ZvckRhdGFMYWJlbHM7IGxldCBpID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrRGF0YUxhYmVsQnlcXFwiXFxuICAgICAgICBbYmFyWF09XFxcImIueFxcXCJcXG4gICAgICAgIFtiYXJZXT1cXFwiYi55XFxcIlxcbiAgICAgICAgW2JhcldpZHRoXT1cXFwiYi53aWR0aFxcXCJcXG4gICAgICAgIFtiYXJIZWlnaHRdPVxcXCJiLmhlaWdodFxcXCJcXG4gICAgICAgIFt2YWx1ZV09XFxcImIudG90YWxcXFwiXFxuICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwiZGF0YUxhYmVsRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgIFtvcmllbnRhdGlvbl09XFxcIidob3Jpem9udGFsJ1xcXCJcXG4gICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcImRhdGFMYWJlbFdpZHRoQ2hhbmdlZC5lbWl0KHsgc2l6ZTogJGV2ZW50LCBpbmRleDogaSB9KVxcXCJcXG4gICAgICAvPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbCk7XHJcbiAgICByZXR1cm4gU2VyaWVzSG9yaXpvbnRhbDtcclxufSgpKTtcclxuXHJcbnZhciBCYXJMYWJlbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhckxhYmVsQ29tcG9uZW50KGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbFBhZGRpbmcgPSAyO1xyXG4gICAgICAgIHRoaXMudmVydGljYWxQYWRkaW5nID0gNTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQmFyTGFiZWxDb21wb25lbnQucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGggPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB3ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xyXG4gICAgICAgIHJldHVybiB7IGhlaWdodDogaCwgd2lkdGg6IHcsIG5lZ2F0aXZlOiB0aGlzLnZhbHVlIDwgMCB9O1xyXG4gICAgfTtcclxuICAgIEJhckxhYmVsQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZC5lbWl0KHRoaXMuZ2V0U2l6ZSgpKTtcclxuICAgIH07XHJcbiAgICBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlRm9ybWF0dGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmZvcm1hdGVkVmFsdWUgPSB0aGlzLnZhbHVlRm9ybWF0dGluZyh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0ZWRWYWx1ZSA9IGZvcm1hdExhYmVsKHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMuYmFyWCArIHRoaXMuYmFyV2lkdGg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy54IC0gdGhpcy5ob3Jpem9udGFsUGFkZGluZztcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdlbmQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy54ICsgdGhpcy5ob3Jpem9udGFsUGFkZGluZztcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdzdGFydCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5iYXJZICsgdGhpcy5iYXJIZWlnaHQgLyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5iYXJYICsgdGhpcy5iYXJXaWR0aCAvIDI7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMuYmFyWSArIHRoaXMuYmFySGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSArIHRoaXMudmVydGljYWxQYWRkaW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ2VuZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB0aGlzLnkgLSB0aGlzLnZlcnRpY2FsUGFkZGluZztcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdzdGFydCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInJvdGF0ZSgtNDUsIFwiICsgdGhpcy54ICsgXCIgLCBcIiArIHRoaXMueSArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFyWFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImJhcllcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJXaWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImJhckhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltZW5zaW9uc0NoYW5nZWRcIiwgdm9pZCAwKTtcclxuICAgIEJhckxhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtYmFyLWxhYmVsXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIiAgXFxuICAgIDxzdmc6dGV4dCAgIFxcbiAgICAgIGNsYXNzPVxcXCJ0ZXh0RGF0YUxhYmVsXFxcIiBcXG4gICAgICBhbGlnbm1lbnQtYmFzZWxpbmU9XFxcIm1pZGRsZVxcXCIgICAgIFxcbiAgICAgIFthdHRyLnRleHQtYW5jaG9yXT1cXFwidGV4dEFuY2hvclxcXCJcXG4gICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiXFxuICAgICAgW2F0dHIueF09XFxcInhcXFwiIFxcbiAgICAgIFthdHRyLnldPVxcXCJ5XFxcIj5cXG4gICAgICB7e2Zvcm1hdGVkVmFsdWV9fSAgICAgXFxuICAgIDwvc3ZnOnRleHQ+ICAgICAgICAgIFxcblxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLnRleHREYXRhTGFiZWx7Zm9udC1zaXplOjExcHh9XCJdLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYiA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdF0pXHJcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQmFyTGFiZWxDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgQmFyQ2hhcnRNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCYXJDaGFydE1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIEJhckNoYXJ0TW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIEJhckNvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhckhvcml6b250YWxDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQmFyVmVydGljYWxDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQmFyTGFiZWxDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBTZXJpZXNIb3Jpem9udGFsLFxyXG4gICAgICAgICAgICAgICAgU2VyaWVzVmVydGljYWxDb21wb25lbnRcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZXhwb3J0czogW1xyXG4gICAgICAgICAgICAgICAgQmFyQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQmFySG9yaXpvbnRhbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJWZXJ0aWNhbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJMYWJlbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFNlcmllc0hvcml6b250YWwsXHJcbiAgICAgICAgICAgICAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEJhckNoYXJ0TW9kdWxlKTtcclxuICAgIHJldHVybiBCYXJDaGFydE1vZHVsZTtcclxufSgpKTtcclxuXHJcbmZ1bmN0aW9uIGdldERvbWFpbih2YWx1ZXMsIHNjYWxlVHlwZSwgYXV0b1NjYWxlLCBtaW5WYWwsIG1heFZhbCkge1xyXG4gICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgaWYgKHNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBOdW1iZXIodik7IH0pO1xyXG4gICAgICAgIGlmICghYXV0b1NjYWxlKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzY2FsZVR5cGUgPT09ICd0aW1lJyB8fCBzY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgdmFyIG1pbiQkMSA9IG1pblZhbCA/IG1pblZhbCA6IE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgdmFyIG1heCQkMSA9IG1heFZhbCA/IG1heFZhbCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgZG9tYWluID0gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGRvbWFpbiA9IHZhbHVlcztcclxuICAgIH1cclxuICAgIHJldHVybiBkb21haW47XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2NhbGUoZG9tYWluLCByYW5nZSQkMSwgc2NhbGVUeXBlLCByb3VuZERvbWFpbnMpIHtcclxuICAgIHZhciBzY2FsZTtcclxuICAgIGlmIChzY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgIHNjYWxlID0gc2NhbGVUaW1lKClcclxuICAgICAgICAgICAgLnJhbmdlKHJhbmdlJCQxKVxyXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShyYW5nZSQkMSlcclxuICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xyXG4gICAgICAgIGlmIChyb3VuZERvbWFpbnMpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZS5uaWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICBzY2FsZSA9IHNjYWxlUG9pbnQoKVxyXG4gICAgICAgICAgICAucmFuZ2UoW3JhbmdlJCQxWzBdLCByYW5nZSQkMVsxXV0pXHJcbiAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzY2FsZTtcclxufVxyXG5cclxudmFyIEJ1YmJsZUNoYXJ0Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJ1YmJsZUNoYXJ0Q29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQnViYmxlQ2hhcnRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMueEF4aXMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnlBeGlzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLm1heFhBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLm1heFJhZGl1cyA9IDEwO1xyXG4gICAgICAgIF90aGlzLm1pblJhZGl1cyA9IDM7XHJcbiAgICAgICAgX3RoaXMuc2NoZW1lVHlwZSA9ICdvcmRpbmFsJztcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLnNjYWxlVHlwZSA9ICdsaW5lYXInO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgX3RoaXMuYnViYmxlUGFkZGluZyA9IFswLCAwLCAwLCAwXTtcclxuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XHJcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zZXJpZXNEb21haW4gPSB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWU7IH0pO1xyXG4gICAgICAgIHRoaXMuckRvbWFpbiA9IHRoaXMuZ2V0UkRvbWFpbigpO1xyXG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xyXG4gICAgICAgIHRoaXMueURvbWFpbiA9IHRoaXMuZ2V0WURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiLFwiICsgdGhpcy5tYXJnaW5bMF0gKyBcIilcIjtcclxuICAgICAgICB2YXIgY29sb3JEb21haW4gPSB0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJyA/IHRoaXMuc2VyaWVzRG9tYWluIDogdGhpcy5yRG9tYWluO1xyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGNvbG9yRG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5yZXN1bHRzO1xyXG4gICAgICAgIHRoaXMubWluUmFkaXVzID0gTWF0aC5tYXgodGhpcy5taW5SYWRpdXMsIDEpO1xyXG4gICAgICAgIHRoaXMubWF4UmFkaXVzID0gTWF0aC5tYXgodGhpcy5tYXhSYWRpdXMsIDEpO1xyXG4gICAgICAgIHRoaXMuclNjYWxlID0gdGhpcy5nZXRSU2NhbGUodGhpcy5yRG9tYWluLCBbdGhpcy5taW5SYWRpdXMsIHRoaXMubWF4UmFkaXVzXSk7XHJcbiAgICAgICAgdGhpcy5idWJibGVQYWRkaW5nID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgIHRoaXMuc2V0U2NhbGVzKCk7XHJcbiAgICAgICAgdGhpcy5idWJibGVQYWRkaW5nID0gdGhpcy5nZXRCdWJibGVQYWRkaW5nKCk7XHJcbiAgICAgICAgdGhpcy5zZXRTY2FsZXMoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcclxuICAgICAgICB0aGlzLmNsaXBQYXRoSWQgPSAnY2xpcCcgKyBpZCgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5jbGlwUGF0aCA9IFwidXJsKCNcIiArIHRoaXMuY2xpcFBhdGhJZCArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5oaWRlQ2lyY2xlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcclxuICAgIH07XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXMpIHtcclxuICAgICAgICBpZiAoc2VyaWVzKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc2VyaWVzID0gc2VyaWVzLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldEJ1YmJsZVBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHlNaW4gPSAwO1xyXG4gICAgICAgIHZhciB4TWluID0gMDtcclxuICAgICAgICB2YXIgeU1heCA9IHRoaXMuZGltcy5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHhNYXggPSB0aGlzLmRpbXMud2lkdGg7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZGF0YTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHMgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBzLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnJTY2FsZShkLnIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gdGhpcy54U2NhbGVUeXBlID09PSAnbGluZWFyJyA/IHRoaXMueFNjYWxlKE51bWJlcihkLngpKSA6IHRoaXMueFNjYWxlKGQueCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSB0aGlzLnlTY2FsZVR5cGUgPT09ICdsaW5lYXInID8gdGhpcy55U2NhbGUoTnVtYmVyKGQueSkpIDogdGhpcy55U2NhbGUoZC55KTtcclxuICAgICAgICAgICAgICAgIHhNaW4gPSBNYXRoLm1heChyIC0gY3gsIHhNaW4pO1xyXG4gICAgICAgICAgICAgICAgeU1pbiA9IE1hdGgubWF4KHIgLSBjeSwgeU1pbik7XHJcbiAgICAgICAgICAgICAgICB5TWF4ID0gTWF0aC5tYXgoY3kgKyByLCB5TWF4KTtcclxuICAgICAgICAgICAgICAgIHhNYXggPSBNYXRoLm1heChjeCArIHIsIHhNYXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHhNYXggPSBNYXRoLm1heCh4TWF4IC0gdGhpcy5kaW1zLndpZHRoLCAwKTtcclxuICAgICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCAtIHRoaXMuZGltcy5oZWlnaHQsIDApO1xyXG4gICAgICAgIHJldHVybiBbeU1pbiwgeE1heCwgeU1heCwgeE1pbl07XHJcbiAgICB9O1xyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnNldFNjYWxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmRpbXMud2lkdGg7XHJcbiAgICAgICAgaWYgKHRoaXMueFNjYWxlTWluID09PSB1bmRlZmluZWQgJiYgdGhpcy54U2NhbGVNYXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoIC0gdGhpcy5idWJibGVQYWRkaW5nWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5kaW1zLmhlaWdodDtcclxuICAgICAgICBpZiAodGhpcy55U2NhbGVNaW4gPT09IHVuZGVmaW5lZCAmJiB0aGlzLnlTY2FsZU1heCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAtIHRoaXMuYnViYmxlUGFkZGluZ1syXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHdpZHRoKTtcclxuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgaGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNjYWxlKGRvbWFpbiwgW2hlaWdodCwgdGhpcy5idWJibGVQYWRkaW5nWzBdXSwgdGhpcy55U2NhbGVUeXBlLCB0aGlzLnJvdW5kRG9tYWlucyk7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIHdpZHRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNjYWxlKGRvbWFpbiwgW3RoaXMuYnViYmxlUGFkZGluZ1szXSwgd2lkdGhdLCB0aGlzLnhTY2FsZVR5cGUsIHRoaXMucm91bmREb21haW5zKTtcclxuICAgIH07XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0UlNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UkJDEpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShyYW5nZSQkMSlcclxuICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGRvbWFpbjogW10sXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uLFxyXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuc2VyaWVzRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy5yRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH07XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSByZXN1bHRzLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZXMuaW5jbHVkZXMoZC54KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGQueCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy54U2NhbGVUeXBlID0gZ2V0U2NhbGVUeXBlKHZhbHVlcyk7XHJcbiAgICAgICAgcmV0dXJuIGdldERvbWFpbih2YWx1ZXMsIHRoaXMueFNjYWxlVHlwZSwgdGhpcy5hdXRvU2NhbGUsIHRoaXMueFNjYWxlTWluLCB0aGlzLnhTY2FsZU1heCk7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gcmVzdWx0cy5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKGQueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChkLnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueVNjYWxlVHlwZSA9IGdldFNjYWxlVHlwZSh2YWx1ZXMpO1xyXG4gICAgICAgIHJldHVybiBnZXREb21haW4odmFsdWVzLCB0aGlzLnlTY2FsZVR5cGUsIHRoaXMuYXV0b1NjYWxlLCB0aGlzLnlTY2FsZU1pbiwgdGhpcy55U2NhbGVNYXgpO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRSRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtaW4kJDEgPSBJbmZpbml0eTtcclxuICAgICAgICB2YXIgbWF4JCQxID0gLUluZmluaXR5O1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gcmVzdWx0cy5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihkLnIpIHx8IDE7XHJcbiAgICAgICAgICAgICAgICBtaW4kJDEgPSBNYXRoLm1pbihtaW4kJDEsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIG1heCQkMSA9IE1hdGgubWF4KG1heCQkMSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5kZWFjdGl2YXRlQWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmFjdGl2ZUVudHJpZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogZW50cnksIGVudHJpZXM6IFtdIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgIH07XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFlBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFJhZGl1c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblJhZGl1c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhdXRvU2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZU1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZU1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZU1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZU1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImhpZGVDaXJjbGVzXCIsIG51bGwpO1xyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYnViYmxlLWNoYXJ0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpkZWZzPlxcbiAgICAgICAgPHN2ZzpjbGlwUGF0aCBbYXR0ci5pZF09XFxcImNsaXBQYXRoSWRcXFwiPlxcbiAgICAgICAgICA8c3ZnOnJlY3RcXG4gICAgICAgICAgICBbYXR0ci53aWR0aF09XFxcImRpbXMud2lkdGggKyAxMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJkaW1zLmhlaWdodCArIDEwXFxcIlxcbiAgICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcIid0cmFuc2xhdGUoLTUsIC01KSdcXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpjbGlwUGF0aD5cXG4gICAgICA8L3N2ZzpkZWZzPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJidWJibGUtY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhZQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInlBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8c3ZnOnJlY3RcXG4gICAgICAgICAgY2xhc3M9XFxcImJ1YmJsZS1jaGFydC1hcmVhXFxcIlxcbiAgICAgICAgICB4PVxcXCIwXFxcIlxcbiAgICAgICAgICB5PVxcXCIwXFxcIlxcbiAgICAgICAgICBbYXR0ci53aWR0aF09XFxcImRpbXMud2lkdGhcXFwiXFxuICAgICAgICAgIFthdHRyLmhlaWdodF09XFxcImRpbXMuaGVpZ2h0XFxcIlxcbiAgICAgICAgICBzdHlsZT1cXFwiZmlsbDogcmdiKDI1NSwgMCwgMCk7IG9wYWNpdHk6IDA7IGN1cnNvcjogJ2F1dG8nO1xcXCJcXG4gICAgICAgICAgKG1vdXNlZW50ZXIpPVxcXCJkZWFjdGl2YXRlQWxsKClcXFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPHN2ZzpnIFthdHRyLmNsaXAtcGF0aF09XFxcImNsaXBQYXRoXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiBkYXRhOyB0cmFja0J5OiB0cmFja0J5XFxcIiBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1idWJibGUtc2VyaWVzXFxuICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFtyU2NhbGVdPVxcXCJyU2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbeFNjYWxlVHlwZV09XFxcInhTY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICBbeVNjYWxlVHlwZV09XFxcInlTY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICBbeEF4aXNMYWJlbF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgICAgICBbeUF4aXNMYWJlbF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudCwgc2VyaWVzKVxcXCJcXG4gICAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIl0sXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50KTtcclxuICAgIHJldHVybiBCdWJibGVDaGFydENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBCdWJibGVTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCdWJibGVTZXJpZXNDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jaXJjbGVzID0gdGhpcy5nZXRDaXJjbGVzKCk7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDaXJjbGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHNlcmllc05hbWUgPSB0aGlzLmRhdGEubmFtZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNlcmllc1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZC55ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZC54ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBkLnk7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGQueDtcclxuICAgICAgICAgICAgICAgIHZhciByID0gZC5yO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IF90aGlzLnJTY2FsZShyIHx8IDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBMYWJlbCA9IGZvcm1hdExhYmVsKGQubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSBfdGhpcy54U2NhbGVUeXBlID09PSAnbGluZWFyJyA/IF90aGlzLnhTY2FsZShOdW1iZXIoeCkpIDogX3RoaXMueFNjYWxlKHgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gX3RoaXMueVNjYWxlVHlwZSA9PT0gJ2xpbmVhcicgPyBfdGhpcy55U2NhbGUoTnVtYmVyKHkpKSA6IF90aGlzLnlTY2FsZSh5KTtcclxuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IF90aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInID8gX3RoaXMuY29sb3JzLmdldENvbG9yKHIpIDogX3RoaXMuY29sb3JzLmdldENvbG9yKHNlcmllc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQWN0aXZlID0gIV90aGlzLmFjdGl2ZUVudHJpZXMubGVuZ3RoID8gdHJ1ZSA6IF90aGlzLmlzQWN0aXZlKHsgbmFtZTogc2VyaWVzTmFtZSB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gaXNBY3RpdmUgPyAxIDogMC4zO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGQubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC55LFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IGQueCxcclxuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IGQuclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgICAgICB5OiB5LFxyXG4gICAgICAgICAgICAgICAgICAgIHI6IHIsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lczogW1wiY2lyY2xlLWRhdGEtXCIgKyBpXSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeSxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogeCxcclxuICAgICAgICAgICAgICAgICAgICBjeDogY3gsXHJcbiAgICAgICAgICAgICAgICAgICAgY3k6IGN5LFxyXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBMYWJlbDogdG9vbHRpcExhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmU6IGlzQWN0aXZlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBjeCArIFwiLFwiICsgY3kgKyBcIilcIlxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGNpcmNsZSkgeyByZXR1cm4gY2lyY2xlICE9PSB1bmRlZmluZWQ7IH0pO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0VG9vbHRpcFRleHQgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XHJcbiAgICAgICAgdmFyIGhhc1JhZGl1cyA9IHR5cGVvZiBjaXJjbGUuciAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgICAgICAgdmFyIGhhc1Rvb2x0aXBMYWJlbCA9IGNpcmNsZS50b29sdGlwTGFiZWwgJiYgY2lyY2xlLnRvb2x0aXBMYWJlbC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGhhc1Nlcmllc05hbWUgPSBjaXJjbGUuc2VyaWVzTmFtZSAmJiBjaXJjbGUuc2VyaWVzTmFtZS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHJhZGl1c1ZhbHVlID0gaGFzUmFkaXVzID8gZm9ybWF0TGFiZWwoY2lyY2xlLnIpIDogJyc7XHJcbiAgICAgICAgdmFyIHhBeGlzTGFiZWwgPSB0aGlzLnhBeGlzTGFiZWwgJiYgdGhpcy54QXhpc0xhYmVsICE9PSAnJyA/IHRoaXMueEF4aXNMYWJlbCArIFwiOlwiIDogJyc7XHJcbiAgICAgICAgdmFyIHlBeGlzTGFiZWwgPSB0aGlzLnlBeGlzTGFiZWwgJiYgdGhpcy55QXhpc0xhYmVsICE9PSAnJyA/IHRoaXMueUF4aXNMYWJlbCArIFwiOlwiIDogJyc7XHJcbiAgICAgICAgdmFyIHggPSBmb3JtYXRMYWJlbChjaXJjbGUueCk7XHJcbiAgICAgICAgdmFyIHkgPSBmb3JtYXRMYWJlbChjaXJjbGUueSk7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBoYXNTZXJpZXNOYW1lICYmIGhhc1Rvb2x0aXBMYWJlbFxyXG4gICAgICAgICAgICA/IGNpcmNsZS5zZXJpZXNOYW1lICsgXCIgXFx1MjAyMiBcIiArIGNpcmNsZS50b29sdGlwTGFiZWxcclxuICAgICAgICAgICAgOiBjaXJjbGUuc2VyaWVzTmFtZSArIGNpcmNsZS50b29sdGlwTGFiZWw7XHJcbiAgICAgICAgdmFyIHRvb2x0aXBUaXRsZSA9IGhhc1Nlcmllc05hbWUgfHwgaGFzVG9vbHRpcExhYmVsID8gXCI8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC1sYWJlbFxcXCI+XCIgKyBuYW1lICsgXCI8L3NwYW4+XCIgOiAnJztcclxuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBcIiArIHRvb2x0aXBUaXRsZSArIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtbGFiZWxcXFwiPlxcbiAgICAgICAgPGxhYmVsPlwiICsgeEF4aXNMYWJlbCArIFwiPC9sYWJlbD4gXCIgKyB4ICsgXCI8YnIgLz5cXG4gICAgICAgIDxsYWJlbD5cIiArIHlBeGlzTGFiZWwgKyBcIjwvbGFiZWw+IFwiICsgeSArIFwiXFxuICAgICAgPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XFxuICAgICAgICBcIiArIHJhZGl1c1ZhbHVlICsgXCJcXG4gICAgICA8L3NwYW4+XFxuICAgIFwiO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVFbnRyaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBY3RpdmUoeyBuYW1lOiBjaXJjbGUuc2VyaWVzTmFtZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNpcmNsZS5vcGFjaXR5ICE9PSAwO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuYWN0aXZhdGVDaXJjbGUgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XHJcbiAgICAgICAgY2lyY2xlLmJhclZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IG5hbWU6IHRoaXMuZGF0YS5uYW1lIH0pO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZGVhY3RpdmF0ZUNpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcclxuICAgICAgICBjaXJjbGUuYmFyVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgbmFtZTogdGhpcy5kYXRhLm5hbWUgfSk7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBjaXJjbGUpIHtcclxuICAgICAgICByZXR1cm4gY2lyY2xlLmRhdGEuc2VyaWVzICsgXCIgXCIgKyBjaXJjbGUuZGF0YS5uYW1lO1xyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInJTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInZpc2libGVWYWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBCdWJibGVTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1idWJibGUtc2VyaWVzXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgY2lyY2xlIG9mIGNpcmNsZXM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJjaXJjbGUudHJhbnNmb3JtXFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWNpcmNsZVxcbiAgICAgICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgICAgIGNsYXNzPVxcXCJjaXJjbGVcXFwiXFxuICAgICAgICAgIFtjeF09XFxcIjBcXFwiXFxuICAgICAgICAgIFtjeV09XFxcIjBcXFwiXFxuICAgICAgICAgIFtyXT1cXFwiY2lyY2xlLnJhZGl1c1xcXCJcXG4gICAgICAgICAgW2ZpbGxdPVxcXCJjaXJjbGUuY29sb3JcXFwiXFxuICAgICAgICAgIFtzdHlsZS5vcGFjaXR5XT1cXFwiY2lyY2xlLm9wYWNpdHlcXFwiXFxuICAgICAgICAgIFtjbGFzcy5hY3RpdmVdPVxcXCJjaXJjbGUuaXNBY3RpdmVcXFwiXFxuICAgICAgICAgIFtwb2ludGVyRXZlbnRzXT1cXFwiJ2FsbCdcXFwiXFxuICAgICAgICAgIFtkYXRhXT1cXFwiY2lyY2xlLnZhbHVlXFxcIlxcbiAgICAgICAgICBbY2xhc3NOYW1lc109XFxcImNpcmNsZS5jbGFzc05hbWVzXFxcIlxcbiAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljayhjaXJjbGUuZGF0YSlcXFwiXFxuICAgICAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlQ2lyY2xlKGNpcmNsZSlcXFwiXFxuICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwiZGVhY3RpdmF0ZUNpcmNsZShjaXJjbGUpXFxcIlxcbiAgICAgICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcFR5cGVdPVxcXCIndG9vbHRpcCdcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGl0bGVdPVxcXCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiBnZXRUb29sdGlwVGV4dChjaXJjbGUpXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJjaXJjbGUuZGF0YVxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAxLCB0cmFuc2Zvcm06ICdzY2FsZSgxKScgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBCdWJibGVTZXJpZXNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgQnViYmxlQ2hhcnRNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCdWJibGVDaGFydE1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIEJ1YmJsZUNoYXJ0TW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQnViYmxlU2VyaWVzQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQnViYmxlU2VyaWVzQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRNb2R1bGUpO1xyXG4gICAgcmV0dXJuIEJ1YmJsZUNoYXJ0TW9kdWxlO1xyXG59KCkpO1xyXG5cclxudmFyIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZm9yY2UgPSBmb3JjZVNpbXVsYXRpb24oKVxyXG4gICAgICAgICAgICAuZm9yY2UoJ2NoYXJnZScsIGZvcmNlTWFueUJvZHkoKSlcclxuICAgICAgICAgICAgLmZvcmNlKCdjb2xsaWRlJywgZm9yY2VDb2xsaWRlKDUpKVxyXG4gICAgICAgICAgICAuZm9yY2UoJ3gnLCBmb3JjZVgoKSlcclxuICAgICAgICAgICAgLmZvcmNlKCd5JywgZm9yY2VZKCkpO1xyXG4gICAgICAgIF90aGlzLmZvcmNlTGluayA9IGZvcmNlTGluaygpLmlkKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZhbHVlOyB9KTtcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy5ub2RlcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLmxpbmtzID0gW107XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgIF90aGlzLnJlc3VsdHMgPSBbXTtcclxuICAgICAgICBfdGhpcy5ncm91cFJlc3VsdHNCeSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZhbHVlOyB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzRG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJcXG4gICAgICB0cmFuc2xhdGUoXCIgKyAodGhpcy5kaW1zLnhPZmZzZXQgKyB0aGlzLmRpbXMud2lkdGggLyAyKSArIFwiLCBcIiArICh0aGlzLm1hcmdpblswXSArIHRoaXMuZGltcy5oZWlnaHQgLyAyKSArIFwiKVxcbiAgICBcIjtcclxuICAgICAgICBpZiAodGhpcy5mb3JjZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZvcmNlXHJcbiAgICAgICAgICAgICAgICAubm9kZXModGhpcy5ub2RlcylcclxuICAgICAgICAgICAgICAgIC5mb3JjZSgnbGluaycsIHRoaXMuZm9yY2VMaW5rLmxpbmtzKHRoaXMubGlua3MpKVxyXG4gICAgICAgICAgICAgICAgLmFscGhhKDAuNSlcclxuICAgICAgICAgICAgICAgIC5yZXN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVFbnRyaWVzLmluZGV4T2YoZXZlbnQkJDEpID4gLTEpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbZXZlbnQkJDFdLmNvbmNhdCh0aGlzLmFjdGl2ZUVudHJpZXMpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBldmVudCQkMSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5pbmRleE9mKGV2ZW50JCQxKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogZXZlbnQkJDEsIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmdldFNlcmllc0RvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLmdyb3VwUmVzdWx0c0J5KGQpOyB9KVxyXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChub2Rlcywgbm9kZSkgeyByZXR1cm4gKG5vZGVzLmluY2x1ZGVzKG5vZGUpID8gbm9kZXMgOiBub2Rlcy5jb25jYXQoW25vZGVdKSk7IH0sIFtdKVxyXG4gICAgICAgICAgICAuc29ydCgpO1xyXG4gICAgfTtcclxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tMaW5rQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGxpbmspIHtcclxuICAgICAgICByZXR1cm4gbGluay5pbmRleDtcclxuICAgIH07XHJcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLnRyYWNrTm9kZUJ5ID0gZnVuY3Rpb24gKGluZGV4LCBub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsICdvcmRpbmFsJywgdGhpcy5zZXJpZXNEb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiAnb3JkaW5hbCcsXHJcbiAgICAgICAgICAgIGRvbWFpbjogdGhpcy5zZXJpZXNEb21haW4sXHJcbiAgICAgICAgICAgIGNvbG9yczogdGhpcy5jb2xvcnMsXHJcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLmxlZ2VuZFRpdGxlLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChub2RlLCAkZXZlbnQpIHtcclxuICAgICAgICB0aGlzLmZvcmNlLmFscGhhVGFyZ2V0KDAuMykucmVzdGFydCgpO1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdOb2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLmRyYWdnaW5nU3RhcnQgPSB7IHg6ICRldmVudC54IC0gbm9kZS54LCB5OiAkZXZlbnQueSAtIG5vZGUueSB9O1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdOb2RlLmZ4ID0gJGV2ZW50LnggLSB0aGlzLmRyYWdnaW5nU3RhcnQueDtcclxuICAgICAgICB0aGlzLmRyYWdnaW5nTm9kZS5meSA9ICRldmVudC55IC0gdGhpcy5kcmFnZ2luZ1N0YXJ0Lnk7XHJcbiAgICB9O1xyXG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5vbkRyYWcgPSBmdW5jdGlvbiAoJGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nTm9kZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdOb2RlLmZ4ID0gJGV2ZW50LnggLSB0aGlzLmRyYWdnaW5nU3RhcnQueDtcclxuICAgICAgICB0aGlzLmRyYWdnaW5nTm9kZS5meSA9ICRldmVudC55IC0gdGhpcy5kcmFnZ2luZ1N0YXJ0Lnk7XHJcbiAgICB9O1xyXG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5vbkRyYWdFbmQgPSBmdW5jdGlvbiAoJGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nTm9kZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuZm9yY2UuYWxwaGFUYXJnZXQoMCk7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZ05vZGUuZnggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZ05vZGUuZnkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZ05vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcImZvcmNlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcImZvcmNlTGlua1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9kZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgQXJyYXkgIT09IFwidW5kZWZpbmVkXCIgJiYgQXJyYXkpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwibGlua3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCdsaW5rVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2QgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdClcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwibGlua1RlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ25vZGVUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfZSA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9lIDogT2JqZWN0KVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub2RlVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9mID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2YgOiBPYmplY3QpXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVmlld0NoaWxkKENoYXJ0Q29tcG9uZW50LCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2cgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2cgOiBPYmplY3QpXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcImNoYXJ0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBSZXN1bHRzQnlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6bW91c2Vtb3ZlJywgWyckZXZlbnQnXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2ggPSB0eXBlb2YgTW91c2VFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBNb3VzZUV2ZW50KSA9PT0gXCJmdW5jdGlvblwiID8gX2ggOiBPYmplY3RdKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkRyYWdcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50Om1vdXNldXAnLCBbJyRldmVudCddKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfaiA9IHR5cGVvZiBNb3VzZUV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIE1vdXNlRXZlbnQpID09PSBcImZ1bmN0aW9uXCIgPyBfaiA6IE9iamVjdF0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRHJhZ0VuZFwiLCBudWxsKTtcclxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1mb3JjZS1kaXJlY3RlZC1ncmFwaCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImZvcmNlLWRpcmVjdGVkLWdyYXBoIGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6ZyBjbGFzcz1cXFwibGlua3NcXFwiPlxcbiAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgbGluayBvZiBsaW5rczsgdHJhY2tCeTogdHJhY2tMaW5rQnlcXFwiPlxcbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZVxcbiAgICAgICAgICAgICAgKm5nSWY9XFxcImxpbmtUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cXFwibGlua1RlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cXFwieyAkaW1wbGljaXQ6IGxpbmsgfVxcXCJcXG4gICAgICAgICAgICA+PC9uZy10ZW1wbGF0ZT5cXG4gICAgICAgICAgICA8c3ZnOmxpbmVcXG4gICAgICAgICAgICAgICpuZ0lmPVxcXCIhbGlua1RlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XFxcIjFcXFwiXFxuICAgICAgICAgICAgICBjbGFzcz1cXFwiZWRnZVxcXCJcXG4gICAgICAgICAgICAgIFthdHRyLngxXT1cXFwibGluay5zb3VyY2UueFxcXCJcXG4gICAgICAgICAgICAgIFthdHRyLnkxXT1cXFwibGluay5zb3VyY2UueVxcXCJcXG4gICAgICAgICAgICAgIFthdHRyLngyXT1cXFwibGluay50YXJnZXQueFxcXCJcXG4gICAgICAgICAgICAgIFthdHRyLnkyXT1cXFwibGluay50YXJnZXQueVxcXCJcXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6ZyBjbGFzcz1cXFwibm9kZXNcXFwiPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAqbmdGb3I9XFxcImxldCBub2RlIG9mIG5vZGVzOyB0cmFja0J5OiB0cmFja05vZGVCeVxcXCJcXG4gICAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCIndHJhbnNsYXRlKCcgKyBub2RlLnggKyAnLCcgKyBub2RlLnkgKyAnKSdcXFwiXFxuICAgICAgICAgICAgW2F0dHIuZmlsbF09XFxcImNvbG9ycy5nZXRDb2xvcihncm91cFJlc3VsdHNCeShub2RlKSlcXFwiXFxuICAgICAgICAgICAgW2F0dHIuc3Ryb2tlXT1cXFwiY29sb3JzLmdldENvbG9yKGdyb3VwUmVzdWx0c0J5KG5vZGUpKVxcXCJcXG4gICAgICAgICAgICAobW91c2Vkb3duKT1cXFwib25EcmFnU3RhcnQobm9kZSwgJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAoY2xpY2spPVxcXCJvbkNsaWNrKHsgbmFtZTogbm9kZS52YWx1ZSB9KVxcXCJcXG4gICAgICAgICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVxcXCIndG9wJ1xcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFR5cGVdPVxcXCIndG9vbHRpcCdcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IG5vZGUudmFsdWVcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJub2RlXFxcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlXFxuICAgICAgICAgICAgICAqbmdJZj1cXFwibm9kZVRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVxcXCJub2RlVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVxcXCJ7ICRpbXBsaWNpdDogbm9kZSB9XFxcIlxcbiAgICAgICAgICAgID48L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgIDxzdmc6Y2lyY2xlICpuZ0lmPVxcXCIhbm9kZVRlbXBsYXRlXFxcIiByPVxcXCI1XFxcIiAvPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiLCBcIi5mb3JjZS1kaXJlY3RlZC1ncmFwaCAuZWRnZXtzdHJva2U6IzMzM31cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEZvcmNlRGlyZWN0ZWRHcmFwaE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZvcmNlRGlyZWN0ZWRHcmFwaE1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NoYXJ0Q29tbW9uTW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudCxcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhNb2R1bGUpO1xyXG4gICAgcmV0dXJuIEZvcmNlRGlyZWN0ZWRHcmFwaE1vZHVsZTtcclxufSgpKTtcclxuXHJcbnZhciBIZWF0TWFwQ2VsbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEhlYXRNYXBDZWxsQ29tcG9uZW50KGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmdyYWRpZW50ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnggKyBcIiAsIFwiICsgdGhpcy55ICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy5zdGFydE9wYWNpdHkgPSAwLjM7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudElkID0gJ2dyYWQnICsgaWQoKS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnRVcmwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcclxuICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB0aGlzLmdldEdyYWRpZW50U3RvcHMoKTtcclxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZEFuaW1hdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JhZGllbnRTdG9wcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5maWxsLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5zdGFydE9wYWNpdHlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxMDAsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5maWxsLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUubG9hZEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpLnNlbGVjdCgnLmNlbGwnKTtcclxuICAgICAgICBub2RlLmF0dHIoJ29wYWNpdHknLCAwKTtcclxuICAgICAgICB0aGlzLmFuaW1hdGVUb0N1cnJlbnRGb3JtKCk7XHJcbiAgICB9O1xyXG4gICAgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLmFuaW1hdGVUb0N1cnJlbnRGb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub2RlID0gc2VsZWN0KHRoaXMuZWxlbWVudCkuc2VsZWN0KCcuY2VsbCcpO1xyXG4gICAgICAgIG5vZGVcclxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAuZHVyYXRpb24oNzUwKVxyXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDEpO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQodGhpcy5kYXRhKTtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUub25Nb3VzZUVudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh0aGlzLmRhdGEpO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5vbk1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQodGhpcy5kYXRhKTtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUVudGVyXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUxlYXZlXCIsIG51bGwpO1xyXG4gICAgSGVhdE1hcENlbGxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1oZWF0LW1hcC1jZWxsXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiY2VsbFxcXCI+XFxuICAgICAgPGRlZnMgKm5nSWY9XFxcImdyYWRpZW50XFxcIj5cXG4gICAgICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLXN2Zy1saW5lYXItZ3JhZGllbnQgb3JpZW50YXRpb249XFxcInZlcnRpY2FsXFxcIiBbbmFtZV09XFxcImdyYWRpZW50SWRcXFwiIFtzdG9wc109XFxcImdyYWRpZW50U3RvcHNcXFwiIC8+XFxuICAgICAgPC9kZWZzPlxcbiAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgW2F0dHIuZmlsbF09XFxcImdyYWRpZW50ID8gZ3JhZGllbnRVcmwgOiBmaWxsXFxcIlxcbiAgICAgICAgcng9XFxcIjNcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcIndpZHRoXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiaGVpZ2h0XFxcIlxcbiAgICAgICAgY2xhc3M9XFxcImNlbGxcXFwiXFxuICAgICAgICBzdHlsZT1cXFwiY3Vyc29yOiBwb2ludGVyXFxcIlxcbiAgICAgICAgKGNsaWNrKT1cXFwib25DbGljaygpXFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxyXG4gICAgXSwgSGVhdE1hcENlbGxDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEhlYXRNYXBDZWxsQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSGVhdENlbGxTZXJpZXNDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy50b29sdGlwVGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBUZXh0ID0gdGhpcy5nZXRUb29sdGlwVGV4dDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jZWxscyA9IHRoaXMuZ2V0Q2VsbHMoKTtcclxuICAgIH07XHJcbiAgICBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q2VsbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY2VsbHMgPSBbXTtcclxuICAgICAgICB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICAgICAgcm93LnNlcmllcy5tYXAoZnVuY3Rpb24gKGNlbGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNlbGwudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBjZWxsLnNlcmllcyA9IHJvdy5uYW1lO1xyXG4gICAgICAgICAgICAgICAgY2VsbHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbDogY2VsbCxcclxuICAgICAgICAgICAgICAgICAgICB4OiBfdGhpcy54U2NhbGUocm93Lm5hbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IF90aGlzLnlTY2FsZShjZWxsLm5hbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBfdGhpcy54U2NhbGUuYmFuZHdpZHRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBfdGhpcy55U2NhbGUuYmFuZHdpZHRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogX3RoaXMuY29sb3JzLmdldENvbG9yKHZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogZm9ybWF0TGFiZWwoY2VsbC5uYW1lKSxcclxuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHJvdy5uYW1lXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNlbGxzO1xyXG4gICAgfTtcclxuICAgIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUb29sdGlwVGV4dCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBsYWJlbCA9IF9hLmxhYmVsLCBkYXRhID0gX2EuZGF0YSwgc2VyaWVzID0gX2Euc2VyaWVzO1xyXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIHNlcmllcyArIFwiIFxcdTIwMjIgXCIgKyBsYWJlbCArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyBkYXRhLnRvTG9jYWxlU3RyaW5nKCkgKyBcIjwvc3Bhbj5cXG4gICAgXCI7XHJcbiAgICB9O1xyXG4gICAgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS50b29sdGlwVGV4dDtcclxuICAgIH07XHJcbiAgICBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWhlYXQtbWFwLWNlbGwtc2VyaWVzXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmdcXG4gICAgICBuZ3gtY2hhcnRzLWhlYXQtbWFwLWNlbGxcXG4gICAgICAqbmdGb3I9XFxcImxldCBjIG9mIGNlbGxzOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgIFt4XT1cXFwiYy54XFxcIlxcbiAgICAgIFt5XT1cXFwiYy55XFxcIlxcbiAgICAgIFt3aWR0aF09XFxcImMud2lkdGhcXFwiXFxuICAgICAgW2hlaWdodF09XFxcImMuaGVpZ2h0XFxcIlxcbiAgICAgIFtmaWxsXT1cXFwiYy5maWxsXFxcIlxcbiAgICAgIFtkYXRhXT1cXFwiYy5kYXRhXFxcIlxcbiAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKGMuY2VsbClcXFwiXFxuICAgICAgKGFjdGl2YXRlKT1cXFwiYWN0aXZhdGUuZW1pdChjLmNlbGwpXFxcIlxcbiAgICAgIChkZWFjdGl2YXRlKT1cXFwiZGVhY3RpdmF0ZS5lbWl0KGMuY2VsbClcXFwiXFxuICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIG5neC10b29sdGlwXFxuICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgIFt0b29sdGlwVHlwZV09XFxcIid0b29sdGlwJ1xcXCJcXG4gICAgICBbdG9vbHRpcFRpdGxlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogdG9vbHRpcFRleHQoYylcXFwiXFxuICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJ7IHNlcmllczogYy5zZXJpZXMsIG5hbWU6IGMubGFiZWwsIHZhbHVlOiBjLmRhdGEgfVxcXCJcXG4gICAgPjwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIEhlYXRNYXBDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSGVhdE1hcENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEhlYXRNYXBDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMuaW5uZXJQYWRkaW5nID0gODtcclxuICAgICAgICBfdGhpcy50cmltWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLm1heFhBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xyXG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xyXG4gICAgICAgIF90aGlzLnNjYWxlVHlwZSA9ICdsaW5lYXInO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcclxuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmdldFhEb21haW4oKTtcclxuICAgICAgICB0aGlzLnlEb21haW4gPSB0aGlzLmdldFlEb21haW4oKTtcclxuICAgICAgICB0aGlzLnZhbHVlRG9tYWluID0gdGhpcy5nZXRWYWx1ZURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuc2NhbGVUeXBlID0gZ2V0U2NhbGVUeXBlKHRoaXMudmFsdWVEb21haW4sIGZhbHNlKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjYWxlVHlwZSxcclxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW4kJDEgPSB0aGlzLm1pbjtcclxuICAgICAgICAgICAgdmFyIG1heCQkMSA9IHRoaXMubWF4O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWluKSB7XHJcbiAgICAgICAgICAgICAgICBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBbMF0uY29uY2F0KHRoaXMudmFsdWVEb21haW4pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWF4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB0aGlzLnZhbHVlRG9tYWluKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZhbHVlRG9tYWluID0gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiICwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMucmVjdHMgPSB0aGlzLmdldFJlY3RzKCk7XHJcbiAgICB9O1xyXG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhncm91cC5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZ3JvdXAubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGQubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIE4sIEwpIHtcclxuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IDA7IH1cclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnWycsICcnKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ10nLCAnJylcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdweCcsICcnKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1xcJycsICcnKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCcsJykpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb24odmFsdWVbaW5kZXhdLCBudWxsLCBOLCBMKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuaW5jbHVkZXMoJyUnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gK3ZhbHVlLnJlcGxhY2UoJyUnLCAnJykgLyAxMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOIC8gKEwgLyArdmFsdWUgKyAxKTtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGYgPSB0aGlzLmdldERpbWVuc2lvbih0aGlzLmlubmVyUGFkZGluZywgMCwgdGhpcy54RG9tYWluLmxlbmd0aCwgdGhpcy5kaW1zLndpZHRoKTtcclxuICAgICAgICByZXR1cm4gc2NhbGVCYW5kKClcclxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHRoaXMuZGltcy53aWR0aF0pXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy54RG9tYWluKVxyXG4gICAgICAgICAgICAucGFkZGluZ0lubmVyKGYpO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZiA9IHRoaXMuZ2V0RGltZW5zaW9uKHRoaXMuaW5uZXJQYWRkaW5nLCAxLCB0aGlzLnlEb21haW4ubGVuZ3RoLCB0aGlzLmRpbXMuaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4gc2NhbGVCYW5kKClcclxuICAgICAgICAgICAgLnJhbmdlUm91bmQoW3RoaXMuZGltcy5oZWlnaHQsIDBdKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMueURvbWFpbilcclxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcihmKTtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5nZXRSZWN0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciByZWN0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMueERvbWFpbi5tYXAoZnVuY3Rpb24gKHhWYWwpIHtcclxuICAgICAgICAgICAgX3RoaXMueURvbWFpbi5tYXAoZnVuY3Rpb24gKHlWYWwpIHtcclxuICAgICAgICAgICAgICAgIHJlY3RzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IF90aGlzLnhTY2FsZSh4VmFsKSxcclxuICAgICAgICAgICAgICAgICAgICB5OiBfdGhpcy55U2NhbGUoeVZhbCksXHJcbiAgICAgICAgICAgICAgICAgICAgcng6IDMsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IF90aGlzLnhTY2FsZS5iYW5kd2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IF90aGlzLnlTY2FsZS5iYW5kd2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAncmdiYSgyMDAsMjAwLDIwMCwwLjAzKSdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVjdHM7XHJcbiAgICB9O1xyXG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NhbGVUeXBlLCB0aGlzLnZhbHVlRG9tYWluKTtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2FsZVR5cGUsXHJcbiAgICAgICAgICAgIGRvbWFpbjogdGhpcy52YWx1ZURvbWFpbixcclxuICAgICAgICAgICAgY29sb3JzOiB0aGlzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnID8gdGhpcy5jb2xvcnMgOiB0aGlzLmNvbG9ycy5zY2FsZSxcclxuICAgICAgICAgICAgdGl0bGU6IHRoaXMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcgPyB0aGlzLmxlZ2VuZFRpdGxlIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5yZXN1bHRzXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGcpIHsgcmV0dXJuIGcuc2VyaWVzOyB9KVxyXG4gICAgICAgICAgICAuZmxhdCgpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gaXRlbXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXAsIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQkJDEpO1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsICE9PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIShpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcImlubmVyUGFkZGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFlBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgSGVhdE1hcENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1oZWF0LW1hcCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiaGVhdC1tYXAgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhZQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInlBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpyZWN0XFxuICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IHJlY3Qgb2YgcmVjdHNcXFwiXFxuICAgICAgICAgIFthdHRyLnhdPVxcXCJyZWN0LnhcXFwiXFxuICAgICAgICAgIFthdHRyLnldPVxcXCJyZWN0LnlcXFwiXFxuICAgICAgICAgIFthdHRyLnJ4XT1cXFwicmVjdC5yeFxcXCJcXG4gICAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJyZWN0LndpZHRoXFxcIlxcbiAgICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJyZWN0LmhlaWdodFxcXCJcXG4gICAgICAgICAgW2F0dHIuZmlsbF09XFxcInJlY3QuZmlsbFxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1oZWF0LW1hcC1jZWxsLXNlcmllc1xcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICBbZGF0YV09XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGV4dF09XFxcInRvb2x0aXBUZXh0XFxcIlxcbiAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBIZWF0TWFwQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEhlYXRNYXBNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIZWF0TWFwTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgSGVhdE1hcE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NoYXJ0Q29tbW9uTW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICBIZWF0TWFwQ2VsbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgSGVhdE1hcENvbXBvbmVudFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgICAgICAgICBIZWF0TWFwQ2VsbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgSGVhdE1hcENvbXBvbmVudFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEhlYXRNYXBNb2R1bGUpO1xyXG4gICAgcmV0dXJuIEhlYXRNYXBNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG52YXIgTGluZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExpbmVDb21wb25lbnQoZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5maWxsID0gJ25vbmUnO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgTGluZUNvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsUGF0aCA9IHRoaXMucGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGF0aEVsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExpbmVDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVBhdGhFbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkuc2VsZWN0KCcubGluZScpO1xyXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbnMpIHtcclxuICAgICAgICAgICAgbm9kZVxyXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbig3NTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLmF0dHIoJ2QnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYXRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdHJva2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIExpbmVDb21wb25lbnQucHJvdG90eXBlLCBcImZpbGxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBMaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBMaW5lQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtbGluZV0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpwYXRoXFxuICAgICAgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIlxcbiAgICAgIGNsYXNzPVxcXCJsaW5lXFxcIlxcbiAgICAgIFthdHRyLmRdPVxcXCJpbml0aWFsUGF0aFxcXCJcXG4gICAgICBbYXR0ci5maWxsXT1cXFwiZmlsbFxcXCJcXG4gICAgICBbYXR0ci5zdHJva2VdPVxcXCJzdHJva2VcXFwiXFxuICAgICAgc3Ryb2tlLXdpZHRoPVxcXCIxLjVweFxcXCJcXG4gICAgLz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VEYXNoYXJyYXk6IDIwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiAyMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgxMDAwLCBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcclxuICAgIF0sIExpbmVDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIExpbmVDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgTGluZUNoYXJ0Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExpbmVDaGFydENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpbmVDaGFydENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5jdXJ2ZSA9IGN1cnZlTGluZWFyO1xyXG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy50cmltWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLm1heFhBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnNob3dSZWZMaW5lcyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnNob3dSZWZMYWJlbHMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcclxuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XHJcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XHJcbiAgICAgICAgX3RoaXMudGltZWxpbmVIZWlnaHQgPSA1MDtcclxuICAgICAgICBfdGhpcy50aW1lbGluZVBhZGRpbmcgPSAxMDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxyXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXHJcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcclxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXHJcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcclxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy50aW1lbGluZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpbXMuaGVpZ2h0IC09IHRoaXMudGltZWxpbmVIZWlnaHQgKyB0aGlzLm1hcmdpblsyXSArIHRoaXMudGltZWxpbmVQYWRkaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmdldFhEb21haW4oKTtcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXJlZERvbWFpbikge1xyXG4gICAgICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmZpbHRlcmVkRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnlEb21haW4gPSB0aGlzLmdldFlEb21haW4oKTtcclxuICAgICAgICB0aGlzLnNlcmllc0RvbWFpbiA9IHRoaXMuZ2V0U2VyaWVzRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHRoaXMuZGltcy53aWR0aCk7XHJcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSh0aGlzLnlEb21haW4sIHRoaXMuZGltcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGltZWxpbmUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiICwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMuY2xpcFBhdGhJZCA9ICdjbGlwJyArIGlkKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmNsaXBQYXRoID0gXCJ1cmwoI1wiICsgdGhpcy5jbGlwUGF0aElkICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVUaW1lbGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lbGluZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lV2lkdGggPSB0aGlzLmRpbXMud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVYRG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVYU2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnRpbWVsaW5lWERvbWFpbiwgdGhpcy50aW1lbGluZVdpZHRoKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy50aW1lbGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIsIFwiICsgLXRoaXMubWFyZ2luWzJdICsgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gZ2V0VW5pcXVlWERvbWFpblZhbHVlcyh0aGlzLnJlc3VsdHMpO1xyXG4gICAgICAgIHRoaXMuc2NhbGVUeXBlID0gZ2V0U2NhbGVUeXBlKHZhbHVlcyk7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gTnVtYmVyKHYpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pbiQkMTtcclxuICAgICAgICB2YXIgbWF4JCQxO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnIHx8IHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICBtaW4kJDEgPSB0aGlzLnhTY2FsZU1pbiA/IHRoaXMueFNjYWxlTWluIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgbWF4JCQxID0gdGhpcy54U2NhbGVNYXggPyB0aGlzLnhTY2FsZU1heCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IFtuZXcgRGF0ZShtaW4kJDEpLCBuZXcgRGF0ZShtYXgkJDEpXTtcclxuICAgICAgICAgICAgdGhpcy54U2V0ID0gdmFsdWVzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFEYXRlID0gYS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYkRhdGUgPSBiLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChhRGF0ZSA+IGJEYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJEYXRlID4gYURhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgICAgICAgICAgdGhpcy54U2V0ID0gdmFsdWVzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdmFsdWVzO1xyXG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRZRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHJlc3VsdHMuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluLmluZGV4T2YoZC52YWx1ZSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5taW4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzUmFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4uaW5kZXhPZihkLm1pbikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubWluKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5tYXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzUmFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4uaW5kZXhPZihkLm1heCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubWF4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IGRvbWFpbi5zbGljZSgpO1xyXG4gICAgICAgIGlmICghdGhpcy5hdXRvU2NhbGUpIHtcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2goMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaW4kJDEgPSB0aGlzLnlTY2FsZU1pbiA/IHRoaXMueVNjYWxlTWluIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy55U2NhbGVNYXggPyB0aGlzLnlTY2FsZU1heCA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRTZXJpZXNEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZTsgfSk7XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCB3aWR0aCkge1xyXG4gICAgICAgIHZhciBzY2FsZTtcclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlVGltZSgpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcclxuICAgICAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJvdW5kRG9tYWlucykge1xyXG4gICAgICAgICAgICAgICAgc2NhbGUgPSBzY2FsZS5uaWNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlUG9pbnQoKVxyXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pXHJcbiAgICAgICAgICAgICAgICAucGFkZGluZygwLjEpXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIGhlaWdodCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxyXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVEb21haW4gPSBmdW5jdGlvbiAoZG9tYWluKSB7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJlZERvbWFpbiA9IGRvbWFpbjtcclxuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmZpbHRlcmVkRG9tYWluO1xyXG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUodGhpcy54RG9tYWluLCB0aGlzLmRpbXMud2lkdGgpO1xyXG4gICAgfTtcclxuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlSG92ZXJlZFZlcnRpY2FsID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLmhvdmVyZWRWZXJ0aWNhbCA9IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5oaWRlQ2lyY2xlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhvdmVyZWRWZXJ0aWNhbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbjtcclxuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy5zZXJpZXNEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnlEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkb21haW46IFtdLFxyXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnNlcmllc0RvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcclxuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMueURvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdHM7XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVhBeGlzSGVpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbaXRlbV07XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmRlYWN0aXZhdGVBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuYWN0aXZlRW50cmllczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBlbnRyeSwgZW50cmllczogW10gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhdXRvU2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidGltZWxpbmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlRmlsbE9wYWNpdHlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZERvbWFpbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1JlZkxpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJlZmVyZW5jZUxpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93UmVmTGFiZWxzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZU1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZU1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgnc2VyaWVzVG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9kID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2QgOiBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc1Rvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImhpZGVDaXJjbGVzXCIsIG51bGwpO1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWxpbmUtY2hhcnQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmRlZnM+XFxuICAgICAgICA8c3ZnOmNsaXBQYXRoIFthdHRyLmlkXT1cXFwiY2xpcFBhdGhJZFxcXCI+XFxuICAgICAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgICAgIFthdHRyLndpZHRoXT1cXFwiZGltcy53aWR0aCArIDEwXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmhlaWdodF09XFxcImRpbXMuaGVpZ2h0ICsgMTBcXFwiXFxuICAgICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiJ3RyYW5zbGF0ZSgtNSwgLTUpJ1xcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmNsaXBQYXRoPlxcbiAgICAgIDwvc3ZnOmRlZnM+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImxpbmUtY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcmVmZXJlbmNlTGluZXNdPVxcXCJyZWZlcmVuY2VMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dSZWZMaW5lc109XFxcInNob3dSZWZMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dSZWZMYWJlbHNdPVxcXCJzaG93UmVmTGFiZWxzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6ZyBbYXR0ci5jbGlwLXBhdGhdPVxcXCJjbGlwUGF0aFxcXCI+XFxuICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0czsgdHJhY2tCeTogdHJhY2tCeVxcXCIgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtbGluZS1zZXJpZXNcXG4gICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICAgIFtjdXJ2ZV09XFxcImN1cnZlXFxcIlxcbiAgICAgICAgICAgICAgW3JhbmdlRmlsbE9wYWNpdHldPVxcXCJyYW5nZUZpbGxPcGFjaXR5XFxcIlxcbiAgICAgICAgICAgICAgW2hhc1JhbmdlXT1cXFwiaGFzUmFuZ2VcXFwiXFxuICAgICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0lmPVxcXCIhdG9vbHRpcERpc2FibGVkXFxcIiAobW91c2VsZWF2ZSk9XFxcImhpZGVDaXJjbGVzKClcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy10b29sdGlwLWFyZWFcXG4gICAgICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgICAgIFt4U2V0XT1cXFwieFNldFxcXCJcXG4gICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3Jlc3VsdHNdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwic2VyaWVzVG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgKGhvdmVyKT1cXFwidXBkYXRlSG92ZXJlZFZlcnRpY2FsKCRldmVudClcXFwiXFxuICAgICAgICAgICAgLz5cXG5cXG4gICAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHNcXFwiPlxcbiAgICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICAgIG5neC1jaGFydHMtY2lyY2xlLXNlcmllc1xcbiAgICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICAgICAgW3Zpc2libGVWYWx1ZV09XFxcImhvdmVyZWRWZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLXRpbWVsaW5lXFxuICAgICAgICAqbmdJZj1cXFwidGltZWxpbmUgJiYgc2NhbGVUeXBlICE9ICdvcmRpbmFsJ1xcXCJcXG4gICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRpbWVsaW5lVHJhbnNmb3JtXFxcIlxcbiAgICAgICAgW3Jlc3VsdHNdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgW3ZpZXddPVxcXCJbdGltZWxpbmVXaWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICAgIFtoZWlnaHRdPVxcXCJ0aW1lbGluZUhlaWdodFxcXCJcXG4gICAgICAgIFtzY2hlbWVdPVxcXCJzY2hlbWVcXFwiXFxuICAgICAgICBbY3VzdG9tQ29sb3JzXT1cXFwiY3VzdG9tQ29sb3JzXFxcIlxcbiAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgIFtsZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgICAob25Eb21haW5DaGFuZ2UpPVxcXCJ1cGRhdGVEb21haW4oJGV2ZW50KVxcXCJcXG4gICAgICA+XFxuICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLWxpbmUtc2VyaWVzXFxuICAgICAgICAgICAgW3hTY2FsZV09XFxcInRpbWVsaW5lWFNjYWxlXFxcIlxcbiAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ0aW1lbGluZVlTY2FsZVxcXCJcXG4gICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgW2N1cnZlXT1cXFwiY3VydmVcXFwiXFxuICAgICAgICAgICAgW2hhc1JhbmdlXT1cXFwiaGFzUmFuZ2VcXFwiXFxuICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50KTtcclxuICAgIHJldHVybiBMaW5lQ2hhcnRDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgTGluZVNlcmllc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExpbmVTZXJpZXNDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUdyYWRpZW50cygpO1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5zb3J0RGF0YSh0aGlzLmRhdGEuc2VyaWVzKTtcclxuICAgICAgICB2YXIgbGluZUdlbiA9IHRoaXMuZ2V0TGluZUdlbmVyYXRvcigpO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IGxpbmVHZW4oZGF0YSkgfHwgJyc7XHJcbiAgICAgICAgdmFyIGFyZWFHZW4gPSB0aGlzLmdldEFyZWFHZW5lcmF0b3IoKTtcclxuICAgICAgICB0aGlzLmFyZWFQYXRoID0gYXJlYUdlbihkYXRhKSB8fCAnJztcclxuICAgICAgICBpZiAodGhpcy5oYXNSYW5nZSkge1xyXG4gICAgICAgICAgICB2YXIgcmFuZ2UkJDEgPSB0aGlzLmdldFJhbmdlR2VuZXJhdG9yKCk7XHJcbiAgICAgICAgICAgIHRoaXMub3V0ZXJQYXRoID0gcmFuZ2UkJDEoZGF0YSkgfHwgJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhhc0dyYWRpZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlID0gdGhpcy5ncmFkaWVudFVybDtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZGF0YS5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcclxuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICBpZiAobWF4JCQxID09PSBtaW4kJDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3Ryb2tlID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3IobWF4JCQxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdHJva2UgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcih0aGlzLmRhdGEubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldExpbmVHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbGluZSgpXHJcbiAgICAgICAgICAgIC54KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQubmFtZTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnhTY2FsZShOdW1iZXIobGFiZWwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnkoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLnlTY2FsZShkLnZhbHVlKTsgfSlcclxuICAgICAgICAgICAgLmN1cnZlKHRoaXMuY3VydmUpO1xyXG4gICAgfTtcclxuICAgIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFJhbmdlR2VuZXJhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGFyZWEoKVxyXG4gICAgICAgICAgICAueChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkLm5hbWU7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnhTY2FsZShsYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy54U2NhbGUoTnVtYmVyKGxhYmVsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnhTY2FsZShsYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC55MChmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMueVNjYWxlKHR5cGVvZiBkLm1pbiA9PT0gJ251bWJlcicgPyBkLm1pbiA6IGQudmFsdWUpOyB9KVxyXG4gICAgICAgICAgICAueTEoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLnlTY2FsZSh0eXBlb2YgZC5tYXggPT09ICdudW1iZXInID8gZC5tYXggOiBkLnZhbHVlKTsgfSlcclxuICAgICAgICAgICAgLmN1cnZlKHRoaXMuY3VydmUpO1xyXG4gICAgfTtcclxuICAgIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldEFyZWFHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgeFByb3BlcnR5ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gZC5uYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMueFNjYWxlKGxhYmVsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBhcmVhKClcclxuICAgICAgICAgICAgLngoeFByb3BlcnR5KVxyXG4gICAgICAgICAgICAueTAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMueVNjYWxlLnJhbmdlKClbMF07IH0pXHJcbiAgICAgICAgICAgIC55MShmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMueVNjYWxlKGQudmFsdWUpOyB9KVxyXG4gICAgICAgICAgICAuY3VydmUodGhpcy5jdXJ2ZSk7XHJcbiAgICB9O1xyXG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuc29ydERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHNvcnRMaW5lYXIoZGF0YSwgJ25hbWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICBkYXRhID0gc29ydEJ5VGltZShkYXRhLCAnbmFtZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGF0YSA9IHNvcnRCeURvbWFpbihkYXRhLCAnbmFtZScsICdhc2MnLCB0aGlzLnhTY2FsZS5kb21haW4oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfTtcclxuICAgIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZUdyYWRpZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb2xvcnMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudElkID0gJ2dyYWQnICsgaWQoKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50VXJsID0gXCJ1cmwoI1wiICsgdGhpcy5ncmFkaWVudElkICsgXCIpXCI7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmRhdGEuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhtYXgkJDEsIG1pbiQkMSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXJlYUdyYWRpZW50U3RvcHMgPSB0aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKG1heCQkMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5hcmVhR3JhZGllbnRTdG9wcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWUgPT09IGQubmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmlzSW5hY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcyB8fCB0aGlzLmFjdGl2ZUVudHJpZXMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVtID09PSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXJ2ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZUZpbGxPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaGFzUmFuZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBMaW5lU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtbGluZS1zZXJpZXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6Zz5cXG4gICAgICA8ZGVmcz5cXG4gICAgICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLXN2Zy1saW5lYXItZ3JhZGllbnQgKm5nSWY9XFxcImhhc0dyYWRpZW50XFxcIlxcbiAgICAgICAgICBvcmllbnRhdGlvbj1cXFwidmVydGljYWxcXFwiXFxuICAgICAgICAgIFtuYW1lXT1cXFwiZ3JhZGllbnRJZFxcXCJcXG4gICAgICAgICAgW3N0b3BzXT1cXFwiZ3JhZGllbnRTdG9wc1xcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9kZWZzPlxcbiAgICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLWFyZWFcXG4gICAgICAgIGNsYXNzPVxcXCJsaW5lLWhpZ2hsaWdodFxcXCJcXG4gICAgICAgIFtkYXRhXT1cXFwiZGF0YVxcXCJcXG4gICAgICAgIFtwYXRoXT1cXFwiYXJlYVBhdGhcXFwiXFxuICAgICAgICBbZmlsbF09XFxcImhhc0dyYWRpZW50ID8gZ3JhZGllbnRVcmwgOiBjb2xvcnMuZ2V0Q29sb3IoZGF0YS5uYW1lKVxcXCJcXG4gICAgICAgIFtvcGFjaXR5XT1cXFwiMC4yNVxcXCJcXG4gICAgICAgIFtzdGFydE9wYWNpdHldPVxcXCIwXFxcIlxcbiAgICAgICAgW2dyYWRpZW50XT1cXFwidHJ1ZVxcXCJcXG4gICAgICAgIFtzdG9wc109XFxcImFyZWFHcmFkaWVudFN0b3BzXFxcIlxcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlKGRhdGEpXFxcIlxcbiAgICAgICAgW2NsYXNzLmluYWN0aXZlXT1cXFwiaXNJbmFjdGl2ZShkYXRhKVxcXCJcXG4gICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAvPlxcbiAgICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLWxpbmVcXG4gICAgICAgIGNsYXNzPVxcXCJsaW5lLXNlcmllc1xcXCJcXG4gICAgICAgIFtkYXRhXT1cXFwiZGF0YVxcXCJcXG4gICAgICAgIFtwYXRoXT1cXFwicGF0aFxcXCJcXG4gICAgICAgIFtzdHJva2VdPVxcXCJzdHJva2VcXFwiXFxuICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiaXNBY3RpdmUoZGF0YSlcXFwiXFxuICAgICAgICBbY2xhc3MuaW5hY3RpdmVdPVxcXCJpc0luYWN0aXZlKGRhdGEpXFxcIlxcbiAgICAgIC8+XFxuICAgICA8c3ZnOmcgbmd4LWNoYXJ0cy1hcmVhXFxuICAgICAgICAqbmdJZj1cXFwiaGFzUmFuZ2VcXFwiXFxuICAgICAgICBjbGFzcz1cXFwibGluZS1zZXJpZXMtcmFuZ2VcXFwiXFxuICAgICAgICBbZGF0YV09XFxcImRhdGFcXFwiXFxuICAgICAgICBbcGF0aF09XFxcIm91dGVyUGF0aFxcXCJcXG4gICAgICAgIFtmaWxsXT1cXFwiaGFzR3JhZGllbnQgPyBncmFkaWVudFVybCA6IGNvbG9ycy5nZXRDb2xvcihkYXRhLm5hbWUpXFxcIlxcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlKGRhdGEpXFxcIlxcbiAgICAgICAgW2NsYXNzLmluYWN0aXZlXT1cXFwiaXNJbmFjdGl2ZShkYXRhKVxcXCJcXG4gICAgICAgIFtvcGFjaXR5XT1cXFwicmFuZ2VGaWxsT3BhY2l0eVxcXCJcXG4gICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAvPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIExpbmVTZXJpZXNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgTGluZUNoYXJ0TW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGluZUNoYXJ0TW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTGluZUNoYXJ0TW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIExpbmVDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBMaW5lQ2hhcnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBMaW5lU2VyaWVzQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIExpbmVDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBMaW5lQ2hhcnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBMaW5lU2VyaWVzQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgTGluZUNoYXJ0TW9kdWxlKTtcclxuICAgIHJldHVybiBMaW5lQ2hhcnRNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG52YXIgdHdvUEkgPSAyICogTWF0aC5QSTtcclxudmFyIFBvbGFyQ2hhcnRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUG9sYXJDaGFydENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBvbGFyQ2hhcnRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuY3VydmUgPSBjdXJ2ZUNhcmRpbmFsQ2xvc2VkO1xyXG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy5yYW5nZUZpbGxPcGFjaXR5ID0gMC4xNTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuc2hvd1Nlcmllc09uSG92ZXIgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmdyYWRpZW50ID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMueUF4aXNNaW5TY2FsZSA9IDA7XHJcbiAgICAgICAgX3RoaXMubGFiZWxUcmltID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5sYWJlbFRyaW1TaXplID0gMTA7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldERpbXMoKTtcclxuICAgICAgICB0aGlzLnNldFNjYWxlcygpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy5zZXRUaWNrcygpO1xyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnNldERpbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXHJcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcclxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxyXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcclxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxyXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcclxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBoYWxmV2lkdGggPSBNYXRoLmZsb29yKHRoaXMuZGltcy53aWR0aCAvIDIpO1xyXG4gICAgICAgIHZhciBoYWxmSGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLmRpbXMuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgdmFyIG91dGVyUmFkaXVzID0gKHRoaXMub3V0ZXJSYWRpdXMgPSBNYXRoLm1pbihoYWxmSGVpZ2h0IC8gMS41LCBoYWxmV2lkdGggLyAxLjUpKTtcclxuICAgICAgICB2YXIgeU9mZnNldCA9IE1hdGgubWF4KDAsIGhhbGZIZWlnaHQgLSBvdXRlclJhZGl1cyk7XHJcbiAgICAgICAgdGhpcy55QXhpc0RpbXMgPSBfX2Fzc2lnbih7fSwgdGhpcy5kaW1zLCB7IHdpZHRoOiBoYWxmV2lkdGggfSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIsIFwiICsgdGhpcy5tYXJnaW5bMF0gKyBcIilcIjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybVlBeGlzID0gXCJ0cmFuc2xhdGUoMCwgXCIgKyB5T2Zmc2V0ICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IHRoaXMuZGltcy5oZWlnaHQgKyA0MDtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybVBsb3QgPSBcInRyYW5zbGF0ZShcIiArIGhhbGZXaWR0aCArIFwiLCBcIiArIGhhbGZIZWlnaHQgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRTY2FsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHhWYWx1ZXMgPSB0aGlzLmdldFhWYWx1ZXMoKTtcclxuICAgICAgICB0aGlzLnNjYWxlVHlwZSA9IGdldFNjYWxlVHlwZSh4VmFsdWVzKTtcclxuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmZpbHRlcmVkRG9tYWluIHx8IHRoaXMuZ2V0WERvbWFpbih4VmFsdWVzKTtcclxuICAgICAgICB0aGlzLnlEb21haW4gPSB0aGlzLmdldFlEb21haW4oKTtcclxuICAgICAgICB0aGlzLnNlcmllc0RvbWFpbiA9IHRoaXMuZ2V0U2VyaWVzRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHR3b1BJKTtcclxuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy5vdXRlclJhZGl1cyk7XHJcbiAgICAgICAgdGhpcy55QXhpc1NjYWxlID0gdGhpcy5nZXRZU2NhbGUodGhpcy55RG9tYWluLnJldmVyc2UoKSwgdGhpcy5vdXRlclJhZGl1cyk7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuc2V0VGlja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdGlja0Zvcm1hdDtcclxuICAgICAgICBpZiAodGhpcy54QXhpc1RpY2tGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgICAgIHRpY2tGb3JtYXQgPSB0aGlzLnhBeGlzVGlja0Zvcm1hdHRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMueFNjYWxlLnRpY2tGb3JtYXQpIHtcclxuICAgICAgICAgICAgdGlja0Zvcm1hdCA9IHRoaXMueFNjYWxlLnRpY2tGb3JtYXQuYXBwbHkodGhpcy54U2NhbGUsIFs1XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aWNrRm9ybWF0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RhdGUoZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC50b0xvY2FsZURhdGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBkLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXRlclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXM7XHJcbiAgICAgICAgdmFyIHMgPSAxLjE7XHJcbiAgICAgICAgdGhpcy50aGV0YVRpY2tzID0gdGhpcy54RG9tYWluLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IF90aGlzLnhTY2FsZShkKTtcclxuICAgICAgICAgICAgdmFyIGRkID0gcyAqIG91dGVyUmFkaXVzICogKHN0YXJ0QW5nbGUgPiBNYXRoLlBJID8gLTEgOiAxKTtcclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gdGlja0Zvcm1hdChkKTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0UG9zID0gW291dGVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSksIC1vdXRlclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpXTtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IFtkZCwgcyAqIHN0YXJ0UG9zWzFdXTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlubmVyUmFkaXVzOiAwLFxyXG4gICAgICAgICAgICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcclxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG91dGVyUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRQb3M6IHN0YXJ0UG9zLFxyXG4gICAgICAgICAgICAgICAgcG9zOiBwb3NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSAxMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGhldGFUaWNrcy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnRoZXRhVGlja3NbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IHRoaXMudGhldGFUaWNrcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnRoZXRhVGlja3Nbal07XHJcbiAgICAgICAgICAgICAgICBpZiAoYi5wb3NbMF0gKiBhLnBvc1swXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG1pbkRpc3RhbmNlIC0gTWF0aC5hYnMoYi5wb3NbMV0gLSBhLnBvc1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucG9zWzFdICs9IE1hdGguc2lnbihiLnBvc1swXSkgKiBvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJhZGl1c1RpY2tzID0gdGhpcy55QXhpc1NjYWxlLnRpY2tzKE1hdGguZmxvb3IodGhpcy5kaW1zLmhlaWdodCAvIDUwKSkubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy55U2NhbGUoZCk7IH0pO1xyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFhWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gcmVzdWx0cy5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKGQubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WERvbWFpbiA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcclxuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0gdGhpcy5nZXRYVmFsdWVzKCk7IH1cclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gTnVtYmVyKHYpOyB9KTtcclxuICAgICAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRZVmFsdWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHJlc3VsdHMuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluLmluZGV4T2YoZC52YWx1ZSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5taW4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4uaW5kZXhPZihkLm1pbikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubWluKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5tYXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4uaW5kZXhPZihkLm1heCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubWF4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRZRG9tYWluID0gZnVuY3Rpb24gKGRvbWFpbikge1xyXG4gICAgICAgIGlmIChkb21haW4gPT09IHZvaWQgMCkgeyBkb21haW4gPSB0aGlzLmdldFlWYWx1ZXMoKTsgfVxyXG4gICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBkb21haW4pO1xyXG4gICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBbdGhpcy55QXhpc01pblNjYWxlXS5jb25jYXQoZG9tYWluKSk7XHJcbiAgICAgICAgbWluJCQxID0gTWF0aC5tYXgoMCwgbWluJCQxKTtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0b1NjYWxlKSB7XHJcbiAgICAgICAgICAgIG1pbiQkMSA9IE1hdGgubWluKDAsIG1pbiQkMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFNlcmllc0RvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lOyB9KTtcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRYU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCB3aWR0aCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5zY2FsZVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAndGltZSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGVUaW1lKClcclxuICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcclxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgICAgIGNhc2UgJ2xpbmVhcic6XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGVQb2ludCgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aCAtIHR3b1BJIC8gZG9tYWluLmxlbmd0aF0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnBhZGRpbmcoMClcclxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIGhlaWdodCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFswLCBoZWlnaHRdKVxyXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXMpIHtcclxuICAgICAgICBpZiAoc2VyaWVzKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc2VyaWVzID0gc2VyaWVzLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSB0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJyA/IHRoaXMuc2VyaWVzRG9tYWluIDogdGhpcy55RG9tYWluLnJldmVyc2UoKTtcclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgICAgICBjb2xvcnM6IHRoaXMuY29sb3JzLFxyXG4gICAgICAgICAgICAgICAgZG9tYWluOiB0aGlzLnNlcmllc0RvbWFpbixcclxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLmxlZ2VuZFRpdGxlLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGNvbG9yczogdGhpcy5jb2xvcnMuc2NhbGUsXHJcbiAgICAgICAgICAgIGRvbWFpbjogdGhpcy55RG9tYWluLFxyXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLnNob3dTZXJpZXNPbkhvdmVyID8gW2l0ZW1dLmNvbmNhdCh0aGlzLmFjdGl2ZUVudHJpZXMpIDogdGhpcy5hY3RpdmVFbnRyaWVzO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmRlYWN0aXZhdGVBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuYWN0aXZlRW50cmllczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBlbnRyeSwgZW50cmllczogW10gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhdXRvU2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXJ2ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZUZpbGxPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFlBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZERvbWFpbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93U2VyaWVzT25Ib3ZlclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc01pblNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxUcmltXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFRyaW1TaXplXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1wb2xhci1jaGFydCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBjbGFzcz1cXFwicG9sYXItY2hhcnQgY2hhcnRcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCI+XFxuICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtUGxvdFxcXCI+XFxuICAgICAgICAgIDxzdmc6Y2lyY2xlIGNsYXNzPVxcXCJwb2xhci1jaGFydC1iYWNrZ3JvdW5kXFxcIiBjeD1cXFwiMFxcXCIgY3k9XFxcIjBcXFwiIFthdHRyLnJdPVxcXCJ0aGlzLm91dGVyUmFkaXVzXFxcIiAvPlxcbiAgICAgICAgICA8c3ZnOmcgKm5nSWY9XFxcInNob3dHcmlkTGluZXNcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Y2lyY2xlXFxuICAgICAgICAgICAgICAqbmdGb3I9XFxcImxldCByIG9mIHJhZGl1c1RpY2tzXFxcIlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcImdyaWRsaW5lLXBhdGggcmFkaWFsLWdyaWRsaW5lLXBhdGhcXFwiXFxuICAgICAgICAgICAgICBjeD1cXFwiMFxcXCJcXG4gICAgICAgICAgICAgIGN5PVxcXCIwXFxcIlxcbiAgICAgICAgICAgICAgW2F0dHIucl09XFxcInJcXFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0lmPVxcXCJ4QXhpc1xcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLXBpZS1sYWJlbFxcbiAgICAgICAgICAgICAgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aGV0YVRpY2tzXFxcIlxcbiAgICAgICAgICAgICAgW2RhdGFdPVxcXCJ0aWNrXFxcIlxcbiAgICAgICAgICAgICAgW3JhZGl1c109XFxcIm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgICAgW2xhYmVsXT1cXFwidGljay5sYWJlbFxcXCJcXG4gICAgICAgICAgICAgIFttYXhdPVxcXCJvdXRlclJhZGl1c1xcXCJcXG4gICAgICAgICAgICAgIFt2YWx1ZV09XFxcInNob3dHcmlkTGluZXMgPyAxIDogb3V0ZXJSYWRpdXNcXFwiXFxuICAgICAgICAgICAgICBbZXhwbG9kZVNsaWNlc109XFxcInRydWVcXFwiXFxuICAgICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgICBbbGFiZWxUcmltXT1cXFwibGFiZWxUcmltXFxcIlxcbiAgICAgICAgICAgICAgW2xhYmVsVHJpbVNpemVdPVxcXCJsYWJlbFRyaW1TaXplXFxcIlxcbiAgICAgICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1ZQXhpc1xcXCJcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieUF4aXNTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJ5QXhpc0RpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1heGlzLWxhYmVsXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpcyAmJiBzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsXT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW29mZnNldF09XFxcImxhYmVsT2Zmc2V0XFxcIlxcbiAgICAgICAgICBbb3JpZW50XT1cXFwiJ2JvdHRvbSdcXFwiXFxuICAgICAgICAgIFtoZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgICAgW3dpZHRoXT1cXFwiZGltcy53aWR0aFxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVBsb3RcXFwiPlxcbiAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLXBvbGFyLXNlcmllc1xcbiAgICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICBbY3VydmVdPVxcXCJjdXJ2ZVxcXCJcXG4gICAgICAgICAgICAgIFtyYW5nZUZpbGxPcGFjaXR5XT1cXFwicmFuZ2VGaWxsT3BhY2l0eVxcXCJcXG4gICAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1xyXG4gICAgICAgICAgICAgICAgXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiLFxyXG4gICAgICAgICAgICAgICAgXCIucGllLWxhYmVse2ZvbnQtc2l6ZToxMXB4fS5waWUtbGFiZWwuYW5pbWF0aW9ue2FuaW1hdGlvbjo3NTBtcyBlYXNlLWluIGZhZGVJbn1Aa2V5ZnJhbWVzIGZhZGVJbntmcm9te29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fS5waWUtbGFiZWwtbGluZXtzdHJva2UtZGFzaGFycmF5OjEwMCV9LnBpZS1sYWJlbC1saW5lLmFuaW1hdGlvbnthbmltYXRpb246M3MgbGluZWFyIGRyYXdPdXQ7dHJhbnNpdGlvbjpkIDc1MG1zfUBrZXlmcmFtZXMgZHJhd091dHtmcm9te3N0cm9rZS1kYXNob2Zmc2V0OjEwMCV9dG97c3Ryb2tlLWRhc2hvZmZzZXQ6MH19XCIsXHJcbiAgICAgICAgICAgICAgICBcIi5wb2xhci1jaGFydCAucG9sYXItY2hhcnQtYmFja2dyb3VuZHtmaWxsOm5vbmV9LnBvbGFyLWNoYXJ0IC5yYWRpYWwtZ3JpZGxpbmUtcGF0aHtzdHJva2UtZGFzaGFycmF5OjEwIDEwO2ZpbGw6bm9uZX0ucG9sYXItY2hhcnQgLnBpZS1sYWJlbC1saW5le3N0cm9rZTojMmYzNjQ2fS5wb2xhci1jaGFydHMtc2VyaWVzIC5wb2xhci1zZXJpZXMtYXJlYXtwb2ludGVyLWV2ZW50czpub25lfS5wb2xhci1zZXJpZXMtcGF0aHtwb2ludGVyLWV2ZW50czpub25lfVwiXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFBvbGFyQ2hhcnRDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgUG9sYXJTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQb2xhclNlcmllc0NvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuY2lyY2xlUmFkaXVzID0gMztcclxuICAgIH1cclxuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy51cGRhdGVHcmFkaWVudHMoKTtcclxuICAgICAgICB2YXIgbGluZSQkMSA9IHRoaXMuZ2V0TGluZUdlbmVyYXRvcigpO1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5zb3J0RGF0YSh0aGlzLmRhdGEuc2VyaWVzKTtcclxuICAgICAgICB2YXIgc2VyaWVzTmFtZSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgIHZhciBsaW5lYXJTY2FsZVR5cGUgPSB0aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInO1xyXG4gICAgICAgIHZhciBtaW4kJDEgPSB0aGlzLnlTY2FsZS5kb21haW4oKVswXTtcclxuICAgICAgICB0aGlzLnNlcmllc0NvbG9yID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3IobGluZWFyU2NhbGVUeXBlID8gbWluJCQxIDogc2VyaWVzTmFtZSk7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gbGluZSQkMShkYXRhKSB8fCAnJztcclxuICAgICAgICB0aGlzLmNpcmNsZXMgPSBkYXRhLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IF90aGlzLmdldEFuZ2xlKGQpO1xyXG4gICAgICAgICAgICB2YXIgciA9IF90aGlzLmdldFJhZGl1cyhkKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZC52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gX3RoaXMuY29sb3JzLmdldENvbG9yKGxpbmVhclNjYWxlVHlwZSA/IE1hdGguYWJzKHZhbHVlKSA6IHNlcmllc05hbWUpO1xyXG4gICAgICAgICAgICB2YXIgY0RhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBkLCB7XHJcbiAgICAgICAgICAgICAgICBzZXJpZXM6IHNlcmllc05hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBkLm5hbWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBjRGF0YSxcclxuICAgICAgICAgICAgICAgIGN4OiByICogTWF0aC5zaW4oYSksXHJcbiAgICAgICAgICAgICAgICBjeTogLXIgKiBNYXRoLmNvcyhhKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBkLm5hbWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRoaXMuaXNBY3RpdmUodGhpcy5kYXRhKTtcclxuICAgICAgICB0aGlzLmluYWN0aXZlID0gdGhpcy5pc0luYWN0aXZlKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgdGhpcy50b29sdGlwVGV4dCA9IHRoaXMudG9vbHRpcFRleHQgfHwgKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5kZWZhdWx0VG9vbHRpcFRleHQoYyk7IH0pO1xyXG4gICAgfTtcclxuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsID0gZC5uYW1lO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhTY2FsZShsYWJlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54U2NhbGUoTnVtYmVyKGxhYmVsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnhTY2FsZShsYWJlbCk7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFJhZGl1cyA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueVNjYWxlKGQudmFsdWUpO1xyXG4gICAgfTtcclxuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMaW5lR2VuZXJhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVSYWRpYWwoKVxyXG4gICAgICAgICAgICAuYW5nbGUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLmdldEFuZ2xlKGQpOyB9KVxyXG4gICAgICAgICAgICAucmFkaXVzKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy5nZXRSYWRpdXMoZCk7IH0pXHJcbiAgICAgICAgICAgIC5jdXJ2ZSh0aGlzLmN1cnZlKTtcclxuICAgIH07XHJcbiAgICBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuc29ydERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvcnRMaW5lYXIoZGF0YSwgJ25hbWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICByZXR1cm4gc29ydEJ5VGltZShkYXRhLCAnbmFtZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc29ydEJ5RG9tYWluKGRhdGEsICduYW1lJywgJ2FzYycsIHRoaXMueFNjYWxlLmRvbWFpbigpKTtcclxuICAgIH07XHJcbiAgICBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWUgPT09IGQubmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0luYWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMgfHwgdGhpcy5hY3RpdmVFbnRyaWVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWUgPT09IGQubmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5kZWZhdWx0VG9vbHRpcFRleHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgbGFiZWwgPSBfYS5sYWJlbCwgdmFsdWUgPSBfYS52YWx1ZTtcclxuICAgICAgICByZXR1cm4gXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC1sYWJlbFxcXCI+XCIgKyB0aGlzLmRhdGEubmFtZSArIFwiIFxcdTIwMjIgXCIgKyBsYWJlbCArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWx1ZS50b0xvY2FsZVN0cmluZygpICsgXCI8L3NwYW4+XFxuICAgIFwiO1xyXG4gICAgfTtcclxuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVHcmFkaWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IHRoaXMuZ3JhZGllbnQgfHwgdGhpcy5jb2xvcnMuc2NhbGVUeXBlID09PSAnbGluZWFyJztcclxuICAgICAgICBpZiAoIXRoaXMuaGFzR3JhZGllbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyYWRpZW50SWQgPSAnZ3JhZCcgKyBpZCgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudFVybCA9IFwidXJsKCNcIiArIHRoaXMuZ3JhZGllbnRJZCArIFwiKVwiO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmRhdGEuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhtYXgkJDEsIG1pbiQkMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNjYWxlVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VGaWxsT3BhY2l0eVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtcG9sYXItc2VyaWVzXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgY2xhc3M9XFxcInBvbGFyLWNoYXJ0cy1zZXJpZXNcXFwiPlxcbiAgICAgIDxkZWZzPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtc3ZnLXJhZGlhbC1ncmFkaWVudFxcbiAgICAgICAgICAqbmdJZj1cXFwiaGFzR3JhZGllbnRcXFwiXFxuICAgICAgICAgIG9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgW2NvbG9yXT1cXFwic2VyaWVzQ29sb3JcXFwiXFxuICAgICAgICAgIFtuYW1lXT1cXFwiZ3JhZGllbnRJZFxcXCJcXG4gICAgICAgICAgW3N0YXJ0T3BhY2l0eV09XFxcIjAuMjVcXFwiXFxuICAgICAgICAgIFtlbmRPcGFjaXR5XT1cXFwiMVxcXCJcXG4gICAgICAgICAgW3N0b3BzXT1cXFwiZ3JhZGllbnRTdG9wc1xcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9kZWZzPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1saW5lXFxuICAgICAgICBjbGFzcz1cXFwicG9sYXItc2VyaWVzLXBhdGhcXFwiXFxuICAgICAgICBbcGF0aF09XFxcInBhdGhcXFwiXFxuICAgICAgICBbc3Ryb2tlXT1cXFwiaGFzR3JhZGllbnQgPyBncmFkaWVudFVybCA6IHNlcmllc0NvbG9yXFxcIlxcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImFjdGl2ZVxcXCJcXG4gICAgICAgIFtjbGFzcy5pbmFjdGl2ZV09XFxcImluYWN0aXZlXFxcIlxcbiAgICAgICAgW2F0dHIuZmlsbC1vcGFjaXR5XT1cXFwicmFuZ2VGaWxsT3BhY2l0eVxcXCJcXG4gICAgICAgIFtmaWxsXT1cXFwiaGFzR3JhZGllbnQgPyBncmFkaWVudFVybCA6IHNlcmllc0NvbG9yXFxcIlxcbiAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIC8+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLWNpcmNsZVxcbiAgICAgICAgKm5nRm9yPVxcXCJsZXQgY2lyY2xlIG9mIGNpcmNsZXNcXFwiXFxuICAgICAgICBjbGFzcz1cXFwiY2lyY2xlXFxcIlxcbiAgICAgICAgW2N4XT1cXFwiY2lyY2xlLmN4XFxcIlxcbiAgICAgICAgW2N5XT1cXFwiY2lyY2xlLmN5XFxcIlxcbiAgICAgICAgW3JdPVxcXCJjaXJjbGVSYWRpdXNcXFwiXFxuICAgICAgICBbZmlsbF09XFxcImNpcmNsZS5jb2xvclxcXCJcXG4gICAgICAgIFtzdHlsZS5vcGFjaXR5XT1cXFwiaW5hY3RpdmUgPyAwLjIgOiAxXFxcIlxcbiAgICAgICAgbmd4LXRvb2x0aXBcXG4gICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgICAgdG9vbHRpcFR5cGU9XFxcInRvb2x0aXBcXFwiXFxuICAgICAgICBbdG9vbHRpcFRpdGxlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogdG9vbHRpcFRleHQoY2lyY2xlKVxcXCJcXG4gICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJjaXJjbGUuZGF0YVxcXCJcXG4gICAgICAgIChzZWxlY3QpPVxcXCJzZWxlY3QuZW1pdChjaXJjbGUuZGF0YSlcXFwiXFxuICAgICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZS5lbWl0KHsgbmFtZTogY2lyY2xlLmRhdGEuc2VyaWVzIH0pXFxcIlxcbiAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJkZWFjdGl2YXRlLmVtaXQoeyBuYW1lOiBjaXJjbGUuZGF0YS5zZXJpZXMgfSlcXFwiXFxuICAgICAgPjwvc3ZnOmc+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFBvbGFyU2VyaWVzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmxhYmVsID0gJ1RvdGFsJztcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsyMCwgMjAsIDIwLCAyMF07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogKHRoaXMud2lkdGggKiA0KSAvIDEyLjAsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5mb3JtYXREYXRlcygpO1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gdGhpcy5nZXREb21haW4oKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHZhciB4T2Zmc2V0ID0gdGhpcy5kaW1zLndpZHRoIC8gMjtcclxuICAgICAgICB2YXIgeU9mZnNldCA9IHRoaXMubWFyZ2luWzBdICsgdGhpcy5kaW1zLmhlaWdodCAvIDI7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRXaWR0aCA9IHRoaXMud2lkdGggLSB0aGlzLmRpbXMud2lkdGggLSB0aGlzLm1hcmdpblsxXTtcclxuICAgICAgICB0aGlzLm91dGVyUmFkaXVzID0gTWF0aC5taW4odGhpcy5kaW1zLndpZHRoLCB0aGlzLmRpbXMuaGVpZ2h0KSAvIDIuNTtcclxuICAgICAgICB0aGlzLmlubmVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cyAqIDAuNzU7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHhPZmZzZXQgKyBcIiAsIFwiICsgeU9mZnNldCArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5sYWJlbDsgfSk7XHJcbiAgICB9O1xyXG4gICAgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsICdvcmRpbmFsJywgdGhpcy5kb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbaXRlbV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcyk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0cy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWUgJiYgZC5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibmFtZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicGVyY2VudGFnZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYWR2YW5jZWQtcGllLWNoYXJ0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxkaXYgW3N0eWxlLndpZHRoLnB4XT1cXFwid2lkdGhcXFwiIFtzdHlsZS5oZWlnaHQucHhdPVxcXCJoZWlnaHRcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImFkdmFuY2VkLXBpZSBjaGFydFxcXCIgW3N0eWxlLndpZHRoLnB4XT1cXFwiZGltcy53aWR0aFxcXCIgW3N0eWxlLmhlaWdodC5weF09XFxcImRpbXMuaGVpZ2h0XFxcIj5cXG4gICAgICAgIDxuZ3gtY2hhcnRzLWNoYXJ0IFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIiBbc2hvd0xlZ2VuZF09XFxcImZhbHNlXFxcIiBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiPlxcbiAgICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwicGllIGNoYXJ0XFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtcGllLXNlcmllc1xcbiAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgIFtzZXJpZXNdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgICAgICAgW2lubmVyUmFkaXVzXT1cXFwiaW5uZXJSYWRpdXNcXFwiXFxuICAgICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgICBbb3V0ZXJSYWRpdXNdPVxcXCJvdXRlclJhZGl1c1xcXCJcXG4gICAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcFRleHRdPVxcXCJ0b29sdGlwVGV4dFxcXCJcXG4gICAgICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImFkdmFuY2VkLXBpZS1sZWdlbmQtd3JhcHBlclxcXCIgW3N0eWxlLndpZHRoLnB4XT1cXFwid2lkdGggLSBkaW1zLndpZHRoXFxcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cXFwiaGVpZ2h0XFxcIj5cXG4gICAgICAgIDxuZ3gtY2hhcnRzLWFkdmFuY2VkLWxlZ2VuZFxcbiAgICAgICAgICBbZGF0YV09XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgIFt3aWR0aF09XFxcIndpZHRoIC0gZGltcy53aWR0aCAtIG1hcmdpblsxXVxcXCJcXG4gICAgICAgICAgW2xhYmVsXT1cXFwibGFiZWxcXFwiXFxuICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgW3ZhbHVlRm9ybWF0dGluZ109XFxcInZhbHVlRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW2xhYmVsRm9ybWF0dGluZ109XFxcIm5hbWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbcGVyY2VudGFnZUZvcm1hdHRpbmddPVxcXCJwZXJjZW50YWdlRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgdW5kZWZpbmVkLCB0cnVlKVxcXCJcXG4gICAgICAgID5cXG4gICAgICAgIDwvbmd4LWNoYXJ0cy1hZHZhbmNlZC1sZWdlbmQ+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIiwgXCIuYWR2YW5jZWQtcGlle2Rpc3BsYXk6aW5saW5lLWJsb2NrO2Zsb2F0OmxlZnR9LmFkdmFuY2VkLXBpZS1sZWdlbmQtd3JhcHBlcntkaXNwbGF5OmlubGluZS1ibG9ja31cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgUGllTGFiZWxDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQaWVMYWJlbENvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFiZWxUcmltID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxhYmVsVHJpbVNpemUgPSAxMDtcclxuICAgICAgICB0aGlzLmlzSUUgPSAvKGVkZ2V8bXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgICAgICAgdGhpcy50cmltTGFiZWwgPSB0cmltTGFiZWw7XHJcbiAgICB9XHJcbiAgICBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3RhcnRSYWRpdXMgPSB0aGlzLnJhZGl1cztcclxuICAgICAgICBpZiAodGhpcy5leHBsb2RlU2xpY2VzKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0UmFkaXVzID0gdGhpcy5yYWRpdXMgKiB0aGlzLnZhbHVlIC8gdGhpcy5tYXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbm5lckFyYyA9IGFyYygpXHJcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cyhzdGFydFJhZGl1cylcclxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKHN0YXJ0UmFkaXVzKTtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgaW5uZXJQb3MgdGhlbiBzY2FsZSBvdXRlciBwb3NpdGlvbiB0byBtYXRjaCBsYWJlbCBwb3NpdGlvblxyXG4gICAgICAgIHZhciBpbm5lclBvcyA9IGlubmVyQXJjLmNlbnRyb2lkKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5kYXRhLnBvc1sxXSAvIGlubmVyUG9zWzFdO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEucG9zWzFdID09PSAwIHx8IGlubmVyUG9zWzFdID09PSAwKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG91dGVyUG9zID0gW3NjYWxlICogaW5uZXJQb3NbMF0sIHNjYWxlICogaW5uZXJQb3NbMV1dO1xyXG4gICAgICAgIHRoaXMubGluZSA9IFwiTVwiICsgaW5uZXJQb3MgKyBcIkxcIiArIG91dGVyUG9zICsgXCJMXCIgKyB0aGlzLmRhdGEucG9zO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwidGV4dFhcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnBvc1swXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwidGV4dFlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnBvc1sxXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwic3R5bGVUcmFuc2Zvcm1cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0lFID8gbnVsbCA6IFwidHJhbnNsYXRlM2QoXCIgKyB0aGlzLnRleHRYICsgXCJweCxcIiArIHRoaXMudGV4dFkgKyBcInB4LCAwKVwiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhdHRyVHJhbnNmb3JtXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzSUUgPyBudWxsIDogXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnRleHRYICsgXCIsXCIgKyB0aGlzLnRleHRZICsgXCIpXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRUcmFuc2l0aW9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNJRSB8fCAhdGhpcy5hbmltYXRpb25zID8gbnVsbCA6ICd0cmFuc2Zvcm0gMC43NXMnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLnRleHRBbmNob3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWlkQW5nbGUodGhpcy5kYXRhKSA8IE1hdGguUEkgPyAnc3RhcnQnIDogJ2VuZCc7XHJcbiAgICB9O1xyXG4gICAgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLm1pZEFuZ2xlID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gZC5zdGFydEFuZ2xlICsgKGQuZW5kQW5nbGUgLSBkLnN0YXJ0QW5nbGUpIC8gMjtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcInJhZGl1c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImV4cGxvZGVTbGljZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFRyaW1cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFRyaW1TaXplXCIsIHZvaWQgMCk7XHJcbiAgICBQaWVMYWJlbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXBpZS1sYWJlbF0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHRpdGxlPnt7bGFiZWx9fTwvdGl0bGU+XFxuICAgIDxzdmc6Z1xcbiAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcImF0dHJUcmFuc2Zvcm1cXFwiXFxuICAgICAgW3N0eWxlLnRyYW5zZm9ybV09XFxcInN0eWxlVHJhbnNmb3JtXFxcIlxcbiAgICAgIFtzdHlsZS50cmFuc2l0aW9uXT1cXFwidGV4dFRyYW5zaXRpb25cXFwiPlxcbiAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgY2xhc3M9XFxcInBpZS1sYWJlbFxcXCJcXG4gICAgICAgIFtjbGFzcy5hbmltYXRpb25dPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgZHk9XFxcIi4zNWVtXFxcIlxcbiAgICAgICAgW3N0eWxlLnRleHRBbmNob3JdPVxcXCJ0ZXh0QW5jaG9yKClcXFwiXFxuICAgICAgICBbc3R5bGUuc2hhcGVSZW5kZXJpbmddPVxcXCInY3Jpc3BFZGdlcydcXFwiPlxcbiAgICAgICAge3tsYWJlbFRyaW0gPyB0cmltTGFiZWwobGFiZWwsIGxhYmVsVHJpbVNpemUpIDogbGFiZWx9fVxcbiAgICAgIDwvc3ZnOnRleHQ+XFxuICAgIDwvc3ZnOmc+XFxuICAgIDxzdmc6cGF0aFxcbiAgICAgIFthdHRyLmRdPVxcXCJsaW5lXFxcIlxcbiAgICAgIFthdHRyLnN0cm9rZV09XFxcImNvbG9yXFxcIlxcbiAgICAgIGZpbGw9XFxcIm5vbmVcXFwiXFxuICAgICAgY2xhc3M9XFxcInBpZS1sYWJlbC1saW5lIGxpbmVcXFwiXFxuICAgICAgW2NsYXNzLmFuaW1hdGlvbl09XFxcImFuaW1hdGlvbnNcXFwiPlxcbiAgICA8L3N2ZzpwYXRoPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFBpZUxhYmVsQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIFBpZUFyY0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBpZUFyY0NvbXBvbmVudChlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5zdGFydEFuZ2xlID0gMDtcclxuICAgICAgICB0aGlzLmVuZEFuZ2xlID0gTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgdGhpcy5jb3JuZXJSYWRpdXMgPSAwO1xyXG4gICAgICAgIHRoaXMuZXhwbG9kZVNsaWNlcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucG9pbnRlckV2ZW50cyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGJsY2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcclxuICAgIH1cclxuICAgIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ncmFkaWVudCA/IHRoaXMuZ3JhZGllbnRGaWxsIDogdGhpcy5maWxsO1xyXG4gICAgfTtcclxuICAgIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0UG9pbnRlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludGVyRXZlbnRzID8gJ2F1dG8nIDogJ25vbmUnO1xyXG4gICAgfTtcclxuICAgIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjYWxjID0gdGhpcy5jYWxjdWxhdGVBcmMoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0T3BhY2l0eSA9IDAuNTtcclxuICAgICAgICB0aGlzLnJhZGlhbEdyYWRpZW50SWQgPSAnbGluZWFyR3JhZCcgKyBpZCgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudEZpbGwgPSBcInVybCgjXCIgKyB0aGlzLnJhZGlhbEdyYWRpZW50SWQgKyBcIilcIjtcclxuICAgICAgICBpZiAodGhpcy5hbmltYXRlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gY2FsYy5zdGFydEFuZ2xlKHRoaXMuc3RhcnRBbmdsZSkuZW5kQW5nbGUodGhpcy5lbmRBbmdsZSkoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS5jYWxjdWxhdGVBcmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG91dGVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cztcclxuICAgICAgICBpZiAodGhpcy5leHBsb2RlU2xpY2VzICYmIHRoaXMuaW5uZXJSYWRpdXMgPT09IDApIHtcclxuICAgICAgICAgICAgb3V0ZXJSYWRpdXMgPSAodGhpcy5vdXRlclJhZGl1cyAqIHRoaXMudmFsdWUpIC8gdGhpcy5tYXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcmMoKVxyXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXModGhpcy5pbm5lclJhZGl1cylcclxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKG91dGVyUmFkaXVzKVxyXG4gICAgICAgICAgICAuY29ybmVyUmFkaXVzKHRoaXMuY29ybmVyUmFkaXVzKTtcclxuICAgIH07XHJcbiAgICBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLmxvYWRBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3QodGhpcy5lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCcuYXJjJylcclxuICAgICAgICAgICAgLmRhdGEoW3sgc3RhcnRBbmdsZTogdGhpcy5zdGFydEFuZ2xlLCBlbmRBbmdsZTogdGhpcy5lbmRBbmdsZSB9XSk7XHJcbiAgICAgICAgdmFyIGNhbGMgPSB0aGlzLmNhbGN1bGF0ZUFyYygpO1xyXG4gICAgICAgIG5vZGVcclxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAuYXR0clR3ZWVuKCdkJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgfHwgZDtcclxuICAgICAgICAgICAgdmFyIGNvcHlPZkQgPSBPYmplY3QuYXNzaWduKHt9LCBkKTtcclxuICAgICAgICAgICAgY29weU9mRC5lbmRBbmdsZSA9IGNvcHlPZkQuc3RhcnRBbmdsZTtcclxuICAgICAgICAgICAgdmFyIGludGVycG9sYXRlciA9IGludGVycG9sYXRlKGNvcHlPZkQsIGNvcHlPZkQpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGVyKDApO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjKGludGVycG9sYXRlcih0KSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAuZHVyYXRpb24oNzUwKVxyXG4gICAgICAgICAgICAuYXR0clR3ZWVuKCdkJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgfHwgZDtcclxuICAgICAgICAgICAgdmFyIGludGVycG9sYXRlciA9IGludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIGQpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGVyKDApO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjKGludGVycG9sYXRlcih0KSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3QodGhpcy5lbGVtZW50KVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCcuYXJjJylcclxuICAgICAgICAgICAgLmRhdGEoW3sgc3RhcnRBbmdsZTogdGhpcy5zdGFydEFuZ2xlLCBlbmRBbmdsZTogdGhpcy5lbmRBbmdsZSB9XSk7XHJcbiAgICAgICAgdmFyIGNhbGMgPSB0aGlzLmNhbGN1bGF0ZUFyYygpO1xyXG4gICAgICAgIG5vZGVcclxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAuZHVyYXRpb24oNzUwKVxyXG4gICAgICAgICAgICAuYXR0clR3ZWVuKCdkJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgfHwgZDtcclxuICAgICAgICAgICAgdmFyIGludGVycG9sYXRlciA9IGludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIGQpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGVyKDApO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjKGludGVycG9sYXRlcih0KSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xyXG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNlbGVjdC5lbWl0KF90aGlzLmRhdGEpOyB9LCAyMDApO1xyXG4gICAgfTtcclxuICAgIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUub25EYmxDbGljayA9IGZ1bmN0aW9uIChldmVudCQkMSkge1xyXG4gICAgICAgIGV2ZW50JCQxLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZXZlbnQkJDEuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xyXG4gICAgICAgIHRoaXMuZGJsY2xpY2suZW1pdCh7XHJcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcclxuICAgICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50JCQxXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZW5kQW5nbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29ybmVyUmFkaXVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBsb2RlU2xpY2VzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwicG9pbnRlckV2ZW50c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNBY3RpdmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImRibGNsaWNrXCIsIHZvaWQgMCk7XHJcbiAgICBQaWVBcmNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1waWUtYXJjXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgY2xhc3M9XFxcImFyYy1ncm91cFxcXCI+XFxuICAgICAgPHN2ZzpkZWZzICpuZ0lmPVxcXCJncmFkaWVudFxcXCI+XFxuICAgICAgICA8c3ZnOmcgbmd4LWNoYXJ0cy1zdmctcmFkaWFsLWdyYWRpZW50XFxuICAgICAgICAgIFtjb2xvcl09XFxcImZpbGxcXFwiXFxuICAgICAgICAgIG9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgW25hbWVdPVxcXCJyYWRpYWxHcmFkaWVudElkXFxcIlxcbiAgICAgICAgICBbc3RhcnRPcGFjaXR5XT1cXFwic3RhcnRPcGFjaXR5XFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L3N2ZzpkZWZzPlxcbiAgICAgIDxzdmc6cGF0aFxcbiAgICAgICAgW2F0dHIuZF09XFxcInBhdGhcXFwiXFxuICAgICAgICBjbGFzcz1cXFwiYXJjXFxcIlxcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlXFxcIlxcbiAgICAgICAgW2F0dHIuZmlsbF09XFxcImdldEdyYWRpZW50KClcXFwiXFxuICAgICAgICAoY2xpY2spPVxcXCJvbkNsaWNrKClcXFwiXFxuICAgICAgICAoZGJsY2xpY2spPVxcXCJvbkRibENsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAobW91c2VlbnRlcik9XFxcImFjdGl2YXRlLmVtaXQoZGF0YSlcXFwiXFxuICAgICAgICAobW91c2VsZWF2ZSk9XFxcImRlYWN0aXZhdGUuZW1pdChkYXRhKVxcXCJcXG4gICAgICAgIFtzdHlsZS5wb2ludGVyLWV2ZW50c109XFxcImdldFBvaW50ZXJFdmVudHMoKVxcXCJcXG4gICAgICAvPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gUGllQXJjQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIFBpZUNoYXJ0Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBpZUNoYXJ0Q29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGllQ2hhcnRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGFiZWxzID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMuZXhwbG9kZVNsaWNlcyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmRvdWdobnV0ID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuYXJjV2lkdGggPSAwLjI1O1xyXG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy50cmltTGFiZWxzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5tYXhMYWJlbExlbmd0aCA9IDEwO1xyXG4gICAgICAgIF90aGlzLmRibGNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhYmVscyAmJiB0aGlzLmhhc05vT3B0aW9uYWxNYXJnaW5zU2V0KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXJnaW5zID0gWzMwLCA4MCwgMzAsIDgwXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMubGFiZWxzICYmIHRoaXMuaGFzTm9PcHRpb25hbE1hcmdpbnNTZXQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcmdpbnMgPSBbMjAsIDIwLCAyMCwgMjBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbnMsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcclxuICAgICAgICB2YXIgeE9mZnNldCA9IHRoaXMubWFyZ2luc1szXSArIHRoaXMuZGltcy53aWR0aCAvIDI7XHJcbiAgICAgICAgdmFyIHlPZmZzZXQgPSB0aGlzLm1hcmdpbnNbMF0gKyB0aGlzLmRpbXMuaGVpZ2h0IC8gMjtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uID0gXCJ0cmFuc2xhdGUoXCIgKyB4T2Zmc2V0ICsgXCIsIFwiICsgeU9mZnNldCArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBNYXRoLm1pbih0aGlzLmRpbXMud2lkdGgsIHRoaXMuZGltcy5oZWlnaHQpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhYmVscykge1xyXG4gICAgICAgICAgICB0aGlzLm91dGVyUmFkaXVzIC89IDM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm91dGVyUmFkaXVzIC89IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXMgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmRvdWdobnV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzICogKDEgLSB0aGlzLmFyY1dpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSB0aGlzLmdldERvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMucmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5kb21haW4uaW5kZXhPZihhLm5hbWUpIC0gX3RoaXMuZG9tYWluLmluZGV4T2YoYi5uYW1lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgfTtcclxuICAgIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXREb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubGFiZWw7IH0pO1xyXG4gICAgfTtcclxuICAgIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsICdvcmRpbmFsJywgdGhpcy5kb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6ICdvcmRpbmFsJyxcclxuICAgICAgICAgICAgZG9tYWluOiB0aGlzLmRvbWFpbixcclxuICAgICAgICAgICAgY29sb3JzOiB0aGlzLmNvbG9ycyxcclxuICAgICAgICAgICAgdGl0bGU6IHRoaXMubGVnZW5kVGl0bGUsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICBpdGVtID0gdGhpcy5yZXN1bHRzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZSAmJiBkLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW2l0ZW1dLmNvbmNhdCh0aGlzLmFjdGl2ZUVudHJpZXMpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICBpdGVtID0gdGhpcy5yZXN1bHRzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZSAmJiBkLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuaGFzTm9PcHRpb25hbE1hcmdpbnNTZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLm1hcmdpbnMgfHwgdGhpcy5tYXJnaW5zLmxlbmd0aCA8PSAwO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBsb2RlU2xpY2VzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZG91Z2hudXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmNXaWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbUxhYmVsc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heExhYmVsTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGJsY2xpY2tcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1hcmdpbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgUGllQ2hhcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtcGllLWNoYXJ0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zbGF0aW9uXFxcIiBjbGFzcz1cXFwicGllLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXBpZS1zZXJpZXNcXG4gICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgW3Nlcmllc109XFxcImRhdGFcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxzXT1cXFwibGFiZWxzXFxcIlxcbiAgICAgICAgICBbbGFiZWxGb3JtYXR0aW5nXT1cXFwibGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdHJpbUxhYmVsc109XFxcInRyaW1MYWJlbHNcXFwiXFxuICAgICAgICAgIFttYXhMYWJlbExlbmd0aF09XFxcIm1heExhYmVsTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgIFtpbm5lclJhZGl1c109XFxcImlubmVyUmFkaXVzXFxcIlxcbiAgICAgICAgICBbb3V0ZXJSYWRpdXNdPVxcXCJvdXRlclJhZGl1c1xcXCJcXG4gICAgICAgICAgW2V4cGxvZGVTbGljZXNdPVxcXCJleHBsb2RlU2xpY2VzXFxcIlxcbiAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICBbdG9vbHRpcFRleHRdPVxcXCJ0b29sdGlwVGV4dFxcXCJcXG4gICAgICAgICAgKGRibGNsaWNrKT1cXFwiZGJsY2xpY2suZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCIsIFwiLnBpZS1sYWJlbHtmb250LXNpemU6MTFweH0ucGllLWxhYmVsLmFuaW1hdGlvbnthbmltYXRpb246NzUwbXMgZWFzZS1pbiBmYWRlSW59QGtleWZyYW1lcyBmYWRlSW57ZnJvbXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX0ucGllLWxhYmVsLWxpbmV7c3Ryb2tlLWRhc2hhcnJheToxMDAlfS5waWUtbGFiZWwtbGluZS5hbmltYXRpb257YW5pbWF0aW9uOjNzIGxpbmVhciBkcmF3T3V0O3RyYW5zaXRpb246ZCA3NTBtc31Aa2V5ZnJhbWVzIGRyYXdPdXR7ZnJvbXtzdHJva2UtZGFzaG9mZnNldDoxMDAlfXRve3N0cm9rZS1kYXNob2Zmc2V0OjB9fVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFBpZUNoYXJ0Q29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxuZnVuY3Rpb24gZ3JpZFNpemUoZGltcywgbGVuLCBtaW5XaWR0aCkge1xyXG4gICAgdmFyIHJvd3MgPSAxO1xyXG4gICAgdmFyIGNvbHMgPSBsZW47XHJcbiAgICB2YXIgd2lkdGggPSBkaW1zLndpZHRoO1xyXG4gICAgaWYgKHdpZHRoID4gbWluV2lkdGgpIHtcclxuICAgICAgICB3aGlsZSAod2lkdGggLyBjb2xzIDwgbWluV2lkdGgpIHtcclxuICAgICAgICAgICAgcm93cyArPSAxO1xyXG4gICAgICAgICAgICBjb2xzID0gTWF0aC5jZWlsKGxlbiAvIHJvd3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbY29scywgcm93c107XHJcbn1cclxuZnVuY3Rpb24gZ3JpZExheW91dChkaW1zLCBkYXRhLCBtaW5XaWR0aCwgZGVzaWduYXRlZFRvdGFsKSB7XHJcbiAgICB2YXIgeFNjYWxlID0gc2NhbGVCYW5kKCk7XHJcbiAgICB2YXIgeVNjYWxlID0gc2NhbGVCYW5kKCk7XHJcbiAgICB2YXIgd2lkdGggPSBkaW1zLndpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IGRpbXMuaGVpZ2h0O1xyXG4gICAgdmFyIF9hID0gZ3JpZFNpemUoZGltcywgZGF0YS5sZW5ndGgsIG1pbldpZHRoKSwgY29sdW1ucyA9IF9hWzBdLCByb3dzID0gX2FbMV07XHJcbiAgICB2YXIgeERvbWFpbiA9IFtdO1xyXG4gICAgdmFyIHlEb21haW4gPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XHJcbiAgICAgICAgeURvbWFpbi5wdXNoKGkpO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zOyBpKyspIHtcclxuICAgICAgICB4RG9tYWluLnB1c2goaSk7XHJcbiAgICB9XHJcbiAgICB4U2NhbGUuZG9tYWluKHhEb21haW4pO1xyXG4gICAgeVNjYWxlLmRvbWFpbih5RG9tYWluKTtcclxuICAgIHhTY2FsZS5yYW5nZVJvdW5kKFswLCB3aWR0aF0sIDAuMSk7XHJcbiAgICB5U2NhbGUucmFuZ2VSb3VuZChbMCwgaGVpZ2h0XSwgMC4xKTtcclxuICAgIHZhciByZXMgPSBbXTtcclxuICAgIHZhciB0b3RhbCA9IGRlc2lnbmF0ZWRUb3RhbCA/IGRlc2lnbmF0ZWRUb3RhbCA6IGdldFRvdGFsKGRhdGEpO1xyXG4gICAgdmFyIGNhcmRXaWR0aCA9IHhTY2FsZS5iYW5kd2lkdGgoKTtcclxuICAgIHZhciBjYXJkSGVpZ2h0ID0geVNjYWxlLmJhbmR3aWR0aCgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmVzW2ldID0ge307XHJcbiAgICAgICAgcmVzW2ldLmRhdGEgPSB7XHJcbiAgICAgICAgICAgIG5hbWU6IGRhdGFbaV0gPyBkYXRhW2ldLm5hbWUgOiAnJyxcclxuICAgICAgICAgICAgdmFsdWU6IGRhdGFbaV0gPyBkYXRhW2ldLnZhbHVlIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBleHRyYTogZGF0YVtpXSA/IGRhdGFbaV0uZXh0cmEgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGxhYmVsOiBkYXRhW2ldID8gZGF0YVtpXS5sYWJlbCA6ICcnXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXNbaV0ueCA9IHhTY2FsZShpICUgY29sdW1ucyk7XHJcbiAgICAgICAgcmVzW2ldLnkgPSB5U2NhbGUoTWF0aC5mbG9vcihpIC8gY29sdW1ucykpO1xyXG4gICAgICAgIHJlc1tpXS53aWR0aCA9IGNhcmRXaWR0aDtcclxuICAgICAgICByZXNbaV0uaGVpZ2h0ID0gY2FyZEhlaWdodDtcclxuICAgICAgICByZXNbaV0uZGF0YS5wZXJjZW50ID0gdG90YWwgPiAwID8gcmVzW2ldLmRhdGEudmFsdWUgLyB0b3RhbCA6IDA7XHJcbiAgICAgICAgcmVzW2ldLmRhdGEudG90YWwgPSB0b3RhbDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VG90YWwocmVzdWx0cykge1xyXG4gICAgcmV0dXJuIHJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiAoZCA/IGQudmFsdWUgOiAwKTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHZhbCkgeyByZXR1cm4gc3VtICsgdmFsOyB9LCAwKTtcclxufVxyXG5cclxudmFyIFBpZUdyaWRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUGllR3JpZENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBpZUdyaWRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGFiZWwgPSAnVG90YWwnO1xyXG4gICAgICAgIF90aGlzLm1pbldpZHRoID0gMTUwO1xyXG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsyMCwgMjAsIDIwLCAyMF07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW5cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSB0aGlzLmdldERvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGdyaWRMYXlvdXQodGhpcy5kaW1zLCB0aGlzLnJlc3VsdHMsIHRoaXMubWluV2lkdGgsIHRoaXMuZGVzaWduYXRlZFRvdGFsKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5tYXJnaW5bM10gKyBcIiAsIFwiICsgdGhpcy5tYXJnaW5bMF0gKyBcIilcIjtcclxuICAgICAgICB0aGlzLnNlcmllcyA9IHRoaXMuZ2V0U2VyaWVzKCk7XHJcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcclxuICAgICAgICB0aGlzLnRvb2x0aXBUZXh0ID0gdGhpcy50b29sdGlwVGV4dCB8fCB0aGlzLmRlZmF1bHRUb29sdGlwVGV4dDtcclxuICAgIH07XHJcbiAgICBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZS5kZWZhdWx0VG9vbHRpcFRleHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGE7XHJcbiAgICAgICAgdmFyIGxhYmVsID0gdHJpbUxhYmVsKGZvcm1hdExhYmVsKGRhdGEubmFtZSkpO1xyXG4gICAgICAgIHZhciB2YWwgPSBkYXRhLnZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtbGFiZWxcXFwiPlwiICsgbGFiZWwgKyBcIjwvc3Bhbj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC12YWxcXFwiPlwiICsgdmFsICsgXCI8L3NwYW4+XFxuICAgIFwiO1xyXG4gICAgfTtcclxuICAgIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLmdldERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5sYWJlbDsgfSk7XHJcbiAgICB9O1xyXG4gICAgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2VyaWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5kZXNpZ25hdGVkVG90YWwgPyB0aGlzLmRlc2lnbmF0ZWRUb3RhbCA6IHRoaXMuZ2V0VG90YWwoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgYmFzZWxpbmVMYWJlbEhlaWdodCA9IDIwO1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IDEwO1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGQuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBmb3JtYXRMYWJlbChuYW1lKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZC5kYXRhLnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gbWluKFtkLndpZHRoIC0gcGFkZGluZywgZC5oZWlnaHQgLSBiYXNlbGluZUxhYmVsSGVpZ2h0XSkgLyAyIC0gNTtcclxuICAgICAgICAgICAgdmFyIGlubmVyUmFkaXVzID0gcmFkaXVzICogMC45O1xyXG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgY29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncmdiYSgxMDAsMTAwLDEwMCwwLjMpJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb2xvclNjYWxlLmdldENvbG9yKGxhYmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHhQb3MgPSBkLnggKyAoZC53aWR0aCAtIHBhZGRpbmcpIC8gMjtcclxuICAgICAgICAgICAgdmFyIHlQb3MgPSBkLnkgKyAoZC5oZWlnaHQgLSBiYXNlbGluZUxhYmVsSGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgeFBvcyArIFwiLCBcIiArIHlQb3MgKyBcIilcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yczogY29sb3JzLFxyXG4gICAgICAgICAgICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgb3V0ZXJSYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogdHJpbUxhYmVsKGxhYmVsKSxcclxuICAgICAgICAgICAgICAgIHRvdGFsOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIHBlcmNlbnQ6IGZvcm1hdCgnLjElJykoZC5kYXRhLnBlcmNlbnQpLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogW1xyXG4gICAgICAgICAgICAgICAgICAgIGQsXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b3RhbCAtIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZC5kYXRhLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUb3RhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIHN1bSArIGQ7IH0sIDApO1xyXG4gICAgfTtcclxuICAgIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sb3JTY2FsZSA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgJ29yZGluYWwnLCB0aGlzLmRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0cy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWUgJiYgZC5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICBpdGVtID0gdGhpcy5yZXN1bHRzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZSAmJiBkLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImRlc2lnbmF0ZWRUb3RhbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbiAgICBdLCBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1pbldpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBQaWVHcmlkQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLXBpZS1ncmlkJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0IFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIiBbc2hvd0xlZ2VuZF09XFxcImZhbHNlXFxcIiBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJwaWUtZ3JpZCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHNlcmllc1xcXCIgY2xhc3M9XFxcInBpZS1ncmlkLWl0ZW1cXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInNlcmllcy50cmFuc2Zvcm1cXFwiPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLXBpZS1ncmlkLXNlcmllc1xcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJzZXJpZXMuY29sb3JzXFxcIlxcbiAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzLmRhdGFcXFwiXFxuICAgICAgICAgICAgW2lubmVyUmFkaXVzXT1cXFwic2VyaWVzLmlubmVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgIFtvdXRlclJhZGl1c109XFxcInNlcmllcy5vdXRlclJhZGl1c1xcXCJcXG4gICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVxcXCIndG9wJ1xcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFR5cGVdPVxcXCIndG9vbHRpcCdcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IHRvb2x0aXBUZXh0KHsgZGF0YTogc2VyaWVzIH0pXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBDb250ZXh0XT1cXFwic2VyaWVzLmRhdGFbMF0uZGF0YVxcXCJcXG4gICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICAgICAgKm5nSWY9XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcImxhYmVsIHBlcmNlbnQtbGFiZWxcXFwiXFxuICAgICAgICAgICAgZHk9XFxcIi0wLjVlbVxcXCJcXG4gICAgICAgICAgICB4PVxcXCIwXFxcIlxcbiAgICAgICAgICAgIHk9XFxcIjVcXFwiXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1jb3VudC11cFxcbiAgICAgICAgICAgIFtjb3VudFRvXT1cXFwic2VyaWVzLnBlcmNlbnRcXFwiXFxuICAgICAgICAgICAgW2NvdW50U3VmZml4XT1cXFwiJyUnXFxcIlxcbiAgICAgICAgICAgIHRleHQtYW5jaG9yPVxcXCJtaWRkbGVcXFwiXFxuICAgICAgICAgID48L3N2Zzp0ZXh0PlxcbiAgICAgICAgICA8c3ZnOnRleHQgKm5nSWY9XFxcIiFhbmltYXRpb25zXFxcIiBjbGFzcz1cXFwibGFiZWwgcGVyY2VudC1sYWJlbFxcXCIgZHk9XFxcIi0wLjVlbVxcXCIgeD1cXFwiMFxcXCIgeT1cXFwiNVxcXCIgdGV4dC1hbmNob3I9XFxcIm1pZGRsZVxcXCI+XFxuICAgICAgICAgICAge3sgc2VyaWVzLnBlcmNlbnQudG9Mb2NhbGVTdHJpbmcoKSB9fVxcbiAgICAgICAgICA8L3N2Zzp0ZXh0PlxcbiAgICAgICAgICA8c3ZnOnRleHQgY2xhc3M9XFxcImxhYmVsXFxcIiBkeT1cXFwiMC41ZW1cXFwiIHg9XFxcIjBcXFwiIHk9XFxcIjVcXFwiIHRleHQtYW5jaG9yPVxcXCJtaWRkbGVcXFwiPlxcbiAgICAgICAgICAgIHt7IHNlcmllcy5sYWJlbCB9fVxcbiAgICAgICAgICA8L3N2Zzp0ZXh0PlxcbiAgICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgICAqbmdJZj1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwibGFiZWxcXFwiXFxuICAgICAgICAgICAgZHk9XFxcIjEuMjNlbVxcXCJcXG4gICAgICAgICAgICB4PVxcXCIwXFxcIlxcbiAgICAgICAgICAgIFthdHRyLnldPVxcXCJzZXJpZXMub3V0ZXJSYWRpdXNcXFwiXFxuICAgICAgICAgICAgdGV4dC1hbmNob3I9XFxcIm1pZGRsZVxcXCJcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLWNvdW50LXVwXFxuICAgICAgICAgICAgW2NvdW50VG9dPVxcXCJzZXJpZXMudG90YWxcXFwiXFxuICAgICAgICAgICAgW2NvdW50UHJlZml4XT1cXFwibGFiZWwgKyAnOiAnXFxcIlxcbiAgICAgICAgICA+PC9zdmc6dGV4dD5cXG4gICAgICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICAgICAgKm5nSWY9XFxcIiFhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJsYWJlbFxcXCJcXG4gICAgICAgICAgICBkeT1cXFwiMS4yM2VtXFxcIlxcbiAgICAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgICAgW2F0dHIueV09XFxcInNlcmllcy5vdXRlclJhZGl1c1xcXCJcXG4gICAgICAgICAgICB0ZXh0LWFuY2hvcj1cXFwibWlkZGxlXFxcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAge3sgbGFiZWwgfX06IHt7IHNlcmllcy50b3RhbC50b0xvY2FsZVN0cmluZygpIH19XFxuICAgICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCIsIFwiLnBpZS1ncmlkIC5hcmMxe29wYWNpdHk6LjR9LnBpZS1ncmlkIC5wZXJjZW50LWxhYmVse2ZvbnQtc2l6ZToxNnB4O2ZvbnQtd2VpZ2h0OjQwMH1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFBpZUdyaWRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFBpZUdyaWRDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgUGllR3JpZFNlcmllc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBpZUdyaWRTZXJpZXNDb21wb25lbnQoZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXMgPSA3MDtcclxuICAgICAgICB0aGlzLm91dGVyUmFkaXVzID0gODA7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5sYXlvdXQgPSBwaWUoKVxyXG4gICAgICAgICAgICAudmFsdWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZGF0YS52YWx1ZTsgfSlcclxuICAgICAgICAgICAgLnNvcnQobnVsbCk7XHJcbiAgICAgICAgdGhpcy5hcmNzID0gdGhpcy5nZXRBcmNzKCk7XHJcbiAgICB9O1xyXG4gICAgUGllR3JpZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0QXJjcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dCh0aGlzLmRhdGEpLm1hcChmdW5jdGlvbiAoYXJjJCQxLCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBhcmMkJDEuZGF0YS5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGFyYyQkMS5kYXRhLmRhdGEub3RoZXI7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgYXJjJCQxLnN0YXJ0QW5nbGUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IF90aGlzLmNvbG9ycyhsYWJlbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBhcmMkJDEuZGF0YS5kYXRhLFxyXG4gICAgICAgICAgICAgICAgY2xhc3M6ICdhcmMgJyArICdhcmMnICsgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcixcclxuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGU6IG90aGVyID8gMCA6IGFyYyQkMS5zdGFydEFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IGFyYyQkMS5lbmRBbmdsZSxcclxuICAgICAgICAgICAgICAgIGFuaW1hdGU6IF90aGlzLmFuaW1hdGlvbnMgJiYgIW90aGVyLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogIW90aGVyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUGllR3JpZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdCh0aGlzLmRhdGFbMF0uZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgUGllR3JpZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLmRhdGEubmFtZTtcclxuICAgIH07XHJcbiAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uIChhcmMkJDEpIHtcclxuICAgICAgICByZXR1cm4gYXJjJCQxLmRhdGEubmFtZTtcclxuICAgIH07XHJcbiAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5jb2xvciA9IGZ1bmN0aW9uIChhcmMkJDEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcnModGhpcy5sYWJlbChhcmMkJDEpKTtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImlubmVyUmFkaXVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIFBpZUdyaWRTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1waWUtZ3JpZC1zZXJpZXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBjbGFzcz1cXFwicGllLWdyaWQtYXJjc1xcXCI+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLXBpZS1hcmNcXG4gICAgICAgICpuZ0Zvcj1cXFwibGV0IGFyYyBvZiBhcmNzOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgICAgW2F0dHIuY2xhc3NdPVxcXCJhcmMuY2xhc3NcXFwiXFxuICAgICAgICBbc3RhcnRBbmdsZV09XFxcImFyYy5zdGFydEFuZ2xlXFxcIlxcbiAgICAgICAgW2VuZEFuZ2xlXT1cXFwiYXJjLmVuZEFuZ2xlXFxcIlxcbiAgICAgICAgW2lubmVyUmFkaXVzXT1cXFwiaW5uZXJSYWRpdXNcXFwiXFxuICAgICAgICBbb3V0ZXJSYWRpdXNdPVxcXCJvdXRlclJhZGl1c1xcXCJcXG4gICAgICAgIFtmaWxsXT1cXFwiY29sb3IoYXJjKVxcXCJcXG4gICAgICAgIFt2YWx1ZV09XFxcImFyYy5kYXRhLnZhbHVlXFxcIlxcbiAgICAgICAgW2RhdGFdPVxcXCJhcmMuZGF0YVxcXCJcXG4gICAgICAgIFtncmFkaWVudF09XFxcImZhbHNlXFxcIlxcbiAgICAgICAgW3BvaW50ZXJFdmVudHNdPVxcXCJhcmMucG9pbnRlckV2ZW50c1xcXCJcXG4gICAgICAgIFthbmltYXRlXT1cXFwiYXJjLmFuaW1hdGVcXFwiXFxuICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgKGFjdGl2YXRlKT1cXFwiYWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJkZWFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICA+PC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXHJcbiAgICBdLCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBQaWVHcmlkU2VyaWVzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIFBpZVNlcmllc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBpZVNlcmllc0NvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLnNlcmllcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXMgPSA2MDtcclxuICAgICAgICB0aGlzLm91dGVyUmFkaXVzID0gODA7XHJcbiAgICAgICAgdGhpcy50cmltTGFiZWxzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm1heExhYmVsTGVuZ3RoID0gMTA7XHJcbiAgICAgICAgdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGJsY2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwaWVHZW5lcmF0b3IgPSBwaWUoKVxyXG4gICAgICAgICAgICAudmFsdWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pXHJcbiAgICAgICAgICAgIC5zb3J0KG51bGwpO1xyXG4gICAgICAgIHZhciBhcmNEYXRhID0gcGllR2VuZXJhdG9yKHRoaXMuc2VyaWVzKTtcclxuICAgICAgICB0aGlzLm1heCA9IG1heChhcmNEYXRhLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsUG9zaXRpb25zKGFyY0RhdGEpO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFRleHQgPSB0aGlzLnRvb2x0aXBUZXh0IHx8IHRoaXMuZGVmYXVsdFRvb2x0aXBUZXh0O1xyXG4gICAgfTtcclxuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubWlkQW5nbGUgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyO1xyXG4gICAgfTtcclxuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUub3V0ZXJBcmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvciA9IDEuNTtcclxuICAgICAgICByZXR1cm4gYXJjKClcclxuICAgICAgICAgICAgLmlubmVyUmFkaXVzKHRoaXMub3V0ZXJSYWRpdXMgKiBmYWN0b3IpXHJcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyh0aGlzLm91dGVyUmFkaXVzICogZmFjdG9yKTtcclxuICAgIH07XHJcbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmNhbGN1bGF0ZUxhYmVsUG9zaXRpb25zID0gZnVuY3Rpb24gKHBpZURhdGEpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBmYWN0b3IgPSAxLjU7XHJcbiAgICAgICAgdmFyIG1pbkRpc3RhbmNlID0gMTA7XHJcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb25zID0gcGllRGF0YTtcclxuICAgICAgICBsYWJlbFBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGQucG9zID0gX3RoaXMub3V0ZXJBcmMoKS5jZW50cm9pZChkKTtcclxuICAgICAgICAgICAgZC5wb3NbMF0gPSBmYWN0b3IgKiBfdGhpcy5vdXRlclJhZGl1cyAqIChfdGhpcy5taWRBbmdsZShkKSA8IE1hdGguUEkgPyAxIDogLTEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxQb3NpdGlvbnMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gbGFiZWxQb3NpdGlvbnNbaV07XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5sYWJlbFZpc2libGUoYSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGxhYmVsUG9zaXRpb25zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGxhYmVsUG9zaXRpb25zW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxhYmVsVmlzaWJsZShiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhleSdyZSBvbiB0aGUgc2FtZSBzaWRlXHJcbiAgICAgICAgICAgICAgICBpZiAoYi5wb3NbMF0gKiBhLnBvc1swXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGV5J3JlIG92ZXJsYXBwaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSBtaW5EaXN0YW5jZSAtIE1hdGguYWJzKGIucG9zWzFdIC0gYS5wb3NbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHRoZSBzZWNvbmQgdXAgb3IgZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnBvc1sxXSArPSBNYXRoLnNpZ24oYi5wb3NbMF0pICogbztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsUG9zaXRpb25zO1xyXG4gICAgfTtcclxuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubGFiZWxWaXNpYmxlID0gZnVuY3Rpb24gKG15QXJjKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvd0xhYmVscyAmJiBteUFyYy5lbmRBbmdsZSAtIG15QXJjLnN0YXJ0QW5nbGUgPiBNYXRoLlBJIC8gMzA7XHJcbiAgICB9O1xyXG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUb29sdGlwVGl0bGUgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IHRoaXMudG9vbHRpcFRleHQoYSk7XHJcbiAgICB9O1xyXG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5sYWJlbFRleHQgPSBmdW5jdGlvbiAobXlBcmMpIHtcclxuICAgICAgICBpZiAodGhpcy5sYWJlbEZvcm1hdHRpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxGb3JtYXR0aW5nKG15QXJjLmRhdGEubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsKG15QXJjKTtcclxuICAgIH07XHJcbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gKG15QXJjKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdExhYmVsKG15QXJjLmRhdGEubmFtZSk7XHJcbiAgICB9O1xyXG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5kZWZhdWx0VG9vbHRpcFRleHQgPSBmdW5jdGlvbiAobXlBcmMpIHtcclxuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmxhYmVsKG15QXJjKTtcclxuICAgICAgICB2YXIgdmFsID0gZm9ybWF0TGFiZWwobXlBcmMuZGF0YS52YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtbGFiZWxcXFwiPlwiICsgbGFiZWwgKyBcIjwvc3Bhbj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC12YWxcXFwiPlwiICsgdmFsICsgXCI8L3NwYW4+XFxuICAgIFwiO1xyXG4gICAgfTtcclxuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuY29sb3IgPSBmdW5jdGlvbiAobXlBcmMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcnMuZ2V0Q29sb3IodGhpcy5sYWJlbChteUFyYykpO1xyXG4gICAgfTtcclxuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLmRhdGEubmFtZTtcclxuICAgIH07XHJcbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lICYmIGVudHJ5LnNlcmllcyA9PT0gZC5zZXJpZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBsb2RlU2xpY2VzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dMYWJlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1MYWJlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4TGFiZWxMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGJsY2xpY2tcIiwgdm9pZCAwKTtcclxuICAgIFBpZVNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXBpZS1zZXJpZXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBhcmMgb2YgZGF0YTsgdHJhY2tCeTogdHJhY2tCeVxcXCI+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLXBpZS1sYWJlbFxcbiAgICAgICAgKm5nSWY9XFxcImxhYmVsVmlzaWJsZShhcmMpXFxcIlxcbiAgICAgICAgW2RhdGFdPVxcXCJhcmNcXFwiXFxuICAgICAgICBbcmFkaXVzXT1cXFwib3V0ZXJSYWRpdXNcXFwiXFxuICAgICAgICBbY29sb3JdPVxcXCJjb2xvcihhcmMpXFxcIlxcbiAgICAgICAgW2xhYmVsXT1cXFwibGFiZWxUZXh0KGFyYylcXFwiXFxuICAgICAgICBbbGFiZWxUcmltXT1cXFwidHJpbUxhYmVsc1xcXCJcXG4gICAgICAgIFtsYWJlbFRyaW1TaXplXT1cXFwibWF4TGFiZWxMZW5ndGhcXFwiXFxuICAgICAgICBbbWF4XT1cXFwibWF4XFxcIlxcbiAgICAgICAgW3ZhbHVlXT1cXFwiYXJjLnZhbHVlXFxcIlxcbiAgICAgICAgW2V4cGxvZGVTbGljZXNdPVxcXCJleHBsb2RlU2xpY2VzXFxcIlxcbiAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgID48L3N2ZzpnPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1waWUtYXJjXFxuICAgICAgICBbc3RhcnRBbmdsZV09XFxcImFyYy5zdGFydEFuZ2xlXFxcIlxcbiAgICAgICAgW2VuZEFuZ2xlXT1cXFwiYXJjLmVuZEFuZ2xlXFxcIlxcbiAgICAgICAgW2lubmVyUmFkaXVzXT1cXFwiaW5uZXJSYWRpdXNcXFwiXFxuICAgICAgICBbb3V0ZXJSYWRpdXNdPVxcXCJvdXRlclJhZGl1c1xcXCJcXG4gICAgICAgIFtmaWxsXT1cXFwiY29sb3IoYXJjKVxcXCJcXG4gICAgICAgIFt2YWx1ZV09XFxcImFyYy5kYXRhLnZhbHVlXFxcIlxcbiAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICBbZGF0YV09XFxcImFyYy5kYXRhXFxcIlxcbiAgICAgICAgW21heF09XFxcIm1heFxcXCJcXG4gICAgICAgIFtleHBsb2RlU2xpY2VzXT1cXFwiZXhwbG9kZVNsaWNlc1xcXCJcXG4gICAgICAgIFtpc0FjdGl2ZV09XFxcImlzQWN0aXZlKGFyYy5kYXRhKVxcXCJcXG4gICAgICAgIFthbmltYXRlXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgKGRibGNsaWNrKT1cXFwiZGJsY2xpY2suZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgbmd4LXRvb2x0aXBcXG4gICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwiJ3Rvb2x0aXAnXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcImdldFRvb2x0aXBUaXRsZShhcmMpXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImFyYy5kYXRhXFxcIlxcbiAgICAgID48L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gUGllU2VyaWVzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIFBpZUNoYXJ0TW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGllQ2hhcnRNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBQaWVDaGFydE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NoYXJ0Q29tbW9uTW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgUGllTGFiZWxDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBQaWVBcmNDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBQaWVDaGFydENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFBpZUdyaWRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgUGllU2VyaWVzQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBQaWVMYWJlbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFBpZUFyY0NvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFBpZUNoYXJ0Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgUGllR3JpZENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFBpZUdyaWRTZXJpZXNDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBQaWVTZXJpZXNDb21wb25lbnRcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBQaWVDaGFydE1vZHVsZSk7XHJcbiAgICByZXR1cm4gUGllQ2hhcnRNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG52YXIgUG9sYXJDaGFydE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvbGFyQ2hhcnRNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBQb2xhckNoYXJ0TW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGUsIFBpZUNoYXJ0TW9kdWxlLCBMaW5lQ2hhcnRNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIFBvbGFyQ2hhcnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBQb2xhclNlcmllc0NvbXBvbmVudFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgICAgICAgICBQb2xhckNoYXJ0Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgUG9sYXJTZXJpZXNDb21wb25lbnRcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBQb2xhckNoYXJ0TW9kdWxlKTtcclxuICAgIHJldHVybiBQb2xhckNoYXJ0TW9kdWxlO1xyXG59KCkpO1xyXG5cclxudmFyIENhcmRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDYXJkQ29tcG9uZW50KGVsZW1lbnQsIGNkLCB6b25lKSB7XHJcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xyXG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gJyc7XHJcbiAgICAgICAgdGhpcy50ZXh0Rm9udFNpemUgPSAxMjtcclxuICAgICAgICB0aGlzLnRleHRUcmFuc2Zvcm0gPSAnJztcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5iYW5kSGVpZ2h0ID0gMTA7XHJcbiAgICAgICAgdGhpcy50ZXh0UGFkZGluZyA9IFsxMCwgMjAsIDUsIDIwXTtcclxuICAgICAgICB0aGlzLmxhYmVsRm9udFNpemUgPSAxNTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBDYXJkQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvblJlcSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNWYWx1ZSA9IF90aGlzLmRhdGEgJiYgdHlwZW9mIF90aGlzLmRhdGEudmFsdWUgIT09ICd1bmRlZmluZWQnO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVGb3JtYXR0aW5nID0gX3RoaXMudmFsdWVGb3JtYXR0aW5nIHx8IChmdW5jdGlvbiAoY2FyZCkgeyByZXR1cm4gY2FyZC52YWx1ZS50b0xvY2FsZVN0cmluZygpOyB9KTtcclxuICAgICAgICAgICAgdmFyIGxhYmVsRm9ybWF0dGluZyA9IF90aGlzLmxhYmVsRm9ybWF0dGluZyB8fCAoZnVuY3Rpb24gKGNhcmQpIHsgcmV0dXJuIHRyaW1MYWJlbChjYXJkLmxhYmVsLCA1NSk7IH0pO1xyXG4gICAgICAgICAgICBfdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIF90aGlzLnggKyBcIiAsIFwiICsgX3RoaXMueSArIFwiKVwiO1xyXG4gICAgICAgICAgICBfdGhpcy50ZXh0V2lkdGggPSBNYXRoLm1heCgwLCBfdGhpcy53aWR0aCkgLSBfdGhpcy50ZXh0UGFkZGluZ1sxXSAtIF90aGlzLnRleHRQYWRkaW5nWzNdO1xyXG4gICAgICAgICAgICBfdGhpcy5jYXJkV2lkdGggPSBNYXRoLm1heCgwLCBfdGhpcy53aWR0aCk7XHJcbiAgICAgICAgICAgIF90aGlzLmNhcmRIZWlnaHQgPSBNYXRoLm1heCgwLCBfdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICBfdGhpcy5sYWJlbCA9IF90aGlzLmxhYmVsID8gX3RoaXMubGFiZWwgOiBfdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHZhciBjYXJkRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBfdGhpcy5sYWJlbCxcclxuICAgICAgICAgICAgICAgIGRhdGE6IF90aGlzLmRhdGEsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3RoaXMuZGF0YS52YWx1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfdGhpcy5mb3JtYXR0ZWRMYWJlbCA9IGxhYmVsRm9ybWF0dGluZyhjYXJkRGF0YSk7XHJcbiAgICAgICAgICAgIF90aGlzLnRyYW5zZm9ybUJhbmQgPSBcInRyYW5zbGF0ZSgwICwgXCIgKyAoX3RoaXMuY2FyZEhlaWdodCAtIF90aGlzLmJhbmRIZWlnaHQpICsgXCIpXCI7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhhc1ZhbHVlID8gdmFsdWVGb3JtYXR0aW5nKGNhcmREYXRhKSA6ICcnO1xyXG4gICAgICAgICAgICBfdGhpcy52YWx1ZSA9IF90aGlzLnBhZGRlZFZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgX3RoaXMuc2V0UGFkZGluZygpO1xyXG4gICAgICAgICAgICBfdGhpcy5iYW5kUGF0aCA9IHJvdW5kZWRSZWN0KDAsIDAsIF90aGlzLmNhcmRXaWR0aCwgX3RoaXMuYmFuZEhlaWdodCwgMywgW2ZhbHNlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZV0pO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNjYWxlVGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNWYWx1ZSAmJiAhX3RoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnN0YXJ0Q291bnQoKTsgfSwgMjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCA4KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29tcG9uZW50LnByb3RvdHlwZS5wYWRkZWRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm1lZGlhblNpemUgJiYgdGhpcy5tZWRpYW5TaXplID4gdmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhbHVlICs9ICdcXHUyMDA3Jy5yZXBlYXQodGhpcy5tZWRpYW5TaXplIC0gdmFsdWUubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuICAgIENhcmRDb21wb25lbnQucHJvdG90eXBlLnN0YXJ0Q291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQgJiYgdGhpcy5hbmltYXRpb25zKSB7XHJcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uUmVxKTtcclxuICAgICAgICAgICAgdmFyIHZhbF8xID0gdGhpcy5kYXRhLnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgZGVjcyA9IGRlY2ltYWxDaGVja2VyKHZhbF8xKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlRm9ybWF0dGluZ18xID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcgfHwgKGZ1bmN0aW9uIChjYXJkKSB7IHJldHVybiBjYXJkLnZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7IH0pO1xyXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlLCBmaW5pc2hlZCA9IF9hLmZpbmlzaGVkO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuem9uZS5ydW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmluaXNoZWQgPyB2YWxfMSA6IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWVGb3JtYXR0aW5nXzEoeyBsYWJlbDogX3RoaXMubGFiZWwsIGRhdGE6IF90aGlzLmRhdGEsIHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gX3RoaXMucGFkZGVkVmFsdWUoX3RoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblJlcSA9IGNvdW50KDAsIHZhbF8xLCBkZWNzLCAxLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYXJkQ29tcG9uZW50LnByb3RvdHlwZS5zY2FsZVRleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMudGV4dEVsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZXh0UGFkZGluZyA9IChfdGhpcy50ZXh0UGFkZGluZ1sxXSA9IF90aGlzLnRleHRQYWRkaW5nWzNdID0gX3RoaXMuY2FyZFdpZHRoIC8gOCk7XHJcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IF90aGlzLmNhcmRXaWR0aCAtIDIgKiB0ZXh0UGFkZGluZztcclxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUhlaWdodCA9IF90aGlzLmNhcmRIZWlnaHQgLyAzO1xyXG4gICAgICAgICAgICB2YXIgcmVzaXplU2NhbGUgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCAvIHdpZHRoLCBhdmFpbGFibGVIZWlnaHQgLyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBfdGhpcy50ZXh0Rm9udFNpemUgPSBNYXRoLmZsb29yKF90aGlzLnRleHRGb250U2l6ZSAqIHJlc2l6ZVNjYWxlKTtcclxuICAgICAgICAgICAgX3RoaXMubGFiZWxGb250U2l6ZSA9IE1hdGgubWluKF90aGlzLnRleHRGb250U2l6ZSwgMTUpO1xyXG4gICAgICAgICAgICBfdGhpcy5zZXRQYWRkaW5nKCk7XHJcbiAgICAgICAgICAgIF90aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhcmRDb21wb25lbnQucHJvdG90eXBlLnNldFBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0UGFkZGluZ1sxXSA9IHRoaXMudGV4dFBhZGRpbmdbM10gPSB0aGlzLmNhcmRXaWR0aCAvIDg7XHJcbiAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmNhcmRIZWlnaHQgLyAyO1xyXG4gICAgICAgIHRoaXMudGV4dFBhZGRpbmdbMF0gPSBwYWRkaW5nIC0gdGhpcy50ZXh0Rm9udFNpemUgLSB0aGlzLmxhYmVsRm9udFNpemUgLyAyO1xyXG4gICAgICAgIHRoaXMudGV4dFBhZGRpbmdbMl0gPSBwYWRkaW5nIC0gdGhpcy5sYWJlbEZvbnRTaXplO1xyXG4gICAgfTtcclxuICAgIENhcmRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdCh0aGlzLmRhdGEpO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYW5kQ29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRDb2xvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwieFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwieVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcIm1lZGlhblNpemVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVmlld0NoaWxkKCd0ZXh0RWwnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0RWxcIiwgdm9pZCAwKTtcclxuICAgIENhcmRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1jYXJkXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiY2VsbFxcXCIgKGNsaWNrKT1cXFwib25DbGljaygpXFxcIj5cXG4gICAgICA8c3ZnOnJlY3QgY2xhc3M9XFxcImNhcmRcXFwiIFtzdHlsZS5maWxsXT1cXFwiY29sb3JcXFwiIFthdHRyLndpZHRoXT1cXFwiY2FyZFdpZHRoXFxcIiBbYXR0ci5oZWlnaHRdPVxcXCJjYXJkSGVpZ2h0XFxcIiByeD1cXFwiM1xcXCIgcnk9XFxcIjNcXFwiIC8+XFxuICAgICAgPHN2ZzpwYXRoXFxuICAgICAgICAqbmdJZj1cXFwiYmFuZENvbG9yICYmIGJhbmRDb2xvciAhPT0gY29sb3JcXFwiXFxuICAgICAgICBjbGFzcz1cXFwiY2FyZC1iYW5kXFxcIlxcbiAgICAgICAgW2F0dHIuZmlsbF09XFxcImJhbmRDb2xvclxcXCJcXG4gICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybUJhbmRcXFwiXFxuICAgICAgICBzdHJva2U9XFxcIm5vbmVcXFwiXFxuICAgICAgICBbYXR0ci5kXT1cXFwiYmFuZFBhdGhcXFwiXFxuICAgICAgLz5cXG4gICAgICA8dGl0bGU+e3sgbGFiZWwgfX08L3RpdGxlPlxcbiAgICAgIDxzdmc6Zm9yZWlnbk9iamVjdFxcbiAgICAgICAgY2xhc3M9XFxcInRyaW1tZWQtbGFiZWxcXFwiXFxuICAgICAgICB4PVxcXCI1XFxcIlxcbiAgICAgICAgW2F0dHIueF09XFxcInRleHRQYWRkaW5nWzNdXFxcIlxcbiAgICAgICAgW2F0dHIueV09XFxcImNhcmRIZWlnaHQgLSB0ZXh0UGFkZGluZ1syXVxcXCJcXG4gICAgICAgIFthdHRyLndpZHRoXT1cXFwidGV4dFdpZHRoXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwibGFiZWxGb250U2l6ZSArIHRleHRQYWRkaW5nWzJdXFxcIlxcbiAgICAgICAgYWxpZ25tZW50LWJhc2VsaW5lPVxcXCJoYW5naW5nXFxcIlxcbiAgICAgID5cXG4gICAgICAgIDx4aHRtbDpwXFxuICAgICAgICAgIFtzdHlsZS5jb2xvcl09XFxcInRleHRDb2xvclxcXCJcXG4gICAgICAgICAgW3N0eWxlLmZvbnRTaXplLnB4XT1cXFwibGFiZWxGb250U2l6ZVxcXCJcXG4gICAgICAgICAgW3N0eWxlLmxpbmVIZWlnaHQucHhdPVxcXCJsYWJlbEZvbnRTaXplXFxcIlxcbiAgICAgICAgICBbaW5uZXJIVE1MXT1cXFwiZm9ybWF0dGVkTGFiZWxcXFwiXFxuICAgICAgICA+XFxuICAgICAgICA8L3hodG1sOnA+XFxuICAgICAgPC9zdmc6Zm9yZWlnbk9iamVjdD5cXG4gICAgICA8c3ZnOnRleHRcXG4gICAgICAgICN0ZXh0RWxcXG4gICAgICAgIGNsYXNzPVxcXCJ2YWx1ZS10ZXh0XFxcIlxcbiAgICAgICAgW2F0dHIueF09XFxcInRleHRQYWRkaW5nWzNdXFxcIlxcbiAgICAgICAgW2F0dHIueV09XFxcInRleHRQYWRkaW5nWzBdXFxcIlxcbiAgICAgICAgW3N0eWxlLmZpbGxdPVxcXCJ0ZXh0Q29sb3JcXFwiXFxuICAgICAgICB0ZXh0LWFuY2hvcj1cXFwic3RhcnRcXFwiXFxuICAgICAgICBhbGlnbm1lbnQtYmFzZWxpbmU9XFxcImhhbmdpbmdcXFwiXFxuICAgICAgICBbc3R5bGUuZm9udC1zaXplLnB0XT1cXFwidGV4dEZvbnRTaXplXFxcIlxcbiAgICAgID5cXG4gICAgICAgIHt7IHZhbHVlIH19XFxuICAgICAgPC9zdmc6dGV4dD5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYiA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdCwgdHlwZW9mIChfYyA9IHR5cGVvZiBDaGFuZ2VEZXRlY3RvclJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBDaGFuZ2VEZXRlY3RvclJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0LCB0eXBlb2YgKF9kID0gdHlwZW9mIE5nWm9uZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBOZ1pvbmUpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdF0pXHJcbiAgICBdLCBDYXJkQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBDYXJkQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIENhcmRTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDYXJkU2VyaWVzQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMuaW5uZXJQYWRkaW5nID0gMTU7XHJcbiAgICAgICAgdGhpcy5lbXB0eUNvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMCknO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZUZvcm1hdHRpbmdfMSA9IHRoaXMudmFsdWVGb3JtYXR0aW5nIHx8IChmdW5jdGlvbiAoY2FyZCkgeyByZXR1cm4gY2FyZC52YWx1ZS50b0xvY2FsZVN0cmluZygpOyB9KTtcclxuICAgICAgICAgICAgdmFyIHNvcnRlZExlbmd0aHMgPSB0aGlzLmRhdGFcclxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNWYWx1ZSA9IGQgJiYgZC5kYXRhICYmIHR5cGVvZiBkLmRhdGEudmFsdWUgIT09ICd1bmRlZmluZWQnICYmIGQuZGF0YS52YWx1ZSAhPT0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNWYWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVGb3JtYXR0aW5nXzEoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBkID8gZC5kYXRhLm5hbWUgOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGQgJiYgZC5kYXRhID8gZC5kYXRhLnZhbHVlIDogJydcclxuICAgICAgICAgICAgICAgICAgICB9KS5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYiAtIGE7IH0pO1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gTWF0aC5jZWlsKHRoaXMuZGF0YS5sZW5ndGggLyAyKTtcclxuICAgICAgICAgICAgdGhpcy5tZWRpYW5TaXplID0gc29ydGVkTGVuZ3Roc1tpZHhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FyZHMgPSB0aGlzLmdldENhcmRzKCk7XHJcbiAgICAgICAgdGhpcy5jYXJkcyA9IGNhcmRzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5kYXRhLnZhbHVlICE9PSBudWxsOyB9KTtcclxuICAgICAgICB0aGlzLmVtcHR5U2xvdHMgPSBjYXJkcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZGF0YS52YWx1ZSA9PT0gbnVsbDsgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q2FyZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgeVBhZGRpbmcgPSB0eXBlb2YgdGhpcy5pbm5lclBhZGRpbmcgPT09ICdudW1iZXInID8gdGhpcy5pbm5lclBhZGRpbmcgOiB0aGlzLmlubmVyUGFkZGluZ1swXSArIHRoaXMuaW5uZXJQYWRkaW5nWzJdO1xyXG4gICAgICAgIHZhciB4UGFkZGluZyA9IHR5cGVvZiB0aGlzLmlubmVyUGFkZGluZyA9PT0gJ251bWJlcicgPyB0aGlzLmlubmVyUGFkZGluZyA6IHRoaXMuaW5uZXJQYWRkaW5nWzFdICsgdGhpcy5pbm5lclBhZGRpbmdbM107XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKGQsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICBpZiAobGFiZWwgJiYgbGFiZWwuY29uc3RydWN0b3IubmFtZSA9PT0gJ0RhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbCA/IGxhYmVsLnRvTG9jYWxlU3RyaW5nKCkgOiBsYWJlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkLmRhdGEudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZUNvbG9yID0gbGFiZWwgPyBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IobGFiZWwpIDogX3RoaXMuZW1wdHlDb2xvcjtcclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gX3RoaXMuY2FyZENvbG9yIHx8IHZhbHVlQ29sb3IgfHwgJyMwMDAnO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogZC54LFxyXG4gICAgICAgICAgICAgICAgeTogZC55LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGQud2lkdGggLSB4UGFkZGluZyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogZC5oZWlnaHQgLSB5UGFkZGluZyxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgICAgIGJhbmRDb2xvcjogX3RoaXMuYmFuZENvbG9yIHx8IHZhbHVlQ29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IF90aGlzLnRleHRDb2xvciB8fCBpbnZlcnRDb2xvcihjb2xvciksXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkLmRhdGEsXHJcbiAgICAgICAgICAgICAgICB0b29sdGlwVGV4dDogbGFiZWwgKyBcIjogXCIgKyB2YWx1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGNhcmQpIHtcclxuICAgICAgICByZXR1cm4gY2FyZC5sYWJlbDtcclxuICAgIH07XHJcbiAgICBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzbG90c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbm5lclBhZGRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNhcmRDb2xvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFuZENvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlbXB0eUNvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0Q29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgQ2FyZFNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWNhcmQtc2VyaWVzXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOnJlY3RcXG4gICAgICAqbmdGb3I9XFxcImxldCBjIG9mIGVtcHR5U2xvdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgY2xhc3M9XFxcImNhcmQtZW1wdHlcXFwiXFxuICAgICAgW2F0dHIueF09XFxcImMueFxcXCJcXG4gICAgICBbYXR0ci55XT1cXFwiYy55XFxcIlxcbiAgICAgIFtzdHlsZS5maWxsXT1cXFwiZW1wdHlDb2xvclxcXCJcXG4gICAgICBbYXR0ci53aWR0aF09XFxcImMud2lkdGhcXFwiXFxuICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiYy5oZWlnaHRcXFwiXFxuICAgICAgcng9XFxcIjNcXFwiXFxuICAgICAgcnk9XFxcIjNcXFwiXFxuICAgIC8+XFxuICAgIDxzdmc6Z1xcbiAgICAgIG5neC1jaGFydHMtY2FyZFxcbiAgICAgICpuZ0Zvcj1cXFwibGV0IGMgb2YgY2FyZHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgW3hdPVxcXCJjLnhcXFwiXFxuICAgICAgW3ldPVxcXCJjLnlcXFwiXFxuICAgICAgW3dpZHRoXT1cXFwiYy53aWR0aFxcXCJcXG4gICAgICBbaGVpZ2h0XT1cXFwiYy5oZWlnaHRcXFwiXFxuICAgICAgW2NvbG9yXT1cXFwiYy5jb2xvclxcXCJcXG4gICAgICBbYmFuZENvbG9yXT1cXFwiYy5iYW5kQ29sb3JcXFwiXFxuICAgICAgW3RleHRDb2xvcl09XFxcImMudGV4dENvbG9yXFxcIlxcbiAgICAgIFtkYXRhXT1cXFwiYy5kYXRhXFxcIlxcbiAgICAgIFtsYWJlbF09XFxcImMubGFiZWxcXFwiXFxuICAgICAgW21lZGlhblNpemVdPVxcXCJtZWRpYW5TaXplXFxcIlxcbiAgICAgIFt2YWx1ZUZvcm1hdHRpbmddPVxcXCJ2YWx1ZUZvcm1hdHRpbmdcXFwiXFxuICAgICAgW2xhYmVsRm9ybWF0dGluZ109XFxcImxhYmVsRm9ybWF0dGluZ1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgLz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBDYXJkU2VyaWVzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIE51bWJlckNhcmRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTnVtYmVyQ2FyZENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE51bWJlckNhcmRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZW1wdHlDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDApJztcclxuICAgICAgICBfdGhpcy5pbm5lclBhZGRpbmcgPSAxNTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDEwLCAxMCwgMTBdO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbGlja2FibGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLnNlbGVjdC5vYnNlcnZlcnMubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW5cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSB0aGlzLmdldERvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XHJcbiAgICAgICAgdmFyIHNpemUgPSBncmlkU2l6ZSh0aGlzLmRpbXMsIHRoaXMucmVzdWx0cy5sZW5ndGgsIDE1MCk7XHJcbiAgICAgICAgdmFyIE4gPSBzaXplWzBdICogc2l6ZVsxXTtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucmVzdWx0cy5zbGljZSgpO1xyXG4gICAgICAgIHdoaWxlIChkYXRhLmxlbmd0aCA8IE4pIHtcclxuICAgICAgICAgICAgZGF0YS5wdXNoKHsgdmFsdWU6IG51bGwgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF0YSA9IGdyaWRMYXlvdXQodGhpcy5kaW1zLCBkYXRhLCAxNTAsIHRoaXMuZGVzaWduYXRlZFRvdGFsKTtcclxuICAgIH07XHJcbiAgICBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZS5nZXREb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubGFiZWw7IH0pO1xyXG4gICAgfTtcclxuICAgIE51bWJlckNhcmRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCAnb3JkaW5hbCcsIHRoaXMuZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2FyZENvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYW5kQ29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE51bWJlckNhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImVtcHR5Q29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE51bWJlckNhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImlubmVyUGFkZGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwidGV4dENvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE51bWJlckNhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVzaWduYXRlZFRvdGFsXCIsIHZvaWQgMCk7XHJcbiAgICBOdW1iZXJDYXJkQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLW51bWJlci1jYXJkJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0IFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIiBbc2hvd0xlZ2VuZF09XFxcImZhbHNlXFxcIiBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJudW1iZXItY2FyZCBjaGFydFxcXCIgW2NsYXNzLmNsaWNrYWJsZV09XFxcImNsaWNrYWJsZVxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1jYXJkLXNlcmllc1xcbiAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICBbY2FyZENvbG9yXT1cXFwiY2FyZENvbG9yXFxcIlxcbiAgICAgICAgICBbYmFuZENvbG9yXT1cXFwiYmFuZENvbG9yXFxcIlxcbiAgICAgICAgICBbdGV4dENvbG9yXT1cXFwidGV4dENvbG9yXFxcIlxcbiAgICAgICAgICBbZW1wdHlDb2xvcl09XFxcImVtcHR5Q29sb3JcXFwiXFxuICAgICAgICAgIFtkYXRhXT1cXFwiZGF0YVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbaW5uZXJQYWRkaW5nXT1cXFwiaW5uZXJQYWRkaW5nXFxcIlxcbiAgICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbbGFiZWxGb3JtYXR0aW5nXT1cXFwibGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCIsIFwibmd4LWNoYXJ0cy1udW1iZXItY2FyZCAuY2VsbCAudHJpbW1lZC1sYWJlbHtmb250LXNpemU6MTJweDtwb2ludGVyLWV2ZW50czpub25lO292ZXJmbG93OmhpZGRlbjt0ZXh0LWFsaWduOmxlZnQ7bGluZS1oZWlnaHQ6MWVtfW5neC1jaGFydHMtbnVtYmVyLWNhcmQgLmNlbGwgLnRyaW1tZWQtbGFiZWwgcHtvdmVyZmxvdzpoaWRkZW47d2hpdGUtc3BhY2U6bm93cmFwO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2lkdGg6MTAwJTtwYWRkaW5nOjA7bWFyZ2luOjB9bmd4LWNoYXJ0cy1udW1iZXItY2FyZCAuY2VsbCAudmFsdWUtdGV4dHtwb2ludGVyLWV2ZW50czpub25lfW5neC1jaGFydHMtbnVtYmVyLWNhcmQgLm51bWJlci1jYXJkLmNsaWNrYWJsZSAuY2VsbCAuY2FyZCxuZ3gtY2hhcnRzLW51bWJlci1jYXJkIC5udW1iZXItY2FyZC5jbGlja2FibGUgLmNlbGwgLmNhcmQtYmFuZHtjdXJzb3I6cG9pbnRlcn1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE51bWJlckNhcmRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE51bWJlckNhcmRDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgTnVtYmVyQ2FyZE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE51bWJlckNhcmRNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBOdW1iZXJDYXJkTW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIENhcmRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBDYXJkU2VyaWVzQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyQ2FyZENvbXBvbmVudFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgICAgICAgICBDYXJkQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQ2FyZFNlcmllc0NvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIE51bWJlckNhcmRDb21wb25lbnRcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBOdW1iZXJDYXJkTW9kdWxlKTtcclxuICAgIHJldHVybiBOdW1iZXJDYXJkTW9kdWxlO1xyXG59KCkpO1xyXG5cclxudmFyIFRyZWVNYXBDZWxsQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHJlZU1hcENlbGxDb21wb25lbnQoZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB0aGlzLnZhbHVlRm9ybWF0dGluZyA9IHRoaXMudmFsdWVGb3JtYXR0aW5nIHx8IChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7IH0pO1xyXG4gICAgICAgIHZhciBsYWJlbEZvcm1hdHRpbmcgPSB0aGlzLmxhYmVsRm9ybWF0dGluZyB8fCAoZnVuY3Rpb24gKGNlbGwpIHsgcmV0dXJuIHRyaW1MYWJlbChjZWxsLmxhYmVsLCA1NSk7IH0pO1xyXG4gICAgICAgIHZhciBjZWxsRGF0YSA9IHtcclxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxyXG4gICAgICAgICAgICBsYWJlbDogdGhpcy5sYWJlbCxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZm9ybWF0dGVkVmFsdWUgPSB0aGlzLnZhbHVlRm9ybWF0dGluZyhjZWxsRGF0YS52YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWRMYWJlbCA9IGxhYmVsRm9ybWF0dGluZyhjZWxsRGF0YSk7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudElkID0gJ2dyYWQnICsgaWQoKS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnRVcmwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcclxuICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB0aGlzLmdldEdyYWRpZW50U3RvcHMoKTtcclxuICAgIH07XHJcbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvQ3VycmVudEZvcm0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZEFuaW1hdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUubG9hZEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpLnNlbGVjdCgnLmNlbGwnKTtcclxuICAgICAgICBub2RlXHJcbiAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCB0aGlzLngpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgdGhpcy55KTtcclxuICAgICAgICB0aGlzLmFuaW1hdGVUb0N1cnJlbnRGb3JtKCk7XHJcbiAgICB9O1xyXG4gICAgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLmdldFRleHRDb2xvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gaW52ZXJ0Q29sb3IodGhpcy5maWxsKTtcclxuICAgIH07XHJcbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUuYW5pbWF0ZVRvQ3VycmVudEZvcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3QodGhpcy5lbGVtZW50KS5zZWxlY3QoJy5jZWxsJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9ucykge1xyXG4gICAgICAgICAgICBub2RlXHJcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24oNzUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAxKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB0aGlzLngpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHRoaXMueSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMud2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAxKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB0aGlzLngpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHRoaXMueSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMud2lkdGgpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLmdldEdyYWRpZW50U3RvcHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuZmlsbCxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuM1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwMCxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmZpbGwsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXRyZWUtbWFwLWNlbGxdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6Zz5cXG4gICAgICA8ZGVmcyAqbmdJZj1cXFwiZ3JhZGllbnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnIG5neC1jaGFydHMtc3ZnLWxpbmVhci1ncmFkaWVudCBvcmllbnRhdGlvbj1cXFwidmVydGljYWxcXFwiIFtuYW1lXT1cXFwiZ3JhZGllbnRJZFxcXCIgW3N0b3BzXT1cXFwiZ3JhZGllbnRTdG9wc1xcXCIgLz5cXG4gICAgICA8L2RlZnM+XFxuICAgICAgPHN2ZzpyZWN0XFxuICAgICAgICBbYXR0ci5maWxsXT1cXFwiZ3JhZGllbnQgPyBncmFkaWVudFVybCA6IGZpbGxcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcIndpZHRoXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiaGVpZ2h0XFxcIlxcbiAgICAgICAgW2F0dHIueF09XFxcInhcXFwiXFxuICAgICAgICBbYXR0ci55XT1cXFwieVxcXCJcXG4gICAgICAgIFtzdHlsZS5jdXJzb3JdPVxcXCIncG9pbnRlcidcXFwiXFxuICAgICAgICBjbGFzcz1cXFwiY2VsbFxcXCJcXG4gICAgICAgIChjbGljayk9XFxcIm9uQ2xpY2soKVxcXCJcXG4gICAgICAvPlxcbiAgICAgIDxzdmc6Zm9yZWlnbk9iamVjdFxcbiAgICAgICAgKm5nSWY9XFxcIndpZHRoID49IDcwICYmIGhlaWdodCA+PSAzNVxcXCJcXG4gICAgICAgIFthdHRyLnhdPVxcXCJ4XFxcIlxcbiAgICAgICAgW2F0dHIueV09XFxcInlcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcIndpZHRoXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiaGVpZ2h0XFxcIlxcbiAgICAgICAgY2xhc3M9XFxcInRyZWVtYXAtbGFiZWxcXFwiXFxuICAgICAgICBbc3R5bGUucG9pbnRlci1ldmVudHNdPVxcXCInbm9uZSdcXFwiXFxuICAgICAgPlxcbiAgICAgICAgPHhodG1sOnAgW3N0eWxlLmNvbG9yXT1cXFwiZ2V0VGV4dENvbG9yKClcXFwiIFtzdHlsZS5oZWlnaHRdPVxcXCJoZWlnaHQgKyAncHgnXFxcIiBbc3R5bGUud2lkdGhdPVxcXCJ3aWR0aCArICdweCdcXFwiPlxcbiAgICAgICAgICA8eGh0bWw6c3BhbiBjbGFzcz1cXFwidHJlZW1hcC1sYWJlbFxcXCIgW2lubmVySFRNTF09XFxcImZvcm1hdHRlZExhYmVsXFxcIj4gPC94aHRtbDpzcGFuPlxcbiAgICAgICAgICA8eGh0bWw6YnIgLz5cXG4gICAgICAgICAgPHhodG1sOnNwYW5cXG4gICAgICAgICAgICAqbmdJZj1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwidHJlZW1hcC12YWxcXFwiXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1jb3VudC11cFxcbiAgICAgICAgICAgIFtjb3VudFRvXT1cXFwidmFsdWVcXFwiXFxuICAgICAgICAgICAgW3ZhbHVlRm9ybWF0dGluZ109XFxcInZhbHVlRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgPlxcbiAgICAgICAgICA8L3hodG1sOnNwYW4+XFxuICAgICAgICAgIDx4aHRtbDpzcGFuICpuZ0lmPVxcXCIhYW5pbWF0aW9uc1xcXCIgY2xhc3M9XFxcInRyZWVtYXAtdmFsXFxcIj5cXG4gICAgICAgICAgICB7eyBmb3JtYXR0ZWRWYWx1ZSB9fVxcbiAgICAgICAgICA8L3hodG1sOnNwYW4+XFxuICAgICAgICA8L3hodG1sOnA+XFxuICAgICAgPC9zdmc6Zm9yZWlnbk9iamVjdD5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXHJcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gVHJlZU1hcENlbGxDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLmdyYWRpZW50ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy5nZXRDZWxscygpO1xyXG4gICAgfTtcclxuICAgIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDZWxscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuY2hpbGRyZW5cclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5kZXB0aCA9PT0gMTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkLCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkLmlkO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZGF0YTogZC5kYXRhLFxyXG4gICAgICAgICAgICAgICAgeDogZC54MCxcclxuICAgICAgICAgICAgICAgIHk6IGQueTAsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogZC54MSAtIGQueDAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGQueTEgLSBkLnkwLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogX3RoaXMuY29sb3JzLmdldENvbG9yKGxhYmVsKSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBkLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBkLnZhbHVlVHlwZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUb29sdGlwVGV4dCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBsYWJlbCA9IF9hLmxhYmVsLCB2YWx1ZSA9IF9hLnZhbHVlO1xyXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIGxhYmVsICsgXCI8L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtdmFsXFxcIj5cIiArIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCkgKyBcIjwvc3Bhbj5cXG4gICAgXCI7XHJcbiAgICB9O1xyXG4gICAgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5sYWJlbDtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRpbXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXRyZWUtbWFwLWNlbGwtc2VyaWVzXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmdcXG4gICAgICBuZ3gtY2hhcnRzLXRyZWUtbWFwLWNlbGxcXG4gICAgICAqbmdGb3I9XFxcImxldCBjIG9mIGNlbGxzOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgIFtkYXRhXT1cXFwiYy5kYXRhXFxcIlxcbiAgICAgIFt4XT1cXFwiYy54XFxcIlxcbiAgICAgIFt5XT1cXFwiYy55XFxcIlxcbiAgICAgIFt3aWR0aF09XFxcImMud2lkdGhcXFwiXFxuICAgICAgW2hlaWdodF09XFxcImMuaGVpZ2h0XFxcIlxcbiAgICAgIFtmaWxsXT1cXFwiYy5maWxsXFxcIlxcbiAgICAgIFtsYWJlbF09XFxcImMubGFiZWxcXFwiXFxuICAgICAgW3ZhbHVlXT1cXFwiYy52YWx1ZVxcXCJcXG4gICAgICBbdmFsdWVUeXBlXT1cXFwiYy52YWx1ZVR5cGVcXFwiXFxuICAgICAgW3ZhbHVlRm9ybWF0dGluZ109XFxcInZhbHVlRm9ybWF0dGluZ1xcXCJcXG4gICAgICBbbGFiZWxGb3JtYXR0aW5nXT1cXFwibGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIG5neC10b29sdGlwXFxuICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgIFt0b29sdGlwVHlwZV09XFxcIid0b29sdGlwJ1xcXCJcXG4gICAgICBbdG9vbHRpcFRpdGxlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogZ2V0VG9vbHRpcFRleHQoYylcXFwiXFxuICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJjLmRhdGFcXFwiXFxuICAgID48L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBUcmVlTWFwQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFRyZWVNYXBDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUcmVlTWFwQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmdyYWRpZW50ID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMTAsIDEwLCAxMF07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW5cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy50cmVlbWFwID0gdHJlZW1hcCgpLnNpemUoW3RoaXMuZGltcy53aWR0aCwgdGhpcy5kaW1zLmhlaWdodF0pO1xyXG4gICAgICAgIHZhciByb290Tm9kZSA9IHtcclxuICAgICAgICAgICAgbmFtZTogJ3Jvb3QnLFxyXG4gICAgICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICAgICAgaXNSb290OiB0cnVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcm9vdCA9IHN0cmF0aWZ5KClcclxuICAgICAgICAgICAgLmlkKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQubmFtZTtcclxuICAgICAgICAgICAgaWYgKGxhYmVsLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdEYXRlJykge1xyXG4gICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbC50b0xvY2FsZURhdGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWwudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnBhcmVudElkKGZ1bmN0aW9uIChkKSB7IHJldHVybiAoZC5pc1Jvb3QgPyBudWxsIDogJ3Jvb3QnKTsgfSkoW3Jvb3ROb2RlXS5jb25jYXQodGhpcy5yZXN1bHRzKSlcclxuICAgICAgICAgICAgLnN1bShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy50cmVlbWFwKHJvb3QpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUuZ2V0RG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWU7IH0pO1xyXG4gICAgfTtcclxuICAgIFRyZWVNYXBDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCAnb3JkaW5hbCcsIHRoaXMuZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwicmVzdWx0c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFRyZWVNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgVHJlZU1hcENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy10cmVlLW1hcCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydCBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCIgW3Nob3dMZWdlbmRdPVxcXCJmYWxzZVxcXCIgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIj5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwidHJlZS1tYXAgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtdHJlZS1tYXAtY2VsbC1zZXJpZXNcXG4gICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgW2RhdGFdPVxcXCJkYXRhXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgIFt2YWx1ZUZvcm1hdHRpbmddPVxcXCJ2YWx1ZUZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFtsYWJlbEZvcm1hdHRpbmddPVxcXCJsYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi50cmVlLW1hcCAudHJlZW1hcC12YWx7Zm9udC1zaXplOjEuM2VtO3BhZGRpbmctdG9wOjVweDtkaXNwbGF5OmlubGluZS1ibG9ja30udHJlZS1tYXAgLnRyZWVtYXAtbGFiZWwgcHtkaXNwbGF5OnRhYmxlLWNlbGw7dGV4dC1hbGlnbjpjZW50ZXI7bGluZS1oZWlnaHQ6MS4yZW07dmVydGljYWwtYWxpZ246bWlkZGxlfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgVHJlZU1hcENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gVHJlZU1hcENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBUcmVlTWFwTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVHJlZU1hcE1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIFRyZWVNYXBNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDaGFydENvbW1vbk1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgVHJlZU1hcENlbGxDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFRyZWVNYXBDb21wb25lbnRcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZXhwb3J0czogW1xyXG4gICAgICAgICAgICAgICAgVHJlZU1hcENlbGxDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFRyZWVNYXBDb21wb25lbnRcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBUcmVlTWFwTW9kdWxlKTtcclxuICAgIHJldHVybiBUcmVlTWFwTW9kdWxlO1xyXG59KCkpO1xyXG5cclxudmFyIExpbmVhckdhdWdlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKExpbmVhckdhdWdlQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGluZWFyR2F1Z2VDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubWluID0gMDtcclxuICAgICAgICBfdGhpcy5tYXggPSAxMDA7XHJcbiAgICAgICAgX3RoaXMudmFsdWUgPSAwO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgX3RoaXMudmFsdWVSZXNpemVTY2FsZSA9IDE7XHJcbiAgICAgICAgX3RoaXMudW5pdHNSZXNpemVTY2FsZSA9IDE7XHJcbiAgICAgICAgX3RoaXMudmFsdWVUZXh0VHJhbnNmb3JtID0gJyc7XHJcbiAgICAgICAgX3RoaXMudmFsdWVUcmFuc2xhdGUgPSAnJztcclxuICAgICAgICBfdGhpcy51bml0c1RleHRUcmFuc2Zvcm0gPSAnJztcclxuICAgICAgICBfdGhpcy51bml0c1RyYW5zbGF0ZSA9ICcnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5zY2FsZVRleHQoJ3ZhbHVlJyk7XHJcbiAgICAgICAgICAgIF90aGlzLnNjYWxlVGV4dCgndW5pdHMnKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmhhc1ByZXZpb3VzVmFsdWUgPSB0aGlzLnByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCB0aGlzLnZhbHVlKTtcclxuICAgICAgICB0aGlzLm1pbiA9IE1hdGgubWluKHRoaXMubWluLCB0aGlzLnZhbHVlKTtcclxuICAgICAgICBpZiAodGhpcy5oYXNQcmV2aW91c1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5tYXgsIHRoaXMucHJldmlvdXNWYWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMubWluID0gTWF0aC5taW4odGhpcy5taW4sIHRoaXMucHJldmlvdXNWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy52YWx1ZURvbWFpbiA9IHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcclxuICAgICAgICB0aGlzLnZhbHVlU2NhbGUgPSB0aGlzLmdldFZhbHVlU2NhbGUoKTtcclxuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZ2V0RGlzcGxheVZhbHVlKCk7XHJcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcclxuICAgICAgICB2YXIgeE9mZnNldCA9IHRoaXMubWFyZ2luWzNdICsgdGhpcy5kaW1zLndpZHRoIC8gMjtcclxuICAgICAgICB2YXIgeU9mZnNldCA9IHRoaXMubWFyZ2luWzBdICsgdGhpcy5kaW1zLmhlaWdodCAvIDI7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHhPZmZzZXQgKyBcIiwgXCIgKyB5T2Zmc2V0ICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1MaW5lID0gXCJ0cmFuc2xhdGUoXCIgKyAodGhpcy5tYXJnaW5bM10gKyB0aGlzLnZhbHVlU2NhbGUodGhpcy5wcmV2aW91c1ZhbHVlKSkgKyBcIiwgXCIgKyB5T2Zmc2V0ICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy52YWx1ZVRyYW5zbGF0ZSA9IFwidHJhbnNsYXRlKDAsIC0xNSlcIjtcclxuICAgICAgICB0aGlzLnVuaXRzVHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUoMCwgMTUpXCI7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY2FsZVRleHQoJ3ZhbHVlJyk7IH0sIDUwKTtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNjYWxlVGV4dCgndW5pdHMnKTsgfSwgNTApO1xyXG4gICAgfTtcclxuICAgIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMubWluLCB0aGlzLm1heF07XHJcbiAgICB9O1xyXG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFswLCB0aGlzLmRpbXMud2lkdGhdKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMudmFsdWVEb21haW4pO1xyXG4gICAgfTtcclxuICAgIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5nZXREaXNwbGF5VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlRm9ybWF0dGluZyh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuc2NhbGVUZXh0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHJlcGVhdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHJlcGVhdCA9PT0gdm9pZCAwKSB7IHJlcGVhdCA9IHRydWU7IH1cclxuICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgdmFyIHJlc2l6ZVNjYWxlO1xyXG4gICAgICAgIGlmIChlbGVtZW50ID09PSAndmFsdWUnKSB7XHJcbiAgICAgICAgICAgIGVsID0gdGhpcy52YWx1ZVRleHRFbDtcclxuICAgICAgICAgICAgcmVzaXplU2NhbGUgPSB0aGlzLnZhbHVlUmVzaXplU2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbCA9IHRoaXMudW5pdHNUZXh0RWw7XHJcbiAgICAgICAgICAgIHJlc2l6ZVNjYWxlID0gdGhpcy51bml0c1Jlc2l6ZVNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2EgPSBlbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBvbGRTY2FsZSA9IHJlc2l6ZVNjYWxlO1xyXG4gICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHRoaXMuZGltcy53aWR0aDtcclxuICAgICAgICB2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5kaW1zLmhlaWdodCAvIDIgLSAxNSwgMCk7XHJcbiAgICAgICAgdmFyIHJlc2l6ZVNjYWxlV2lkdGggPSBNYXRoLmZsb29yKChhdmFpbGFibGVXaWR0aCAvICh3aWR0aCAvIHJlc2l6ZVNjYWxlKSkgKiAxMDApIC8gMTAwO1xyXG4gICAgICAgIHZhciByZXNpemVTY2FsZUhlaWdodCA9IE1hdGguZmxvb3IoKGF2YWlsYWJsZUhlaWdodCAvIChoZWlnaHQgLyByZXNpemVTY2FsZSkpICogMTAwKSAvIDEwMDtcclxuICAgICAgICByZXNpemVTY2FsZSA9IE1hdGgubWluKHJlc2l6ZVNjYWxlSGVpZ2h0LCByZXNpemVTY2FsZVdpZHRoKTtcclxuICAgICAgICBpZiAocmVzaXplU2NhbGUgIT09IG9sZFNjYWxlKSB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSAndmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlUmVzaXplU2NhbGUgPSByZXNpemVTY2FsZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVUZXh0VHJhbnNmb3JtID0gXCJzY2FsZShcIiArIHJlc2l6ZVNjYWxlICsgXCIsIFwiICsgcmVzaXplU2NhbGUgKyBcIilcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5pdHNSZXNpemVTY2FsZSA9IHJlc2l6ZVNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bml0c1RleHRUcmFuc2Zvcm0gPSBcInNjYWxlKFwiICsgcmVzaXplU2NhbGUgKyBcIiwgXCIgKyByZXNpemVTY2FsZSArIFwiKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgICAgICAgIGlmIChyZXBlYXQpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNjYWxlVGV4dChlbGVtZW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9LCA1MCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdCh7XHJcbiAgICAgICAgICAgIG5hbWU6ICdWYWx1ZScsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgJ29yZGluYWwnLCBbdGhpcy52YWx1ZV0sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidW5pdHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmV2aW91c1ZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBWaWV3Q2hpbGQoJ3ZhbHVlVGV4dEVsJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlVGV4dEVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBWaWV3Q2hpbGQoJ3VuaXRzVGV4dEVsJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInVuaXRzVGV4dEVsXCIsIHZvaWQgMCk7XHJcbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1saW5lYXItZ2F1Z2UnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnQgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiIFtzaG93TGVnZW5kXT1cXFwiZmFsc2VcXFwiIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCIgKGNsaWNrKT1cXFwib25DbGljaygpXFxcIj5cXG4gICAgICA8c3ZnOmcgY2xhc3M9XFxcImxpbmVhci1nYXVnZSBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1iYXJcXG4gICAgICAgICAgY2xhc3M9XFxcImJhY2tncm91bmQtYmFyXFxcIlxcbiAgICAgICAgICBbd2lkdGhdPVxcXCJkaW1zLndpZHRoXFxcIlxcbiAgICAgICAgICBbaGVpZ2h0XT1cXFwiM1xcXCJcXG4gICAgICAgICAgW3hdPVxcXCJtYXJnaW5bM11cXFwiXFxuICAgICAgICAgIFt5XT1cXFwiZGltcy5oZWlnaHQgLyAyICsgbWFyZ2luWzBdIC0gMlxcXCJcXG4gICAgICAgICAgW2RhdGFdPVxcXCJ7fVxcXCJcXG4gICAgICAgICAgW29yaWVudGF0aW9uXT1cXFwiJ2hvcml6b250YWwnXFxcIlxcbiAgICAgICAgICBbcm91bmRFZGdlc109XFxcInRydWVcXFwiXFxuICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtYmFyXFxuICAgICAgICAgIFt3aWR0aF09XFxcInZhbHVlU2NhbGUodmFsdWUpXFxcIlxcbiAgICAgICAgICBbaGVpZ2h0XT1cXFwiM1xcXCJcXG4gICAgICAgICAgW3hdPVxcXCJtYXJnaW5bM11cXFwiXFxuICAgICAgICAgIFt5XT1cXFwiZGltcy5oZWlnaHQgLyAyICsgbWFyZ2luWzBdIC0gMlxcXCJcXG4gICAgICAgICAgW2ZpbGxdPVxcXCJjb2xvcnMuZ2V0Q29sb3IodW5pdHMpXFxcIlxcbiAgICAgICAgICBbZGF0YV09XFxcInt9XFxcIlxcbiAgICAgICAgICBbb3JpZW50YXRpb25dPVxcXCInaG9yaXpvbnRhbCdcXFwiXFxuICAgICAgICAgIFtyb3VuZEVkZ2VzXT1cXFwidHJ1ZVxcXCJcXG4gICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuXFxuICAgICAgICA8c3ZnOmxpbmVcXG4gICAgICAgICAgKm5nSWY9XFxcImhhc1ByZXZpb3VzVmFsdWVcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybUxpbmVcXFwiXFxuICAgICAgICAgIHgxPVxcXCIwXFxcIlxcbiAgICAgICAgICB5MT1cXFwiNVxcXCJcXG4gICAgICAgICAgeDI9XFxcIjBcXFwiXFxuICAgICAgICAgIHkyPVxcXCIxNVxcXCJcXG4gICAgICAgICAgW2F0dHIuc3Ryb2tlXT1cXFwiY29sb3JzLmdldENvbG9yKHVuaXRzKVxcXCJcXG4gICAgICAgIC8+XFxuXFxuICAgICAgICA8c3ZnOmxpbmVcXG4gICAgICAgICAgKm5nSWY9XFxcImhhc1ByZXZpb3VzVmFsdWVcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybUxpbmVcXFwiXFxuICAgICAgICAgIHgxPVxcXCIwXFxcIlxcbiAgICAgICAgICB5MT1cXFwiLTVcXFwiXFxuICAgICAgICAgIHgyPVxcXCIwXFxcIlxcbiAgICAgICAgICB5Mj1cXFwiLTE1XFxcIlxcbiAgICAgICAgICBbYXR0ci5zdHJva2VdPVxcXCJjb2xvcnMuZ2V0Q29sb3IodW5pdHMpXFxcIlxcbiAgICAgICAgLz5cXG5cXG4gICAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiPlxcbiAgICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidmFsdWVUcmFuc2xhdGVcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgICAgICAgI3ZhbHVlVGV4dEVsXFxuICAgICAgICAgICAgICBjbGFzcz1cXFwidmFsdWVcXFwiXFxuICAgICAgICAgICAgICBbc3R5bGUudGV4dEFuY2hvcl09XFxcIidtaWRkbGUnXFxcIlxcbiAgICAgICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidmFsdWVUZXh0VHJhbnNmb3JtXFxcIlxcbiAgICAgICAgICAgICAgYWxpZ25tZW50LWJhc2VsaW5lPVxcXCJhZnRlci1lZGdlXFxcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgIHt7IGRpc3BsYXlWYWx1ZSB9fVxcbiAgICAgICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuXFxuICAgICAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ1bml0c1RyYW5zbGF0ZVxcXCI+XFxuICAgICAgICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICAgICAgICAjdW5pdHNUZXh0RWxcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJ1bml0c1xcXCJcXG4gICAgICAgICAgICAgIFtzdHlsZS50ZXh0QW5jaG9yXT1cXFwiJ21pZGRsZSdcXFwiXFxuICAgICAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ1bml0c1RleHRUcmFuc2Zvcm1cXFwiXFxuICAgICAgICAgICAgICBhbGlnbm1lbnQtYmFzZWxpbmU9XFxcImJlZm9yZS1lZGdlXFxcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgIHt7IHVuaXRzIH19XFxuICAgICAgICAgICAgPC9zdmc6dGV4dD5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIiwgXCIubGluZWFyLWdhdWdle2N1cnNvcjpwb2ludGVyfS5saW5lYXItZ2F1Z2UgLmJhY2tncm91bmQtYmFyIHBhdGh7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9LmxpbmVhci1nYXVnZSAudW5pdHN7ZmlsbDojNjY2fVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIExpbmVhckdhdWdlQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEdhdWdlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEdhdWdlQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gR2F1Z2VDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMubWluID0gMDtcclxuICAgICAgICBfdGhpcy5tYXggPSAxMDA7XHJcbiAgICAgICAgX3RoaXMuYmlnU2VnbWVudHMgPSAxMDtcclxuICAgICAgICBfdGhpcy5zbWFsbFNlZ21lbnRzID0gNTtcclxuICAgICAgICBfdGhpcy5zaG93QXhpcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuc3RhcnRBbmdsZSA9IC0xMjA7XHJcbiAgICAgICAgX3RoaXMuYW5nbGVTcGFuID0gMjQwO1xyXG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zaG93VGV4dCA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5yZXNpemVTY2FsZSA9IDE7XHJcbiAgICAgICAgX3RoaXMucm90YXRpb24gPSAnJztcclxuICAgICAgICBfdGhpcy50ZXh0VHJhbnNmb3JtID0gJ3NjYWxlKDEsIDEpJztcclxuICAgICAgICBfdGhpcy5jb3JuZXJSYWRpdXMgPSAxMDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNjYWxlVGV4dCgpOyB9KTtcclxuICAgIH07XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvd0F4aXMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm1hcmdpbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWFyZ2luKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmdpbiA9IFs2MCwgMTAwLCA2MCwgMTAwXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdGFydEFuZ2xlIDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0QW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlICUgMzYwKSArIDM2MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbmdsZVNwYW4gPSBNYXRoLm1pbih0aGlzLmFuZ2xlU3BhbiwgMzYwKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSB0aGlzLmdldERvbWFpbigpO1xyXG4gICAgICAgIHRoaXMudmFsdWVEb21haW4gPSB0aGlzLmdldFZhbHVlRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZVNjYWxlID0gdGhpcy5nZXRWYWx1ZVNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmdldERpc3BsYXlWYWx1ZSgpO1xyXG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBNYXRoLm1pbih0aGlzLmRpbXMud2lkdGgsIHRoaXMuZGltcy5oZWlnaHQpIC8gMjtcclxuICAgICAgICB0aGlzLmFyY3MgPSB0aGlzLmdldEFyY3MoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHZhciB4T2Zmc2V0ID0gdGhpcy5tYXJnaW5bM10gKyB0aGlzLmRpbXMud2lkdGggLyAyO1xyXG4gICAgICAgIHZhciB5T2Zmc2V0ID0gdGhpcy5tYXJnaW5bMF0gKyB0aGlzLmRpbXMuaGVpZ2h0IC8gMjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgeE9mZnNldCArIFwiLCBcIiArIHlPZmZzZXQgKyBcIilcIjtcclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gXCJyb3RhdGUoXCIgKyB0aGlzLnN0YXJ0QW5nbGUgKyBcIilcIjtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNjYWxlVGV4dCgpOyB9LCA1MCk7XHJcbiAgICB9O1xyXG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLmdldEFyY3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyY3MgPSBbXTtcclxuICAgICAgICB2YXIgYXZhaWxhYmxlUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cyAqIDAuNztcclxuICAgICAgICB2YXIgcmFkaXVzUGVyQXJjID0gTWF0aC5taW4oYXZhaWxhYmxlUmFkaXVzIC8gdGhpcy5yZXN1bHRzLmxlbmd0aCwgMTApO1xyXG4gICAgICAgIHZhciBhcmNXaWR0aCA9IHJhZGl1c1BlckFyYyAqIDAuNztcclxuICAgICAgICB0aGlzLnRleHRSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gdGhpcy5yZXN1bHRzLmxlbmd0aCAqIHJhZGl1c1BlckFyYztcclxuICAgICAgICB0aGlzLmNvcm5lclJhZGl1cyA9IE1hdGguZmxvb3IoYXJjV2lkdGggLyAyKTtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGQgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHZhciBvdXRlclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSBpICogcmFkaXVzUGVyQXJjO1xyXG4gICAgICAgICAgICB2YXIgaW5uZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIGFyY1dpZHRoO1xyXG4gICAgICAgICAgICB2YXIgYmFja2dyb3VuZEFyYyA9IHtcclxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiAodGhpcy5hbmdsZVNwYW4gKiBNYXRoLlBJKSAvIDE4MCxcclxuICAgICAgICAgICAgICAgIGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcclxuICAgICAgICAgICAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5tYXgsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZC5uYW1lXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZUFyYyA9IHtcclxuICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiAoTWF0aC5taW4odGhpcy52YWx1ZVNjYWxlKGQudmFsdWUpLCB0aGlzLmFuZ2xlU3BhbikgKiBNYXRoLlBJKSAvIDE4MCxcclxuICAgICAgICAgICAgICAgIGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcclxuICAgICAgICAgICAgICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkLm5hbWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGFyYyQkMSA9IHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRBcmM6IGJhY2tncm91bmRBcmMsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZUFyYzogdmFsdWVBcmNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYXJjcy5wdXNoKGFyYyQkMSk7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyY3M7XHJcbiAgICB9O1xyXG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLmdldERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lOyB9KTtcclxuICAgIH07XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pO1xyXG4gICAgICAgIHZhciBkYXRhTWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICB2YXIgZGF0YU1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgaWYgKHRoaXMubWluICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5taW4gPSBNYXRoLm1pbih0aGlzLm1pbiwgZGF0YU1pbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1pbiA9IGRhdGFNaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1heCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5tYXgsIGRhdGFNYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBkYXRhTWF4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3RoaXMubWluLCB0aGlzLm1heF07XHJcbiAgICB9O1xyXG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFswLCB0aGlzLmFuZ2xlU3Bhbl0pXHJcbiAgICAgICAgICAgIC5uaWNlKClcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnZhbHVlRG9tYWluKTtcclxuICAgIH07XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0RGlzcGxheVZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSArIGI7IH0sIDApO1xyXG4gICAgICAgIGlmICh0aGlzLnRleHRWYWx1ZSAmJiAwICE9PSB0aGlzLnRleHRWYWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dFZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlRm9ybWF0dGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUZvcm1hdHRpbmcodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuc2NhbGVUZXh0ID0gZnVuY3Rpb24gKHJlcGVhdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHJlcGVhdCA9PT0gdm9pZCAwKSB7IHJlcGVhdCA9IHRydWU7IH1cclxuICAgICAgICBpZiAoIXRoaXMuc2hvd1RleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnRleHRFbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xyXG4gICAgICAgIHZhciBvbGRTY2FsZSA9IHRoaXMucmVzaXplU2NhbGU7XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2NhbGUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVNwYWNlID0gdGhpcy50ZXh0UmFkaXVzO1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVNjYWxlID0gTWF0aC5mbG9vcigoYXZhaWxhYmxlU3BhY2UgLyAod2lkdGggLyB0aGlzLnJlc2l6ZVNjYWxlKSkgKiAxMDApIC8gMTAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yZXNpemVTY2FsZSAhPT0gb2xkU2NhbGUpIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0VHJhbnNmb3JtID0gXCJzY2FsZShcIiArIHRoaXMucmVzaXplU2NhbGUgKyBcIiwgXCIgKyB0aGlzLnJlc2l6ZVNjYWxlICsgXCIpXCI7XHJcbiAgICAgICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgICAgICAgIGlmIChyZXBlYXQpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2NhbGVUZXh0KGZhbHNlKTsgfSwgNTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNjYWxlVHlwZTogJ29yZGluYWwnLFxyXG4gICAgICAgICAgICBjb2xvcnM6IHRoaXMuY29sb3JzLFxyXG4gICAgICAgICAgICBkb21haW46IHRoaXMuZG9tYWluLFxyXG4gICAgICAgICAgICB0aXRsZTogdGhpcy5sZWdlbmRUaXRsZSxcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsICdvcmRpbmFsJywgdGhpcy5kb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW2l0ZW1dLmNvbmNhdCh0aGlzLmFjdGl2ZUVudHJpZXMpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWUgPT09IGQubmFtZSAmJiBlbnRyeS5zZXJpZXMgPT09IGQuc2VyaWVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZUFyYy5kYXRhLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0VmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ1bml0c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImJpZ1NlZ21lbnRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic21hbGxTZWdtZW50c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicmVzdWx0c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmdsZVNwYW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJheGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1RleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFZpZXdDaGlsZCgndGV4dEVsJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9kID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9kIDogT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRFbFwiLCB2b2lkIDApO1xyXG4gICAgR2F1Z2VDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtZ2F1Z2UnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiZ2F1Z2UgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IGFyYyBvZiBhcmNzOyB0cmFja0J5OiB0cmFja0J5XFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJyb3RhdGlvblxcXCI+XFxuICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgIG5neC1jaGFydHMtZ2F1Z2UtYXJjXFxuICAgICAgICAgICAgW2JhY2tncm91bmRBcmNdPVxcXCJhcmMuYmFja2dyb3VuZEFyY1xcXCJcXG4gICAgICAgICAgICBbdmFsdWVBcmNdPVxcXCJhcmMudmFsdWVBcmNcXFwiXFxuICAgICAgICAgICAgW2Nvcm5lclJhZGl1c109XFxcImNvcm5lclJhZGl1c1xcXCJcXG4gICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgIFtpc0FjdGl2ZV09XFxcImlzQWN0aXZlKGFyYy52YWx1ZUFyYy5kYXRhKVxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgW3ZhbHVlRm9ybWF0dGluZ109XFxcInZhbHVlRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8L3N2ZzpnPlxcblxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtZ2F1Z2UtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwic2hvd0F4aXNcXFwiXFxuICAgICAgICAgIFtiaWdTZWdtZW50c109XFxcImJpZ1NlZ21lbnRzXFxcIlxcbiAgICAgICAgICBbc21hbGxTZWdtZW50c109XFxcInNtYWxsU2VnbWVudHNcXFwiXFxuICAgICAgICAgIFttaW5dPVxcXCJtaW5cXFwiXFxuICAgICAgICAgIFttYXhdPVxcXCJtYXhcXFwiXFxuICAgICAgICAgIFtyYWRpdXNdPVxcXCJvdXRlclJhZGl1c1xcXCJcXG4gICAgICAgICAgW2FuZ2xlU3Bhbl09XFxcImFuZ2xlU3BhblxcXCJcXG4gICAgICAgICAgW3ZhbHVlU2NhbGVdPVxcXCJ2YWx1ZVNjYWxlXFxcIlxcbiAgICAgICAgICBbc3RhcnRBbmdsZV09XFxcInN0YXJ0QW5nbGVcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcImF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcblxcbiAgICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICAgICN0ZXh0RWxcXG4gICAgICAgICAgKm5nSWY9XFxcInNob3dUZXh0XFxcIlxcbiAgICAgICAgICBbc3R5bGUudGV4dEFuY2hvcl09XFxcIidtaWRkbGUnXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0ZXh0VHJhbnNmb3JtXFxcIlxcbiAgICAgICAgICBhbGlnbm1lbnQtYmFzZWxpbmU9XFxcImNlbnRyYWxcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIDx0c3BhbiB4PVxcXCIwXFxcIiBkeT1cXFwiMFxcXCI+e3sgZGlzcGxheVZhbHVlIH19PC90c3Bhbj5cXG4gICAgICAgICAgPHRzcGFuIHg9XFxcIjBcXFwiIGR5PVxcXCIxLjJlbVxcXCI+e3sgdW5pdHMgfX08L3RzcGFuPlxcbiAgICAgICAgPC9zdmc6dGV4dD5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiLCBcIi5nYXVnZSAuYmFja2dyb3VuZC1hcmMgcGF0aHtmaWxsOnJnYmEoMCwwLDAsLjA1KX0uZ2F1Z2UgLmdhdWdlLXRpY2sgcGF0aHtzdHJva2U6IzY2Nn0uZ2F1Z2UgLmdhdWdlLXRpY2sgdGV4dHtmb250LXNpemU6MTJweDtmaWxsOiM2NjY7Zm9udC13ZWlnaHQ6NzAwfS5nYXVnZSAuZ2F1Z2UtdGljay1sYXJnZSBwYXRoe3N0cm9rZS13aWR0aDoycHh9LmdhdWdlIC5nYXVnZS10aWNrLXNtYWxsIHBhdGh7c3Ryb2tlLXdpZHRoOjFweH1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBHYXVnZUNvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBHYXVnZUFyY0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEdhdWdlQXJjQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBHYXVnZUFyY0NvbXBvbmVudC5wcm90b3R5cGUudG9vbHRpcFRleHQgPSBmdW5jdGlvbiAoYXJjJCQxKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsID0gZm9ybWF0TGFiZWwoYXJjJCQxLmRhdGEubmFtZSk7XHJcbiAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZUZvcm1hdHRpbmcpIHtcclxuICAgICAgICAgICAgdmFsID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcoYXJjJCQxLmRhdGEudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFsID0gZm9ybWF0TGFiZWwoYXJjJCQxLmRhdGEudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC1sYWJlbFxcXCI+XCIgKyBsYWJlbCArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWwgKyBcIjwvc3Bhbj5cXG4gICAgXCI7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kQXJjXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVBcmNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb3JuZXJSYWRpdXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgQ29sb3JIZWxwZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgQ29sb3JIZWxwZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBHYXVnZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNBY3RpdmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBHYXVnZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBHYXVnZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgR2F1Z2VBcmNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1nYXVnZS1hcmNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLXBpZS1hcmNcXG4gICAgICBjbGFzcz1cXFwiYmFja2dyb3VuZC1hcmNcXFwiXFxuICAgICAgW3N0YXJ0QW5nbGVdPVxcXCIwXFxcIlxcbiAgICAgIFtlbmRBbmdsZV09XFxcImJhY2tncm91bmRBcmMuZW5kQW5nbGVcXFwiXFxuICAgICAgW2lubmVyUmFkaXVzXT1cXFwiYmFja2dyb3VuZEFyYy5pbm5lclJhZGl1c1xcXCJcXG4gICAgICBbb3V0ZXJSYWRpdXNdPVxcXCJiYWNrZ3JvdW5kQXJjLm91dGVyUmFkaXVzXFxcIlxcbiAgICAgIFtjb3JuZXJSYWRpdXNdPVxcXCJjb3JuZXJSYWRpdXNcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJiYWNrZ3JvdW5kQXJjLmRhdGFcXFwiXFxuICAgICAgW2FuaW1hdGVdPVxcXCJmYWxzZVxcXCJcXG4gICAgICBbcG9pbnRlckV2ZW50c109XFxcImZhbHNlXFxcIj5cXG4gICAgPC9zdmc6Zz5cXG4gICAgPHN2ZzpnIG5neC1jaGFydHMtcGllLWFyY1xcbiAgICAgIFtzdGFydEFuZ2xlXT1cXFwiMFxcXCJcXG4gICAgICBbZW5kQW5nbGVdPVxcXCJ2YWx1ZUFyYy5lbmRBbmdsZVxcXCJcXG4gICAgICBbaW5uZXJSYWRpdXNdPVxcXCJ2YWx1ZUFyYy5pbm5lclJhZGl1c1xcXCJcXG4gICAgICBbb3V0ZXJSYWRpdXNdPVxcXCJ2YWx1ZUFyYy5vdXRlclJhZGl1c1xcXCJcXG4gICAgICBbY29ybmVyUmFkaXVzXT1cXFwiY29ybmVyUmFkaXVzXFxcIlxcbiAgICAgIFtmaWxsXT1cXFwiY29sb3JzLmdldENvbG9yKHZhbHVlQXJjLmRhdGEubmFtZSlcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJ2YWx1ZUFyYy5kYXRhXFxcIlxcbiAgICAgIFthbmltYXRlXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICBbaXNBY3RpdmVdPVxcXCJpc0FjdGl2ZVxcXCJcXG4gICAgICAoc2VsZWN0KT1cXFwic2VsZWN0LmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgKGRlYWN0aXZhdGUpPVxcXCJkZWFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVxcXCIndG9wJ1xcXCJcXG4gICAgICBbdG9vbHRpcFR5cGVdPVxcXCIndG9vbHRpcCdcXFwiXFxuICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IHRvb2x0aXBUZXh0KHZhbHVlQXJjKVxcXCJcXG4gICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcInZhbHVlQXJjLmRhdGFcXFwiPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBHYXVnZUFyY0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gR2F1Z2VBcmNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgR2F1Z2VBeGlzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR2F1Z2VBeGlzQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMucm90YXRlID0gJyc7XHJcbiAgICB9XHJcbiAgICBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucm90YXRpb25BbmdsZSA9IC05MCArIHRoaXMuc3RhcnRBbmdsZTtcclxuICAgICAgICB0aGlzLnJvdGF0ZSA9IFwicm90YXRlKFwiICsgdGhpcy5yb3RhdGlvbkFuZ2xlICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy50aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcclxuICAgIH07XHJcbiAgICBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLmdldFRpY2tzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBiaWdUaWNrU2VnbWVudCA9IHRoaXMuYW5nbGVTcGFuIC8gdGhpcy5iaWdTZWdtZW50cztcclxuICAgICAgICB2YXIgc21hbGxUaWNrU2VnbWVudCA9IGJpZ1RpY2tTZWdtZW50IC8gKHRoaXMuc21hbGxTZWdtZW50cyk7XHJcbiAgICAgICAgdmFyIHRpY2tMZW5ndGggPSAyMDtcclxuICAgICAgICB2YXIgdGlja3MgPSB7XHJcbiAgICAgICAgICAgIGJpZzogW10sXHJcbiAgICAgICAgICAgIHNtYWxsOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHN0YXJ0RGlzdGFuY2UgPSB0aGlzLnJhZGl1cyArIDEwO1xyXG4gICAgICAgIHZhciB0ZXh0RGlzdCA9IHN0YXJ0RGlzdGFuY2UgKyB0aWNrTGVuZ3RoICsgMTA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdGhpcy5iaWdTZWdtZW50czsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZURlZyA9IGkgKiBiaWdUaWNrU2VnbWVudDtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gYW5nbGVEZWcgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICAgICAgICB2YXIgdGV4dEFuY2hvciA9IHRoaXMuZ2V0VGV4dEFuY2hvcihhbmdsZURlZyk7XHJcbiAgICAgICAgICAgIHZhciBza2lwID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwICYmIHRoaXMuYW5nbGVTcGFuID09PSAzNjApIHtcclxuICAgICAgICAgICAgICAgIHNraXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc2tpcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBOdW1iZXIucGFyc2VGbG9hdCh0aGlzLnZhbHVlU2NhbGUuaW52ZXJ0KGFuZ2xlRGVnKS50b1N0cmluZygpKS50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGlja0Zvcm1hdHRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy50aWNrRm9ybWF0dGluZyh0ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRpY2tzLmJpZy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmdldFRpY2tQYXRoKHN0YXJ0RGlzdGFuY2UsIHRpY2tMZW5ndGgsIGFuZ2xlKSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFRyYW5zZm9ybTogXCJcXG4gICAgICAgICAgICB0cmFuc2xhdGUoXCIgKyB0ZXh0RGlzdCAqIE1hdGguY29zKGFuZ2xlKSArIFwiLCBcIiArIHRleHREaXN0ICogTWF0aC5zaW4oYW5nbGUpICsgXCIpIHJvdGF0ZShcIiArIC10aGlzLnJvdGF0aW9uQW5nbGUgKyBcIilcXG4gICAgICAgICAgXCJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpID09PSB0aGlzLmJpZ1NlZ21lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8PSB0aGlzLnNtYWxsU2VnbWVudHM7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNtYWxsQW5nbGVEZWcgPSBhbmdsZURlZyArIGogKiBzbWFsbFRpY2tTZWdtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNtYWxsQW5nbGUgPSBzbWFsbEFuZ2xlRGVnICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgICAgICAgICAgIHRpY2tzLnNtYWxsLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuZ2V0VGlja1BhdGgoc3RhcnREaXN0YW5jZSwgdGlja0xlbmd0aCAvIDIsIHNtYWxsQW5nbGUpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGlja3M7XHJcbiAgICB9O1xyXG4gICAgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUZXh0QW5jaG9yID0gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICAgICAgLy8gWzAsIDQ1XSA9ICdtaWRkbGUnO1xyXG4gICAgICAgIC8vIFs0NiwgMTM1XSA9ICdzdGFydCc7XHJcbiAgICAgICAgLy8gWzEzNiwgMjI1XSA9ICdtaWRkbGUnO1xyXG4gICAgICAgIC8vIFsyMjYsIDMxNV0gPSAnZW5kJztcclxuICAgICAgICBhbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyBhbmdsZSkgJSAzNjA7XHJcbiAgICAgICAgdmFyIHRleHRBbmNob3IgPSAnbWlkZGxlJztcclxuICAgICAgICBpZiAoYW5nbGUgPiA0NSAmJiBhbmdsZSA8PSAxMzUpIHtcclxuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFuZ2xlID4gMjI1ICYmIGFuZ2xlIDw9IDMxNSkge1xyXG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ2VuZCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0QW5jaG9yO1xyXG4gICAgfTtcclxuICAgIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0VGlja1BhdGggPSBmdW5jdGlvbiAoc3RhcnREaXN0YW5jZSwgdGlja0xlbmd0aCwgYW5nbGUpIHtcclxuICAgICAgICB2YXIgeTEgPSBzdGFydERpc3RhbmNlICogTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIHZhciB5MiA9IChzdGFydERpc3RhbmNlICsgdGlja0xlbmd0aCkgKiBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgdmFyIHgxID0gc3RhcnREaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICB2YXIgeDIgPSAoc3RhcnREaXN0YW5jZSArIHRpY2tMZW5ndGgpICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbeyB4OiB4MSwgeTogeTEgfSwgeyB4OiB4MiwgeTogeTIgfV07XHJcbiAgICAgICAgdmFyIGxpbmVHZW5lcmF0b3IgPSBsaW5lKCkueChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC54OyB9KS55KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnk7IH0pO1xyXG4gICAgICAgIHJldHVybiBsaW5lR2VuZXJhdG9yKHBvaW50cyk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiaWdTZWdtZW50c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzbWFsbFNlZ21lbnRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5nbGVTcGFuXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwicmFkaXVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlU2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIEdhdWdlQXhpc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWdhdWdlLWF4aXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJyb3RhdGVcXFwiPlxcbiAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHRpY2sgb2YgdGlja3MuYmlnXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJnYXVnZS10aWNrIGdhdWdlLXRpY2stbGFyZ2VcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6cGF0aCBbYXR0ci5kXT1cXFwidGljay5saW5lXFxcIiAvPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCB0aWNrIG9mIHRpY2tzLmJpZ1xcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwiZ2F1Z2UtdGljayBnYXVnZS10aWNrLWxhcmdlXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgICAgICAgW3N0eWxlLnRleHRBbmNob3JdPVxcXCJ0aWNrLnRleHRBbmNob3JcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRpY2sudGV4dFRyYW5zZm9ybVxcXCJcXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LWJhc2VsaW5lPVxcXCJjZW50cmFsXFxcIj5cXG4gICAgICAgICAgICAgICAge3t0aWNrLnRleHR9fVxcbiAgICAgICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHRpY2sgb2YgdGlja3Muc21hbGxcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcImdhdWdlLXRpY2sgZ2F1Z2UtdGljay1zbWFsbFxcXCI+XFxuICAgICAgICAgICAgPHN2ZzpwYXRoIFthdHRyLmRdPVxcXCJ0aWNrLmxpbmVcXFwiIC8+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gR2F1Z2VBeGlzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIEdhdWdlTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR2F1Z2VNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBHYXVnZU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NoYXJ0Q29tbW9uTW9kdWxlLCBQaWVDaGFydE1vZHVsZSwgQmFyQ2hhcnRNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIExpbmVhckdhdWdlQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgR2F1Z2VDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBHYXVnZUFyY0NvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEdhdWdlQXhpc0NvbXBvbmVudFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgICAgICAgICBMaW5lYXJHYXVnZUNvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEdhdWdlQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgR2F1Z2VBcmNDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBHYXVnZUF4aXNDb21wb25lbnRcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBHYXVnZU1vZHVsZSk7XHJcbiAgICByZXR1cm4gR2F1Z2VNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG52YXIgTmd4Q2hhcnRzTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmd4Q2hhcnRzTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTmd4Q2hhcnRzTW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgICAgICAgICBDaGFydENvbW1vbk1vZHVsZSxcclxuICAgICAgICAgICAgICAgIEFyZWFDaGFydE1vZHVsZSxcclxuICAgICAgICAgICAgICAgIEJhckNoYXJ0TW9kdWxlLFxyXG4gICAgICAgICAgICAgICAgQnViYmxlQ2hhcnRNb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBGb3JjZURpcmVjdGVkR3JhcGhNb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBIZWF0TWFwTW9kdWxlLFxyXG4gICAgICAgICAgICAgICAgTGluZUNoYXJ0TW9kdWxlLFxyXG4gICAgICAgICAgICAgICAgUG9sYXJDaGFydE1vZHVsZSxcclxuICAgICAgICAgICAgICAgIE51bWJlckNhcmRNb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBQaWVDaGFydE1vZHVsZSxcclxuICAgICAgICAgICAgICAgIFRyZWVNYXBNb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBHYXVnZU1vZHVsZVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE5neENoYXJ0c01vZHVsZSk7XHJcbiAgICByZXR1cm4gTmd4Q2hhcnRzTW9kdWxlO1xyXG59KCkpO1xyXG5cclxuZnVuY3Rpb24gdGlja0Zvcm1hdChmaWVsZFR5cGUsIGdyb3VwQnlUeXBlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGxhYmVsKSB7XHJcbiAgICAgICAgaWYgKGxhYmVsID09PSAnTm8gVmFsdWUnIHx8IGxhYmVsID09PSAnT3RoZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpZWxkVHlwZSA9PT0gJ2RhdGUnICYmIGdyb3VwQnlUeXBlID09PSAnZ3JvdXBCeScpIHtcclxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IHRpbWVGb3JtYXQoJ01NL0REL1lZWVknKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlcihsYWJlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsYWJlbC50b1N0cmluZygpO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IHsgTmd4Q2hhcnRzTW9kdWxlLCBDaGFydENvbW1vbk1vZHVsZSwgTGVnZW5kQ29tcG9uZW50LCBTY2FsZUxlZ2VuZENvbXBvbmVudCwgTGVnZW5kRW50cnlDb21wb25lbnQsIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LCBUb29sdGlwTW9kdWxlLCBUb29sdGlwU2VydmljZSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQsIFRvb2x0aXBEaXJlY3RpdmUsIFN0eWxlVHlwZXMsIEFsaWdubWVudFR5cGVzLCBTaG93VHlwZXMsIEF4ZXNNb2R1bGUsIEF4aXNMYWJlbENvbXBvbmVudCwgWEF4aXNDb21wb25lbnQsIFhBeGlzVGlja3NDb21wb25lbnQsIFlBeGlzQ29tcG9uZW50LCBZQXhpc1RpY2tzQ29tcG9uZW50LCByZWR1Y2VUaWNrcywgQ291bnRVcERpcmVjdGl2ZSwgY291bnQsIGRlY2ltYWxDaGVja2VyLCBUaW1lbGluZSwgQ29sb3JIZWxwZXIsIENoYXJ0Q29tcG9uZW50LCBBcmVhQ29tcG9uZW50LCBCYXNlQ2hhcnRDb21wb25lbnQsIENpcmNsZUNvbXBvbmVudCwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LCBncmlkU2l6ZSwgZ3JpZExheW91dCwgR3JpZFBhbmVsQ29tcG9uZW50LCBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQsIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50LCBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudCwgVG9vbHRpcEFyZWEsIHRpY2tGb3JtYXQsIHRyaW1MYWJlbCwgY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMsIGZvcm1hdExhYmVsLCBnZXRVbmlxdWVYRG9tYWluVmFsdWVzLCBnZXRTY2FsZVR5cGUsIEFyZWFDaGFydE1vZHVsZSwgQXJlYUNoYXJ0Q29tcG9uZW50LCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LCBBcmVhU2VyaWVzQ29tcG9uZW50LCBCYXJDaGFydE1vZHVsZSwgQmFyQ29tcG9uZW50LCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQsIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudCwgU2VyaWVzSG9yaXpvbnRhbCwgQmFyTGFiZWxDb21wb25lbnQsIEJhclZlcnRpY2FsQ29tcG9uZW50LCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQsIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudCwgRDBUeXBlcywgU2VyaWVzVmVydGljYWxDb21wb25lbnQsIEJ1YmJsZUNoYXJ0TW9kdWxlLCBCdWJibGVDaGFydENvbXBvbmVudCwgZ2V0RG9tYWluLCBnZXRTY2FsZSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LCBGb3JjZURpcmVjdGVkR3JhcGhNb2R1bGUsIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudCwgSGVhdE1hcE1vZHVsZSwgSGVhdE1hcENvbXBvbmVudCwgSGVhdE1hcENlbGxDb21wb25lbnQsIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LCBMaW5lQ2hhcnRNb2R1bGUsIExpbmVDaGFydENvbXBvbmVudCwgTGluZUNvbXBvbmVudCwgTGluZVNlcmllc0NvbXBvbmVudCwgUG9sYXJDaGFydE1vZHVsZSwgUG9sYXJDaGFydENvbXBvbmVudCwgUG9sYXJTZXJpZXNDb21wb25lbnQsIE51bWJlckNhcmRNb2R1bGUsIE51bWJlckNhcmRDb21wb25lbnQsIENhcmRDb21wb25lbnQsIENhcmRTZXJpZXNDb21wb25lbnQsIFBpZUNoYXJ0TW9kdWxlLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LCBQaWVDaGFydENvbXBvbmVudCwgUGllQXJjQ29tcG9uZW50LCBQaWVHcmlkQ29tcG9uZW50LCBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LCBQaWVTZXJpZXNDb21wb25lbnQsIFBpZUxhYmVsQ29tcG9uZW50LCBUcmVlTWFwTW9kdWxlLCBUcmVlTWFwQ29tcG9uZW50LCBUcmVlTWFwQ2VsbENvbXBvbmVudCwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQsIEdhdWdlTW9kdWxlLCBHYXVnZUFyY0NvbXBvbmVudCwgR2F1Z2VBeGlzQ29tcG9uZW50LCBHYXVnZUNvbXBvbmVudCwgTGluZWFyR2F1Z2VDb21wb25lbnQgfTtcclxuIl19