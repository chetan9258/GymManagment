import { CellClassFunc, CellClassRules, CellClickedEvent, CellContextMenuEvent, CellDoubleClickedEvent, CellEditorSelectorFunc, CellRendererSelectorFunc, CellStyle, CellStyleFunc, CheckboxSelectionCallback, ColDef, ColGroupDef, ColSpanParams, ColumnsMenuParams, DndSourceCallback, DndSourceOnRowDragParams, EditableCallback, GetQuickFilterTextParams, HeaderCheckboxSelectionCallback, HeaderClass, HeaderValueGetterFunc, IAggFunc, ICellRendererComp, ICellRendererFunc, IRowDragItem, ITooltipParams, KeyCreatorParams, NewValueParams, RowDragCallback, RowNode, RowSpanParams, SuppressHeaderKeyboardEventParams, SuppressKeyboardEventParams, SuppressNavigableCallback, SuppressPasteCallback, ToolPanelClass, ValueFormatterFunc, ValueGetterFunc, ValueParserFunc, ValueSetterFunc } from "ag-grid-community";
import { QueryList } from "@angular/core";
import * as ɵngcc0 from '@angular/core';
export declare class AgGridColumn {
    childColumns: QueryList<AgGridColumn>;
    hasChildColumns(): boolean;
    toColDef(): ColDef;
    private getChildColDefs;
    private createColDefFromGridColumn;
    filterFramework: any;
    filterParams: any;
    floatingFilterComponent: any;
    floatingFilterComponentParams: any;
    floatingFilterComponentFramework: any;
    floatingFilterFramework: any;
    filter: any;
    /** The name to render in the column header. If not specified and field is specified, the field name will be used as the header name.     */
    headerName: string | undefined;
    /** Function or expression. Gets the value for display in the header.     */
    headerValueGetter: string | HeaderValueGetterFunc | undefined;
    /** Tooltip for the column header     */
    headerTooltip: string | undefined;
    /** CSS class to use for the header cell. Can be a string, array of strings, or function.     */
    headerClass: HeaderClass | undefined;
    /** Suppress the grid taking action for the relevant keyboard event when a header is focused.     */
    suppressHeaderKeyboardEvent: ((params: SuppressHeaderKeyboardEventParams) => boolean) | undefined;
    /** Whether to show the column when the group is open / closed.     */
    columnGroupShow: string | undefined;
    /** CSS class to use for the tool panel cell. Can be a string, array of strings, or function.     */
    toolPanelClass: ToolPanelClass | undefined;
    /** Set to `true` if you do not want this column or group to appear in the Columns Tool Panel. Default: `false`     */
    suppressColumnsToolPanel: boolean | undefined;
    /** Set to `true` if you do not want this column (filter) or group (filter group) to appear in the Filters Tool Panel. Default: `false`     */
    suppressFiltersToolPanel: boolean | undefined;
    /** Provide your own tooltip component for the column.
     * See [Tooltip Component](https://www.ag-grid.com/javascript-data-grid/component-tooltip/) for framework specific implementation details.     */
    tooltipComponent: any;
    /** @deprecated As of v27, use `tooltipComponent` for framework components too.
     */
    tooltipComponentFramework: any;
    /** The params used to configure `tooltipComponent`.     */
    tooltipComponentParams: any;
    /** A list containing a mix of columns and column groups.     */
    children: (ColDef | ColGroupDef)[] | undefined;
    /** The unique ID to give the column. This is optional. If missing, a unique ID will be generated. This ID is used to identify the column group in the column API.     */
    groupId: string | undefined;
    /** Set to `true` if this group should be opened by default. Default: `false`     */
    openByDefault: boolean | undefined;
    /** Set to `true` to keep columns in this group beside each other in the grid. Moving the columns outside of the group (and hence breaking the group) is not allowed. Default: `false`     */
    marryChildren: boolean | undefined;
    /** The custom header group component to be used for rendering the component header. If none specified the default AG Grid is used.
     * See [Header Group Component](https://www.ag-grid.com/javascript-data-grid/component-header/#header-group-components/) for framework specific implementation details.     */
    headerGroupComponent: any;
    /** @deprecated As of v27, use `headerGroupComponent` for framework components too.
     */
    headerGroupComponentFramework: any;
    /** The params used to configure the `headerGroupComponent`.     */
    headerGroupComponentParams: any;
    /** The unique ID to give the column. This is optional. If missing, the ID will default to the field.
     * If both field and colId are missing, a unique ID will be generated.
     * This ID is used to identify the column in the API for sorting, filtering etc.     */
    colId: string | undefined;
    /** The field of the row to get the cells data from     */
    field: string | undefined;
    /** A comma separated string or array of strings containing `ColumnType` keys which can be used as a template for a column.
     * This helps to reduce duplication of properties when you have a lot of common column properties.     */
    type: string | string[] | undefined;
    /** Function or expression. Gets the value from your data for display.     */
    valueGetter: string | ValueGetterFunc | undefined;
    /** A function or expression to format a value, should return a string. Not used for CSV export or copy to clipboard, only for UI cell rendering.     */
    valueFormatter: string | ValueFormatterFunc | undefined;
    /** Provided a reference data map to be used to map column values to their respective value from the map.     */
    refData: {
        [key: string]: string;
    } | undefined;
    /** Function to return a string key for a value.
     * This string is used for grouping, Set filtering, and searching within cell editor dropdowns.
     * When filtering and searching the string is exposed to the user, so make sure to return a human-readable value.     */
    keyCreator: ((params: KeyCreatorParams) => string) | undefined;
    /** Custom comparator for values, used by renderer to know if values have changed. Cells who's values have not changed don't get refreshed.
     * By default the grid uses `===` is used which should work for most use cases.     */
    equals: ((valueA: any, valueB: any) => boolean) | undefined;
    /** The field of the tooltip to apply to the cell.     */
    tooltipField: string | undefined;
    /** Callback that should return the string to use for a tooltip, `tooltipField` takes precedence if set.
     * If using a custom `tooltipComponent` you may return any custom value to be passed to your tooltip component.     */
    tooltipValueGetter: ((params: ITooltipParams) => string | any) | undefined;
    /** `boolean` or `Function`. Set to `true` (or return `true` from function) to render a selection checkbox in the column. Default: `false`     */
    checkboxSelection: boolean | CheckboxSelectionCallback | undefined;
    /** Icons to use inside the column instead of the grid's default icons. Leave undefined to use defaults.     */
    icons: {
        [key: string]: Function | string;
    } | undefined;
    /** Set to `true` if this column is not navigable (i.e. cannot be tabbed into), otherwise `false`.
     * Can also be a callback function to have different rows navigable.
     * Default: `false`     */
    suppressNavigable: boolean | SuppressNavigableCallback | undefined;
    /** Allows the user to suppress certain keyboard events in the grid cell. Default: `false`     */
    suppressKeyboardEvent: ((params: SuppressKeyboardEventParams) => boolean) | undefined;
    /** Pasting is on by default as long as cells are editable (non-editable cells cannot be modified, even with a paste operation).
     * Set to `true` turn paste operations off.     */
    suppressPaste: boolean | SuppressPasteCallback | undefined;
    /** Set to true to prevent the fillHandle from being rendered in any cell that belongs to this column     */
    suppressFillHandle: boolean | undefined;
    /** Set to `true` for this column to be hidden. Default: `false`     */
    hide: boolean | undefined;
    /** Same as `hide`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialHide: boolean | undefined;
    /** Set to `true` to block making column visible / hidden via the UI (API will still work). Default: `false`     */
    lockVisible: boolean | undefined;
    /** Set to `true` to always have this column displayed first. Default: `false`     */
    lockPosition: boolean | undefined;
    /** Set to `true` if you do not want this column to be movable via dragging. Default: `false`     */
    suppressMovable: boolean | undefined;
    /** Set to `true` if this column is editable, otherwise `false`. Can also be a function to have different rows editable. Default: `false`     */
    editable: boolean | EditableCallback | undefined;
    /** Function or expression. Sets the value into your data for saving. Return `true` if the data changed.     */
    valueSetter: string | ValueSetterFunc | undefined;
    /** Function or expression. Parses the value for saving.     */
    valueParser: string | ValueParserFunc | undefined;
    /** Provide your own cell editor component for this column's cells.
     * See [Cell Editor](https://www.ag-grid.com/javascript-data-grid/component-cell-editor/) for framework specific implementation detail.     */
    cellEditor: any;
    /** @deprecated As of v27, use `cellEditor` for framework components too.
     */
    cellEditorFramework: any;
    /** Params to be passed to the `cellEditor` component.     */
    cellEditorParams: any;
    /** Callback to select which cell editor to be used for a given row within the same column.     */
    cellEditorSelector: CellEditorSelectorFunc | undefined;
    /** Set to `true` to have cells under this column enter edit mode after single click. Default: `false`     */
    singleClickEdit: boolean | undefined;
    /** @deprecated use `valueSetter` instead
     */
    newValueHandler: ((params: NewValueParams) => boolean) | undefined;
    /** Set to `true`, to have the cell editor appear in a popup.     */
    cellEditorPopup: boolean | undefined;
    /** Set the position for the popup cell editor. Possible values are
     *   - `over` Popup will be positioned over the cell
     *   - `under` Popup will be positioned below the cell leaving the cell value visible.
     *
     * Default: `over`.     */
    cellEditorPopupPosition: string | undefined;
    /** Callback for after the value of a cell has changed, either due to editing or the application calling `api.setValue()`.     */
    onCellValueChanged: ((event: NewValueParams) => void) | undefined;
    /** Callback called when a cell is clicked.     */
    onCellClicked: ((event: CellClickedEvent) => void) | undefined;
    /** Callback called when a cell is double clicked.     */
    onCellDoubleClicked: ((event: CellDoubleClickedEvent) => void) | undefined;
    /** Callback called when a cell is right clicked.     */
    onCellContextMenu: ((event: CellContextMenuEvent) => void) | undefined;
    /** A function to tell the grid what quick filter text to use for this column if you don't want to use the default (which is calling `toString` on the value).     */
    getQuickFilterText: ((params: GetQuickFilterTextParams) => string) | undefined;
    /** Function or expression. Gets the value for filtering purposes.     */
    filterValueGetter: string | ValueGetterFunc | undefined;
    /** Whether to display a floating filter for this column. Default: `false`     */
    floatingFilter: boolean | undefined;
    /**     */
    /** The custom header component to be used for rendering the component header. If none specified the default AG Grid header component is used.
         * See [Header Component](https://www.ag-grid.com/javascript-data-grid/component-header/) for framework specific implementation detail.     */
    headerComponent: any;
    /** @deprecated As of v27, use `headerComponent` for framework components too.
     */
    headerComponentFramework: any;
    /** The parameters to be passed to the `headerComponent`.     */
    headerComponentParams: any;
    /** Set to an array containing zero, one or many of the following options: `'filterMenuTab' | 'generalMenuTab' | 'columnsMenuTab'`.
     * This is used to figure out which menu tabs are present and in which order the tabs are shown.     */
    menuTabs: string[] | undefined;
    /** Params used to change the behaviour and appearance of the Columns Menu tab.     */
    columnsMenuParams: ColumnsMenuParams | undefined;
    /** Set to `true` if no menu should be shown for this column header. Default: `false`     */
    suppressMenu: boolean | undefined;
    /** If `true` or the callback returns `true`, a 'select all' checkbox will be put into the header.     */
    headerCheckboxSelection: boolean | HeaderCheckboxSelectionCallback | undefined;
    /** If `true`, the header checkbox selection will only select filtered items.     */
    headerCheckboxSelectionFilteredOnly: boolean | undefined;
    /** Defines the chart data type that should be used for a column.     */
    chartDataType: 'category' | 'series' | 'time' | 'excluded' | undefined;
    /** Pin a column to one side: `right` or `left`. A value of `true` is converted to `'left'`.     */
    pinned: boolean | string | null | undefined;
    /** Same as `pinned`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialPinned: boolean | string | undefined;
    /** Set to true to block the user pinning the column, the column can only be pinned via definitions or API. Default: `false`     */
    lockPinned: boolean | undefined;
    /** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.
     */
    pinnedRowCellRenderer: {
        new (): ICellRendererComp;
    } | ICellRendererFunc | string | undefined;
    /** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.
     */
    pinnedRowCellRendererFramework: any;
    /** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.
     */
    pinnedRowCellRendererParams: any;
    /** @deprecated Use valueFormatter for pinned rows, and check params.node.rowPinned.
     */
    pinnedRowValueFormatter: string | ValueFormatterFunc | undefined;
    /** Set to true to pivot by this column.     */
    pivot: boolean | undefined;
    /** Same as `pivot`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialPivot: boolean | undefined;
    /** Set this in columns you want to pivot by.
     * If only pivoting by one column, set this to any number (e.g. `0`).
     * If pivoting by multiple columns, set this to where you want this column to be in the order of pivots (e.g. `0` for first, `1` for second, and so on).     */
    pivotIndex: number | null | undefined;
    /** Same as `pivotIndex`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialPivotIndex: number | undefined;
    /** Comparator to use when ordering the pivot columns, when this column is used to pivot on.
     * The values will always be strings, as the pivot service uses strings as keys for the pivot groups.     */
    pivotComparator: ((valueA: string, valueB: string) => number) | undefined;
    /** Set to `true` if you want to be able to pivot by this column via the GUI. This will not block the API or properties being used to achieve pivot. Default: `false`     */
    enablePivot: boolean | undefined;
    /** An object of css values / or function returning an object of css values for a particular cell.     */
    cellStyle: CellStyle | CellStyleFunc | undefined;
    /** Class to use for the cell. Can be string, array of strings, or function that returns a string or array of strings.     */
    cellClass: string | string[] | CellClassFunc | undefined;
    /** Rules which can be applied to include certain CSS classes.     */
    cellClassRules: CellClassRules | undefined;
    /** Provide your own cell Renderer component for this column's cells.
     * See [Cell Renderer](https://www.ag-grid.com/javascript-data-grid/component-cell-renderer/) for framework specific implementation details.     */
    cellRenderer: any;
    /** @deprecated As of v27, use `cellRenderer` for framework components too.
     */
    cellRendererFramework: any;
    /** Params to be passed to the `cellRenderer` component.     */
    cellRendererParams: any;
    /** Callback to select which cell renderer to be used for a given row within the same column.     */
    cellRendererSelector: CellRendererSelectorFunc | undefined;
    /** Set to `true` to have the grid calculate the height of a row based on contents of this column. Default: `false`     */
    autoHeight: boolean | undefined;
    /** Set to `true` to have the text wrap inside the cell - typically used with `autoHeight`. Default: `false`     */
    wrapText: boolean | undefined;
    /** Set to `true` to flash a cell when it's refreshed. Default: `false`     */
    enableCellChangeFlash: boolean | undefined;
    /** Set to `true` to prevent this column from flashing on changes. Only applicable if cell flashing is turned on for the grid. Default: `false`     */
    suppressCellFlash: boolean | undefined;
    /** `boolean` or `Function`. Set to `true` (or return `true` from function) to allow row dragging. Default: `false`     */
    rowDrag: boolean | RowDragCallback | undefined;
    /** A callback that should return a string to be displayed by the `rowDragComp` while dragging a row.
     * If this callback is not set, the current cell value will be used.     */
    rowDragText: ((params: IRowDragItem, dragItemCount: number) => string) | undefined;
    /** `boolean` or `Function`. Set to `true` (or return `true` from function) to allow dragging for native drag and drop. Default: `false`     */
    dndSource: boolean | DndSourceCallback | undefined;
    /** Function to allow custom drag functionality for native drag and drop.     */
    dndSourceOnRowDrag: ((params: DndSourceOnRowDragParams) => void) | undefined;
    /** Set to `true` to row group by this column. Default: `false`     */
    rowGroup: boolean | undefined;
    /** Same as `rowGroup`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialRowGroup: boolean | undefined;
    /** Set this in columns you want to group by.
     * If only grouping by one column, set this to any number (e.g. `0`).
     * If grouping by multiple columns, set this to where you want this column to be in the group (e.g. `0` for first, `1` for second, and so on).     */
    rowGroupIndex: number | null | undefined;
    /** Same as `rowGroupIndex`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialRowGroupIndex: number | undefined;
    /** Set to `true` if you want to be able to row group by this column via the GUI.
     * This will not block the API or properties being used to achieve row grouping.
     * Default: `false`     */
    enableRowGroup: boolean | undefined;
    /** Set to `true` if you want to be able to aggregate by this column via the GUI.
     * This will not block the API or properties being used to achieve aggregation.
     * Default: `false`     */
    enableValue: boolean | undefined;
    /** Name of function to use for aggregation. You can also provide your own agg function.     */
    aggFunc: string | IAggFunc | null | undefined;
    /** Same as `aggFunc`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialAggFunc: string | IAggFunc | undefined;
    /** Aggregation functions allowed on this column e.g. `['sum', 'avg']`.
     * If missing, all installed functions are allowed.
     * This will only restrict what the GUI allows a user to select, it does not impact when you set a function via the API.     */
    allowedAggFuncs: string[] | undefined;
    /** Set to true to have the grid place the values for the group into the cell, or put the name of a grouped column to just show that group.     */
    showRowGroup: string | boolean | undefined;
    /** Set to `true` to allow sorting on this column. Default: `false`     */
    sortable: boolean | undefined;
    /** If sorting by default, set it here. Set to `asc` or `desc`.     */
    sort: 'asc' | 'desc' | null | undefined;
    /** Same as `sort`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialSort: 'asc' | 'desc' | null | undefined;
    /** If sorting more than one column by default, specifies order in which the sorting should be applied.     */
    sortIndex: number | null | undefined;
    /** Same as `sortIndex`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialSortIndex: number | undefined;
    /** Array defining the order in which sorting occurs (if sorting is enabled). An array with any of the following in any order `['asc','desc',null]`     */
    sortingOrder: ('asc' | 'desc' | null)[] | undefined;
    /** Comparator function for custom sorting.     */
    comparator: ((valueA: any, valueB: any, nodeA: RowNode, nodeB: RowNode, isInverted: boolean) => number) | undefined;
    /** Set to `true` if you want the unsorted icon to be shown when no sort is applied to this column. Default: `false`     */
    unSortIcon: boolean | undefined;
    /** @deprecated since v24 - use sortIndex instead
     */
    sortedAt: number | undefined;
    /** By default, each cell will take up the width of one column. You can change this behaviour to allow cells to span multiple columns.     */
    colSpan: ((params: ColSpanParams) => number) | undefined;
    /** By default, each cell will take up the height of one row. You can change this behaviour to allow cells to span multiple rows.     */
    rowSpan: ((params: RowSpanParams) => number) | undefined;
    /** Initial width in pixels for the cell.     */
    width: number | undefined;
    /** Same as `width`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialWidth: number | undefined;
    /** Minimum width in pixels for the cell.     */
    minWidth: number | undefined;
    /** Maximum width in pixels for the cell.     */
    maxWidth: number | undefined;
    /** Used instead of `width` when the goal is to fill the remaining empty space of the grid.     */
    flex: number | undefined;
    /** Same as `flex`, except only applied when creating a new column. Not applied when updating column definitions.     */
    initialFlex: number | undefined;
    /** Set to `true` to allow this column should be resized. Default: `false`     */
    resizable: boolean | undefined;
    /** Set to `true` if you want this column's width to be fixed during 'size to fit' operations. Default: `false`     */
    suppressSizeToFit: boolean | undefined;
    /** Set to `true` if you do not want this column to be auto-resizable by double clicking it's edge. Default: `false`     */
    suppressAutoSize: boolean | undefined;
    static ngAcceptInputType_suppressCellFlash: boolean | null | '';
    static ngAcceptInputType_suppressColumnsToolPanel: boolean | null | '';
    static ngAcceptInputType_suppressFiltersToolPanel: boolean | null | '';
    static ngAcceptInputType_openByDefault: boolean | null | '';
    static ngAcceptInputType_marryChildren: boolean | null | '';
    static ngAcceptInputType_hide: boolean | null | '';
    static ngAcceptInputType_initialHide: boolean | null | '';
    static ngAcceptInputType_rowGroup: boolean | null | '';
    static ngAcceptInputType_initialRowGroup: boolean | null | '';
    static ngAcceptInputType_pivot: boolean | null | '';
    static ngAcceptInputType_initialPivot: boolean | null | '';
    static ngAcceptInputType_checkboxSelection: boolean | null | '';
    static ngAcceptInputType_headerCheckboxSelection: boolean | null | '';
    static ngAcceptInputType_headerCheckboxSelectionFilteredOnly: boolean | null | '';
    static ngAcceptInputType_suppressMenu: boolean | null | '';
    static ngAcceptInputType_suppressMovable: boolean | null | '';
    static ngAcceptInputType_lockPosition: boolean | null | '';
    static ngAcceptInputType_lockVisible: boolean | null | '';
    static ngAcceptInputType_lockPinned: boolean | null | '';
    static ngAcceptInputType_unSortIcon: boolean | null | '';
    static ngAcceptInputType_suppressSizeToFit: boolean | null | '';
    static ngAcceptInputType_suppressAutoSize: boolean | null | '';
    static ngAcceptInputType_enableRowGroup: boolean | null | '';
    static ngAcceptInputType_enablePivot: boolean | null | '';
    static ngAcceptInputType_enableValue: boolean | null | '';
    static ngAcceptInputType_editable: boolean | null | '';
    static ngAcceptInputType_suppressPaste: boolean | null | '';
    static ngAcceptInputType_suppressNavigable: boolean | null | '';
    static ngAcceptInputType_enableCellChangeFlash: boolean | null | '';
    static ngAcceptInputType_rowDrag: boolean | null | '';
    static ngAcceptInputType_dndSource: boolean | null | '';
    static ngAcceptInputType_autoHeight: boolean | null | '';
    static ngAcceptInputType_wrapText: boolean | null | '';
    static ngAcceptInputType_sortable: boolean | null | '';
    static ngAcceptInputType_resizable: boolean | null | '';
    static ngAcceptInputType_singleClickEdit: boolean | null | '';
    static ngAcceptInputType_floatingFilter: boolean | null | '';
    static ngAcceptInputType_cellEditorPopup: boolean | null | '';
    static ngAcceptInputType_suppressFillHandle: boolean | null | '';
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgGridColumn, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<AgGridColumn, "ag-grid-column", never, { "filterFramework": "filterFramework"; "filterParams": "filterParams"; "floatingFilterComponent": "floatingFilterComponent"; "floatingFilterComponentParams": "floatingFilterComponentParams"; "floatingFilterComponentFramework": "floatingFilterComponentFramework"; "floatingFilterFramework": "floatingFilterFramework"; "filter": "filter"; "headerName": "headerName"; "headerValueGetter": "headerValueGetter"; "headerTooltip": "headerTooltip"; "headerClass": "headerClass"; "suppressHeaderKeyboardEvent": "suppressHeaderKeyboardEvent"; "columnGroupShow": "columnGroupShow"; "toolPanelClass": "toolPanelClass"; "suppressColumnsToolPanel": "suppressColumnsToolPanel"; "suppressFiltersToolPanel": "suppressFiltersToolPanel"; "tooltipComponent": "tooltipComponent"; "tooltipComponentFramework": "tooltipComponentFramework"; "tooltipComponentParams": "tooltipComponentParams"; "children": "children"; "groupId": "groupId"; "openByDefault": "openByDefault"; "marryChildren": "marryChildren"; "headerGroupComponent": "headerGroupComponent"; "headerGroupComponentFramework": "headerGroupComponentFramework"; "headerGroupComponentParams": "headerGroupComponentParams"; "colId": "colId"; "field": "field"; "type": "type"; "valueGetter": "valueGetter"; "valueFormatter": "valueFormatter"; "refData": "refData"; "keyCreator": "keyCreator"; "equals": "equals"; "tooltipField": "tooltipField"; "tooltipValueGetter": "tooltipValueGetter"; "checkboxSelection": "checkboxSelection"; "icons": "icons"; "suppressNavigable": "suppressNavigable"; "suppressKeyboardEvent": "suppressKeyboardEvent"; "suppressPaste": "suppressPaste"; "suppressFillHandle": "suppressFillHandle"; "hide": "hide"; "initialHide": "initialHide"; "lockVisible": "lockVisible"; "lockPosition": "lockPosition"; "suppressMovable": "suppressMovable"; "editable": "editable"; "valueSetter": "valueSetter"; "valueParser": "valueParser"; "cellEditor": "cellEditor"; "cellEditorFramework": "cellEditorFramework"; "cellEditorParams": "cellEditorParams"; "cellEditorSelector": "cellEditorSelector"; "singleClickEdit": "singleClickEdit"; "newValueHandler": "newValueHandler"; "cellEditorPopup": "cellEditorPopup"; "cellEditorPopupPosition": "cellEditorPopupPosition"; "onCellValueChanged": "onCellValueChanged"; "onCellClicked": "onCellClicked"; "onCellDoubleClicked": "onCellDoubleClicked"; "onCellContextMenu": "onCellContextMenu"; "getQuickFilterText": "getQuickFilterText"; "filterValueGetter": "filterValueGetter"; "floatingFilter": "floatingFilter"; "headerComponent": "headerComponent"; "headerComponentFramework": "headerComponentFramework"; "headerComponentParams": "headerComponentParams"; "menuTabs": "menuTabs"; "columnsMenuParams": "columnsMenuParams"; "suppressMenu": "suppressMenu"; "headerCheckboxSelection": "headerCheckboxSelection"; "headerCheckboxSelectionFilteredOnly": "headerCheckboxSelectionFilteredOnly"; "chartDataType": "chartDataType"; "pinned": "pinned"; "initialPinned": "initialPinned"; "lockPinned": "lockPinned"; "pinnedRowCellRenderer": "pinnedRowCellRenderer"; "pinnedRowCellRendererFramework": "pinnedRowCellRendererFramework"; "pinnedRowCellRendererParams": "pinnedRowCellRendererParams"; "pinnedRowValueFormatter": "pinnedRowValueFormatter"; "pivot": "pivot"; "initialPivot": "initialPivot"; "pivotIndex": "pivotIndex"; "initialPivotIndex": "initialPivotIndex"; "pivotComparator": "pivotComparator"; "enablePivot": "enablePivot"; "cellStyle": "cellStyle"; "cellClass": "cellClass"; "cellClassRules": "cellClassRules"; "cellRenderer": "cellRenderer"; "cellRendererFramework": "cellRendererFramework"; "cellRendererParams": "cellRendererParams"; "cellRendererSelector": "cellRendererSelector"; "autoHeight": "autoHeight"; "wrapText": "wrapText"; "enableCellChangeFlash": "enableCellChangeFlash"; "suppressCellFlash": "suppressCellFlash"; "rowDrag": "rowDrag"; "rowDragText": "rowDragText"; "dndSource": "dndSource"; "dndSourceOnRowDrag": "dndSourceOnRowDrag"; "rowGroup": "rowGroup"; "initialRowGroup": "initialRowGroup"; "rowGroupIndex": "rowGroupIndex"; "initialRowGroupIndex": "initialRowGroupIndex"; "enableRowGroup": "enableRowGroup"; "enableValue": "enableValue"; "aggFunc": "aggFunc"; "initialAggFunc": "initialAggFunc"; "allowedAggFuncs": "allowedAggFuncs"; "showRowGroup": "showRowGroup"; "sortable": "sortable"; "sort": "sort"; "initialSort": "initialSort"; "sortIndex": "sortIndex"; "initialSortIndex": "initialSortIndex"; "sortingOrder": "sortingOrder"; "comparator": "comparator"; "unSortIcon": "unSortIcon"; "sortedAt": "sortedAt"; "colSpan": "colSpan"; "rowSpan": "rowSpan"; "width": "width"; "initialWidth": "initialWidth"; "minWidth": "minWidth"; "maxWidth": "maxWidth"; "flex": "flex"; "initialFlex": "initialFlex"; "resizable": "resizable"; "suppressSizeToFit": "suppressSizeToFit"; "suppressAutoSize": "suppressAutoSize"; }, {}, ["childColumns"], never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWctZ3JpZC1jb2x1bW4uY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImFnLWdyaWQtY29sdW1uLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2VsbENsYXNzRnVuYywgQ2VsbENsYXNzUnVsZXMsIENlbGxDbGlja2VkRXZlbnQsIENlbGxDb250ZXh0TWVudUV2ZW50LCBDZWxsRG91YmxlQ2xpY2tlZEV2ZW50LCBDZWxsRWRpdG9yU2VsZWN0b3JGdW5jLCBDZWxsUmVuZGVyZXJTZWxlY3RvckZ1bmMsIENlbGxTdHlsZSwgQ2VsbFN0eWxlRnVuYywgQ2hlY2tib3hTZWxlY3Rpb25DYWxsYmFjaywgQ29sRGVmLCBDb2xHcm91cERlZiwgQ29sU3BhblBhcmFtcywgQ29sdW1uc01lbnVQYXJhbXMsIERuZFNvdXJjZUNhbGxiYWNrLCBEbmRTb3VyY2VPblJvd0RyYWdQYXJhbXMsIEVkaXRhYmxlQ2FsbGJhY2ssIEdldFF1aWNrRmlsdGVyVGV4dFBhcmFtcywgSGVhZGVyQ2hlY2tib3hTZWxlY3Rpb25DYWxsYmFjaywgSGVhZGVyQ2xhc3MsIEhlYWRlclZhbHVlR2V0dGVyRnVuYywgSUFnZ0Z1bmMsIElDZWxsUmVuZGVyZXJDb21wLCBJQ2VsbFJlbmRlcmVyRnVuYywgSVJvd0RyYWdJdGVtLCBJVG9vbHRpcFBhcmFtcywgS2V5Q3JlYXRvclBhcmFtcywgTmV3VmFsdWVQYXJhbXMsIFJvd0RyYWdDYWxsYmFjaywgUm93Tm9kZSwgUm93U3BhblBhcmFtcywgU3VwcHJlc3NIZWFkZXJLZXlib2FyZEV2ZW50UGFyYW1zLCBTdXBwcmVzc0tleWJvYXJkRXZlbnRQYXJhbXMsIFN1cHByZXNzTmF2aWdhYmxlQ2FsbGJhY2ssIFN1cHByZXNzUGFzdGVDYWxsYmFjaywgVG9vbFBhbmVsQ2xhc3MsIFZhbHVlRm9ybWF0dGVyRnVuYywgVmFsdWVHZXR0ZXJGdW5jLCBWYWx1ZVBhcnNlckZ1bmMsIFZhbHVlU2V0dGVyRnVuYyB9IGZyb20gXCJhZy1ncmlkLWNvbW11bml0eVwiO1xyXG5pbXBvcnQgeyBRdWVyeUxpc3QgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBBZ0dyaWRDb2x1bW4ge1xyXG4gICAgY2hpbGRDb2x1bW5zOiBRdWVyeUxpc3Q8QWdHcmlkQ29sdW1uPjtcclxuICAgIGhhc0NoaWxkQ29sdW1ucygpOiBib29sZWFuO1xyXG4gICAgdG9Db2xEZWYoKTogQ29sRGVmO1xyXG4gICAgcHJpdmF0ZSBnZXRDaGlsZENvbERlZnM7XHJcbiAgICBwcml2YXRlIGNyZWF0ZUNvbERlZkZyb21HcmlkQ29sdW1uO1xyXG4gICAgZmlsdGVyRnJhbWV3b3JrOiBhbnk7XHJcbiAgICBmaWx0ZXJQYXJhbXM6IGFueTtcclxuICAgIGZsb2F0aW5nRmlsdGVyQ29tcG9uZW50OiBhbnk7XHJcbiAgICBmbG9hdGluZ0ZpbHRlckNvbXBvbmVudFBhcmFtczogYW55O1xyXG4gICAgZmxvYXRpbmdGaWx0ZXJDb21wb25lbnRGcmFtZXdvcms6IGFueTtcclxuICAgIGZsb2F0aW5nRmlsdGVyRnJhbWV3b3JrOiBhbnk7XHJcbiAgICBmaWx0ZXI6IGFueTtcclxuICAgIC8qKiBUaGUgbmFtZSB0byByZW5kZXIgaW4gdGhlIGNvbHVtbiBoZWFkZXIuIElmIG5vdCBzcGVjaWZpZWQgYW5kIGZpZWxkIGlzIHNwZWNpZmllZCwgdGhlIGZpZWxkIG5hbWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBoZWFkZXIgbmFtZS4gICAgICovXHJcbiAgICBoZWFkZXJOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogRnVuY3Rpb24gb3IgZXhwcmVzc2lvbi4gR2V0cyB0aGUgdmFsdWUgZm9yIGRpc3BsYXkgaW4gdGhlIGhlYWRlci4gICAgICovXHJcbiAgICBoZWFkZXJWYWx1ZUdldHRlcjogc3RyaW5nIHwgSGVhZGVyVmFsdWVHZXR0ZXJGdW5jIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFRvb2x0aXAgZm9yIHRoZSBjb2x1bW4gaGVhZGVyICAgICAqL1xyXG4gICAgaGVhZGVyVG9vbHRpcDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIENTUyBjbGFzcyB0byB1c2UgZm9yIHRoZSBoZWFkZXIgY2VsbC4gQ2FuIGJlIGEgc3RyaW5nLCBhcnJheSBvZiBzdHJpbmdzLCBvciBmdW5jdGlvbi4gICAgICovXHJcbiAgICBoZWFkZXJDbGFzczogSGVhZGVyQ2xhc3MgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU3VwcHJlc3MgdGhlIGdyaWQgdGFraW5nIGFjdGlvbiBmb3IgdGhlIHJlbGV2YW50IGtleWJvYXJkIGV2ZW50IHdoZW4gYSBoZWFkZXIgaXMgZm9jdXNlZC4gICAgICovXHJcbiAgICBzdXBwcmVzc0hlYWRlcktleWJvYXJkRXZlbnQ6ICgocGFyYW1zOiBTdXBwcmVzc0hlYWRlcktleWJvYXJkRXZlbnRQYXJhbXMpID0+IGJvb2xlYW4pIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFdoZXRoZXIgdG8gc2hvdyB0aGUgY29sdW1uIHdoZW4gdGhlIGdyb3VwIGlzIG9wZW4gLyBjbG9zZWQuICAgICAqL1xyXG4gICAgY29sdW1uR3JvdXBTaG93OiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogQ1NTIGNsYXNzIHRvIHVzZSBmb3IgdGhlIHRvb2wgcGFuZWwgY2VsbC4gQ2FuIGJlIGEgc3RyaW5nLCBhcnJheSBvZiBzdHJpbmdzLCBvciBmdW5jdGlvbi4gICAgICovXHJcbiAgICB0b29sUGFuZWxDbGFzczogVG9vbFBhbmVsQ2xhc3MgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIGB0cnVlYCBpZiB5b3UgZG8gbm90IHdhbnQgdGhpcyBjb2x1bW4gb3IgZ3JvdXAgdG8gYXBwZWFyIGluIHRoZSBDb2x1bW5zIFRvb2wgUGFuZWwuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICBzdXBwcmVzc0NvbHVtbnNUb29sUGFuZWw6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIGB0cnVlYCBpZiB5b3UgZG8gbm90IHdhbnQgdGhpcyBjb2x1bW4gKGZpbHRlcikgb3IgZ3JvdXAgKGZpbHRlciBncm91cCkgdG8gYXBwZWFyIGluIHRoZSBGaWx0ZXJzIFRvb2wgUGFuZWwuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICBzdXBwcmVzc0ZpbHRlcnNUb29sUGFuZWw6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogUHJvdmlkZSB5b3VyIG93biB0b29sdGlwIGNvbXBvbmVudCBmb3IgdGhlIGNvbHVtbi5cclxuICAgICAqIFNlZSBbVG9vbHRpcCBDb21wb25lbnRdKGh0dHBzOi8vd3d3LmFnLWdyaWQuY29tL2phdmFzY3JpcHQtZGF0YS1ncmlkL2NvbXBvbmVudC10b29sdGlwLykgZm9yIGZyYW1ld29yayBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLiAgICAgKi9cclxuICAgIHRvb2x0aXBDb21wb25lbnQ6IGFueTtcclxuICAgIC8qKiBAZGVwcmVjYXRlZCBBcyBvZiB2MjcsIHVzZSBgdG9vbHRpcENvbXBvbmVudGAgZm9yIGZyYW1ld29yayBjb21wb25lbnRzIHRvby5cclxuICAgICAqL1xyXG4gICAgdG9vbHRpcENvbXBvbmVudEZyYW1ld29yazogYW55O1xyXG4gICAgLyoqIFRoZSBwYXJhbXMgdXNlZCB0byBjb25maWd1cmUgYHRvb2x0aXBDb21wb25lbnRgLiAgICAgKi9cclxuICAgIHRvb2x0aXBDb21wb25lbnRQYXJhbXM6IGFueTtcclxuICAgIC8qKiBBIGxpc3QgY29udGFpbmluZyBhIG1peCBvZiBjb2x1bW5zIGFuZCBjb2x1bW4gZ3JvdXBzLiAgICAgKi9cclxuICAgIGNoaWxkcmVuOiAoQ29sRGVmIHwgQ29sR3JvdXBEZWYpW10gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogVGhlIHVuaXF1ZSBJRCB0byBnaXZlIHRoZSBjb2x1bW4uIFRoaXMgaXMgb3B0aW9uYWwuIElmIG1pc3NpbmcsIGEgdW5pcXVlIElEIHdpbGwgYmUgZ2VuZXJhdGVkLiBUaGlzIElEIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGNvbHVtbiBncm91cCBpbiB0aGUgY29sdW1uIEFQSS4gICAgICovXHJcbiAgICBncm91cElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIGB0cnVlYCBpZiB0aGlzIGdyb3VwIHNob3VsZCBiZSBvcGVuZWQgYnkgZGVmYXVsdC4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cclxuICAgIG9wZW5CeURlZmF1bHQ6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBrZWVwIGNvbHVtbnMgaW4gdGhpcyBncm91cCBiZXNpZGUgZWFjaCBvdGhlciBpbiB0aGUgZ3JpZC4gTW92aW5nIHRoZSBjb2x1bW5zIG91dHNpZGUgb2YgdGhlIGdyb3VwIChhbmQgaGVuY2UgYnJlYWtpbmcgdGhlIGdyb3VwKSBpcyBub3QgYWxsb3dlZC4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cclxuICAgIG1hcnJ5Q2hpbGRyZW46IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogVGhlIGN1c3RvbSBoZWFkZXIgZ3JvdXAgY29tcG9uZW50IHRvIGJlIHVzZWQgZm9yIHJlbmRlcmluZyB0aGUgY29tcG9uZW50IGhlYWRlci4gSWYgbm9uZSBzcGVjaWZpZWQgdGhlIGRlZmF1bHQgQUcgR3JpZCBpcyB1c2VkLlxyXG4gICAgICogU2VlIFtIZWFkZXIgR3JvdXAgQ29tcG9uZW50XShodHRwczovL3d3dy5hZy1ncmlkLmNvbS9qYXZhc2NyaXB0LWRhdGEtZ3JpZC9jb21wb25lbnQtaGVhZGVyLyNoZWFkZXItZ3JvdXAtY29tcG9uZW50cy8pIGZvciBmcmFtZXdvcmsgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gZGV0YWlscy4gICAgICovXHJcbiAgICBoZWFkZXJHcm91cENvbXBvbmVudDogYW55O1xyXG4gICAgLyoqIEBkZXByZWNhdGVkIEFzIG9mIHYyNywgdXNlIGBoZWFkZXJHcm91cENvbXBvbmVudGAgZm9yIGZyYW1ld29yayBjb21wb25lbnRzIHRvby5cclxuICAgICAqL1xyXG4gICAgaGVhZGVyR3JvdXBDb21wb25lbnRGcmFtZXdvcms6IGFueTtcclxuICAgIC8qKiBUaGUgcGFyYW1zIHVzZWQgdG8gY29uZmlndXJlIHRoZSBgaGVhZGVyR3JvdXBDb21wb25lbnRgLiAgICAgKi9cclxuICAgIGhlYWRlckdyb3VwQ29tcG9uZW50UGFyYW1zOiBhbnk7XHJcbiAgICAvKiogVGhlIHVuaXF1ZSBJRCB0byBnaXZlIHRoZSBjb2x1bW4uIFRoaXMgaXMgb3B0aW9uYWwuIElmIG1pc3NpbmcsIHRoZSBJRCB3aWxsIGRlZmF1bHQgdG8gdGhlIGZpZWxkLlxyXG4gICAgICogSWYgYm90aCBmaWVsZCBhbmQgY29sSWQgYXJlIG1pc3NpbmcsIGEgdW5pcXVlIElEIHdpbGwgYmUgZ2VuZXJhdGVkLlxyXG4gICAgICogVGhpcyBJRCBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBjb2x1bW4gaW4gdGhlIEFQSSBmb3Igc29ydGluZywgZmlsdGVyaW5nIGV0Yy4gICAgICovXHJcbiAgICBjb2xJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFRoZSBmaWVsZCBvZiB0aGUgcm93IHRvIGdldCB0aGUgY2VsbHMgZGF0YSBmcm9tICAgICAqL1xyXG4gICAgZmllbGQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBBIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIGBDb2x1bW5UeXBlYCBrZXlzIHdoaWNoIGNhbiBiZSB1c2VkIGFzIGEgdGVtcGxhdGUgZm9yIGEgY29sdW1uLlxyXG4gICAgICogVGhpcyBoZWxwcyB0byByZWR1Y2UgZHVwbGljYXRpb24gb2YgcHJvcGVydGllcyB3aGVuIHlvdSBoYXZlIGEgbG90IG9mIGNvbW1vbiBjb2x1bW4gcHJvcGVydGllcy4gICAgICovXHJcbiAgICB0eXBlOiBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBGdW5jdGlvbiBvciBleHByZXNzaW9uLiBHZXRzIHRoZSB2YWx1ZSBmcm9tIHlvdXIgZGF0YSBmb3IgZGlzcGxheS4gICAgICovXHJcbiAgICB2YWx1ZUdldHRlcjogc3RyaW5nIHwgVmFsdWVHZXR0ZXJGdW5jIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIEEgZnVuY3Rpb24gb3IgZXhwcmVzc2lvbiB0byBmb3JtYXQgYSB2YWx1ZSwgc2hvdWxkIHJldHVybiBhIHN0cmluZy4gTm90IHVzZWQgZm9yIENTViBleHBvcnQgb3IgY29weSB0byBjbGlwYm9hcmQsIG9ubHkgZm9yIFVJIGNlbGwgcmVuZGVyaW5nLiAgICAgKi9cclxuICAgIHZhbHVlRm9ybWF0dGVyOiBzdHJpbmcgfCBWYWx1ZUZvcm1hdHRlckZ1bmMgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogUHJvdmlkZWQgYSByZWZlcmVuY2UgZGF0YSBtYXAgdG8gYmUgdXNlZCB0byBtYXAgY29sdW1uIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIHZhbHVlIGZyb20gdGhlIG1hcC4gICAgICovXHJcbiAgICByZWZEYXRhOiB7XHJcbiAgICAgICAgW2tleTogc3RyaW5nXTogc3RyaW5nO1xyXG4gICAgfSB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBGdW5jdGlvbiB0byByZXR1cm4gYSBzdHJpbmcga2V5IGZvciBhIHZhbHVlLlxyXG4gICAgICogVGhpcyBzdHJpbmcgaXMgdXNlZCBmb3IgZ3JvdXBpbmcsIFNldCBmaWx0ZXJpbmcsIGFuZCBzZWFyY2hpbmcgd2l0aGluIGNlbGwgZWRpdG9yIGRyb3Bkb3ducy5cclxuICAgICAqIFdoZW4gZmlsdGVyaW5nIGFuZCBzZWFyY2hpbmcgdGhlIHN0cmluZyBpcyBleHBvc2VkIHRvIHRoZSB1c2VyLCBzbyBtYWtlIHN1cmUgdG8gcmV0dXJuIGEgaHVtYW4tcmVhZGFibGUgdmFsdWUuICAgICAqL1xyXG4gICAga2V5Q3JlYXRvcjogKChwYXJhbXM6IEtleUNyZWF0b3JQYXJhbXMpID0+IHN0cmluZykgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogQ3VzdG9tIGNvbXBhcmF0b3IgZm9yIHZhbHVlcywgdXNlZCBieSByZW5kZXJlciB0byBrbm93IGlmIHZhbHVlcyBoYXZlIGNoYW5nZWQuIENlbGxzIHdobydzIHZhbHVlcyBoYXZlIG5vdCBjaGFuZ2VkIGRvbid0IGdldCByZWZyZXNoZWQuXHJcbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBncmlkIHVzZXMgYD09PWAgaXMgdXNlZCB3aGljaCBzaG91bGQgd29yayBmb3IgbW9zdCB1c2UgY2FzZXMuICAgICAqL1xyXG4gICAgZXF1YWxzOiAoKHZhbHVlQTogYW55LCB2YWx1ZUI6IGFueSkgPT4gYm9vbGVhbikgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogVGhlIGZpZWxkIG9mIHRoZSB0b29sdGlwIHRvIGFwcGx5IHRvIHRoZSBjZWxsLiAgICAgKi9cclxuICAgIHRvb2x0aXBGaWVsZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIENhbGxiYWNrIHRoYXQgc2hvdWxkIHJldHVybiB0aGUgc3RyaW5nIHRvIHVzZSBmb3IgYSB0b29sdGlwLCBgdG9vbHRpcEZpZWxkYCB0YWtlcyBwcmVjZWRlbmNlIGlmIHNldC5cclxuICAgICAqIElmIHVzaW5nIGEgY3VzdG9tIGB0b29sdGlwQ29tcG9uZW50YCB5b3UgbWF5IHJldHVybiBhbnkgY3VzdG9tIHZhbHVlIHRvIGJlIHBhc3NlZCB0byB5b3VyIHRvb2x0aXAgY29tcG9uZW50LiAgICAgKi9cclxuICAgIHRvb2x0aXBWYWx1ZUdldHRlcjogKChwYXJhbXM6IElUb29sdGlwUGFyYW1zKSA9PiBzdHJpbmcgfCBhbnkpIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIGBib29sZWFuYCBvciBgRnVuY3Rpb25gLiBTZXQgdG8gYHRydWVgIChvciByZXR1cm4gYHRydWVgIGZyb20gZnVuY3Rpb24pIHRvIHJlbmRlciBhIHNlbGVjdGlvbiBjaGVja2JveCBpbiB0aGUgY29sdW1uLiBEZWZhdWx0OiBgZmFsc2VgICAgICAqL1xyXG4gICAgY2hlY2tib3hTZWxlY3Rpb246IGJvb2xlYW4gfCBDaGVja2JveFNlbGVjdGlvbkNhbGxiYWNrIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIEljb25zIHRvIHVzZSBpbnNpZGUgdGhlIGNvbHVtbiBpbnN0ZWFkIG9mIHRoZSBncmlkJ3MgZGVmYXVsdCBpY29ucy4gTGVhdmUgdW5kZWZpbmVkIHRvIHVzZSBkZWZhdWx0cy4gICAgICovXHJcbiAgICBpY29uczoge1xyXG4gICAgICAgIFtrZXk6IHN0cmluZ106IEZ1bmN0aW9uIHwgc3RyaW5nO1xyXG4gICAgfSB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHRoaXMgY29sdW1uIGlzIG5vdCBuYXZpZ2FibGUgKGkuZS4gY2Fubm90IGJlIHRhYmJlZCBpbnRvKSwgb3RoZXJ3aXNlIGBmYWxzZWAuXHJcbiAgICAgKiBDYW4gYWxzbyBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGhhdmUgZGlmZmVyZW50IHJvd3MgbmF2aWdhYmxlLlxyXG4gICAgICogRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cclxuICAgIHN1cHByZXNzTmF2aWdhYmxlOiBib29sZWFuIHwgU3VwcHJlc3NOYXZpZ2FibGVDYWxsYmFjayB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBBbGxvd3MgdGhlIHVzZXIgdG8gc3VwcHJlc3MgY2VydGFpbiBrZXlib2FyZCBldmVudHMgaW4gdGhlIGdyaWQgY2VsbC4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cclxuICAgIHN1cHByZXNzS2V5Ym9hcmRFdmVudDogKChwYXJhbXM6IFN1cHByZXNzS2V5Ym9hcmRFdmVudFBhcmFtcykgPT4gYm9vbGVhbikgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogUGFzdGluZyBpcyBvbiBieSBkZWZhdWx0IGFzIGxvbmcgYXMgY2VsbHMgYXJlIGVkaXRhYmxlIChub24tZWRpdGFibGUgY2VsbHMgY2Fubm90IGJlIG1vZGlmaWVkLCBldmVuIHdpdGggYSBwYXN0ZSBvcGVyYXRpb24pLlxyXG4gICAgICogU2V0IHRvIGB0cnVlYCB0dXJuIHBhc3RlIG9wZXJhdGlvbnMgb2ZmLiAgICAgKi9cclxuICAgIHN1cHByZXNzUGFzdGU6IGJvb2xlYW4gfCBTdXBwcmVzc1Bhc3RlQ2FsbGJhY2sgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIHRydWUgdG8gcHJldmVudCB0aGUgZmlsbEhhbmRsZSBmcm9tIGJlaW5nIHJlbmRlcmVkIGluIGFueSBjZWxsIHRoYXQgYmVsb25ncyB0byB0aGlzIGNvbHVtbiAgICAgKi9cclxuICAgIHN1cHByZXNzRmlsbEhhbmRsZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdG8gYHRydWVgIGZvciB0aGlzIGNvbHVtbiB0byBiZSBoaWRkZW4uIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICBoaWRlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNhbWUgYXMgYGhpZGVgLCBleGNlcHQgb25seSBhcHBsaWVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgY29sdW1uLiBOb3QgYXBwbGllZCB3aGVuIHVwZGF0aW5nIGNvbHVtbiBkZWZpbml0aW9ucy4gICAgICovXHJcbiAgICBpbml0aWFsSGlkZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdG8gYHRydWVgIHRvIGJsb2NrIG1ha2luZyBjb2x1bW4gdmlzaWJsZSAvIGhpZGRlbiB2aWEgdGhlIFVJIChBUEkgd2lsbCBzdGlsbCB3b3JrKS4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cclxuICAgIGxvY2tWaXNpYmxlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgdG8gYWx3YXlzIGhhdmUgdGhpcyBjb2x1bW4gZGlzcGxheWVkIGZpcnN0LiBEZWZhdWx0OiBgZmFsc2VgICAgICAqL1xyXG4gICAgbG9ja1Bvc2l0aW9uOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgeW91IGRvIG5vdCB3YW50IHRoaXMgY29sdW1uIHRvIGJlIG1vdmFibGUgdmlhIGRyYWdnaW5nLiBEZWZhdWx0OiBgZmFsc2VgICAgICAqL1xyXG4gICAgc3VwcHJlc3NNb3ZhYmxlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgdGhpcyBjb2x1bW4gaXMgZWRpdGFibGUsIG90aGVyd2lzZSBgZmFsc2VgLiBDYW4gYWxzbyBiZSBhIGZ1bmN0aW9uIHRvIGhhdmUgZGlmZmVyZW50IHJvd3MgZWRpdGFibGUuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICBlZGl0YWJsZTogYm9vbGVhbiB8IEVkaXRhYmxlQ2FsbGJhY2sgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogRnVuY3Rpb24gb3IgZXhwcmVzc2lvbi4gU2V0cyB0aGUgdmFsdWUgaW50byB5b3VyIGRhdGEgZm9yIHNhdmluZy4gUmV0dXJuIGB0cnVlYCBpZiB0aGUgZGF0YSBjaGFuZ2VkLiAgICAgKi9cclxuICAgIHZhbHVlU2V0dGVyOiBzdHJpbmcgfCBWYWx1ZVNldHRlckZ1bmMgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogRnVuY3Rpb24gb3IgZXhwcmVzc2lvbi4gUGFyc2VzIHRoZSB2YWx1ZSBmb3Igc2F2aW5nLiAgICAgKi9cclxuICAgIHZhbHVlUGFyc2VyOiBzdHJpbmcgfCBWYWx1ZVBhcnNlckZ1bmMgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogUHJvdmlkZSB5b3VyIG93biBjZWxsIGVkaXRvciBjb21wb25lbnQgZm9yIHRoaXMgY29sdW1uJ3MgY2VsbHMuXHJcbiAgICAgKiBTZWUgW0NlbGwgRWRpdG9yXShodHRwczovL3d3dy5hZy1ncmlkLmNvbS9qYXZhc2NyaXB0LWRhdGEtZ3JpZC9jb21wb25lbnQtY2VsbC1lZGl0b3IvKSBmb3IgZnJhbWV3b3JrIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGRldGFpbC4gICAgICovXHJcbiAgICBjZWxsRWRpdG9yOiBhbnk7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgQXMgb2YgdjI3LCB1c2UgYGNlbGxFZGl0b3JgIGZvciBmcmFtZXdvcmsgY29tcG9uZW50cyB0b28uXHJcbiAgICAgKi9cclxuICAgIGNlbGxFZGl0b3JGcmFtZXdvcms6IGFueTtcclxuICAgIC8qKiBQYXJhbXMgdG8gYmUgcGFzc2VkIHRvIHRoZSBgY2VsbEVkaXRvcmAgY29tcG9uZW50LiAgICAgKi9cclxuICAgIGNlbGxFZGl0b3JQYXJhbXM6IGFueTtcclxuICAgIC8qKiBDYWxsYmFjayB0byBzZWxlY3Qgd2hpY2ggY2VsbCBlZGl0b3IgdG8gYmUgdXNlZCBmb3IgYSBnaXZlbiByb3cgd2l0aGluIHRoZSBzYW1lIGNvbHVtbi4gICAgICovXHJcbiAgICBjZWxsRWRpdG9yU2VsZWN0b3I6IENlbGxFZGl0b3JTZWxlY3RvckZ1bmMgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBoYXZlIGNlbGxzIHVuZGVyIHRoaXMgY29sdW1uIGVudGVyIGVkaXQgbW9kZSBhZnRlciBzaW5nbGUgY2xpY2suIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICBzaW5nbGVDbGlja0VkaXQ6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGB2YWx1ZVNldHRlcmAgaW5zdGVhZFxyXG4gICAgICovXHJcbiAgICBuZXdWYWx1ZUhhbmRsZXI6ICgocGFyYW1zOiBOZXdWYWx1ZVBhcmFtcykgPT4gYm9vbGVhbikgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIGB0cnVlYCwgdG8gaGF2ZSB0aGUgY2VsbCBlZGl0b3IgYXBwZWFyIGluIGEgcG9wdXAuICAgICAqL1xyXG4gICAgY2VsbEVkaXRvclBvcHVwOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNldCB0aGUgcG9zaXRpb24gZm9yIHRoZSBwb3B1cCBjZWxsIGVkaXRvci4gUG9zc2libGUgdmFsdWVzIGFyZVxyXG4gICAgICogICAtIGBvdmVyYCBQb3B1cCB3aWxsIGJlIHBvc2l0aW9uZWQgb3ZlciB0aGUgY2VsbFxyXG4gICAgICogICAtIGB1bmRlcmAgUG9wdXAgd2lsbCBiZSBwb3NpdGlvbmVkIGJlbG93IHRoZSBjZWxsIGxlYXZpbmcgdGhlIGNlbGwgdmFsdWUgdmlzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBEZWZhdWx0OiBgb3ZlcmAuICAgICAqL1xyXG4gICAgY2VsbEVkaXRvclBvcHVwUG9zaXRpb246IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBDYWxsYmFjayBmb3IgYWZ0ZXIgdGhlIHZhbHVlIG9mIGEgY2VsbCBoYXMgY2hhbmdlZCwgZWl0aGVyIGR1ZSB0byBlZGl0aW5nIG9yIHRoZSBhcHBsaWNhdGlvbiBjYWxsaW5nIGBhcGkuc2V0VmFsdWUoKWAuICAgICAqL1xyXG4gICAgb25DZWxsVmFsdWVDaGFuZ2VkOiAoKGV2ZW50OiBOZXdWYWx1ZVBhcmFtcykgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYSBjZWxsIGlzIGNsaWNrZWQuICAgICAqL1xyXG4gICAgb25DZWxsQ2xpY2tlZDogKChldmVudDogQ2VsbENsaWNrZWRFdmVudCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYSBjZWxsIGlzIGRvdWJsZSBjbGlja2VkLiAgICAgKi9cclxuICAgIG9uQ2VsbERvdWJsZUNsaWNrZWQ6ICgoZXZlbnQ6IENlbGxEb3VibGVDbGlja2VkRXZlbnQpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIENhbGxiYWNrIGNhbGxlZCB3aGVuIGEgY2VsbCBpcyByaWdodCBjbGlja2VkLiAgICAgKi9cclxuICAgIG9uQ2VsbENvbnRleHRNZW51OiAoKGV2ZW50OiBDZWxsQ29udGV4dE1lbnVFdmVudCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogQSBmdW5jdGlvbiB0byB0ZWxsIHRoZSBncmlkIHdoYXQgcXVpY2sgZmlsdGVyIHRleHQgdG8gdXNlIGZvciB0aGlzIGNvbHVtbiBpZiB5b3UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIGRlZmF1bHQgKHdoaWNoIGlzIGNhbGxpbmcgYHRvU3RyaW5nYCBvbiB0aGUgdmFsdWUpLiAgICAgKi9cclxuICAgIGdldFF1aWNrRmlsdGVyVGV4dDogKChwYXJhbXM6IEdldFF1aWNrRmlsdGVyVGV4dFBhcmFtcykgPT4gc3RyaW5nKSB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBGdW5jdGlvbiBvciBleHByZXNzaW9uLiBHZXRzIHRoZSB2YWx1ZSBmb3IgZmlsdGVyaW5nIHB1cnBvc2VzLiAgICAgKi9cclxuICAgIGZpbHRlclZhbHVlR2V0dGVyOiBzdHJpbmcgfCBWYWx1ZUdldHRlckZ1bmMgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogV2hldGhlciB0byBkaXNwbGF5IGEgZmxvYXRpbmcgZmlsdGVyIGZvciB0aGlzIGNvbHVtbi4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cclxuICAgIGZsb2F0aW5nRmlsdGVyOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqICAgICAqL1xyXG4gICAgLyoqIFRoZSBjdXN0b20gaGVhZGVyIGNvbXBvbmVudCB0byBiZSB1c2VkIGZvciByZW5kZXJpbmcgdGhlIGNvbXBvbmVudCBoZWFkZXIuIElmIG5vbmUgc3BlY2lmaWVkIHRoZSBkZWZhdWx0IEFHIEdyaWQgaGVhZGVyIGNvbXBvbmVudCBpcyB1c2VkLlxyXG4gICAgICAgICAqIFNlZSBbSGVhZGVyIENvbXBvbmVudF0oaHR0cHM6Ly93d3cuYWctZ3JpZC5jb20vamF2YXNjcmlwdC1kYXRhLWdyaWQvY29tcG9uZW50LWhlYWRlci8pIGZvciBmcmFtZXdvcmsgc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gZGV0YWlsLiAgICAgKi9cclxuICAgIGhlYWRlckNvbXBvbmVudDogYW55O1xyXG4gICAgLyoqIEBkZXByZWNhdGVkIEFzIG9mIHYyNywgdXNlIGBoZWFkZXJDb21wb25lbnRgIGZvciBmcmFtZXdvcmsgY29tcG9uZW50cyB0b28uXHJcbiAgICAgKi9cclxuICAgIGhlYWRlckNvbXBvbmVudEZyYW1ld29yazogYW55O1xyXG4gICAgLyoqIFRoZSBwYXJhbWV0ZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgYGhlYWRlckNvbXBvbmVudGAuICAgICAqL1xyXG4gICAgaGVhZGVyQ29tcG9uZW50UGFyYW1zOiBhbnk7XHJcbiAgICAvKiogU2V0IHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgemVybywgb25lIG9yIG1hbnkgb2YgdGhlIGZvbGxvd2luZyBvcHRpb25zOiBgJ2ZpbHRlck1lbnVUYWInIHwgJ2dlbmVyYWxNZW51VGFiJyB8ICdjb2x1bW5zTWVudVRhYidgLlxyXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIGZpZ3VyZSBvdXQgd2hpY2ggbWVudSB0YWJzIGFyZSBwcmVzZW50IGFuZCBpbiB3aGljaCBvcmRlciB0aGUgdGFicyBhcmUgc2hvd24uICAgICAqL1xyXG4gICAgbWVudVRhYnM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFBhcmFtcyB1c2VkIHRvIGNoYW5nZSB0aGUgYmVoYXZpb3VyIGFuZCBhcHBlYXJhbmNlIG9mIHRoZSBDb2x1bW5zIE1lbnUgdGFiLiAgICAgKi9cclxuICAgIGNvbHVtbnNNZW51UGFyYW1zOiBDb2x1bW5zTWVudVBhcmFtcyB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIG5vIG1lbnUgc2hvdWxkIGJlIHNob3duIGZvciB0aGlzIGNvbHVtbiBoZWFkZXIuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICBzdXBwcmVzc01lbnU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogSWYgYHRydWVgIG9yIHRoZSBjYWxsYmFjayByZXR1cm5zIGB0cnVlYCwgYSAnc2VsZWN0IGFsbCcgY2hlY2tib3ggd2lsbCBiZSBwdXQgaW50byB0aGUgaGVhZGVyLiAgICAgKi9cclxuICAgIGhlYWRlckNoZWNrYm94U2VsZWN0aW9uOiBib29sZWFuIHwgSGVhZGVyQ2hlY2tib3hTZWxlY3Rpb25DYWxsYmFjayB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBJZiBgdHJ1ZWAsIHRoZSBoZWFkZXIgY2hlY2tib3ggc2VsZWN0aW9uIHdpbGwgb25seSBzZWxlY3QgZmlsdGVyZWQgaXRlbXMuICAgICAqL1xyXG4gICAgaGVhZGVyQ2hlY2tib3hTZWxlY3Rpb25GaWx0ZXJlZE9ubHk6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogRGVmaW5lcyB0aGUgY2hhcnQgZGF0YSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGEgY29sdW1uLiAgICAgKi9cclxuICAgIGNoYXJ0RGF0YVR5cGU6ICdjYXRlZ29yeScgfCAnc2VyaWVzJyB8ICd0aW1lJyB8ICdleGNsdWRlZCcgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogUGluIGEgY29sdW1uIHRvIG9uZSBzaWRlOiBgcmlnaHRgIG9yIGBsZWZ0YC4gQSB2YWx1ZSBvZiBgdHJ1ZWAgaXMgY29udmVydGVkIHRvIGAnbGVmdCdgLiAgICAgKi9cclxuICAgIHBpbm5lZDogYm9vbGVhbiB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2FtZSBhcyBgcGlubmVkYCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xyXG4gICAgaW5pdGlhbFBpbm5lZDogYm9vbGVhbiB8IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdG8gdHJ1ZSB0byBibG9jayB0aGUgdXNlciBwaW5uaW5nIHRoZSBjb2x1bW4sIHRoZSBjb2x1bW4gY2FuIG9ubHkgYmUgcGlubmVkIHZpYSBkZWZpbml0aW9ucyBvciBBUEkuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICBsb2NrUGlubmVkOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBjZWxsUmVuZGVyZXJTZWxlY3RvciBpZiB5b3Ugd2FudCBhIGRpZmZlcmVudCBDZWxsIFJlbmRlcmVyIGZvciBwaW5uZWQgcm93cy4gQ2hlY2sgcGFyYW1zLm5vZGUucm93UGlubmVkLlxyXG4gICAgICovXHJcbiAgICBwaW5uZWRSb3dDZWxsUmVuZGVyZXI6IHtcclxuICAgICAgICBuZXcgKCk6IElDZWxsUmVuZGVyZXJDb21wO1xyXG4gICAgfSB8IElDZWxsUmVuZGVyZXJGdW5jIHwgc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBjZWxsUmVuZGVyZXJTZWxlY3RvciBpZiB5b3Ugd2FudCBhIGRpZmZlcmVudCBDZWxsIFJlbmRlcmVyIGZvciBwaW5uZWQgcm93cy4gQ2hlY2sgcGFyYW1zLm5vZGUucm93UGlubmVkLlxyXG4gICAgICovXHJcbiAgICBwaW5uZWRSb3dDZWxsUmVuZGVyZXJGcmFtZXdvcms6IGFueTtcclxuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgY2VsbFJlbmRlcmVyU2VsZWN0b3IgaWYgeW91IHdhbnQgYSBkaWZmZXJlbnQgQ2VsbCBSZW5kZXJlciBmb3IgcGlubmVkIHJvd3MuIENoZWNrIHBhcmFtcy5ub2RlLnJvd1Bpbm5lZC5cclxuICAgICAqL1xyXG4gICAgcGlubmVkUm93Q2VsbFJlbmRlcmVyUGFyYW1zOiBhbnk7XHJcbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIHZhbHVlRm9ybWF0dGVyIGZvciBwaW5uZWQgcm93cywgYW5kIGNoZWNrIHBhcmFtcy5ub2RlLnJvd1Bpbm5lZC5cclxuICAgICAqL1xyXG4gICAgcGlubmVkUm93VmFsdWVGb3JtYXR0ZXI6IHN0cmluZyB8IFZhbHVlRm9ybWF0dGVyRnVuYyB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdG8gdHJ1ZSB0byBwaXZvdCBieSB0aGlzIGNvbHVtbi4gICAgICovXHJcbiAgICBwaXZvdDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTYW1lIGFzIGBwaXZvdGAsIGV4Y2VwdCBvbmx5IGFwcGxpZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBjb2x1bW4uIE5vdCBhcHBsaWVkIHdoZW4gdXBkYXRpbmcgY29sdW1uIGRlZmluaXRpb25zLiAgICAgKi9cclxuICAgIGluaXRpYWxQaXZvdDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdGhpcyBpbiBjb2x1bW5zIHlvdSB3YW50IHRvIHBpdm90IGJ5LlxyXG4gICAgICogSWYgb25seSBwaXZvdGluZyBieSBvbmUgY29sdW1uLCBzZXQgdGhpcyB0byBhbnkgbnVtYmVyIChlLmcuIGAwYCkuXHJcbiAgICAgKiBJZiBwaXZvdGluZyBieSBtdWx0aXBsZSBjb2x1bW5zLCBzZXQgdGhpcyB0byB3aGVyZSB5b3Ugd2FudCB0aGlzIGNvbHVtbiB0byBiZSBpbiB0aGUgb3JkZXIgb2YgcGl2b3RzIChlLmcuIGAwYCBmb3IgZmlyc3QsIGAxYCBmb3Igc2Vjb25kLCBhbmQgc28gb24pLiAgICAgKi9cclxuICAgIHBpdm90SW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2FtZSBhcyBgcGl2b3RJbmRleGAsIGV4Y2VwdCBvbmx5IGFwcGxpZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBjb2x1bW4uIE5vdCBhcHBsaWVkIHdoZW4gdXBkYXRpbmcgY29sdW1uIGRlZmluaXRpb25zLiAgICAgKi9cclxuICAgIGluaXRpYWxQaXZvdEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogQ29tcGFyYXRvciB0byB1c2Ugd2hlbiBvcmRlcmluZyB0aGUgcGl2b3QgY29sdW1ucywgd2hlbiB0aGlzIGNvbHVtbiBpcyB1c2VkIHRvIHBpdm90IG9uLlxyXG4gICAgICogVGhlIHZhbHVlcyB3aWxsIGFsd2F5cyBiZSBzdHJpbmdzLCBhcyB0aGUgcGl2b3Qgc2VydmljZSB1c2VzIHN0cmluZ3MgYXMga2V5cyBmb3IgdGhlIHBpdm90IGdyb3Vwcy4gICAgICovXHJcbiAgICBwaXZvdENvbXBhcmF0b3I6ICgodmFsdWVBOiBzdHJpbmcsIHZhbHVlQjogc3RyaW5nKSA9PiBudW1iZXIpIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdG8gYmUgYWJsZSB0byBwaXZvdCBieSB0aGlzIGNvbHVtbiB2aWEgdGhlIEdVSS4gVGhpcyB3aWxsIG5vdCBibG9jayB0aGUgQVBJIG9yIHByb3BlcnRpZXMgYmVpbmcgdXNlZCB0byBhY2hpZXZlIHBpdm90LiBEZWZhdWx0OiBgZmFsc2VgICAgICAqL1xyXG4gICAgZW5hYmxlUGl2b3Q6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogQW4gb2JqZWN0IG9mIGNzcyB2YWx1ZXMgLyBvciBmdW5jdGlvbiByZXR1cm5pbmcgYW4gb2JqZWN0IG9mIGNzcyB2YWx1ZXMgZm9yIGEgcGFydGljdWxhciBjZWxsLiAgICAgKi9cclxuICAgIGNlbGxTdHlsZTogQ2VsbFN0eWxlIHwgQ2VsbFN0eWxlRnVuYyB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBDbGFzcyB0byB1c2UgZm9yIHRoZSBjZWxsLiBDYW4gYmUgc3RyaW5nLCBhcnJheSBvZiBzdHJpbmdzLCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncy4gICAgICovXHJcbiAgICBjZWxsQ2xhc3M6IHN0cmluZyB8IHN0cmluZ1tdIHwgQ2VsbENsYXNzRnVuYyB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBSdWxlcyB3aGljaCBjYW4gYmUgYXBwbGllZCB0byBpbmNsdWRlIGNlcnRhaW4gQ1NTIGNsYXNzZXMuICAgICAqL1xyXG4gICAgY2VsbENsYXNzUnVsZXM6IENlbGxDbGFzc1J1bGVzIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFByb3ZpZGUgeW91ciBvd24gY2VsbCBSZW5kZXJlciBjb21wb25lbnQgZm9yIHRoaXMgY29sdW1uJ3MgY2VsbHMuXHJcbiAgICAgKiBTZWUgW0NlbGwgUmVuZGVyZXJdKGh0dHBzOi8vd3d3LmFnLWdyaWQuY29tL2phdmFzY3JpcHQtZGF0YS1ncmlkL2NvbXBvbmVudC1jZWxsLXJlbmRlcmVyLykgZm9yIGZyYW1ld29yayBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLiAgICAgKi9cclxuICAgIGNlbGxSZW5kZXJlcjogYW55O1xyXG4gICAgLyoqIEBkZXByZWNhdGVkIEFzIG9mIHYyNywgdXNlIGBjZWxsUmVuZGVyZXJgIGZvciBmcmFtZXdvcmsgY29tcG9uZW50cyB0b28uXHJcbiAgICAgKi9cclxuICAgIGNlbGxSZW5kZXJlckZyYW1ld29yazogYW55O1xyXG4gICAgLyoqIFBhcmFtcyB0byBiZSBwYXNzZWQgdG8gdGhlIGBjZWxsUmVuZGVyZXJgIGNvbXBvbmVudC4gICAgICovXHJcbiAgICBjZWxsUmVuZGVyZXJQYXJhbXM6IGFueTtcclxuICAgIC8qKiBDYWxsYmFjayB0byBzZWxlY3Qgd2hpY2ggY2VsbCByZW5kZXJlciB0byBiZSB1c2VkIGZvciBhIGdpdmVuIHJvdyB3aXRoaW4gdGhlIHNhbWUgY29sdW1uLiAgICAgKi9cclxuICAgIGNlbGxSZW5kZXJlclNlbGVjdG9yOiBDZWxsUmVuZGVyZXJTZWxlY3RvckZ1bmMgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBoYXZlIHRoZSBncmlkIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIGEgcm93IGJhc2VkIG9uIGNvbnRlbnRzIG9mIHRoaXMgY29sdW1uLiBEZWZhdWx0OiBgZmFsc2VgICAgICAqL1xyXG4gICAgYXV0b0hlaWdodDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdG8gYHRydWVgIHRvIGhhdmUgdGhlIHRleHQgd3JhcCBpbnNpZGUgdGhlIGNlbGwgLSB0eXBpY2FsbHkgdXNlZCB3aXRoIGBhdXRvSGVpZ2h0YC4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cclxuICAgIHdyYXBUZXh0OiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgdG8gZmxhc2ggYSBjZWxsIHdoZW4gaXQncyByZWZyZXNoZWQuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICBlbmFibGVDZWxsQ2hhbmdlRmxhc2g6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBwcmV2ZW50IHRoaXMgY29sdW1uIGZyb20gZmxhc2hpbmcgb24gY2hhbmdlcy4gT25seSBhcHBsaWNhYmxlIGlmIGNlbGwgZmxhc2hpbmcgaXMgdHVybmVkIG9uIGZvciB0aGUgZ3JpZC4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cclxuICAgIHN1cHByZXNzQ2VsbEZsYXNoOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIGBib29sZWFuYCBvciBgRnVuY3Rpb25gLiBTZXQgdG8gYHRydWVgIChvciByZXR1cm4gYHRydWVgIGZyb20gZnVuY3Rpb24pIHRvIGFsbG93IHJvdyBkcmFnZ2luZy4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cclxuICAgIHJvd0RyYWc6IGJvb2xlYW4gfCBSb3dEcmFnQ2FsbGJhY2sgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogQSBjYWxsYmFjayB0aGF0IHNob3VsZCByZXR1cm4gYSBzdHJpbmcgdG8gYmUgZGlzcGxheWVkIGJ5IHRoZSBgcm93RHJhZ0NvbXBgIHdoaWxlIGRyYWdnaW5nIGEgcm93LlxyXG4gICAgICogSWYgdGhpcyBjYWxsYmFjayBpcyBub3Qgc2V0LCB0aGUgY3VycmVudCBjZWxsIHZhbHVlIHdpbGwgYmUgdXNlZC4gICAgICovXHJcbiAgICByb3dEcmFnVGV4dDogKChwYXJhbXM6IElSb3dEcmFnSXRlbSwgZHJhZ0l0ZW1Db3VudDogbnVtYmVyKSA9PiBzdHJpbmcpIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIGBib29sZWFuYCBvciBgRnVuY3Rpb25gLiBTZXQgdG8gYHRydWVgIChvciByZXR1cm4gYHRydWVgIGZyb20gZnVuY3Rpb24pIHRvIGFsbG93IGRyYWdnaW5nIGZvciBuYXRpdmUgZHJhZyBhbmQgZHJvcC4gRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cclxuICAgIGRuZFNvdXJjZTogYm9vbGVhbiB8IERuZFNvdXJjZUNhbGxiYWNrIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIEZ1bmN0aW9uIHRvIGFsbG93IGN1c3RvbSBkcmFnIGZ1bmN0aW9uYWxpdHkgZm9yIG5hdGl2ZSBkcmFnIGFuZCBkcm9wLiAgICAgKi9cclxuICAgIGRuZFNvdXJjZU9uUm93RHJhZzogKChwYXJhbXM6IERuZFNvdXJjZU9uUm93RHJhZ1BhcmFtcykgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byByb3cgZ3JvdXAgYnkgdGhpcyBjb2x1bW4uIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICByb3dHcm91cDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTYW1lIGFzIGByb3dHcm91cGAsIGV4Y2VwdCBvbmx5IGFwcGxpZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBjb2x1bW4uIE5vdCBhcHBsaWVkIHdoZW4gdXBkYXRpbmcgY29sdW1uIGRlZmluaXRpb25zLiAgICAgKi9cclxuICAgIGluaXRpYWxSb3dHcm91cDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdGhpcyBpbiBjb2x1bW5zIHlvdSB3YW50IHRvIGdyb3VwIGJ5LlxyXG4gICAgICogSWYgb25seSBncm91cGluZyBieSBvbmUgY29sdW1uLCBzZXQgdGhpcyB0byBhbnkgbnVtYmVyIChlLmcuIGAwYCkuXHJcbiAgICAgKiBJZiBncm91cGluZyBieSBtdWx0aXBsZSBjb2x1bW5zLCBzZXQgdGhpcyB0byB3aGVyZSB5b3Ugd2FudCB0aGlzIGNvbHVtbiB0byBiZSBpbiB0aGUgZ3JvdXAgKGUuZy4gYDBgIGZvciBmaXJzdCwgYDFgIGZvciBzZWNvbmQsIGFuZCBzbyBvbikuICAgICAqL1xyXG4gICAgcm93R3JvdXBJbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTYW1lIGFzIGByb3dHcm91cEluZGV4YCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xyXG4gICAgaW5pdGlhbFJvd0dyb3VwSW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIGJlIGFibGUgdG8gcm93IGdyb3VwIGJ5IHRoaXMgY29sdW1uIHZpYSB0aGUgR1VJLlxyXG4gICAgICogVGhpcyB3aWxsIG5vdCBibG9jayB0aGUgQVBJIG9yIHByb3BlcnRpZXMgYmVpbmcgdXNlZCB0byBhY2hpZXZlIHJvdyBncm91cGluZy5cclxuICAgICAqIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICBlbmFibGVSb3dHcm91cDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHlvdSB3YW50IHRvIGJlIGFibGUgdG8gYWdncmVnYXRlIGJ5IHRoaXMgY29sdW1uIHZpYSB0aGUgR1VJLlxyXG4gICAgICogVGhpcyB3aWxsIG5vdCBibG9jayB0aGUgQVBJIG9yIHByb3BlcnRpZXMgYmVpbmcgdXNlZCB0byBhY2hpZXZlIGFnZ3JlZ2F0aW9uLlxyXG4gICAgICogRGVmYXVsdDogYGZhbHNlYCAgICAgKi9cclxuICAgIGVuYWJsZVZhbHVlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIE5hbWUgb2YgZnVuY3Rpb24gdG8gdXNlIGZvciBhZ2dyZWdhdGlvbi4gWW91IGNhbiBhbHNvIHByb3ZpZGUgeW91ciBvd24gYWdnIGZ1bmN0aW9uLiAgICAgKi9cclxuICAgIGFnZ0Z1bmM6IHN0cmluZyB8IElBZ2dGdW5jIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTYW1lIGFzIGBhZ2dGdW5jYCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xyXG4gICAgaW5pdGlhbEFnZ0Z1bmM6IHN0cmluZyB8IElBZ2dGdW5jIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIEFnZ3JlZ2F0aW9uIGZ1bmN0aW9ucyBhbGxvd2VkIG9uIHRoaXMgY29sdW1uIGUuZy4gYFsnc3VtJywgJ2F2ZyddYC5cclxuICAgICAqIElmIG1pc3NpbmcsIGFsbCBpbnN0YWxsZWQgZnVuY3Rpb25zIGFyZSBhbGxvd2VkLlxyXG4gICAgICogVGhpcyB3aWxsIG9ubHkgcmVzdHJpY3Qgd2hhdCB0aGUgR1VJIGFsbG93cyBhIHVzZXIgdG8gc2VsZWN0LCBpdCBkb2VzIG5vdCBpbXBhY3Qgd2hlbiB5b3Ugc2V0IGEgZnVuY3Rpb24gdmlhIHRoZSBBUEkuICAgICAqL1xyXG4gICAgYWxsb3dlZEFnZ0Z1bmNzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdG8gdHJ1ZSB0byBoYXZlIHRoZSBncmlkIHBsYWNlIHRoZSB2YWx1ZXMgZm9yIHRoZSBncm91cCBpbnRvIHRoZSBjZWxsLCBvciBwdXQgdGhlIG5hbWUgb2YgYSBncm91cGVkIGNvbHVtbiB0byBqdXN0IHNob3cgdGhhdCBncm91cC4gICAgICovXHJcbiAgICBzaG93Um93R3JvdXA6IHN0cmluZyB8IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIGB0cnVlYCB0byBhbGxvdyBzb3J0aW5nIG9uIHRoaXMgY29sdW1uLiBEZWZhdWx0OiBgZmFsc2VgICAgICAqL1xyXG4gICAgc29ydGFibGU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogSWYgc29ydGluZyBieSBkZWZhdWx0LCBzZXQgaXQgaGVyZS4gU2V0IHRvIGBhc2NgIG9yIGBkZXNjYC4gICAgICovXHJcbiAgICBzb3J0OiAnYXNjJyB8ICdkZXNjJyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2FtZSBhcyBgc29ydGAsIGV4Y2VwdCBvbmx5IGFwcGxpZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBjb2x1bW4uIE5vdCBhcHBsaWVkIHdoZW4gdXBkYXRpbmcgY29sdW1uIGRlZmluaXRpb25zLiAgICAgKi9cclxuICAgIGluaXRpYWxTb3J0OiAnYXNjJyB8ICdkZXNjJyB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogSWYgc29ydGluZyBtb3JlIHRoYW4gb25lIGNvbHVtbiBieSBkZWZhdWx0LCBzcGVjaWZpZXMgb3JkZXIgaW4gd2hpY2ggdGhlIHNvcnRpbmcgc2hvdWxkIGJlIGFwcGxpZWQuICAgICAqL1xyXG4gICAgc29ydEluZGV4OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNhbWUgYXMgYHNvcnRJbmRleGAsIGV4Y2VwdCBvbmx5IGFwcGxpZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBjb2x1bW4uIE5vdCBhcHBsaWVkIHdoZW4gdXBkYXRpbmcgY29sdW1uIGRlZmluaXRpb25zLiAgICAgKi9cclxuICAgIGluaXRpYWxTb3J0SW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBBcnJheSBkZWZpbmluZyB0aGUgb3JkZXIgaW4gd2hpY2ggc29ydGluZyBvY2N1cnMgKGlmIHNvcnRpbmcgaXMgZW5hYmxlZCkuIEFuIGFycmF5IHdpdGggYW55IG9mIHRoZSBmb2xsb3dpbmcgaW4gYW55IG9yZGVyIGBbJ2FzYycsJ2Rlc2MnLG51bGxdYCAgICAgKi9cclxuICAgIHNvcnRpbmdPcmRlcjogKCdhc2MnIHwgJ2Rlc2MnIHwgbnVsbClbXSB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBDb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBjdXN0b20gc29ydGluZy4gICAgICovXHJcbiAgICBjb21wYXJhdG9yOiAoKHZhbHVlQTogYW55LCB2YWx1ZUI6IGFueSwgbm9kZUE6IFJvd05vZGUsIG5vZGVCOiBSb3dOb2RlLCBpc0ludmVydGVkOiBib29sZWFuKSA9PiBudW1iZXIpIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgaWYgeW91IHdhbnQgdGhlIHVuc29ydGVkIGljb24gdG8gYmUgc2hvd24gd2hlbiBubyBzb3J0IGlzIGFwcGxpZWQgdG8gdGhpcyBjb2x1bW4uIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICB1blNvcnRJY29uOiBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIEBkZXByZWNhdGVkIHNpbmNlIHYyNCAtIHVzZSBzb3J0SW5kZXggaW5zdGVhZFxyXG4gICAgICovXHJcbiAgICBzb3J0ZWRBdDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIEJ5IGRlZmF1bHQsIGVhY2ggY2VsbCB3aWxsIHRha2UgdXAgdGhlIHdpZHRoIG9mIG9uZSBjb2x1bW4uIFlvdSBjYW4gY2hhbmdlIHRoaXMgYmVoYXZpb3VyIHRvIGFsbG93IGNlbGxzIHRvIHNwYW4gbXVsdGlwbGUgY29sdW1ucy4gICAgICovXHJcbiAgICBjb2xTcGFuOiAoKHBhcmFtczogQ29sU3BhblBhcmFtcykgPT4gbnVtYmVyKSB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBCeSBkZWZhdWx0LCBlYWNoIGNlbGwgd2lsbCB0YWtlIHVwIHRoZSBoZWlnaHQgb2Ygb25lIHJvdy4gWW91IGNhbiBjaGFuZ2UgdGhpcyBiZWhhdmlvdXIgdG8gYWxsb3cgY2VsbHMgdG8gc3BhbiBtdWx0aXBsZSByb3dzLiAgICAgKi9cclxuICAgIHJvd1NwYW46ICgocGFyYW1zOiBSb3dTcGFuUGFyYW1zKSA9PiBudW1iZXIpIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIEluaXRpYWwgd2lkdGggaW4gcGl4ZWxzIGZvciB0aGUgY2VsbC4gICAgICovXHJcbiAgICB3aWR0aDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNhbWUgYXMgYHdpZHRoYCwgZXhjZXB0IG9ubHkgYXBwbGllZCB3aGVuIGNyZWF0aW5nIGEgbmV3IGNvbHVtbi4gTm90IGFwcGxpZWQgd2hlbiB1cGRhdGluZyBjb2x1bW4gZGVmaW5pdGlvbnMuICAgICAqL1xyXG4gICAgaW5pdGlhbFdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogTWluaW11bSB3aWR0aCBpbiBwaXhlbHMgZm9yIHRoZSBjZWxsLiAgICAgKi9cclxuICAgIG1pbldpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogTWF4aW11bSB3aWR0aCBpbiBwaXhlbHMgZm9yIHRoZSBjZWxsLiAgICAgKi9cclxuICAgIG1heFdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogVXNlZCBpbnN0ZWFkIG9mIGB3aWR0aGAgd2hlbiB0aGUgZ29hbCBpcyB0byBmaWxsIHRoZSByZW1haW5pbmcgZW1wdHkgc3BhY2Ugb2YgdGhlIGdyaWQuICAgICAqL1xyXG4gICAgZmxleDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNhbWUgYXMgYGZsZXhgLCBleGNlcHQgb25seSBhcHBsaWVkIHdoZW4gY3JlYXRpbmcgYSBuZXcgY29sdW1uLiBOb3QgYXBwbGllZCB3aGVuIHVwZGF0aW5nIGNvbHVtbiBkZWZpbml0aW9ucy4gICAgICovXHJcbiAgICBpbml0aWFsRmxleDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgLyoqIFNldCB0byBgdHJ1ZWAgdG8gYWxsb3cgdGhpcyBjb2x1bW4gc2hvdWxkIGJlIHJlc2l6ZWQuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICByZXNpemFibGU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU2V0IHRvIGB0cnVlYCBpZiB5b3Ugd2FudCB0aGlzIGNvbHVtbidzIHdpZHRoIHRvIGJlIGZpeGVkIGR1cmluZyAnc2l6ZSB0byBmaXQnIG9wZXJhdGlvbnMuIERlZmF1bHQ6IGBmYWxzZWAgICAgICovXHJcbiAgICBzdXBwcmVzc1NpemVUb0ZpdDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTZXQgdG8gYHRydWVgIGlmIHlvdSBkbyBub3Qgd2FudCB0aGlzIGNvbHVtbiB0byBiZSBhdXRvLXJlc2l6YWJsZSBieSBkb3VibGUgY2xpY2tpbmcgaXQncyBlZGdlLiBEZWZhdWx0OiBgZmFsc2VgICAgICAqL1xyXG4gICAgc3VwcHJlc3NBdXRvU2l6ZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc0NlbGxGbGFzaDogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc0NvbHVtbnNUb29sUGFuZWw6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc3VwcHJlc3NGaWx0ZXJzVG9vbFBhbmVsOiBib29sZWFuIHwgbnVsbCB8ICcnO1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX29wZW5CeURlZmF1bHQ6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbWFycnlDaGlsZHJlbjogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9oaWRlOiBib29sZWFuIHwgbnVsbCB8ICcnO1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2luaXRpYWxIaWRlOiBib29sZWFuIHwgbnVsbCB8ICcnO1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3Jvd0dyb3VwOiBib29sZWFuIHwgbnVsbCB8ICcnO1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2luaXRpYWxSb3dHcm91cDogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9waXZvdDogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9pbml0aWFsUGl2b3Q6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfY2hlY2tib3hTZWxlY3Rpb246IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfaGVhZGVyQ2hlY2tib3hTZWxlY3Rpb246IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfaGVhZGVyQ2hlY2tib3hTZWxlY3Rpb25GaWx0ZXJlZE9ubHk6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc3VwcHJlc3NNZW51OiBib29sZWFuIHwgbnVsbCB8ICcnO1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3N1cHByZXNzTW92YWJsZTogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9sb2NrUG9zaXRpb246IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbG9ja1Zpc2libGU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfbG9ja1Bpbm5lZDogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV91blNvcnRJY29uOiBib29sZWFuIHwgbnVsbCB8ICcnO1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3N1cHByZXNzU2l6ZVRvRml0OiBib29sZWFuIHwgbnVsbCB8ICcnO1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX3N1cHByZXNzQXV0b1NpemU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZW5hYmxlUm93R3JvdXA6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZW5hYmxlUGl2b3Q6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZW5hYmxlVmFsdWU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfZWRpdGFibGU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc3VwcHJlc3NQYXN0ZTogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc05hdmlnYWJsZTogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9lbmFibGVDZWxsQ2hhbmdlRmxhc2g6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfcm93RHJhZzogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9kbmRTb3VyY2U6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfYXV0b0hlaWdodDogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV93cmFwVGV4dDogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zb3J0YWJsZTogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9yZXNpemFibGU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbiAgICBzdGF0aWMgbmdBY2NlcHRJbnB1dFR5cGVfc2luZ2xlQ2xpY2tFZGl0OiBib29sZWFuIHwgbnVsbCB8ICcnO1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2Zsb2F0aW5nRmlsdGVyOiBib29sZWFuIHwgbnVsbCB8ICcnO1xyXG4gICAgc3RhdGljIG5nQWNjZXB0SW5wdXRUeXBlX2NlbGxFZGl0b3JQb3B1cDogYm9vbGVhbiB8IG51bGwgfCAnJztcclxuICAgIHN0YXRpYyBuZ0FjY2VwdElucHV0VHlwZV9zdXBwcmVzc0ZpbGxIYW5kbGU6IGJvb2xlYW4gfCBudWxsIHwgJyc7XHJcbn1cclxuIl19