import { ApplicationRef, ComponentFactoryResolver, Injectable, Injector, Input, Component, ElementRef, ViewEncapsulation, HostListener, ViewChild, HostBinding, Renderer2, Directive, Output, EventEmitter, ViewContainerRef, NgModule, ChangeDetectionStrategy, ChangeDetectorRef, NgZone, TemplateRef, ContentChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { trigger, style, animate, transition } from '@angular/animations';
import { DomSanitizer } from '@angular/platform-browser';
import { rgb } from 'd3-color';
import { fromEvent } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { range, min, max } from 'd3-array';
import { scaleBand, scaleLinear, scaleOrdinal, scaleQuantile, scaleTime, scalePoint } from 'd3-scale';
import { brushX } from 'd3-brush';
import { select, event } from 'd3-selection';
import { curveLinear, area, line, curveCardinalClosed, lineRadial, arc, pie } from 'd3-shape';
import { forceCollide, forceLink, forceManyBody, forceSimulation, forceX, forceY } from 'd3-force';
import { interpolate } from 'd3-interpolate';
import { format } from 'd3-format';
import { treemap, stratify } from 'd3-hierarchy';
import { timeFormat } from 'd3-time-format';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

var _c0 = ["caretElm"];
function TooltipContentComponent_span_4_ng_template_1_Template(rf, ctx) { }
var _c1 = function (a0) { return { model: a0 }; };
function TooltipContentComponent_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, TooltipContentComponent_span_4_ng_template_1_Template, 0, 0, "ng-template", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c1, ctx_r1.context));
} }
function TooltipContentComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 6);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r2.title, ɵngcc0.ɵɵsanitizeHtml);
} }
function ChartComponent_ngx_charts_scale_legend_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelement(0, "ngx-charts-scale-legend", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("horizontal", ctx_r0.legendOptions && ctx_r0.legendOptions.position === "below")("valueRange", ctx_r0.legendOptions.domain)("colors", ctx_r0.legendOptions.colors)("height", ctx_r0.view[1])("width", ctx_r0.legendWidth);
} }
function ChartComponent_ngx_charts_legend_4_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "ngx-charts-legend", 5);
    ɵngcc0.ɵɵlistener("labelClick", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.legendLabelClick.emit($event); })("labelActivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelActivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.legendLabelActivate.emit($event); })("labelDeactivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelDeactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.legendLabelDeactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("horizontal", ctx_r1.legendOptions && ctx_r1.legendOptions.position === "below")("data", ctx_r1.legendOptions.domain)("title", ctx_r1.legendOptions.title)("colors", ctx_r1.legendOptions.colors)("height", ctx_r1.view[1])("width", ctx_r1.legendWidth)("activeEntries", ctx_r1.activeEntries);
} }
var _c2 = ["*"];
function LegendComponent_header_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "header", 4);
    ɵngcc0.ɵɵelementStart(1, "span", 5);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r0.title);
} }
function LegendComponent_li_4_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 6);
    ɵngcc0.ɵɵelementStart(1, "ngx-charts-legend-entry", 7);
    ɵngcc0.ɵɵlistener("select", function LegendComponent_li_4_Template_ngx_charts_legend_entry_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.labelClick.emit($event); })("activate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate($event); })("deactivate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var entry_r2 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("label", entry_r2.label)("formattedLabel", entry_r2.formattedLabel)("color", entry_r2.color)("isActive", ctx_r1.isActive(entry_r2));
} }
function AdvancedLegendComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 7);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", ctx_r0.roundedTotal)("valueFormatting", ctx_r0.valueFormatting);
} }
function AdvancedLegendComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.valueFormatting ? ctx_r1.valueFormatting(ctx_r1.roundedTotal) : ctx_r1.defaultValueFormatting(ctx_r1.roundedTotal), " ");
} }
function AdvancedLegendComponent_div_7_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 16);
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", legendItem_r3._value)("valueFormatting", ctx_r4.valueFormatting);
} }
function AdvancedLegendComponent_div_7_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r5.valueFormatting ? ctx_r5.valueFormatting(legendItem_r3.value) : ctx_r5.defaultValueFormatting(legendItem_r3.value), " ");
} }
function AdvancedLegendComponent_div_7_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 18);
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("countTo", legendItem_r3.percentage)("countSuffix", "%");
} }
function AdvancedLegendComponent_div_7_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 19);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", legendItem_r3.percentage.toLocaleString(), "%");
} }
function AdvancedLegendComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵlistener("mouseenter", function AdvancedLegendComponent_div_7_Template_div_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.activate.emit(legendItem_r3.data); })("mouseleave", function AdvancedLegendComponent_div_7_Template_div_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = ctx.$implicit; var ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.deactivate.emit(legendItem_r3.data); })("click", function AdvancedLegendComponent_div_7_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r13); var legendItem_r3 = ctx.$implicit; var ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.select.emit(legendItem_r3.data); });
    ɵngcc0.ɵɵelement(1, "div", 10);
    ɵngcc0.ɵɵtemplate(2, AdvancedLegendComponent_div_7_div_2_Template, 1, 2, "div", 11);
    ɵngcc0.ɵɵtemplate(3, AdvancedLegendComponent_div_7_div_3_Template, 2, 1, "div", 12);
    ɵngcc0.ɵɵelementStart(4, "div", 13);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, AdvancedLegendComponent_div_7_div_6_Template, 1, 2, "div", 14);
    ɵngcc0.ɵɵtemplate(7, AdvancedLegendComponent_div_7_div_7_Template, 2, 1, "div", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var legendItem_r3 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("border-left-color", legendItem_r3.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.animations);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(legendItem_r3.displayLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r2.animations);
} }
var _c3 = ["ngx-charts-axis-label", ""];
var _c4 = ["ticksel"];
var _c5 = ["ngx-charts-x-axis-ticks", ""];
function XAxisTicksComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 4);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r3 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.tickTransform(tick_r3));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.tickFormat(tick_r3));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("font-size", "12px");
    ɵngcc0.ɵɵattribute("text-anchor", ctx_r1.textAnchor)("transform", ctx_r1.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.tickTrim(ctx_r1.tickFormat(tick_r3)), " ");
} }
function XAxisTicksComponent__svg_g_3__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "line", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("transform", ctx_r5.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("y1", -ctx_r5.gridLineHeight);
} }
function XAxisTicksComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, XAxisTicksComponent__svg_g_3__svg_g_1_Template, 2, 2, "g", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r4 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r2.tickTransform(tick_r4));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r2.showGridLines);
} }
var _c6 = ["ngx-charts-x-axis", ""];
function XAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function XAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.emitTicksHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r0.trimTicks)("rotateTicks", ctx_r0.rotateTicks)("maxTickLength", ctx_r0.maxTickLength)("tickFormatting", ctx_r0.tickFormatting)("tickArguments", ctx_r0.tickArguments)("tickStroke", ctx_r0.tickStroke)("scale", ctx_r0.xScale)("orient", ctx_r0.xOrient)("showGridLines", ctx_r0.showGridLines)("gridLineHeight", ctx_r0.dims.height)("width", ctx_r0.dims.width)("tickValues", ctx_r0.ticks);
} }
function XAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", "bottom")("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
} }
var _c7 = ["ngx-charts-y-axis-ticks", ""];
function YAxisTicksComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 5);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r5 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.transform(tick_r5));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.tickFormat(tick_r5));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("font-size", "12px");
    ɵngcc0.ɵɵattribute("dy", ctx_r1.dy)("x", ctx_r1.x1)("y", ctx_r1.y1)("text-anchor", ctx_r1.textAnchor);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.tickTrim(ctx_r1.tickFormat(tick_r5)), " ");
} }
function YAxisTicksComponent__svg_path_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "path", 6);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("d", ctx_r2.referenceAreaPath)("transform", ctx_r2.gridLineTransform());
} }
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 9);
} if (rf & 2) {
    var ctx_r8 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵattribute("x2", ctx_r8.gridLineWidth);
} }
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 9);
} if (rf & 2) {
    var ctx_r9 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵattribute("x2", -ctx_r9.gridLineWidth);
} }
function YAxisTicksComponent__svg_g_4__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template, 1, 1, "line", 8);
    ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template, 1, 1, "line", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("transform", ctx_r7.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.orient === "left");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r7.orient === "right");
} }
function YAxisTicksComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_4__svg_g_1_Template, 3, 3, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r6 = ctx.$implicit;
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r3.transform(tick_r6));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r3.showGridLines);
} }
function YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "title");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "text", 11);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var refLine_r10 = ɵngcc0.ɵɵnextContext(2).$implicit;
    var ctx_r12 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r12.tickTrim(ctx_r12.tickFormat(refLine_r10.value)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("dy", ctx_r12.dy)("y", -6)("x", ctx_r12.gridLineWidth)("text-anchor", ctx_r12.textAnchor);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", refLine_r10.name, " ");
} }
function YAxisTicksComponent__svg_g_5__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "line", 10);
    ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template, 5, 6, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var refLine_r10 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r11 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r11.transform(refLine_r10.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("x2", ctx_r11.gridLineWidth)("transform", ctx_r11.gridLineTransform());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r11.showRefLabels);
} }
function YAxisTicksComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, YAxisTicksComponent__svg_g_5__svg_g_1_Template, 3, 4, "g", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r4.showRefLines);
} }
var _c8 = ["ngx-charts-y-axis", ""];
function YAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function YAxisComponent__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.emitTicksWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("trimTicks", ctx_r0.trimTicks)("maxTickLength", ctx_r0.maxTickLength)("tickFormatting", ctx_r0.tickFormatting)("tickArguments", ctx_r0.tickArguments)("tickValues", ctx_r0.ticks)("tickStroke", ctx_r0.tickStroke)("scale", ctx_r0.yScale)("orient", ctx_r0.yOrient)("showGridLines", ctx_r0.showGridLines)("gridLineWidth", ctx_r0.dims.width)("referenceLines", ctx_r0.referenceLines)("showRefLines", ctx_r0.showRefLines)("showRefLabels", ctx_r0.showRefLabels)("height", ctx_r0.dims.height);
} }
function YAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", ctx_r1.yOrient)("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
} }
var _c9 = ["ngx-charts-circle-series", ""];
function CircleSeriesComponent__svg_g_0__svg_rect_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect", 4);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("x", ctx_r1.circle.cx - ctx_r1.circle.radius)("y", ctx_r1.circle.cy)("width", ctx_r1.circle.radius * 2)("height", ctx_r1.circle.height)("fill", ctx_r1.gradientFill);
} }
var _c10 = function (a0) { return { name: a0 }; };
function CircleSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "defs");
    ɵngcc0.ɵɵelement(2, "g", 1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, CircleSeriesComponent__svg_g_0__svg_rect_3_Template, 1, 6, "rect", 2);
    ɵngcc0.ɵɵelementStart(4, "g", 3);
    ɵngcc0.ɵɵlistener("select", function CircleSeriesComponent__svg_g_0_Template__svg_g_select_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(ctx_r2.circle.data); })("activate", function CircleSeriesComponent__svg_g_0_Template__svg_g_activate_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activateCircle(); })("deactivate", function CircleSeriesComponent__svg_g_0_Template__svg_g_deactivate_4_listener() { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivateCircle(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.circle.gradientStops);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.barVisible && ctx_r0.type === "standard");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("active", ctx_r0.isActive(ɵngcc0.ɵɵpureFunction1(18, _c10, ctx_r0.circle.seriesName)));
    ɵngcc0.ɵɵproperty("cx", ctx_r0.circle.cx)("cy", ctx_r0.circle.cy)("r", ctx_r0.circle.radius)("fill", ctx_r0.circle.color)("pointerEvents", ctx_r0.circle.value === 0 ? "none" : "all")("data", ctx_r0.circle.value)("classNames", ctx_r0.circle.classNames)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(ctx_r0.circle))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", ctx_r0.circle.data);
} }
var _c11 = ["ngx-charts-circle", ""];
var _c12 = ["ngx-charts-grid-panel", ""];
var _c13 = ["ngx-charts-grid-panel-series", ""];
function GridPanelSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 1);
} if (rf & 2) {
    var gridPanel_r1 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("grid-panel", true)("odd", gridPanel_r1.class === "odd")("even", gridPanel_r1.class === "even");
    ɵngcc0.ɵɵproperty("height", gridPanel_r1.height)("width", gridPanel_r1.width)("x", gridPanel_r1.x)("y", gridPanel_r1.y);
} }
var _c14 = ["ngx-charts-svg-linear-gradient", ""];
function SvgLinearGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    var stop_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r1.offset + "%");
} }
var _c15 = ["ngx-charts-svg-radial-gradient", ""];
function SvgRadialGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    var stop_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r1.offset + "%");
} }
var _c16 = ["ngx-charts-timeline", ""];
var _c17 = ["ngx-charts-area", ""];
function AreaComponent__svg_defs_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
var _c18 = ["tooltipAnchor"];
var _c19 = ["ngx-charts-tooltip-area", ""];
function TooltipArea__xhtml_ng_template_2__xhtml_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵelement(1, "span", 7);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tooltipItem_r5 = ctx.$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("background-color", tooltipItem_r5.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r4.getToolTipText(tooltipItem_r5), " ");
} }
function TooltipArea__xhtml_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵtemplate(1, TooltipArea__xhtml_ng_template_2__xhtml_div_1_Template, 3, 3, "div", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var model_r3 = ctx.model;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", model_r3);
} }
var _c20 = ["ngx-charts-count-up", ""];
var _c21 = ["tooltipTemplate"];
var _c22 = ["seriesTooltipTemplate"];
function AreaChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("baseValue", ctx_r2.baseValue)("colors", ctx_r2.colors)("data", series_r9)("activeEntries", ctx_r2.activeEntries)("scaleType", ctx_r2.scaleType)("gradient", ctx_r2.gradient)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function AreaChartComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("baseValue", ctx_r19.baseValue)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
var _c23 = function (a0, a1) { return [a0, a1]; };
function AreaChartComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartComponent__svg_g_10__svg_g_1_Template, 2, 9, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
function AreaChartNormalizedComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartNormalizedComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartNormalizedComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("scaleType", ctx_r2.scaleType)("activeEntries", ctx_r2.activeEntries)("gradient", ctx_r2.gradient)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartNormalizedComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartNormalizedComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartNormalizedComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("showPercentage", true)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
function AreaChartNormalizedComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartNormalizedComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
var _c24 = ".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}";
function AreaChartStackedComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartStackedComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function AreaChartStackedComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function AreaChartStackedComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function AreaChartStackedComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("scaleType", ctx_r2.scaleType)("gradient", ctx_r2.gradient)("activeEntries", ctx_r2.activeEntries)("curve", ctx_r2.curve)("animations", ctx_r2.animations);
} }
function AreaChartStackedComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 12);
    ɵngcc0.ɵɵlistener("select", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var series_r11 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event, series_r11); })("activate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("activeEntries", ctx_r10.activeEntries)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function AreaChartStackedComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function AreaChartStackedComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function AreaChartStackedComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, AreaChartStackedComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results)("ngForTrackBy", ctx_r3.trackBy);
} }
function AreaChartStackedComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("gradient", ctx_r19.gradient)("curve", ctx_r19.curve)("animations", ctx_r19.animations);
} }
function AreaChartStackedComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 13);
    ɵngcc0.ɵɵlistener("onDomainChange", function AreaChartStackedComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, AreaChartStackedComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("legend", ctx_r4.legend)("scaleType", ctx_r4.scaleType);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
var _c25 = ["ngx-charts-area-series", ""];
var _c26 = ["ngx-charts-bar", ""];
function BarComponent__svg_defs_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("orientation", ctx_r0.orientation)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function BarHorizontalComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontal2DComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.valueScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontal2DComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_4_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.groupScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontal2DComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelWidthChanged", function BarHorizontal2DComponent__svg_g_5_Template__svg_g_dataLabelWidthChanged_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxWidthChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.valueScale)("activeEntries", ctx_r2.activeEntries)("yScale", ctx_r2.innerScale)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("roundEdges", ctx_r2.roundEdges)("animations", ctx_r2.animations)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarHorizontalNormalizedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalNormalizedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarHorizontalNormalizedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, group_r7); })("activate", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event, group_r7); })("deactivate", function BarHorizontalNormalizedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event, group_r7); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarHorizontalStackedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarHorizontalStackedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative);
} }
function BarHorizontalStackedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelWidthChanged", function BarHorizontalStackedComponent__svg_g_4_Template__svg_g_dataLabelWidthChanged_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxWidthChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("series", group_r7.series)("activeEntries", ctx_r2.activeEntries)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarVerticalComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVerticalComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVertical2DComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVertical2DComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.groupScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVertical2DComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVertical2DComponent__svg_g_4_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.valueScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVertical2DComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BarVertical2DComponent__svg_g_5_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarVertical2DComponent__svg_g_5_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarVertical2DComponent__svg_g_5_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelHeightChanged", function BarVertical2DComponent__svg_g_5_Template__svg_g_dataLabelHeightChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxHeightChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("activeEntries", ctx_r2.activeEntries)("xScale", ctx_r2.innerScale)("yScale", ctx_r2.valueScale)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("seriesName", group_r7.name)("roundEdges", ctx_r2.roundEdges)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
} }
function BarVerticalNormalizedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BarVerticalNormalizedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVerticalNormalizedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, group_r7); })("activate", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event, group_r7); })("deactivate", function BarVerticalNormalizedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event, group_r7); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
function BarVerticalStackedComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks)("xAxisOffset", ctx_r0.dataLabelMaxHeight.negative);
} }
function BarVerticalStackedComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BarVerticalStackedComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 7);
    ɵngcc0.ɵɵlistener("select", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.onClick($event, group_r7); })("activate", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onActivate($event, group_r7); })("deactivate", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var group_r7 = ctx.$implicit; var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onDeactivate($event, group_r7); })("dataLabelHeightChanged", function BarVerticalStackedComponent__svg_g_4_Template__svg_g_dataLabelHeightChanged_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var index_r8 = ctx.index; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDataLabelMaxHeightChanged($event, index_r8); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var group_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.groupTransform(group_r7));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("activeEntries", ctx_r2.activeEntries)("colors", ctx_r2.colors)("series", group_r7.series)("dims", ctx_r2.dims)("gradient", ctx_r2.gradient)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate)("showDataLabel", ctx_r2.showDataLabel)("dataLabelFormatting", ctx_r2.dataLabelFormatting)("seriesName", group_r7.name)("animations", ctx_r2.animations)("noBarWhenZero", ctx_r2.noBarWhenZero);
} }
var _c27 = ["ngx-charts-series-vertical", ""];
function SeriesVerticalComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function SeriesVerticalComponent__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.onClick($event); })("activate", function SeriesVerticalComponent__svg_g_0_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit($event); })("deactivate", function SeriesVerticalComponent__svg_g_0_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var bar_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("@.disabled", !ctx_r0.animations)("width", bar_r2.width)("height", bar_r2.height)("x", bar_r2.x)("y", bar_r2.y)("fill", bar_r2.color)("stops", bar_r2.gradientStops)("data", bar_r2.data)("orientation", "vertical")("roundEdges", bar_r2.roundEdges)("gradient", ctx_r0.gradient)("ariaLabel", bar_r2.ariaLabel)("isActive", ctx_r0.isActive(bar_r2.data))("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", ctx_r0.tooltipPlacement)("tooltipType", ctx_r0.tooltipType)("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : bar_r2.tooltipText)("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", bar_r2.data)("noBarWhenZero", ctx_r0.noBarWhenZero)("animations", ctx_r0.animations);
} }
function SeriesVerticalComponent__svg_g_1__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function SeriesVerticalComponent__svg_g_1__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var i_r9 = ctx.index; var ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.dataLabelHeightChanged.emit({ size: $event, index: i_r9 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var b_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("barX", b_r8.x)("barY", b_r8.y)("barWidth", b_r8.width)("barHeight", b_r8.height)("value", b_r8.total)("valueFormatting", ctx_r7.dataLabelFormatting)("orientation", "vertical");
} }
function SeriesVerticalComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, SeriesVerticalComponent__svg_g_1__svg_g_1_Template, 1, 7, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
} }
var _c28 = ["ngx-charts-series-horizontal", ""];
function SeriesHorizontal__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function SeriesHorizontal__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.click($event); })("activate", function SeriesHorizontal__svg_g_0_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit($event); })("deactivate", function SeriesHorizontal__svg_g_0_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var bar_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active")("width", bar_r2.width)("height", bar_r2.height)("x", bar_r2.x)("y", bar_r2.y)("fill", bar_r2.color)("stops", bar_r2.gradientStops)("data", bar_r2.data)("orientation", "horizontal")("roundEdges", bar_r2.roundEdges)("gradient", ctx_r0.gradient)("isActive", ctx_r0.isActive(bar_r2.data))("ariaLabel", bar_r2.ariaLabel)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", ctx_r0.tooltipPlacement)("tooltipType", ctx_r0.tooltipType)("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : bar_r2.tooltipText)("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", bar_r2.data)("noBarWhenZero", ctx_r0.noBarWhenZero);
} }
function SeriesHorizontal__svg_g_1__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function SeriesHorizontal__svg_g_1__svg_g_1_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var i_r9 = ctx.index; var ctx_r10 = ɵngcc0.ɵɵnextContext(2); return ctx_r10.dataLabelWidthChanged.emit({ size: $event, index: i_r9 }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var b_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("barX", b_r8.x)("barY", b_r8.y)("barWidth", b_r8.width)("barHeight", b_r8.height)("value", b_r8.total)("valueFormatting", ctx_r7.dataLabelFormatting)("orientation", "horizontal");
} }
function SeriesHorizontal__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, SeriesHorizontal__svg_g_1__svg_g_1_Template, 1, 7, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
} }
var _c29 = ["ngx-charts-bar-label", ""];
function BubbleChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BubbleChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("showGridLines", ctx_r0.showGridLines)("dims", ctx_r0.dims)("xScale", ctx_r0.xScale)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function BubbleChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function BubbleChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("showGridLines", ctx_r1.showGridLines)("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function BubbleChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r9 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 8);
    ɵngcc0.ɵɵlistener("select", function BubbleChartComponent__svg_g_9_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var series_r7 = ctx.$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onClick($event, series_r7); })("activate", function BubbleChartComponent__svg_g_9_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onActivate($event); })("deactivate", function BubbleChartComponent__svg_g_9_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r9); var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r7 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("rScale", ctx_r2.rScale)("xScaleType", ctx_r2.xScaleType)("yScaleType", ctx_r2.yScaleType)("xAxisLabel", ctx_r2.xAxisLabel)("yAxisLabel", ctx_r2.yAxisLabel)("colors", ctx_r2.colors)("data", series_r7)("activeEntries", ctx_r2.activeEntries)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipTemplate", ctx_r2.tooltipTemplate);
} }
var _c30 = ["ngx-charts-bubble-series", ""];
function BubbleSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g");
    ɵngcc0.ɵɵelementStart(2, "g", 1);
    ɵngcc0.ɵɵlistener("select", function BubbleSeriesComponent__svg_g_0_Template__svg_g_select_2_listener() { ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = ctx.$implicit; var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(circle_r1.data); })("activate", function BubbleSeriesComponent__svg_g_0_Template__svg_g_activate_2_listener() { ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = ctx.$implicit; var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activateCircle(circle_r1); })("deactivate", function BubbleSeriesComponent__svg_g_0_Template__svg_g_deactivate_2_listener() { ɵngcc0.ɵɵrestoreView(_r3); var circle_r1 = ctx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivateCircle(circle_r1); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var circle_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("transform", circle_r1.transform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("opacity", circle_r1.opacity);
    ɵngcc0.ɵɵclassProp("active", circle_r1.isActive);
    ɵngcc0.ɵɵproperty("@animationState", "active")("cx", 0)("cy", 0)("r", circle_r1.radius)("fill", circle_r1.color)("pointerEvents", "all")("data", circle_r1.value)("classNames", circle_r1.classNames)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(circle_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", circle_r1.data);
} }
var _c31 = ["linkTemplate"];
var _c32 = ["nodeTemplate"];
function ForceDirectedGraphComponent__svg_g_3_1__svg_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
} }
function ForceDirectedGraphComponent__svg_g_3_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵtemplate(0, ForceDirectedGraphComponent__svg_g_3_1__svg_ng_template_0_Template, 0, 0, "ng-template", 8);
} }
function ForceDirectedGraphComponent__svg_g_3__svg_line_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 9);
} if (rf & 2) {
    var link_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵattribute("x1", link_r2.source.x)("y1", link_r2.source.y)("x2", link_r2.target.x)("y2", link_r2.target.y);
} }
function ForceDirectedGraphComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, ForceDirectedGraphComponent__svg_g_3_1_Template, 1, 0, undefined, 6);
    ɵngcc0.ɵɵtemplate(2, ForceDirectedGraphComponent__svg_g_3__svg_line_2_Template, 1, 4, "line", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.linkTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.linkTemplate);
} }
function ForceDirectedGraphComponent__svg_g_5_1__svg_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
} }
function ForceDirectedGraphComponent__svg_g_5_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵtemplate(0, ForceDirectedGraphComponent__svg_g_5_1__svg_ng_template_0_Template, 0, 0, "ng-template", 8);
} }
function ForceDirectedGraphComponent__svg_g_5__svg_circle_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 12);
} }
function ForceDirectedGraphComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mousedown", function ForceDirectedGraphComponent__svg_g_5_Template__svg_g_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r12); var node_r7 = ctx.$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onDragStart(node_r7, $event); })("click", function ForceDirectedGraphComponent__svg_g_5_Template__svg_g_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); var node_r7 = ctx.$implicit; var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onClick({ name: node_r7.value }); });
    ɵngcc0.ɵɵtemplate(1, ForceDirectedGraphComponent__svg_g_5_1_Template, 1, 0, undefined, 6);
    ɵngcc0.ɵɵtemplate(2, ForceDirectedGraphComponent__svg_g_5__svg_circle_2_Template, 1, 0, "circle", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var node_r7 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r1.tooltipTemplate ? undefined : node_r7.value)("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", node_r7);
    ɵngcc0.ɵɵattribute("transform", "translate(" + node_r7.x + "," + node_r7.y + ")")("fill", ctx_r1.colors.getColor(ctx_r1.groupResultsBy(node_r7)))("stroke", ctx_r1.colors.getColor(ctx_r1.groupResultsBy(node_r7)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.nodeTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.nodeTemplate);
} }
var _c33 = ["ngx-charts-heat-map-cell", ""];
function HeatMapCellComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
var _c34 = ["ngx-charts-heat-map-cell-series", ""];
var _c35 = function (a0, a1, a2) { return { series: a0, name: a1, value: a2 }; };
function HeatCellSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 1);
    ɵngcc0.ɵɵlistener("select", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_select_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = ctx.$implicit; var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick(c_r1.cell); })("activate", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_activate_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = ctx.$implicit; var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activate.emit(c_r1.cell); })("deactivate", function HeatCellSeriesComponent__svg_g_0_Template__svg_g_deactivate_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var c_r1 = ctx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivate.emit(c_r1.cell); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("x", c_r1.x)("y", c_r1.y)("width", c_r1.width)("height", c_r1.height)("fill", c_r1.fill)("data", c_r1.data)("gradient", ctx_r0.gradient)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.tooltipText(c_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", ɵngcc0.ɵɵpureFunction3(14, _c35, c_r1.series, c_r1.label, c_r1.data));
} }
function HeatMapComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 6);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function HeatMapComponent__svg_g_2_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r4); var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function HeatMapComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function HeatMapComponent__svg_g_3_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks);
} }
function HeatMapComponent__svg_rect_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect");
} if (rf & 2) {
    var rect_r7 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("x", rect_r7.x)("y", rect_r7.y)("rx", rect_r7.rx)("width", rect_r7.width)("height", rect_r7.height)("fill", rect_r7.fill);
} }
var _c36 = ["ngx-charts-line", ""];
function LineChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    var _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 7);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function LineChartComponent__svg_g_5_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r6); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.updateXAxisHeight($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("xScale", ctx_r0.xScale)("dims", ctx_r0.dims)("showGridLines", ctx_r0.showGridLines)("showLabel", ctx_r0.showXAxisLabel)("labelText", ctx_r0.xAxisLabel)("trimTicks", ctx_r0.trimXAxisTicks)("rotateTicks", ctx_r0.rotateXAxisTicks)("maxTickLength", ctx_r0.maxXAxisTickLength)("tickFormatting", ctx_r0.xAxisTickFormatting)("ticks", ctx_r0.xAxisTicks);
} }
function LineChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 8);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function LineChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r8); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("referenceLines", ctx_r1.referenceLines)("showRefLines", ctx_r1.showRefLines)("showRefLabels", ctx_r1.showRefLabels);
} }
function LineChartComponent__svg_g_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r9 = ctx.$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r2.xScale)("yScale", ctx_r2.yScale)("colors", ctx_r2.colors)("data", series_r9)("activeEntries", ctx_r2.activeEntries)("scaleType", ctx_r2.scaleType)("curve", ctx_r2.curve)("rangeFillOpacity", ctx_r2.rangeFillOpacity)("hasRange", ctx_r2.hasRange)("animations", ctx_r2.animations);
} }
function LineChartComponent__svg_g_9__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(2); return ctx_r12.onClick($event); })("activate", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(2); return ctx_r14.onActivate($event); })("deactivate", function LineChartComponent__svg_g_9__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r10 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r10.xScale)("yScale", ctx_r10.yScale)("colors", ctx_r10.colors)("data", series_r11)("scaleType", ctx_r10.scaleType)("visibleValue", ctx_r10.hoveredVertical)("activeEntries", ctx_r10.activeEntries)("tooltipDisabled", ctx_r10.tooltipDisabled)("tooltipTemplate", ctx_r10.tooltipTemplate);
} }
function LineChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r17 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 10);
    ɵngcc0.ɵɵlistener("mouseleave", function LineChartComponent__svg_g_9_Template__svg_g_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r16 = ɵngcc0.ɵɵnextContext(); return ctx_r16.hideCircles(); });
    ɵngcc0.ɵɵelementStart(1, "g", 11);
    ɵngcc0.ɵɵlistener("hover", function LineChartComponent__svg_g_9_Template__svg_g_hover_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r17); var ctx_r18 = ɵngcc0.ɵɵnextContext(); return ctx_r18.updateHoveredVertical($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, LineChartComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("dims", ctx_r3.dims)("xSet", ctx_r3.xSet)("xScale", ctx_r3.xScale)("yScale", ctx_r3.yScale)("results", ctx_r3.results)("colors", ctx_r3.colors)("tooltipDisabled", ctx_r3.tooltipDisabled)("tooltipTemplate", ctx_r3.seriesTooltipTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r3.results);
} }
function LineChartComponent__svg_g_10__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelement(1, "g", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r20 = ctx.$implicit;
    var ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("xScale", ctx_r19.timelineXScale)("yScale", ctx_r19.timelineYScale)("colors", ctx_r19.colors)("data", series_r20)("scaleType", ctx_r19.scaleType)("curve", ctx_r19.curve)("hasRange", ctx_r19.hasRange)("animations", ctx_r19.animations);
} }
function LineChartComponent__svg_g_10_Template(rf, ctx) { if (rf & 1) {
    var _r22 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 14);
    ɵngcc0.ɵɵlistener("onDomainChange", function LineChartComponent__svg_g_10_Template__svg_g_onDomainChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r22); var ctx_r21 = ɵngcc0.ɵɵnextContext(); return ctx_r21.updateDomain($event); });
    ɵngcc0.ɵɵtemplate(1, LineChartComponent__svg_g_10__svg_g_1_Template, 2, 8, "g", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("results", ctx_r4.results)("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx_r4.timelineWidth, ctx_r4.height))("height", ctx_r4.timelineHeight)("scheme", ctx_r4.scheme)("customColors", ctx_r4.customColors)("scaleType", ctx_r4.scaleType)("legend", ctx_r4.legend);
    ɵngcc0.ɵɵattribute("transform", ctx_r4.timelineTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.results)("ngForTrackBy", ctx_r4.trackBy);
} }
var _c37 = ["ngx-charts-line-series", ""];
function LineSeriesComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function LineSeriesComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 5);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r1.isActive(ctx_r1.data))("inactive", ctx_r1.isInactive(ctx_r1.data));
    ɵngcc0.ɵɵproperty("data", ctx_r1.data)("path", ctx_r1.outerPath)("fill", ctx_r1.hasGradient ? ctx_r1.gradientUrl : ctx_r1.colors.getColor(ctx_r1.data.name))("opacity", ctx_r1.rangeFillOpacity)("animations", ctx_r1.animations);
} }
function PolarChartComponent__svg_g_4__svg_circle_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "circle", 8);
} if (rf & 2) {
    var r_r6 = ctx.$implicit;
    ɵngcc0.ɵɵattribute("r", r_r6);
} }
function PolarChartComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PolarChartComponent__svg_g_4__svg_circle_1_Template, 1, 1, "circle", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r0.radiusTicks);
} }
function PolarChartComponent__svg_g_5__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 10);
} if (rf & 2) {
    var tick_r8 = ctx.$implicit;
    var ctx_r7 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("data", tick_r8)("radius", ctx_r7.outerRadius)("label", tick_r8.label)("max", ctx_r7.outerRadius)("value", ctx_r7.showGridLines ? 1 : ctx_r7.outerRadius)("explodeSlices", true)("animations", ctx_r7.animations)("labelTrim", ctx_r7.labelTrim)("labelTrimSize", ctx_r7.labelTrimSize);
} }
function PolarChartComponent__svg_g_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PolarChartComponent__svg_g_5__svg_g_1_Template, 1, 9, "g", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1.thetaTicks);
} }
function PolarChartComponent__svg_g_6_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 11);
    ɵngcc0.ɵɵlistener("dimensionsChanged", function PolarChartComponent__svg_g_6_Template__svg_g_dimensionsChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.updateYAxisWidth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("yScale", ctx_r2.yAxisScale)("dims", ctx_r2.yAxisDims)("showGridLines", ctx_r2.showGridLines)("showLabel", ctx_r2.showYAxisLabel)("labelText", ctx_r2.yAxisLabel)("trimTicks", ctx_r2.trimYAxisTicks)("maxTickLength", ctx_r2.maxYAxisTickLength)("tickFormatting", ctx_r2.yAxisTickFormatting);
    ɵngcc0.ɵɵattribute("transform", ctx_r2.transformYAxis);
} }
function PolarChartComponent__svg_g_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 12);
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("label", ctx_r3.xAxisLabel)("offset", ctx_r3.labelOffset)("orient", "bottom")("height", ctx_r3.dims.height)("width", ctx_r3.dims.width);
} }
function PolarChartComponent__svg_g_9_Template(rf, ctx) { if (rf & 1) {
    var _r13 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 13);
    ɵngcc0.ɵɵlistener("select", function PolarChartComponent__svg_g_9_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onClick($event); })("activate", function PolarChartComponent__svg_g_9_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r14 = ɵngcc0.ɵɵnextContext(); return ctx_r14.onActivate($event); })("deactivate", function PolarChartComponent__svg_g_9_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r13); var ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r11 = ctx.$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animationState", "active");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("gradient", ctx_r4.gradient)("xScale", ctx_r4.xScale)("yScale", ctx_r4.yScale)("colors", ctx_r4.colors)("data", series_r11)("activeEntries", ctx_r4.activeEntries)("scaleType", ctx_r4.scaleType)("curve", ctx_r4.curve)("rangeFillOpacity", ctx_r4.rangeFillOpacity)("animations", ctx_r4.animations)("tooltipDisabled", ctx_r4.tooltipDisabled)("tooltipTemplate", ctx_r4.tooltipTemplate);
} }
var _c38 = ["ngx-charts-polar-series", ""];
function PolarSeriesComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 4);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("color", ctx_r0.seriesColor)("name", ctx_r0.gradientId)("startOpacity", 0.25)("endOpacity", 1)("stops", ctx_r0.gradientStops);
} }
function PolarSeriesComponent__svg_g_4_Template(rf, ctx) { if (rf & 1) {
    var _r4 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 5);
    ɵngcc0.ɵɵlistener("select", function PolarSeriesComponent__svg_g_4_Template__svg_g_select_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = ctx.$implicit; var ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.select.emit(circle_r2.data); })("activate", function PolarSeriesComponent__svg_g_4_Template__svg_g_activate_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = ctx.$implicit; var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.activate.emit({ name: circle_r2.data.series }); })("deactivate", function PolarSeriesComponent__svg_g_4_Template__svg_g_deactivate_0_listener() { ɵngcc0.ɵɵrestoreView(_r4); var circle_r2 = ctx.$implicit; var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.deactivate.emit({ name: circle_r2.data.series }); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var circle_r2 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("opacity", ctx_r1.inactive ? 0.2 : 1);
    ɵngcc0.ɵɵproperty("cx", circle_r2.cx)("cy", circle_r2.cy)("r", ctx_r1.circleRadius)("fill", circle_r2.color)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", "top")("tooltipTitle", ctx_r1.tooltipTemplate ? undefined : ctx_r1.tooltipText(circle_r2))("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", circle_r2.data);
} }
var _c39 = ["ngx-charts-pie-label", ""];
var _c40 = ["ngx-charts-pie-arc", ""];
function PieArcComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("color", ctx_r0.fill)("name", ctx_r0.radialGradientId)("startOpacity", ctx_r0.startOpacity);
} }
var _c41 = ".pie-label{font-size:11px}.pie-label.animation{animation:750ms ease-in fadeIn}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d 750ms}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}";
function PieGridComponent__svg_g_2__svg_text_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "text", 10);
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("countTo", series_r1.percent)("countSuffix", "%");
} }
function PieGridComponent__svg_g_2__svg_text_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", series_r1.percent.toLocaleString(), " ");
} }
function PieGridComponent__svg_g_2__svg_text_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "text", 12);
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("countTo", series_r1.total)("countPrefix", ctx_r4.label + ": ");
    ɵngcc0.ɵɵattribute("y", series_r1.outerRadius);
} }
function PieGridComponent__svg_g_2__svg_text_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 13);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("y", series_r1.outerRadius);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate2(" ", ctx_r5.label, ": ", series_r1.total.toLocaleString(), " ");
} }
var _c42 = function (a0) { return { data: a0 }; };
function PieGridComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r11 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵelementStart(1, "g", 4);
    ɵngcc0.ɵɵlistener("select", function PieGridComponent__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r10 = ɵngcc0.ɵɵnextContext(); return ctx_r10.onClick($event); })("activate", function PieGridComponent__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r12 = ɵngcc0.ɵɵnextContext(); return ctx_r12.onActivate($event); })("deactivate", function PieGridComponent__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r11); var ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(2, PieGridComponent__svg_g_2__svg_text_2_Template, 1, 2, "text", 5);
    ɵngcc0.ɵɵtemplate(3, PieGridComponent__svg_g_2__svg_text_3_Template, 2, 1, "text", 6);
    ɵngcc0.ɵɵelementStart(4, "text", 7);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, PieGridComponent__svg_g_2__svg_text_6_Template, 1, 3, "text", 8);
    ɵngcc0.ɵɵtemplate(7, PieGridComponent__svg_g_2__svg_text_7_Template, 2, 3, "text", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var series_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", series_r1.transform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("colors", series_r1.colors)("data", series_r1.data)("innerRadius", series_r1.innerRadius)("outerRadius", series_r1.outerRadius)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.tooltipText(ɵngcc0.ɵɵpureFunction1(17, _c42, series_r1)))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", series_r1.data[0].data);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.animations);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", series_r1.label, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.animations);
} }
var _c43 = ["ngx-charts-pie-grid-series", ""];
function PieGridSeriesComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵlistener("select", function PieGridSeriesComponent__svg_g_1_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick($event); })("activate", function PieGridSeriesComponent__svg_g_1_Template__svg_g_activate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.activate.emit($event); })("deactivate", function PieGridSeriesComponent__svg_g_1_Template__svg_g_deactivate_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.deactivate.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("startAngle", arc_r1.startAngle)("endAngle", arc_r1.endAngle)("innerRadius", ctx_r0.innerRadius)("outerRadius", ctx_r0.outerRadius)("fill", ctx_r0.color(arc_r1))("value", arc_r1.data.value)("data", arc_r1.data)("gradient", false)("pointerEvents", arc_r1.pointerEvents)("animate", arc_r1.animate);
    ɵngcc0.ɵɵattribute("class", arc_r1.class);
} }
var _c44 = ["ngx-charts-pie-series", ""];
function PieSeriesComponent__svg_g_0__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 3);
} if (rf & 2) {
    var arc_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", arc_r1)("radius", ctx_r2.outerRadius)("color", ctx_r2.color(arc_r1))("label", ctx_r2.labelText(arc_r1))("labelTrim", ctx_r2.trimLabels)("labelTrimSize", ctx_r2.maxLabelLength)("max", ctx_r2.max)("value", arc_r1.value)("explodeSlices", ctx_r2.explodeSlices)("animations", ctx_r2.animations);
} }
function PieSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵtemplate(1, PieSeriesComponent__svg_g_0__svg_g_1_Template, 1, 10, "g", 1);
    ɵngcc0.ɵɵelementStart(2, "g", 2);
    ɵngcc0.ɵɵlistener("select", function PieSeriesComponent__svg_g_0_Template__svg_g_select_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); })("activate", function PieSeriesComponent__svg_g_0_Template__svg_g_activate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.activate.emit($event); })("deactivate", function PieSeriesComponent__svg_g_0_Template__svg_g_deactivate_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.deactivate.emit($event); })("dblclick", function PieSeriesComponent__svg_g_0_Template__svg_g_dblclick_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.dblclick.emit($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.labelVisible(arc_r1));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("startAngle", arc_r1.startAngle)("endAngle", arc_r1.endAngle)("innerRadius", ctx_r0.innerRadius)("outerRadius", ctx_r0.outerRadius)("fill", ctx_r0.color(arc_r1))("value", arc_r1.data.value)("gradient", ctx_r0.gradient)("data", arc_r1.data)("max", ctx_r0.max)("explodeSlices", ctx_r0.explodeSlices)("isActive", ctx_r0.isActive(arc_r1.data))("animate", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.getTooltipTitle(arc_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", arc_r1.data);
} }
var _c45 = ["textEl"];
var _c46 = ["ngx-charts-card", ""];
function CardComponent__svg_path_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "path", 7);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("fill", ctx_r0.bandColor)("transform", ctx_r0.transformBand)("d", ctx_r0.bandPath);
} }
var _c47 = ["ngx-charts-card-series", ""];
function CardSeriesComponent__svg_rect_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "rect", 2);
} if (rf & 2) {
    var c_r2 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("fill", ctx_r0.emptyColor);
    ɵngcc0.ɵɵattribute("x", c_r2.x)("y", c_r2.y)("width", c_r2.width)("height", c_r2.height);
} }
function CardSeriesComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 3);
    ɵngcc0.ɵɵlistener("select", function CardSeriesComponent__svg_g_1_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r3 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("x", c_r3.x)("y", c_r3.y)("width", c_r3.width)("height", c_r3.height)("color", c_r3.color)("bandColor", c_r3.bandColor)("textColor", c_r3.textColor)("data", c_r3.data)("label", c_r3.label)("medianSize", ctx_r1.medianSize)("valueFormatting", ctx_r1.valueFormatting)("labelFormatting", ctx_r1.labelFormatting)("animations", ctx_r1.animations);
} }
var _c48 = ["ngx-charts-tree-map-cell", ""];
function TreeMapCellComponent__svg_defs_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "defs");
    ɵngcc0.ɵɵelement(1, "g", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
} }
function TreeMapCellComponent__svg_foreignObject_3__xhtml_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 8);
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("countTo", ctx_r2.value)("valueFormatting", ctx_r2.valueFormatting);
} }
function TreeMapCellComponent__svg_foreignObject_3__xhtml_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.formattedValue, " ");
} }
function TreeMapCellComponent__svg_foreignObject_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "foreignObject", 4);
    ɵngcc0.ɵɵnamespaceHTML();
    ɵngcc0.ɵɵelementStart(1, "p");
    ɵngcc0.ɵɵelement(2, "span", 5);
    ɵngcc0.ɵɵelement(3, "br");
    ɵngcc0.ɵɵtemplate(4, TreeMapCellComponent__svg_foreignObject_3__xhtml_span_4_Template, 1, 2, "span", 6);
    ɵngcc0.ɵɵtemplate(5, TreeMapCellComponent__svg_foreignObject_3__xhtml_span_5_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("pointer-events", "none");
    ɵngcc0.ɵɵattribute("x", ctx_r1.x)("y", ctx_r1.y)("width", ctx_r1.width)("height", ctx_r1.height);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("color", ctx_r1.getTextColor())("height", ctx_r1.height + "px")("width", ctx_r1.width + "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r1.formattedLabel, ɵngcc0.ɵɵsanitizeHtml);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.animations);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.animations);
} }
var _c49 = ["ngx-charts-tree-map-cell-series", ""];
function TreeMapCellSeriesComponent__svg_g_0_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 1);
    ɵngcc0.ɵɵlistener("select", function TreeMapCellSeriesComponent__svg_g_0_Template__svg_g_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r3); var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.onClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var c_r1 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("data", c_r1.data)("x", c_r1.x)("y", c_r1.y)("width", c_r1.width)("height", c_r1.height)("fill", c_r1.fill)("label", c_r1.label)("value", c_r1.value)("valueType", c_r1.valueType)("valueFormatting", ctx_r0.valueFormatting)("labelFormatting", ctx_r0.labelFormatting)("gradient", ctx_r0.gradient)("animations", ctx_r0.animations)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx_r0.tooltipTemplate ? undefined : ctx_r0.getTooltipText(c_r1))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", c_r1.data);
} }
var _c50 = ["valueTextEl"];
var _c51 = ["unitsTextEl"];
function LinearGaugeComponent__svg_line_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 10);
} if (rf & 2) {
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r0.transformLine)("stroke", ctx_r0.colors.getColor(ctx_r0.units));
} }
function LinearGaugeComponent__svg_line_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "line", 11);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r1.transformLine)("stroke", ctx_r1.colors.getColor(ctx_r1.units));
} }
var _c52 = function () { return {}; };
function GaugeComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    var _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g");
    ɵngcc0.ɵɵelementStart(1, "g", 5);
    ɵngcc0.ɵɵlistener("select", function GaugeComponent__svg_g_2_Template__svg_g_select_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4.onClick($event); })("activate", function GaugeComponent__svg_g_2_Template__svg_g_activate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r6 = ɵngcc0.ɵɵnextContext(); return ctx_r6.onActivate($event); })("deactivate", function GaugeComponent__svg_g_2_Template__svg_g_deactivate_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r5); var ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.onDeactivate($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var arc_r3 = ctx.$implicit;
    var ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("transform", ctx_r0.rotation);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("backgroundArc", arc_r3.backgroundArc)("valueArc", arc_r3.valueArc)("cornerRadius", ctx_r0.cornerRadius)("colors", ctx_r0.colors)("isActive", ctx_r0.isActive(arc_r3.valueArc.data))("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipTemplate", ctx_r0.tooltipTemplate)("valueFormatting", ctx_r0.valueFormatting)("animations", ctx_r0.animations);
} }
function GaugeComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "g", 6);
} if (rf & 2) {
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("bigSegments", ctx_r1.bigSegments)("smallSegments", ctx_r1.smallSegments)("min", ctx_r1.min)("max", ctx_r1.max)("radius", ctx_r1.outerRadius)("angleSpan", ctx_r1.angleSpan)("valueScale", ctx_r1.valueScale)("startAngle", ctx_r1.startAngle)("tickFormatting", ctx_r1.axisTickFormatting);
} }
function GaugeComponent__svg_text_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 7, 8);
    ɵngcc0.ɵɵelementStart(2, "tspan", 9);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "tspan", 10);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
    ɵngcc0.ɵɵattribute("transform", ctx_r2.textTransform);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.displayValue);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r2.units);
} }
var _c53 = ["ngx-charts-gauge-arc", ""];
var _c54 = ["ngx-charts-gauge-axis", ""];
function GaugeAxisComponent__svg_g_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r3 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r3.line);
} }
function GaugeAxisComponent__svg_g_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 2);
    ɵngcc0.ɵɵelementStart(1, "text", 3);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r4 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("text-anchor", tick_r4.textAnchor);
    ɵngcc0.ɵɵattribute("transform", tick_r4.textTransform);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", tick_r4.text, " ");
} }
function GaugeAxisComponent__svg_g_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "g", 4);
    ɵngcc0.ɵɵelement(1, "path");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var tick_r5 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("d", tick_r5.line);
} }
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

// The export is needed here to generate a valid polyfills.metadata.json file
function ngxChartsPolyfills() {
    // IE11 fix
    // Ref: https://github.com/swimlane/ngx-charts/issues/386
    if (typeof (SVGElement) !== 'undefined' && typeof SVGElement.prototype.contains === 'undefined') {
        SVGElement.prototype.contains = HTMLDivElement.prototype.contains;
    }
}
ngxChartsPolyfills();

var PlacementTypes;
(function (PlacementTypes) {
    PlacementTypes[PlacementTypes["top"] = 'top'] = "top";
    PlacementTypes[PlacementTypes["bottom"] = 'bottom'] = "bottom";
    PlacementTypes[PlacementTypes["left"] = 'left'] = "left";
    PlacementTypes[PlacementTypes["right"] = 'right'] = "right";
})(PlacementTypes || (PlacementTypes = {}));

var caretOffset = 7;
function verticalPosition(elDimensions, popoverDimensions, alignment) {
    if (alignment === 'top') {
        return elDimensions.top - caretOffset;
    }
    if (alignment === 'bottom') {
        return elDimensions.top + elDimensions.height - popoverDimensions.height + caretOffset;
    }
    if (alignment === 'center') {
        return elDimensions.top + elDimensions.height / 2 - popoverDimensions.height / 2;
    }
    return undefined;
}
function horizontalPosition(elDimensions, popoverDimensions, alignment) {
    if (alignment === 'left') {
        return elDimensions.left - caretOffset;
    }
    if (alignment === 'right') {
        return elDimensions.left + elDimensions.width - popoverDimensions.width + caretOffset;
    }
    if (alignment === 'center') {
        return elDimensions.left + elDimensions.width / 2 - popoverDimensions.width / 2;
    }
    return undefined;
}
/**
 * Position helper for the popover directive.
 *
 * @export
 * @class PositionHelper
 */
var PositionHelper = /** @class */ (function () {
    function PositionHelper() {
    }
    /**
     * Calculate vertical alignment position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateVerticalAlignment = function (elDimensions, popoverDimensions, alignment) {
        var result = verticalPosition(elDimensions, popoverDimensions, alignment);
        if (result + popoverDimensions.height > window.innerHeight) {
            result = window.innerHeight - popoverDimensions.height;
        }
        return result;
    };
    /**
     * Calculate vertical caret position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} caretDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateVerticalCaret = function (elDimensions, popoverDimensions, caretDimensions, alignment) {
        var result;
        if (alignment === 'top') {
            result = elDimensions.height / 2 - caretDimensions.height / 2 + caretOffset;
        }
        if (alignment === 'bottom') {
            result = popoverDimensions.height - elDimensions.height / 2 - caretDimensions.height / 2 - caretOffset;
        }
        if (alignment === 'center') {
            result = popoverDimensions.height / 2 - caretDimensions.height / 2;
        }
        var popoverPosition = verticalPosition(elDimensions, popoverDimensions, alignment);
        if (popoverPosition + popoverDimensions.height > window.innerHeight) {
            result += (popoverPosition + popoverDimensions.height - window.innerHeight);
        }
        return result;
    };
    /**
     * Calculate horz alignment position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateHorizontalAlignment = function (elDimensions, popoverDimensions, alignment) {
        var result = horizontalPosition(elDimensions, popoverDimensions, alignment);
        if (result + popoverDimensions.width > window.innerWidth) {
            result = window.innerWidth - popoverDimensions.width;
        }
        return result;
    };
    /**
     * Calculate horz caret position
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} caretDimensions
     * @param {any} alignment
     * @returns {number}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.calculateHorizontalCaret = function (elDimensions, popoverDimensions, caretDimensions, alignment) {
        var result;
        if (alignment === 'left') {
            result = elDimensions.width / 2 - caretDimensions.width / 2 + caretOffset;
        }
        if (alignment === 'right') {
            result = popoverDimensions.width - elDimensions.width / 2 - caretDimensions.width / 2 - caretOffset;
        }
        if (alignment === 'center') {
            result = popoverDimensions.width / 2 - caretDimensions.width / 2;
        }
        var popoverPosition = horizontalPosition(elDimensions, popoverDimensions, alignment);
        if (popoverPosition + popoverDimensions.width > window.innerWidth) {
            result += (popoverPosition + popoverDimensions.width - window.innerWidth);
        }
        return result;
    };
    /**
     * Checks if the element's position should be flipped
     *
     * @static
     * @param {any} elDimensions
     * @param {any} popoverDimensions
     * @param {any} placement
     * @param {any} spacing
     * @returns {boolean}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.shouldFlip = function (elDimensions, popoverDimensions, placement, spacing) {
        var flip = false;
        if (placement === 'right') {
            if (elDimensions.left + elDimensions.width + popoverDimensions.width + spacing > window.innerWidth) {
                flip = true;
            }
        }
        if (placement === 'left') {
            if (elDimensions.left - popoverDimensions.width - spacing < 0) {
                flip = true;
            }
        }
        if (placement === 'top') {
            if (elDimensions.top - popoverDimensions.height - spacing < 0) {
                flip = true;
            }
        }
        if (placement === 'bottom') {
            if (elDimensions.top + elDimensions.height + popoverDimensions.height + spacing > window.innerHeight) {
                flip = true;
            }
        }
        return flip;
    };
    /**
     * Position caret
     *
     * @static
     * @param {any} placement
     * @param {any} elmDim
     * @param {any} hostDim
     * @param {any} caretDimensions
     * @param {any} alignment
     * @returns {*}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.positionCaret = function (placement, elmDim, hostDim, caretDimensions, alignment) {
        var top = 0;
        var left = 0;
        if (placement === PlacementTypes.right) {
            left = -7;
            top = PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.left) {
            left = elmDim.width;
            top = PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.top) {
            top = elmDim.height;
            left = PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.bottom) {
            top = -7;
            left = PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        return { top: top, left: left };
    };
    /**
     * Position content
     *
     * @static
     * @param {any} placement
     * @param {any} elmDim
     * @param {any} hostDim
     * @param {any} spacing
     * @param {any} alignment
     * @returns {*}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.positionContent = function (placement, elmDim, hostDim, spacing, alignment) {
        var top = 0;
        var left = 0;
        if (placement === PlacementTypes.right) {
            left = hostDim.left + hostDim.width + spacing;
            top = PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.left) {
            left = hostDim.left - elmDim.width - spacing;
            top = PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.top) {
            top = hostDim.top - elmDim.height - spacing;
            left = PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.bottom) {
            top = hostDim.top + hostDim.height + spacing;
            left = PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
        }
        return { top: top, left: left };
    };
    /**
     * Determine placement based on flip
     *
     * @static
     * @param {any} placement
     * @param {any} elmDim
     * @param {any} hostDim
     * @param {any} spacing
     * @returns {*}
     *
     * @memberOf PositionHelper
     */
    PositionHelper.determinePlacement = function (placement, elmDim, hostDim, spacing) {
        var shouldFlip = PositionHelper.shouldFlip(hostDim, elmDim, placement, spacing);
        if (shouldFlip) {
            if (placement === PlacementTypes.right) {
                return PlacementTypes.left;
            }
            else if (placement === PlacementTypes.left) {
                return PlacementTypes.right;
            }
            else if (placement === PlacementTypes.top) {
                return PlacementTypes.bottom;
            }
            else if (placement === PlacementTypes.bottom) {
                return PlacementTypes.top;
            }
        }
        return placement;
    };
    return PositionHelper;
}());

var StyleTypes;
(function (StyleTypes) {
    StyleTypes[StyleTypes["popover"] = 'popover'] = "popover";
    StyleTypes[StyleTypes["tooltip"] = 'tooltip'] = "tooltip";
})(StyleTypes || (StyleTypes = {}));

var AlignmentTypes;
(function (AlignmentTypes) {
    AlignmentTypes[AlignmentTypes["left"] = 'left'] = "left";
    AlignmentTypes[AlignmentTypes["center"] = 'center'] = "center";
    AlignmentTypes[AlignmentTypes["right"] = 'right'] = "right";
})(AlignmentTypes || (AlignmentTypes = {}));

var ShowTypes;
(function (ShowTypes) {
    ShowTypes[ShowTypes["all"] = 'all'] = "all";
    ShowTypes[ShowTypes["focus"] = 'focus'] = "focus";
    ShowTypes[ShowTypes["mouseover"] = 'mouseover'] = "mouseover";
})(ShowTypes || (ShowTypes = {}));

/**
 * Injection service is a helper to append components
 * dynamically to a known location in the DOM, most
 * noteably for dialogs/tooltips appending to body.
 *
 * @export
 * @class InjectionService
 */
var InjectionService = /** @class */ (function () {
    function InjectionService(applicationRef, componentFactoryResolver, injector) {
        this.applicationRef = applicationRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
    }
    InjectionService_1 = InjectionService;
    /**
     * Sets a default global root view container. This is useful for
     * things like ngUpgrade that doesn't have a ApplicationRef root.
     *
     * @param container
     */
    InjectionService.setGlobalRootViewContainer = function (container) {
        InjectionService_1.globalRootViewContainer = container;
    };
    /**
     * Gets the root view container to inject the component to.
     *
     * @returns {ComponentRef<any>}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.getRootViewContainer = function () {
        var rootComponents = this.applicationRef.components;
        // fix cannot read length of undefined
        if (rootComponents) {
            if (rootComponents.length)
                return rootComponents[0];
        }
        if (this._container)
            return this._container;
        if (InjectionService_1.globalRootViewContainer)
            return InjectionService_1.globalRootViewContainer;
        throw new Error('View Container not found! ngUpgrade needs to manually set this via setRootViewContainer.');
    };
    /**
     * Overrides the default root view container. This is useful for
     * things like ngUpgrade that doesn't have a ApplicationRef root.
     *
     * @param {any} container
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.setRootViewContainer = function (container) {
        this._container = container;
    };
    /**
     * Gets the html element for a component ref.
     *
     * @param {ComponentRef<any>} componentRef
     * @returns {HTMLElement}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.getComponentRootNode = function (componentRef) {
        // the top most component root node has no `hostView`
        if (!componentRef.hostView)
            return componentRef.element.nativeElement;
        return componentRef.hostView.rootNodes[0];
    };
    /**
     * Gets the root component container html element.
     *
     * @returns {HTMLElement}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.getRootViewContainerNode = function () {
        return this.getComponentRootNode(this.getRootViewContainer());
    };
    /**
     * Projects the bindings onto the component
     *
     * @param {ComponentRef<any>} component
     * @param {*} options
     * @returns {ComponentRef<any>}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.projectComponentBindings = function (component, bindings) {
        if (bindings) {
            if (bindings.inputs !== undefined) {
                var bindingKeys = Object.getOwnPropertyNames(bindings.inputs);
                for (var _i = 0, bindingKeys_1 = bindingKeys; _i < bindingKeys_1.length; _i++) {
                    var bindingName = bindingKeys_1[_i];
                    component.instance[bindingName] = bindings.inputs[bindingName];
                }
            }
            if (bindings.outputs !== undefined) {
                var eventKeys = Object.getOwnPropertyNames(bindings.outputs);
                for (var _a = 0, eventKeys_1 = eventKeys; _a < eventKeys_1.length; _a++) {
                    var eventName = eventKeys_1[_a];
                    component.instance[eventName] = bindings.outputs[eventName];
                }
            }
        }
        return component;
    };
    /**
     * Appends a component to a adjacent location
     *
     * @template T
     * @param {Type<T>} componentClass
     * @param {*} [options={}]
     * @param {Element} [location=this.getRootViewContainerNode()]
     * @returns {ComponentRef<any>}
     *
     * @memberOf InjectionService
     */
    InjectionService.prototype.appendComponent = function (componentClass, bindings, location) {
        if (bindings === void 0) { bindings = {}; }
        if (location === void 0) { location = this.getRootViewContainerNode(); }
        var componentFactory = this.componentFactoryResolver.resolveComponentFactory(componentClass);
        var componentRef = componentFactory.create(this.injector);
        var appRef = this.applicationRef;
        var componentRootNode = this.getComponentRootNode(componentRef);
        // project the options passed to the component instance
        this.projectComponentBindings(componentRef, bindings);
        appRef.attachView(componentRef.hostView);
        componentRef.onDestroy(function () {
            appRef.detachView(componentRef.hostView);
        });
        // use the renderer to append the element for univseral support
        var renderer = componentRef.instance.renderer;
        renderer.appendChild(location, componentRootNode);
        return componentRef;
    };
    var InjectionService_1, _a, _b, _c;
    InjectionService.globalRootViewContainer = null;
    InjectionService = InjectionService_1 = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ApplicationRef !== "undefined" && ApplicationRef) === "function" ? _a : Object, typeof (_b = typeof ComponentFactoryResolver !== "undefined" && ComponentFactoryResolver) === "function" ? _b : Object, typeof (_c = typeof Injector !== "undefined" && Injector) === "function" ? _c : Object])
    ], InjectionService);
InjectionService.ɵfac = function InjectionService_Factory(t) { return new (t || InjectionService)(ɵngcc0.ɵɵinject(typeof (_a = typeof ApplicationRef !== "undefined" && ApplicationRef) === "function" ? _a : Object), ɵngcc0.ɵɵinject(typeof (_b = typeof ComponentFactoryResolver !== "undefined" && ComponentFactoryResolver) === "function" ? _b : Object), ɵngcc0.ɵɵinject(typeof (_c = typeof Injector !== "undefined" && Injector) === "function" ? _c : Object)); };
InjectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: InjectionService, factory: function (t) { return InjectionService.ɵfac(t); } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InjectionService, [{
        type: Injectable
    }], function () { return [{ type: typeof (_a = typeof ApplicationRef !== "undefined" && ApplicationRef) === "function" ? _a : Object }, { type: typeof (_b = typeof ComponentFactoryResolver !== "undefined" && ComponentFactoryResolver) === "function" ? _b : Object }, { type: typeof (_c = typeof Injector !== "undefined" && Injector) === "function" ? _c : Object }]; }, null); })();
    return InjectionService;
}());

var InjectionRegistery = /** @class */ (function () {
    function InjectionRegistery(injectionService) {
        this.injectionService = injectionService;
        this.defaults = {};
        this.components = new Map();
    }
    InjectionRegistery.prototype.getByType = function (type) {
        if (type === void 0) { type = this.type; }
        return this.components.get(type);
    };
    InjectionRegistery.prototype.create = function (bindings) {
        return this.createByType(this.type, bindings);
    };
    InjectionRegistery.prototype.createByType = function (type, bindings) {
        bindings = this.assignDefaults(bindings);
        var component = this.injectComponent(type, bindings);
        this.register(type, component);
        return component;
    };
    InjectionRegistery.prototype.destroy = function (instance) {
        var compsByType = this.components.get(instance.componentType);
        if (compsByType) {
            var idx = compsByType.indexOf(instance);
            if (idx > -1) {
                var component = compsByType[idx];
                component.destroy();
                compsByType.splice(idx, 1);
            }
        }
    };
    InjectionRegistery.prototype.destroyAll = function () {
        this.destroyByType(this.type);
    };
    InjectionRegistery.prototype.destroyByType = function (type) {
        var comps = this.components.get(type);
        if (comps) {
            for (var _i = 0, comps_1 = comps; _i < comps_1.length; _i++) {
                var comp = comps_1[_i];
                this.destroy(comp);
            }
        }
    };
    InjectionRegistery.prototype.assignDefaults = function (bindings) {
        var _a = this.defaults, inputs = _a.inputs, outputs = _a.outputs;
        if (!bindings.inputs && !bindings.outputs) {
            bindings = { inputs: bindings };
        }
        if (inputs) {
            bindings.inputs = Object.assign(inputs, bindings.inputs);
        }
        if (outputs) {
            bindings.outputs = Object.assign(outputs, bindings.outputs);
        }
        return bindings;
    };
    InjectionRegistery.prototype.injectComponent = function (type, bindings) {
        return this.injectionService.appendComponent(type, bindings);
    };
    InjectionRegistery.prototype.register = function (type, component) {
        if (!this.components.has(type)) {
            this.components.set(type, []);
        }
        var types = this.components.get(type);
        types.push(component);
    };
    return InjectionRegistery;
}());

/**
 * Throttle a function
 *
 * @export
 * @param {*}      func
 * @param {number} wait
 * @param {*}      [options]
 * @returns
 */
function throttle(func, wait, options) {
    options = options || {};
    var context;
    var args;
    var result;
    var timeout = null;
    var previous = 0;
    function later() {
        previous = options.leading === false ? 0 : +new Date();
        timeout = null;
        result = func.apply(context, args);
    }
    return function () {
        var now = +new Date();
        if (!previous && options.leading === false) {
            previous = now;
        }
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0) {
            clearTimeout(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
        }
        else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
}
/**
 * Throttle decorator
 *
 *  class MyClass {
 *    throttleable(10)
 *    myFn() { ... }
 *  }
 *
 * @export
 * @param {number} duration
 * @param {*} [options]
 * @returns
 */
function throttleable(duration, options) {
    return function innerDecorator(target, key, descriptor) {
        return {
            configurable: true,
            enumerable: descriptor.enumerable,
            get: function getter() {
                Object.defineProperty(this, key, {
                    configurable: true,
                    enumerable: descriptor.enumerable,
                    value: throttle(descriptor.value, duration, options)
                });
                return this[key];
            }
        };
    };
}

var TooltipContentComponent = /** @class */ (function () {
    function TooltipContentComponent(element, renderer) {
        this.element = element;
        this.renderer = renderer;
    }
    Object.defineProperty(TooltipContentComponent.prototype, "cssClasses", {
        get: function () {
            var clz = 'ngx-charts-tooltip-content';
            clz += " position-" + this.placement;
            clz += " type-" + this.type;
            clz += " " + this.cssClass;
            return clz;
        },
        enumerable: true,
        configurable: true
    });
    TooltipContentComponent.prototype.ngAfterViewInit = function () {
        setTimeout(this.position.bind(this));
    };
    TooltipContentComponent.prototype.position = function () {
        var _this = this;
        var nativeElm = this.element.nativeElement;
        var hostDim = this.host.nativeElement.getBoundingClientRect();
        if (!hostDim.height && !hostDim.width)
            return;
        var elmDim = nativeElm.getBoundingClientRect();
        this.checkFlip(hostDim, elmDim);
        this.positionContent(nativeElm, hostDim, elmDim);
        if (this.showCaret) {
            this.positionCaret(hostDim, elmDim);
        }
        setTimeout(function () { return _this.renderer.addClass(nativeElm, 'animate'); }, 1);
    };
    TooltipContentComponent.prototype.positionContent = function (nativeElm, hostDim, elmDim) {
        var _a = PositionHelper.positionContent(this.placement, elmDim, hostDim, this.spacing, this.alignment), top = _a.top, left = _a.left;
        this.renderer.setStyle(nativeElm, 'top', top + "px");
        this.renderer.setStyle(nativeElm, 'left', left + "px");
    };
    TooltipContentComponent.prototype.positionCaret = function (hostDim, elmDim) {
        var caretElm = this.caretElm.nativeElement;
        var caretDimensions = caretElm.getBoundingClientRect();
        var _a = PositionHelper.positionCaret(this.placement, elmDim, hostDim, caretDimensions, this.alignment), top = _a.top, left = _a.left;
        this.renderer.setStyle(caretElm, 'top', top + "px");
        this.renderer.setStyle(caretElm, 'left', left + "px");
    };
    TooltipContentComponent.prototype.checkFlip = function (hostDim, elmDim) {
        this.placement = PositionHelper.determinePlacement(this.placement, elmDim, hostDim, this.spacing);
    };
    TooltipContentComponent.prototype.onWindowResize = function () {
        this.position();
    };
    var _a, _b, _c, _d, _e;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "host", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipContentComponent.prototype, "showCaret", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof StyleTypes !== "undefined" && StyleTypes) === "function" ? _a : Object)
    ], TooltipContentComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof PlacementTypes !== "undefined" && PlacementTypes) === "function" ? _b : Object)
    ], TooltipContentComponent.prototype, "placement", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_c = typeof AlignmentTypes !== "undefined" && AlignmentTypes) === "function" ? _c : Object)
    ], TooltipContentComponent.prototype, "alignment", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipContentComponent.prototype, "spacing", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipContentComponent.prototype, "cssClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipContentComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "template", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "context", void 0);
    __decorate([
        ViewChild('caretElm', { static: false }),
        __metadata("design:type", Object)
    ], TooltipContentComponent.prototype, "caretElm", void 0);
    __decorate([
        HostBinding('class'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [])
    ], TooltipContentComponent.prototype, "cssClasses", null);
    __decorate([
        HostListener('window:resize'),
        throttleable(100),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipContentComponent.prototype, "onWindowResize", null);
    TooltipContentComponent = __decorate([ __metadata("design:paramtypes", [typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object, typeof (_e = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _e : Object])
    ], TooltipContentComponent);
TooltipContentComponent.ɵfac = function TooltipContentComponent_Factory(t) { return new (t || TooltipContentComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_e = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _e : Object)); };
TooltipContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipContentComponent, selectors: [["ngx-tooltip-content"]], viewQuery: function TooltipContentComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.caretElm = _t.first);
    } }, hostVars: 2, hostBindings: function TooltipContentComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("resize", function TooltipContentComponent_resize_HostBindingHandler() { return ctx.onWindowResize(); }, false, ɵngcc0.ɵɵresolveWindow);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.cssClasses);
    } }, inputs: { placement: "placement", host: "host", showCaret: "showCaret", type: "type", alignment: "alignment", spacing: "spacing", cssClass: "cssClass", title: "title", template: "template", context: "context" }, decls: 6, vars: 6, consts: [[3, "hidden"], ["caretElm", ""], [1, "tooltip-content"], [4, "ngIf"], [3, "innerHTML", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"]], template: function TooltipContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelement(1, "span", 0, 1);
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵtemplate(4, TooltipContentComponent_span_4_Template, 2, 4, "span", 3);
        ɵngcc0.ɵɵtemplate(5, TooltipContentComponent_span_5_Template, 1, 1, "span", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMapInterpolate1("tooltip-caret position-", ctx.placement, "");
        ɵngcc0.ɵɵproperty("hidden", !ctx.showCaret);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:400;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:rgba(0,0,0,.75);font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px 5px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translate3d(0,0,0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}"], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipContentComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-tooltip-content',
                template: "\n    <div>\n      <span #caretElm [hidden]=\"!showCaret\" class=\"tooltip-caret position-{{ this.placement }}\"> </span>\n      <div class=\"tooltip-content\">\n        <span *ngIf=\"!title\">\n          <ng-template [ngTemplateOutlet]=\"template\" [ngTemplateOutletContext]=\"{ model: context }\"> </ng-template>\n        </span>\n        <span *ngIf=\"title\" [innerHTML]=\"title\"> </span>\n      </div>\n    </div>\n  ",
                encapsulation: ViewEncapsulation.None,
                styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:400;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:rgba(0,0,0,.75);font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px 5px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translate3d(0,0,0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}"]
            }]
    }], function () { return [{ type: typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object }, { type: typeof (_e = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _e : Object }]; }, { cssClasses: [{
            type: HostBinding,
            args: ['class']
        }], placement: [{
            type: Input
        }], onWindowResize: [{
            type: HostListener,
            args: ['window:resize']
        }], host: [{
            type: Input
        }], showCaret: [{
            type: Input
        }], type: [{
            type: Input
        }], alignment: [{
            type: Input
        }], spacing: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], title: [{
            type: Input
        }], template: [{
            type: Input
        }], context: [{
            type: Input
        }], caretElm: [{
            type: ViewChild,
            args: ['caretElm', { static: false }]
        }] }); })();
    return TooltipContentComponent;
}());

var TooltipService = /** @class */ (function (_super) {
    __extends(TooltipService, _super);
    function TooltipService(injectionService) {
        var _this = _super.call(this, injectionService) || this;
        _this.injectionService = injectionService;
        _this.type = TooltipContentComponent;
        return _this;
    }
    var _a;
    TooltipService = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof InjectionService !== "undefined" && InjectionService) === "function" ? _a : Object])
    ], TooltipService);
TooltipService.ɵfac = function TooltipService_Factory(t) { return new (t || TooltipService)(ɵngcc0.ɵɵinject(typeof (_a = typeof InjectionService !== "undefined" && InjectionService) === "function" ? _a : Object)); };
TooltipService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TooltipService, factory: function (t) { return TooltipService.ɵfac(t); } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipService, [{
        type: Injectable
    }], function () { return [{ type: typeof (_a = typeof InjectionService !== "undefined" && InjectionService) === "function" ? _a : Object }]; }, null); })();
    return TooltipService;
}(InjectionRegistery));

var TooltipDirective = /** @class */ (function () {
    function TooltipDirective(tooltipService, viewContainerRef, renderer) {
        this.tooltipService = tooltipService;
        this.viewContainerRef = viewContainerRef;
        this.renderer = renderer;
        this.tooltipCssClass = '';
        this.tooltipTitle = '';
        this.tooltipAppendToBody = true;
        this.tooltipSpacing = 10;
        this.tooltipDisabled = false;
        this.tooltipShowCaret = true;
        this.tooltipPlacement = PlacementTypes.top;
        this.tooltipAlignment = AlignmentTypes.center;
        this.tooltipType = StyleTypes.popover;
        this.tooltipCloseOnClickOutside = true;
        this.tooltipCloseOnMouseLeave = true;
        this.tooltipHideTimeout = 300;
        this.tooltipShowTimeout = 100;
        this.tooltipShowEvent = ShowTypes.all;
        this.tooltipImmediateExit = false;
        this.show = new EventEmitter();
        this.hide = new EventEmitter();
    }
    Object.defineProperty(TooltipDirective.prototype, "listensForFocus", {
        get: function () {
            return this.tooltipShowEvent === ShowTypes.all ||
                this.tooltipShowEvent === ShowTypes.focus;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TooltipDirective.prototype, "listensForHover", {
        get: function () {
            return this.tooltipShowEvent === ShowTypes.all ||
                this.tooltipShowEvent === ShowTypes.mouseover;
        },
        enumerable: true,
        configurable: true
    });
    TooltipDirective.prototype.ngOnDestroy = function () {
        this.hideTooltip(true);
    };
    TooltipDirective.prototype.onFocus = function () {
        if (this.listensForFocus) {
            this.showTooltip();
        }
    };
    TooltipDirective.prototype.onBlur = function () {
        if (this.listensForFocus) {
            this.hideTooltip(true);
        }
    };
    TooltipDirective.prototype.onMouseEnter = function () {
        if (this.listensForHover) {
            this.showTooltip();
        }
    };
    TooltipDirective.prototype.onMouseLeave = function (target) {
        if (this.listensForHover && this.tooltipCloseOnMouseLeave) {
            clearTimeout(this.timeout);
            if (this.component) {
                var contentDom = this.component.instance.element.nativeElement;
                var contains = contentDom.contains(target);
                if (contains)
                    return;
            }
            this.hideTooltip(this.tooltipImmediateExit);
        }
    };
    TooltipDirective.prototype.onMouseClick = function () {
        if (this.listensForHover) {
            this.hideTooltip(true);
        }
    };
    TooltipDirective.prototype.showTooltip = function (immediate) {
        var _this = this;
        if (this.component || this.tooltipDisabled)
            return;
        var time = immediate ? 0 : this.tooltipShowTimeout;
        clearTimeout(this.timeout);
        this.timeout = setTimeout(function () {
            _this.tooltipService.destroyAll();
            var options = _this.createBoundOptions();
            _this.component = _this.tooltipService.create(options);
            // add a tiny timeout to avoid event re-triggers
            setTimeout(function () {
                if (_this.component) {
                    _this.addHideListeners(_this.component.instance.element.nativeElement);
                }
            }, 10);
            _this.show.emit(true);
        }, time);
    };
    TooltipDirective.prototype.addHideListeners = function (tooltip) {
        var _this = this;
        // on mouse enter, cancel the hide triggered by the leave
        this.mouseEnterContentEvent = this.renderer.listen(tooltip, 'mouseenter', function () {
            clearTimeout(_this.timeout);
        });
        // content mouse leave listener
        if (this.tooltipCloseOnMouseLeave) {
            this.mouseLeaveContentEvent = this.renderer.listen(tooltip, 'mouseleave', function () {
                _this.hideTooltip(_this.tooltipImmediateExit);
            });
        }
        // content close on click outside
        if (this.tooltipCloseOnClickOutside) {
            this.documentClickEvent = this.renderer.listen(document, 'click', function (event$$1) {
                var contains = tooltip.contains(event$$1.target);
                if (!contains)
                    _this.hideTooltip();
            });
        }
    };
    TooltipDirective.prototype.hideTooltip = function (immediate) {
        var _this = this;
        if (immediate === void 0) { immediate = false; }
        if (!this.component)
            return;
        var destroyFn = function () {
            // remove events
            if (_this.mouseLeaveContentEvent)
                _this.mouseLeaveContentEvent();
            if (_this.mouseEnterContentEvent)
                _this.mouseEnterContentEvent();
            if (_this.documentClickEvent)
                _this.documentClickEvent();
            // emit events
            _this.hide.emit(true);
            // destroy component
            _this.tooltipService.destroy(_this.component);
            _this.component = undefined;
        };
        clearTimeout(this.timeout);
        if (!immediate) {
            this.timeout = setTimeout(destroyFn, this.tooltipHideTimeout);
        }
        else {
            destroyFn();
        }
    };
    TooltipDirective.prototype.createBoundOptions = function () {
        return {
            title: this.tooltipTitle,
            template: this.tooltipTemplate,
            host: this.viewContainerRef.element,
            placement: this.tooltipPlacement,
            alignment: this.tooltipAlignment,
            type: this.tooltipType,
            showCaret: this.tooltipShowCaret,
            cssClass: this.tooltipCssClass,
            spacing: this.tooltipSpacing,
            context: this.tooltipContext
        };
    };
    var _a, _b, _c, _d, _e, _f, _g;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipDirective.prototype, "tooltipCssClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], TooltipDirective.prototype, "tooltipTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipAppendToBody", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "tooltipSpacing", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipShowCaret", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof PlacementTypes !== "undefined" && PlacementTypes) === "function" ? _a : Object)
    ], TooltipDirective.prototype, "tooltipPlacement", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof AlignmentTypes !== "undefined" && AlignmentTypes) === "function" ? _b : Object)
    ], TooltipDirective.prototype, "tooltipAlignment", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_c = typeof StyleTypes !== "undefined" && StyleTypes) === "function" ? _c : Object)
    ], TooltipDirective.prototype, "tooltipType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipCloseOnClickOutside", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipCloseOnMouseLeave", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "tooltipHideTimeout", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], TooltipDirective.prototype, "tooltipShowTimeout", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_d = typeof ShowTypes !== "undefined" && ShowTypes) === "function" ? _d : Object)
    ], TooltipDirective.prototype, "tooltipShowEvent", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "tooltipContext", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipDirective.prototype, "tooltipImmediateExit", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "show", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TooltipDirective.prototype, "hide", void 0);
    __decorate([
        HostListener('focusin'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onFocus", null);
    __decorate([
        HostListener('blur'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onBlur", null);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave', ['$event.target']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onMouseLeave", null);
    __decorate([
        HostListener('click'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], TooltipDirective.prototype, "onMouseClick", null);
    TooltipDirective = __decorate([ __metadata("design:paramtypes", [typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object, typeof (_f = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _f : Object, typeof (_g = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _g : Object])
    ], TooltipDirective);
TooltipDirective.ɵfac = function TooltipDirective_Factory(t) { return new (t || TooltipDirective)(ɵngcc0.ɵɵdirectiveInject(typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_f = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _f : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_g = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _g : Object)); };
TooltipDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TooltipDirective, selectors: [["", "ngx-tooltip", ""]], hostBindings: function TooltipDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focusin", function TooltipDirective_focusin_HostBindingHandler() { return ctx.onFocus(); })("blur", function TooltipDirective_blur_HostBindingHandler() { return ctx.onBlur(); })("mouseenter", function TooltipDirective_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function TooltipDirective_mouseleave_HostBindingHandler($event) { return ctx.onMouseLeave($event.target); })("click", function TooltipDirective_click_HostBindingHandler() { return ctx.onMouseClick(); });
    } }, inputs: { tooltipCssClass: "tooltipCssClass", tooltipTitle: "tooltipTitle", tooltipAppendToBody: "tooltipAppendToBody", tooltipSpacing: "tooltipSpacing", tooltipDisabled: "tooltipDisabled", tooltipShowCaret: "tooltipShowCaret", tooltipPlacement: "tooltipPlacement", tooltipAlignment: "tooltipAlignment", tooltipType: "tooltipType", tooltipCloseOnClickOutside: "tooltipCloseOnClickOutside", tooltipCloseOnMouseLeave: "tooltipCloseOnMouseLeave", tooltipHideTimeout: "tooltipHideTimeout", tooltipShowTimeout: "tooltipShowTimeout", tooltipShowEvent: "tooltipShowEvent", tooltipImmediateExit: "tooltipImmediateExit", tooltipTemplate: "tooltipTemplate", tooltipContext: "tooltipContext" }, outputs: { show: "show", hide: "hide" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipDirective, [{
        type: Directive,
        args: [{ selector: '[ngx-tooltip]' }]
    }], function () { return [{ type: typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object }, { type: typeof (_f = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _f : Object }, { type: typeof (_g = typeof Renderer2 !== "undefined" && Renderer2) === "function" ? _g : Object }]; }, { tooltipCssClass: [{
            type: Input
        }], tooltipTitle: [{
            type: Input
        }], tooltipAppendToBody: [{
            type: Input
        }], tooltipSpacing: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], tooltipShowCaret: [{
            type: Input
        }], tooltipPlacement: [{
            type: Input
        }], tooltipAlignment: [{
            type: Input
        }], tooltipType: [{
            type: Input
        }], tooltipCloseOnClickOutside: [{
            type: Input
        }], tooltipCloseOnMouseLeave: [{
            type: Input
        }], tooltipHideTimeout: [{
            type: Input
        }], tooltipShowTimeout: [{
            type: Input
        }], tooltipShowEvent: [{
            type: Input
        }], tooltipImmediateExit: [{
            type: Input
        }], show: [{
            type: Output
        }], hide: [{
            type: Output
        }], onFocus: [{
            type: HostListener,
            args: ['focusin']
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave', ['$event.target']]
        }], onMouseClick: [{
            type: HostListener,
            args: ['click']
        }], tooltipTemplate: [{
            type: Input
        }], tooltipContext: [{
            type: Input
        }] }); })();
    return TooltipDirective;
}());

var TooltipModule = /** @class */ (function () {
    function TooltipModule() {
    }
TooltipModule.ɵfac = function TooltipModule_Factory(t) { return new (t || TooltipModule)(); };
TooltipModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TooltipModule });
TooltipModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ providers: [InjectionService, TooltipService], imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TooltipModule, { declarations: function () { return [TooltipContentComponent, TooltipDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TooltipContentComponent, TooltipDirective]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipModule, [{
        type: NgModule,
        args: [{
                declarations: [TooltipContentComponent, TooltipDirective],
                providers: [InjectionService, TooltipService],
                exports: [TooltipContentComponent, TooltipDirective],
                imports: [CommonModule],
                entryComponents: [TooltipContentComponent]
            }]
    }], function () { return []; }, null); })();
    return TooltipModule;
}());

var ChartComponent = /** @class */ (function () {
    function ChartComponent(vcr, tooltipService) {
        this.vcr = vcr;
        this.tooltipService = tooltipService;
        this.showLegend = false;
        this.animations = true;
        this.legendLabelClick = new EventEmitter();
        this.legendLabelActivate = new EventEmitter();
        this.legendLabelDeactivate = new EventEmitter();
        this.tooltipService.injectionService.setRootViewContainer(this.vcr);
    }
    ChartComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    ChartComponent.prototype.update = function () {
        var legendColumns = 0;
        if (this.showLegend) {
            this.legendType = this.getLegendType();
            if (!this.legendOptions || this.legendOptions.position === 'right') {
                if (this.legendType === 'scaleLegend') {
                    legendColumns = 1;
                }
                else {
                    legendColumns = 2;
                }
            }
        }
        var chartColumns = 12 - legendColumns;
        this.chartWidth = Math.floor((this.view[0] * chartColumns / 12.0));
        this.legendWidth = (!this.legendOptions || this.legendOptions.position === 'right')
            ? Math.floor((this.view[0] * legendColumns / 12.0))
            : this.chartWidth;
    };
    ChartComponent.prototype.getLegendType = function () {
        if (this.legendOptions.scaleType === 'linear') {
            return 'scaleLegend';
        }
        else {
            return 'legend';
        }
    };
    var _a, _b, _c, _d, _e;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "view", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "showLegend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "legendOptions", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "legendData", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "legendType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ChartComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ChartComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], ChartComponent.prototype, "legendLabelClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], ChartComponent.prototype, "legendLabelActivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], ChartComponent.prototype, "legendLabelDeactivate", void 0);
    ChartComponent = __decorate([ __metadata("design:paramtypes", [typeof (_d = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _d : Object, typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object])
    ], ChartComponent);
ChartComponent.ɵfac = function ChartComponent_Factory(t) { return new (t || ChartComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _d : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object)); };
ChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChartComponent, selectors: [["ngx-charts-chart"]], inputs: { showLegend: "showLegend", animations: "animations", legendType: "legendType", view: "view", legendOptions: "legendOptions", data: "data", legendData: "legendData", colors: "colors", activeEntries: "activeEntries" }, outputs: { legendLabelClick: "legendLabelClick", legendLabelActivate: "legendLabelActivate", legendLabelDeactivate: "legendLabelDeactivate" }, features: [ɵngcc0.ɵɵProvidersFeature([TooltipService]), ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c2, decls: 5, vars: 8, consts: [[1, "ngx-charts-outer"], [1, "ngx-charts"], ["class", "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width", 4, "ngIf"], ["class", "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate", 4, "ngIf"], [1, "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width"], [1, "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate"]], template: function ChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "svg", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, ChartComponent_ngx_charts_scale_legend_3_Template, 1, 5, "ngx-charts-scale-legend", 2);
        ɵngcc0.ɵɵtemplate(4, ChartComponent_ngx_charts_legend_4_Template, 1, 7, "ngx-charts-legend", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.view[0], "px");
        ɵngcc0.ɵɵproperty("@animationState", "active")("@.disabled", !ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.chartWidth)("height", ctx.view[1]);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLegend && ctx.legendType === "scaleLegend");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLegend && ctx.legendType === "legend");
    } }, directives: function () { return [ɵngcc1.NgIf, ScaleLegendComponent, LegendComponent]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({ opacity: 0 }),
                    animate('500ms 100ms', style({ opacity: 1 }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChartComponent, [{
        type: Component,
        args: [{
                providers: [TooltipService],
                selector: 'ngx-charts-chart',
                template: "\n    <div\n      class=\"ngx-charts-outer\"\n      [style.width.px]=\"view[0]\"\n      [@animationState]=\"'active'\"\n      [@.disabled]=\"!animations\">\n      <svg\n        class=\"ngx-charts\"\n        [attr.width]=\"chartWidth\"\n        [attr.height]=\"view[1]\">\n        <ng-content></ng-content>\n      </svg>\n      <ngx-charts-scale-legend\n        *ngIf=\"showLegend && legendType === 'scaleLegend'\"\n        class=\"chart-legend\"\n        [horizontal]=\"legendOptions && legendOptions.position === 'below'\"\n        [valueRange]=\"legendOptions.domain\"\n        [colors]=\"legendOptions.colors\"\n        [height]=\"view[1]\"\n        [width]=\"legendWidth\">\n      </ngx-charts-scale-legend>\n      <ngx-charts-legend\n        *ngIf=\"showLegend && legendType === 'legend'\"\n        class=\"chart-legend\"\n        [horizontal]=\"legendOptions && legendOptions.position === 'below'\"\n        [data]=\"legendOptions.domain\"\n        [title]=\"legendOptions.title\"\n        [colors]=\"legendOptions.colors\"\n        [height]=\"view[1]\"\n        [width]=\"legendWidth\"\n        [activeEntries]=\"activeEntries\"\n        (labelClick)=\"legendLabelClick.emit($event)\"\n        (labelActivate)=\"legendLabelActivate.emit($event)\"\n        (labelDeactivate)=\"legendLabelDeactivate.emit($event)\">\n      </ngx-charts-legend>\n    </div>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({ opacity: 0 }),
                            animate('500ms 100ms', style({ opacity: 1 }))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: typeof (_d = typeof ViewContainerRef !== "undefined" && ViewContainerRef) === "function" ? _d : Object }, { type: typeof (_e = typeof TooltipService !== "undefined" && TooltipService) === "function" ? _e : Object }]; }, { showLegend: [{
            type: Input
        }], animations: [{
            type: Input
        }], legendLabelClick: [{
            type: Output
        }], legendLabelActivate: [{
            type: Output
        }], legendLabelDeactivate: [{
            type: Output
        }], legendType: [{
            type: Input
        }], view: [{
            type: Input
        }], legendOptions: [{
            type: Input
        }], data: [{
            type: Input
        }], legendData: [{
            type: Input
        }], colors: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }] }); })();
    return ChartComponent;
}());

/**
 * Formats a label given a date, number or string.
 *
 * @export
 * @param {*} label
 * @returns {string}
 */
function formatLabel(label) {
    if (label instanceof Date) {
        label = label.toLocaleDateString();
    }
    else {
        label = label.toLocaleString();
    }
    return label;
}

var LegendComponent = /** @class */ (function () {
    function LegendComponent(cd) {
        this.cd = cd;
        this.horizontal = false;
        this.labelClick = new EventEmitter();
        this.labelActivate = new EventEmitter();
        this.labelDeactivate = new EventEmitter();
        this.legendEntries = [];
    }
    LegendComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    LegendComponent.prototype.update = function () {
        this.cd.markForCheck();
        this.legendEntries = this.getLegendEntries();
    };
    LegendComponent.prototype.getLegendEntries = function () {
        var items = [];
        var _loop_1 = function (label) {
            var formattedLabel = formatLabel(label);
            var idx = items.findIndex(function (i) {
                return i.label === formattedLabel;
            });
            if (idx === -1) {
                items.push({
                    label: label,
                    formattedLabel: formattedLabel,
                    color: this_1.colors.getColor(label)
                });
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
            var label = _a[_i];
            _loop_1(label);
        }
        return items;
    };
    LegendComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.label === d.name;
        });
        return item !== undefined;
    };
    LegendComponent.prototype.activate = function (item) {
        this.labelActivate.emit(item);
    };
    LegendComponent.prototype.deactivate = function (item) {
        this.labelDeactivate.emit(item);
    };
    LegendComponent.prototype.trackBy = function (index, item) {
        return item.label;
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendComponent.prototype, "horizontal", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], LegendComponent.prototype, "labelClick", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], LegendComponent.prototype, "labelActivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], LegendComponent.prototype, "labelDeactivate", void 0);
    LegendComponent = __decorate([ __metadata("design:paramtypes", [typeof (_d = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _d : Object])
    ], LegendComponent);
LegendComponent.ɵfac = function LegendComponent_Factory(t) { return new (t || LegendComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _d : Object)); };
LegendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LegendComponent, selectors: [["ngx-charts-legend"]], inputs: { horizontal: "horizontal", data: "data", title: "title", colors: "colors", height: "height", width: "width", activeEntries: "activeEntries" }, outputs: { labelClick: "labelClick", labelActivate: "labelActivate", labelDeactivate: "labelDeactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 5, vars: 9, consts: [["class", "legend-title", 4, "ngIf"], [1, "legend-wrap"], [1, "legend-labels"], ["class", "legend-label", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "legend-title"], [1, "legend-title-text"], [1, "legend-label"], [3, "label", "formattedLabel", "color", "isActive", "select", "activate", "deactivate"]], template: function LegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵtemplate(1, LegendComponent_header_1_Template, 3, 1, "header", 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵelementStart(3, "ul", 2);
        ɵngcc0.ɵɵtemplate(4, LegendComponent_li_4_Template, 2, 4, "li", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", (ctx.title == null ? null : ctx.title.length) > 0);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.height - 45, "px");
        ɵngcc0.ɵɵclassProp("horizontal-legend", ctx.horizontal);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.legendEntries)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc1.NgForOf, LegendEntryComponent]; }, styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:700}.chart-legend li,.chart-legend ul{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:rgba(0,0,0,.05)}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LegendComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-legend',
                template: "\n    <div [style.width.px]=\"width\">\n      <header class=\"legend-title\" *ngIf=\"title?.length > 0\">\n        <span class=\"legend-title-text\">{{title}}</span>\n      </header>\n      <div class=\"legend-wrap\">\n        <ul class=\"legend-labels\"\n            [class.horizontal-legend]=\"horizontal\"\n          [style.max-height.px]=\"height - 45\">\n          <li\n            *ngFor=\"let entry of legendEntries; trackBy: trackBy\"\n            class=\"legend-label\">\n            <ngx-charts-legend-entry\n              [label]=\"entry.label\"\n              [formattedLabel]=\"entry.formattedLabel\"\n              [color]=\"entry.color\"\n              [isActive]=\"isActive(entry)\"\n              (select)=\"labelClick.emit($event)\"\n              (activate)=\"activate($event)\"\n              (deactivate)=\"deactivate($event)\">\n            </ngx-charts-legend-entry>\n          </li>\n        </ul>\n      </div>\n    </div>\n  ",
                styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:700}.chart-legend li,.chart-legend ul{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:rgba(0,0,0,.05)}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_d = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _d : Object }]; }, { horizontal: [{
            type: Input
        }], labelClick: [{
            type: Output
        }], labelActivate: [{
            type: Output
        }], labelDeactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], title: [{
            type: Input
        }], colors: [{
            type: Input
        }], height: [{
            type: Input
        }], width: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }] }); })();
    return LegendComponent;
}());

var ScaleLegendComponent = /** @class */ (function () {
    function ScaleLegendComponent(sanitizer) {
        this.sanitizer = sanitizer;
        this.horizontal = false;
    }
    ScaleLegendComponent.prototype.ngOnChanges = function (changes) {
        var gradientValues = this.gradientString(this.colors.range(), this.colors.domain());
        var direction = (this.horizontal) ? 'right' : 'bottom';
        this.gradient = this.sanitizer.bypassSecurityTrustStyle("linear-gradient(to " + direction + ", " + gradientValues + ")");
    };
    ScaleLegendComponent.prototype.gradientString = function (colors, splits) {
        splits.push(1);
        var pairs = [];
        colors.reverse().forEach(function (c, i) {
            pairs.push(c + " " + Math.round(splits[i] * 100) + "%");
        });
        return pairs.join(', ');
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "valueRange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ScaleLegendComponent.prototype, "horizontal", void 0);
    ScaleLegendComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof DomSanitizer !== "undefined" && DomSanitizer) === "function" ? _a : Object])
    ], ScaleLegendComponent);
ScaleLegendComponent.ɵfac = function ScaleLegendComponent_Factory(t) { return new (t || ScaleLegendComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof DomSanitizer !== "undefined" && DomSanitizer) === "function" ? _a : Object)); };
ScaleLegendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ScaleLegendComponent, selectors: [["ngx-charts-scale-legend"]], inputs: { horizontal: "horizontal", valueRange: "valueRange", colors: "colors", height: "height", width: "width" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 10, consts: [[1, "scale-legend"], [1, "scale-legend-label"], [1, "scale-legend-wrap"]], template: function ScaleLegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "span");
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(4, "div", 2);
        ɵngcc0.ɵɵelementStart(5, "div", 1);
        ɵngcc0.ɵɵelementStart(6, "span");
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("height", ctx.horizontal ? undefined : ctx.height, "px")("width", ctx.width, "px");
        ɵngcc0.ɵɵclassProp("horizontal-legend", ctx.horizontal);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.valueRange[1].toLocaleString());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("background", ctx.gradient);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.valueRange[0].toLocaleString());
    } }, styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{text-align:center;display:flex;flex-direction:column}.chart-legend .scale-legend-wrap{display:inline-block;flex:1;width:30px;border-radius:5px;margin:0 auto}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{width:auto;height:30px;margin:0 16px}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ScaleLegendComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-scale-legend',
                template: "\n    <div\n      class=\"scale-legend\"\n      [class.horizontal-legend]=\"horizontal\"\n      [style.height.px]=\"horizontal ? undefined : height\"\n      [style.width.px]=\"width\">\n      <div class=\"scale-legend-label\">\n        <span>{{ valueRange[1].toLocaleString() }}</span>\n      </div>\n      <div\n        class=\"scale-legend-wrap\"\n        [style.background]=\"gradient\">\n      </div>\n      <div class=\"scale-legend-label\">\n        <span>{{ valueRange[0].toLocaleString() }}</span>\n      </div>\n    </div>\n  ",
                styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{text-align:center;display:flex;flex-direction:column}.chart-legend .scale-legend-wrap{display:inline-block;flex:1;width:30px;border-radius:5px;margin:0 auto}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{width:auto;height:30px;margin:0 16px}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof DomSanitizer !== "undefined" && DomSanitizer) === "function" ? _a : Object }]; }, { horizontal: [{
            type: Input
        }], valueRange: [{
            type: Input
        }], colors: [{
            type: Input
        }], height: [{
            type: Input
        }], width: [{
            type: Input
        }] }); })();
    return ScaleLegendComponent;
}());

var LegendEntryComponent = /** @class */ (function () {
    function LegendEntryComponent() {
        this.isActive = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.toggle = new EventEmitter();
    }
    Object.defineProperty(LegendEntryComponent.prototype, "trimmedLabel", {
        get: function () {
            return this.formattedLabel || '(empty)';
        },
        enumerable: true,
        configurable: true
    });
    LegendEntryComponent.prototype.onMouseEnter = function () {
        this.activate.emit({ name: this.label });
    };
    LegendEntryComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit({ name: this.label });
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LegendEntryComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LegendEntryComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LegendEntryComponent.prototype, "formattedLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LegendEntryComponent.prototype, "isActive", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], LegendEntryComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], LegendEntryComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], LegendEntryComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_d = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _d : Object)
    ], LegendEntryComponent.prototype, "toggle", void 0);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], LegendEntryComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], LegendEntryComponent.prototype, "onMouseLeave", null);
LegendEntryComponent.ɵfac = function LegendEntryComponent_Factory(t) { return new (t || LegendEntryComponent)(); };
LegendEntryComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LegendEntryComponent, selectors: [["ngx-charts-legend-entry"]], hostBindings: function LegendEntryComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function LegendEntryComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function LegendEntryComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { isActive: "isActive", color: "color", label: "label", formattedLabel: "formattedLabel" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", toggle: "toggle" }, decls: 4, vars: 6, consts: [["tabindex", "-1", 3, "title", "click"], [1, "legend-label-color", 3, "click"], [1, "legend-label-text"]], template: function LegendEntryComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵlistener("click", function LegendEntryComponent_Template_span_click_0_listener() { return ctx.select.emit(ctx.formattedLabel); });
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵlistener("click", function LegendEntryComponent_Template_span_click_1_listener() { return ctx.toggle.emit(ctx.formattedLabel); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isActive);
        ɵngcc0.ɵɵproperty("title", ctx.formattedLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("background-color", ctx.color);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.trimmedLabel, " ");
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LegendEntryComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-legend-entry',
                template: "\n    <span \n      [title]=\"formattedLabel\"\n      tabindex=\"-1\"\n      [class.active]=\"isActive\"\n      (click)=\"select.emit(formattedLabel)\">\n      <span\n        class=\"legend-label-color\"\n        [style.background-color]=\"color\"\n        (click)=\"toggle.emit(formattedLabel)\">\n      </span>\n      <span class=\"legend-label-text\">\n        {{trimmedLabel}}\n      </span>\n    </span>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { isActive: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], toggle: [{
            type: Output
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], color: [{
            type: Input
        }], label: [{
            type: Input
        }], formattedLabel: [{
            type: Input
        }] }); })();
    return LegendEntryComponent;
}());

function trimLabel(s, max$$1) {
    if (max$$1 === void 0) { max$$1 = 16; }
    if (typeof s !== 'string') {
        if (typeof s === 'number') {
            return s + '';
        }
        else {
            return '';
        }
    }
    s = s.trim();
    if (s.length <= max$$1) {
        return s;
    }
    else {
        return s.slice(0, max$$1) + "...";
    }
}

var AdvancedLegendComponent = /** @class */ (function () {
    function AdvancedLegendComponent() {
        this.label = 'Total';
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.legendItems = [];
        this.labelFormatting = function (label) { return label; };
        this.percentageFormatting = function (percentage) { return percentage; };
        this.defaultValueFormatting = function (value) { return value.toLocaleString(); };
    }
    AdvancedLegendComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    AdvancedLegendComponent.prototype.getTotal = function () {
        return this.data.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
    };
    AdvancedLegendComponent.prototype.update = function () {
        this.total = this.getTotal();
        this.roundedTotal = this.total;
        this.legendItems = this.getLegendItems();
    };
    AdvancedLegendComponent.prototype.getLegendItems = function () {
        var _this = this;
        return this.data.map(function (d) {
            var label = formatLabel(d.name);
            var value = d.value;
            var color = _this.colors.getColor(label);
            var percentage = _this.total > 0 ? (value / _this.total) * 100 : 0;
            var formattedLabel = typeof _this.labelFormatting === 'function' ? _this.labelFormatting(label) : label;
            return {
                _value: value,
                data: d,
                value: value,
                color: color,
                label: formattedLabel,
                displayLabel: trimLabel(formattedLabel, 20),
                origialLabel: d.name,
                percentage: _this.percentageFormatting ? _this.percentageFormatting(percentage) : percentage.toLocaleString()
            };
        });
    };
    AdvancedLegendComponent.prototype.trackBy = function (item) {
        return item.formattedLabel;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AdvancedLegendComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AdvancedLegendComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AdvancedLegendComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AdvancedLegendComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AdvancedLegendComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AdvancedLegendComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AdvancedLegendComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], AdvancedLegendComponent.prototype, "deactivate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedLegendComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedLegendComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedLegendComponent.prototype, "percentageFormatting", void 0);
AdvancedLegendComponent.ɵfac = function AdvancedLegendComponent_Factory(t) { return new (t || AdvancedLegendComponent)(); };
AdvancedLegendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AdvancedLegendComponent, selectors: [["ngx-charts-advanced-legend"]], inputs: { label: "label", animations: "animations", labelFormatting: "labelFormatting", percentageFormatting: "percentageFormatting", width: "width", data: "data", colors: "colors", valueFormatting: "valueFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 7, consts: [[1, "advanced-pie-legend"], ["class", "total-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "total-value", 4, "ngIf"], [1, "total-label"], [1, "legend-items-container"], [1, "legend-items"], ["tabindex", "-1", "class", "legend-item", 3, "mouseenter", "mouseleave", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-count-up", "", 1, "total-value", 3, "countTo", "valueFormatting"], [1, "total-value"], ["tabindex", "-1", 1, "legend-item", 3, "mouseenter", "mouseleave", "click"], [1, "item-color"], ["class", "item-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "item-value", 4, "ngIf"], [1, "item-label"], ["class", "item-percent", "ngx-charts-count-up", "", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "item-percent", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "item-value", 3, "countTo", "valueFormatting"], [1, "item-value"], ["ngx-charts-count-up", "", 1, "item-percent", 3, "countTo", "countSuffix"], [1, "item-percent"]], template: function AdvancedLegendComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, AdvancedLegendComponent_div_1_Template, 1, 2, "div", 1);
        ɵngcc0.ɵɵtemplate(2, AdvancedLegendComponent_div_2_Template, 2, 1, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵtemplate(7, AdvancedLegendComponent_div_7_Template, 8, 7, "div", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.label, " ");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.legendItems)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ɵngcc1.NgIf, ɵngcc1.NgForOf, CountUpDirective]; }, styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translate(0,-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{white-space:nowrap;overflow:auto}.advanced-pie-legend .legend-items-container .legend-items .legend-item{margin-right:20px;display:inline-block;cursor:pointer}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:0}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-top:-6px;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;opacity:.7;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;opacity:.7;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;width:4px;height:42px;float:left;margin-right:7px}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AdvancedLegendComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-advanced-legend',
                template: "\n    <div class=\"advanced-pie-legend\" [style.width.px]=\"width\">\n      <div\n        *ngIf=\"animations\"\n        class=\"total-value\"\n        ngx-charts-count-up\n        [countTo]=\"roundedTotal\"\n        [valueFormatting]=\"valueFormatting\"\n      ></div>\n      <div class=\"total-value\" *ngIf=\"!animations\">\n        {{ valueFormatting ? valueFormatting(roundedTotal) : defaultValueFormatting(roundedTotal) }}\n      </div>\n      <div class=\"total-label\">\n        {{ label }}\n      </div>\n      <div class=\"legend-items-container\">\n        <div class=\"legend-items\">\n          <div\n            *ngFor=\"let legendItem of legendItems; trackBy: trackBy\"\n            tabindex=\"-1\"\n            class=\"legend-item\"\n            (mouseenter)=\"activate.emit(legendItem.data)\"\n            (mouseleave)=\"deactivate.emit(legendItem.data)\"\n            (click)=\"select.emit(legendItem.data)\"\n          >\n            <div class=\"item-color\" [style.border-left-color]=\"legendItem.color\"></div>\n            <div\n              *ngIf=\"animations\"\n              class=\"item-value\"\n              ngx-charts-count-up\n              [countTo]=\"legendItem._value\"\n              [valueFormatting]=\"valueFormatting\"\n            ></div>\n            <div *ngIf=\"!animations\" class=\"item-value\">\n              {{ valueFormatting ? valueFormatting(legendItem.value) : defaultValueFormatting(legendItem.value) }}\n            </div>\n            <div class=\"item-label\">{{ legendItem.displayLabel }}</div>\n            <div\n              *ngIf=\"animations\"\n              class=\"item-percent\"\n              ngx-charts-count-up\n              [countTo]=\"legendItem.percentage\"\n              [countSuffix]=\"'%'\"\n            ></div>\n            <div *ngIf=\"!animations\" class=\"item-percent\">{{ legendItem.percentage.toLocaleString() }}%</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  ",
                styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translate(0,-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{white-space:nowrap;overflow:auto}.advanced-pie-legend .legend-items-container .legend-items .legend-item{margin-right:20px;display:inline-block;cursor:pointer}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:0}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-top:-6px;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;opacity:.7;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;opacity:.7;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;width:4px;height:42px;float:left;margin-right:7px}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { label: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], labelFormatting: [{
            type: Input
        }], percentageFormatting: [{
            type: Input
        }], width: [{
            type: Input
        }], data: [{
            type: Input
        }], colors: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }] }); })();
    return AdvancedLegendComponent;
}());

var cache = {};
/**
 * Generates a short id.
 *
 * Description:
 *   A 4-character alphanumeric sequence (364 = 1.6 million)
 *   This should only be used for JavaScript specific models.
 *   http://stackoverflow.com/questions/6248666/how-to-generate-short-uid-like-ax4j9z-in-js
 *
 *   Example: `ebgf`
 */
function id() {
    var newId = ('0000' + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
    // append a 'a' because neo gets mad
    newId = "a" + newId;
    // ensure not already used
    if (!cache[newId]) {
        cache[newId] = true;
        return newId;
    }
    return id();
}

var colorSets = [
    {
        name: 'vivid',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#647c8a', '#3f51b5', '#2196f3', '#00b862', '#afdf0a', '#a7b61a', '#f3e562', '#ff9800', '#ff5722', '#ff4514'
        ]
    },
    {
        name: 'natural',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#bf9d76', '#e99450', '#d89f59', '#f2dfa7', '#a5d7c6', '#7794b1', '#afafaf', '#707160', '#ba9383', '#d9d5c3'
        ]
    },
    {
        name: 'cool',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#a8385d', '#7aa3e5', '#a27ea8', '#aae3f5', '#adcded', '#a95963', '#8796c0', '#7ed3ed', '#50abcc', '#ad6886'
        ]
    },
    {
        name: 'fire',
        selectable: true,
        group: 'Ordinal',
        domain: [
            '#ff3d00', '#bf360c', '#ff8f00', '#ff6f00', '#ff5722', '#e65100', '#ffca28', '#ffab00'
        ]
    },
    {
        name: 'solar',
        selectable: true,
        group: 'Continuous',
        domain: [
            '#fff8e1', '#ffecb3', '#ffe082', '#ffd54f', '#ffca28', '#ffc107', '#ffb300', '#ffa000', '#ff8f00', '#ff6f00'
        ]
    },
    {
        name: 'air',
        selectable: true,
        group: 'Continuous',
        domain: [
            '#e1f5fe', '#b3e5fc', '#81d4fa', '#4fc3f7', '#29b6f6', '#03a9f4', '#039be5', '#0288d1', '#0277bd', '#01579b'
        ]
    },
    {
        name: 'aqua',
        selectable: true,
        group: 'Continuous',
        domain: [
            '#e0f7fa', '#b2ebf2', '#80deea', '#4dd0e1', '#26c6da', '#00bcd4', '#00acc1', '#0097a7', '#00838f', '#006064'
        ]
    },
    {
        name: 'flame',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#A10A28', '#D3342D', '#EF6D49', '#FAAD67', '#FDDE90', '#DBED91', '#A9D770', '#6CBA67', '#2C9653', '#146738'
        ]
    },
    {
        name: 'ocean',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#1D68FB', '#33C0FC', '#4AFFFE', '#AFFFFF', '#FFFC63', '#FDBD2D', '#FC8A25', '#FA4F1E', '#FA141B', '#BA38D1'
        ]
    },
    {
        name: 'forest',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#55C22D', '#C1F33D', '#3CC099', '#AFFFFF', '#8CFC9D', '#76CFFA', '#BA60FB', '#EE6490', '#C42A1C', '#FC9F32'
        ]
    },
    {
        name: 'horizon',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#2597FB', '#65EBFD', '#99FDD0', '#FCEE4B', '#FEFCFA', '#FDD6E3', '#FCB1A8', '#EF6F7B', '#CB96E8', '#EFDEE0'
        ]
    },
    {
        name: 'neons',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#FF3333', '#FF33FF', '#CC33FF', '#0000FF', '#33CCFF', '#33FFFF', '#33FF66', '#CCFF33', '#FFCC00', '#FF6600'
        ]
    },
    {
        name: 'picnic',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#FAC51D', '#66BD6D', '#FAA026', '#29BB9C', '#E96B56', '#55ACD2', '#B7332F', '#2C83C9', '#9166B8', '#92E7E8'
        ]
    },
    {
        name: 'night',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#2B1B5A', '#501356', '#183356', '#28203F', '#391B3C', '#1E2B3C', '#120634',
            '#2D0432', '#051932', '#453080', '#75267D', '#2C507D', '#4B3880', '#752F7D', '#35547D'
        ]
    },
    {
        name: 'nightLights',
        selectable: false,
        group: 'Ordinal',
        domain: [
            '#4e31a5', '#9c25a7', '#3065ab', '#57468b', '#904497', '#46648b',
            '#32118d', '#a00fb3', '#1052a2', '#6e51bd', '#b63cc3', '#6c97cb', '#8671c1', '#b455be', '#7496c3'
        ]
    }
];

function sortLinear(data, property, direction) {
    if (direction === void 0) { direction = 'asc'; }
    return data.sort(function (a, b) {
        if (direction === 'asc') {
            return a[property] - b[property];
        }
        else {
            return b[property] - a[property];
        }
    });
}
function sortByDomain(data, property, direction, domain) {
    if (direction === void 0) { direction = 'asc'; }
    return data.sort(function (a, b) {
        var aVal = a[property];
        var bVal = b[property];
        var aIdx = domain.indexOf(aVal);
        var bIdx = domain.indexOf(bVal);
        if (direction === 'asc') {
            return aIdx - bIdx;
        }
        else {
            return bIdx - aIdx;
        }
    });
}
function sortByTime(data, property, direction) {
    if (direction === void 0) { direction = 'asc'; }
    return data.sort(function (a, b) {
        var aDate = a[property].getTime();
        var bDate = b[property].getTime();
        if (direction === 'asc') {
            if (aDate > bDate)
                return 1;
            if (bDate > aDate)
                return -1;
            return 0;
        }
        else {
            if (aDate > bDate)
                return -1;
            if (bDate > aDate)
                return 1;
            return 0;
        }
    });
}

/**
 * Accepts a color (string) and returns a inverted hex color (string)
 * http://stackoverflow.com/questions/9600295/automatically-change-text-color-to-assure-readability
 *
 * @export
 * @param {any} value
 * @returns {string}
 */
function invertColor(value) {
    var color = rgb(value);
    var r = color.r, g = color.g, b = color.b, opacity = color.opacity;
    if (opacity === 0) {
        return color.toString();
    }
    var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    var depth = (yiq >= 128) ? -.8 : .8;
    return shadeRGBColor(color, depth);
}
/**
 * Given a rgb, it will darken/lighten
 * http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
 *
 * @export
 * @param {any} { r, g, b }
 * @param {any} percent
 * @returns
 */
function shadeRGBColor(_a, percent) {
    var r = _a.r, g = _a.g, b = _a.b;
    var t = percent < 0 ? 0 : 255;
    var p = percent < 0 ? percent * -1 : percent;
    r = (Math.round((t - r) * p) + r);
    g = (Math.round((t - g) * p) + g);
    b = (Math.round((t - b) * p) + b);
    return "rgb(" + r + ", " + g + ", " + b + ")";
}

/**
 * Visibility Observer
 */
var VisibilityObserver = /** @class */ (function () {
    function VisibilityObserver(element, zone) {
        this.element = element;
        this.zone = zone;
        this.visible = new EventEmitter();
        this.isVisible = false;
        this.runCheck();
    }
    VisibilityObserver.prototype.destroy = function () {
        clearTimeout(this.timeout);
    };
    VisibilityObserver.prototype.onVisibilityChange = function () {
        var _this = this;
        // trigger zone recalc for columns
        this.zone.run(function () {
            _this.isVisible = true;
            _this.visible.emit(true);
        });
    };
    VisibilityObserver.prototype.runCheck = function () {
        var _this = this;
        var check = function () {
            if (!_this.element) {
                return;
            }
            // https://davidwalsh.name/offsetheight-visibility
            var _a = _this.element.nativeElement, offsetHeight = _a.offsetHeight, offsetWidth = _a.offsetWidth;
            if (offsetHeight && offsetWidth) {
                clearTimeout(_this.timeout);
                _this.onVisibilityChange();
            }
            else {
                clearTimeout(_this.timeout);
                _this.zone.runOutsideAngular(function () {
                    _this.timeout = setTimeout(function () { return check(); }, 100);
                });
            }
        };
        this.zone.runOutsideAngular(function () {
            _this.timeout = setTimeout(function () { return check(); });
        });
    };
    var _a;
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], VisibilityObserver.prototype, "visible", void 0);
VisibilityObserver.ɵfac = function VisibilityObserver_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
VisibilityObserver.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: VisibilityObserver, outputs: { visible: "visible" } });

    return VisibilityObserver;
}());

function isDate(value) {
    return toString.call(value) === '[object Date]';
}

var BaseChartComponent = /** @class */ (function () {
    function BaseChartComponent(chartElement, zone, cd) {
        this.chartElement = chartElement;
        this.zone = zone;
        this.cd = cd;
        this.scheme = 'cool';
        this.schemeType = 'ordinal';
        this.animations = true;
        this.select = new EventEmitter();
    }
    BaseChartComponent.prototype.ngAfterViewInit = function () {
        this.bindWindowResizeEvent();
        // listen for visibility of the element for hidden by default scenario
        this.visibilityObserver = new VisibilityObserver(this.chartElement, this.zone);
        this.visibilityObserver.visible.subscribe(this.update.bind(this));
    };
    BaseChartComponent.prototype.ngOnDestroy = function () {
        this.unbindEvents();
        if (this.visibilityObserver) {
            this.visibilityObserver.visible.unsubscribe();
            this.visibilityObserver.destroy();
        }
    };
    BaseChartComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    BaseChartComponent.prototype.update = function () {
        if (this.results) {
            this.results = this.cloneData(this.results);
        }
        else {
            this.results = [];
        }
        if (this.view) {
            this.width = this.view[0];
            this.height = this.view[1];
        }
        else {
            var dims = this.getContainerDims();
            if (dims) {
                this.width = dims.width;
                this.height = dims.height;
            }
        }
        // default values if width or height are 0 or undefined
        if (!this.width) {
            this.width = 600;
        }
        if (!this.height) {
            this.height = 400;
        }
        this.width = Math.floor(this.width);
        this.height = Math.floor(this.height);
        if (this.cd) {
            this.cd.markForCheck();
        }
    };
    BaseChartComponent.prototype.getContainerDims = function () {
        var width;
        var height;
        var hostElem = this.chartElement.nativeElement;
        if (hostElem.parentNode !== null) {
            // Get the container dimensions
            var dims = hostElem.parentNode.getBoundingClientRect();
            width = dims.width;
            height = dims.height;
        }
        if (width && height) {
            return { width: width, height: height };
        }
        return null;
    };
    /**
     * Converts all date objects that appear as name
     * into formatted date strings
     */
    BaseChartComponent.prototype.formatDates = function () {
        for (var i = 0; i < this.results.length; i++) {
            var g = this.results[i];
            g.label = g.name;
            if (g.label instanceof Date) {
                g.label = g.label.toLocaleDateString();
            }
            if (g.series) {
                for (var j = 0; j < g.series.length; j++) {
                    var d = g.series[j];
                    d.label = d.name;
                    if (d.label instanceof Date) {
                        d.label = d.label.toLocaleDateString();
                    }
                }
            }
        }
    };
    BaseChartComponent.prototype.unbindEvents = function () {
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    };
    BaseChartComponent.prototype.bindWindowResizeEvent = function () {
        var _this = this;
        var source = fromEvent(window, 'resize');
        var subscription = source.pipe(debounceTime(200)).subscribe(function (e) {
            _this.update();
            if (_this.cd) {
                _this.cd.markForCheck();
            }
        });
        this.resizeSubscription = subscription;
    };
    /**
     * Clones the data into a new object
     *
     * @private
     * @param {any} data
     * @returns {*}
     *
     * @memberOf BaseChart
     */
    BaseChartComponent.prototype.cloneData = function (data) {
        var results = [];
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var item = data_1[_i];
            var copy = {
                name: item['name']
            };
            if (item['value'] !== undefined) {
                copy['value'] = item['value'];
            }
            if (item['series'] !== undefined) {
                copy['series'] = [];
                for (var _a = 0, _b = item['series']; _a < _b.length; _a++) {
                    var seriesItem = _b[_a];
                    var seriesItemCopy = Object.assign({}, seriesItem);
                    copy['series'].push(seriesItemCopy);
                }
            }
            if (item['extra'] !== undefined) {
                copy['extra'] = JSON.parse(JSON.stringify(item['extra']));
            }
            results.push(copy);
        }
        return results;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BaseChartComponent.prototype, "view", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "scheme", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BaseChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "customColors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BaseChartComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BaseChartComponent.prototype, "select", void 0);
    BaseChartComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object, typeof (_b = typeof NgZone !== "undefined" && NgZone) === "function" ? _b : Object, typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object])
    ], BaseChartComponent);
BaseChartComponent.ɵfac = function BaseChartComponent_Factory(t) { return new (t || BaseChartComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof NgZone !== "undefined" && NgZone) === "function" ? _b : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object)); };
BaseChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BaseChartComponent, selectors: [["base-chart"]], inputs: { scheme: "scheme", schemeType: "schemeType", animations: "animations", results: "results", view: "view", customColors: "customColors" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 1, vars: 0, template: function BaseChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div");
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BaseChartComponent, [{
        type: Component,
        args: [{
                selector: 'base-chart',
                template: "\n    <div></div>\n  "
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }, { type: typeof (_b = typeof NgZone !== "undefined" && NgZone) === "function" ? _b : Object }, { type: typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object }]; }, { scheme: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], results: [{
            type: Input
        }], view: [{
            type: Input
        }], customColors: [{
            type: Input
        }] }); })();
    return BaseChartComponent;
}());

var AxisLabelComponent = /** @class */ (function () {
    function AxisLabelComponent(element) {
        this.textHeight = 25;
        this.margin = 5;
        this.element = element.nativeElement;
    }
    AxisLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    AxisLabelComponent.prototype.update = function () {
        this.strokeWidth = '0.01';
        this.textAnchor = 'middle';
        this.transform = '';
        switch (this.orient) {
            case 'top':
                this.y = this.offset;
                this.x = this.width / 2;
                break;
            case 'bottom':
                this.y = this.offset;
                this.x = this.width / 2;
                break;
            case 'left':
                this.y = -(this.offset + this.textHeight + this.margin);
                this.x = -this.height / 2;
                this.transform = 'rotate(270)';
                break;
            case 'right':
                this.y = this.offset + this.margin;
                this.x = -this.height / 2;
                this.transform = 'rotate(270)';
                break;
            default:
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "orient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "offset", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AxisLabelComponent.prototype, "height", void 0);
    AxisLabelComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], AxisLabelComponent);
AxisLabelComponent.ɵfac = function AxisLabelComponent_Factory(t) { return new (t || AxisLabelComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
AxisLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AxisLabelComponent, selectors: [["g", "ngx-charts-axis-label", ""]], inputs: { orient: "orient", label: "label", offset: "offset", width: "width", height: "height" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c3, decls: 2, vars: 6, template: function AxisLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "text");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("stroke-width", ctx.strokeWidth)("x", ctx.x)("y", ctx.y)("text-anchor", ctx.textAnchor)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.label, " ");
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AxisLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-axis-label]',
                template: "\n    <svg:text\n      [attr.stroke-width]=\"strokeWidth\"\n      [attr.x]=\"x\"\n      [attr.y]=\"y\"\n      [attr.text-anchor]=\"textAnchor\"\n      [attr.transform]=\"transform\">\n      {{label}}\n    </svg:text>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { orient: [{
            type: Input
        }], label: [{
            type: Input
        }], offset: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }] }); })();
    return AxisLabelComponent;
}());

function reduceTicks(ticks, maxTicks) {
    if (ticks.length > maxTicks) {
        var reduced = [];
        var modulus = Math.floor(ticks.length / maxTicks);
        for (var i = 0; i < ticks.length; i++) {
            if (i % modulus === 0) {
                reduced.push(ticks[i]);
            }
        }
        ticks = reduced;
    }
    return ticks;
}

var XAxisTicksComponent = /** @class */ (function () {
    function XAxisTicksComponent() {
        this.tickArguments = [5];
        this.tickStroke = '#ccc';
        this.trimTicks = true;
        this.maxTickLength = 16;
        this.showGridLines = false;
        this.rotateTicks = true;
        this.dimensionsChanged = new EventEmitter();
        this.verticalSpacing = 20;
        this.rotateLabels = false;
        this.innerTickSize = 6;
        this.outerTickSize = 6;
        this.tickPadding = 3;
        this.textAnchor = 'middle';
        this.maxTicksLength = 0;
        this.maxAllowedLength = 16;
        this.height = 0;
    }
    XAxisTicksComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    XAxisTicksComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () { return _this.updateDims(); });
    };
    XAxisTicksComponent.prototype.updateDims = function () {
        var _this = this;
        var height = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().height, 10);
        if (height !== this.height) {
            this.height = height;
            this.dimensionsChanged.emit({ height: height });
            setTimeout(function () { return _this.updateDims(); });
        }
    };
    XAxisTicksComponent.prototype.update = function () {
        var _this = this;
        var scale = this.scale;
        this.ticks = this.getTicks();
        if (this.tickFormatting) {
            this.tickFormat = this.tickFormatting;
        }
        else if (scale.tickFormat) {
            this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
        }
        else {
            this.tickFormat = function (d) {
                if (d.constructor.name === 'Date') {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        var angle = this.rotateTicks ? this.getRotationAngle(this.ticks) : null;
        this.adjustedScale = this.scale.bandwidth
            ? function (d) {
                return this.scale(d) + this.scale.bandwidth() * 0.5;
            }
            : this.scale;
        this.textTransform = '';
        if (angle && angle !== 0) {
            this.textTransform = "rotate(" + angle + ")";
            this.textAnchor = 'end';
            this.verticalSpacing = 10;
        }
        else {
            this.textAnchor = 'middle';
        }
        setTimeout(function () { return _this.updateDims(); });
    };
    XAxisTicksComponent.prototype.getRotationAngle = function (ticks) {
        var angle = 0;
        this.maxTicksLength = 0;
        for (var i = 0; i < ticks.length; i++) {
            var tick = this.tickFormat(ticks[i]).toString();
            var tickLength = tick.length;
            if (this.trimTicks) {
                tickLength = this.tickTrim(tick).length;
            }
            if (tickLength > this.maxTicksLength) {
                this.maxTicksLength = tickLength;
            }
        }
        var len = Math.min(this.maxTicksLength, this.maxAllowedLength);
        var charWidth = 8; // need to measure this
        var wordWidth = len * charWidth;
        var baseWidth = wordWidth;
        var maxBaseWidth = Math.floor(this.width / ticks.length);
        // calculate optimal angle
        while (baseWidth > maxBaseWidth && angle > -90) {
            angle -= 30;
            baseWidth = Math.cos(angle * (Math.PI / 180)) * wordWidth;
        }
        return angle;
    };
    XAxisTicksComponent.prototype.getTicks = function () {
        var ticks;
        var maxTicks = this.getMaxTicks(20);
        var maxScaleTicks = this.getMaxTicks(100);
        if (this.tickValues) {
            ticks = this.tickValues;
        }
        else if (this.scale.ticks) {
            ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
        }
        else {
            ticks = this.scale.domain();
            ticks = reduceTicks(ticks, maxTicks);
        }
        return ticks;
    };
    XAxisTicksComponent.prototype.getMaxTicks = function (tickWidth) {
        return Math.floor(this.width / tickWidth);
    };
    XAxisTicksComponent.prototype.tickTransform = function (tick) {
        return 'translate(' + this.adjustedScale(tick) + ',' + this.verticalSpacing + ')';
    };
    XAxisTicksComponent.prototype.gridLineTransform = function () {
        return "translate(0," + (-this.verticalSpacing - 5) + ")";
    };
    XAxisTicksComponent.prototype.tickTrim = function (label) {
        return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "scale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "orient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "tickArguments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], XAxisTicksComponent.prototype, "tickValues", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "tickStroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisTicksComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], XAxisTicksComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "gridLineHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisTicksComponent.prototype, "rotateTicks", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], XAxisTicksComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild('ticksel', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], XAxisTicksComponent.prototype, "ticksElement", void 0);
XAxisTicksComponent.ɵfac = function XAxisTicksComponent_Factory(t) { return new (t || XAxisTicksComponent)(); };
XAxisTicksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisTicksComponent, selectors: [["g", "ngx-charts-x-axis-ticks", ""]], viewQuery: function XAxisTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);
    } }, inputs: { tickArguments: "tickArguments", tickStroke: "tickStroke", trimTicks: "trimTicks", maxTickLength: "maxTickLength", showGridLines: "showGridLines", rotateTicks: "rotateTicks", scale: "scale", orient: "orient", tickValues: "tickValues", tickFormatting: "tickFormatting", gridLineHeight: "gridLineHeight", width: "width" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c5, decls: 4, vars: 2, consts: [["ticksel", ""], ["class", "tick", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf"], [1, "tick"], ["stroke-width", "0.01"], [4, "ngIf"], ["y2", "0", 1, "gridline-path", "gridline-path-vertical"]], template: function XAxisTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", null, 0);
        ɵngcc0.ɵɵtemplate(2, XAxisTicksComponent__svg_g_2_Template, 5, 7, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, XAxisTicksComponent__svg_g_3_Template, 2, 2, "g", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisTicksComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-x-axis-ticks]',
                template: "\n    <svg:g #ticksel>\n      <svg:g *ngFor=\"let tick of ticks\" class=\"tick\" [attr.transform]=\"tickTransform(tick)\">\n        <title>{{ tickFormat(tick) }}</title>\n        <svg:text\n          stroke-width=\"0.01\"\n          [attr.text-anchor]=\"textAnchor\"\n          [attr.transform]=\"textTransform\"\n          [style.font-size]=\"'12px'\"\n        >\n          {{ tickTrim(tickFormat(tick)) }}\n        </svg:text>\n      </svg:g>\n    </svg:g>\n\n    <svg:g *ngFor=\"let tick of ticks\" [attr.transform]=\"tickTransform(tick)\">\n      <svg:g *ngIf=\"showGridLines\" [attr.transform]=\"gridLineTransform()\">\n        <svg:line class=\"gridline-path gridline-path-vertical\" [attr.y1]=\"-gridLineHeight\" y2=\"0\" />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tickArguments: [{
            type: Input
        }], tickStroke: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], rotateTicks: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], scale: [{
            type: Input
        }], orient: [{
            type: Input
        }], tickValues: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], gridLineHeight: [{
            type: Input
        }], width: [{
            type: Input
        }], ticksElement: [{
            type: ViewChild,
            args: ['ticksel', { static: false }]
        }] }); })();
    return XAxisTicksComponent;
}());

var XAxisComponent = /** @class */ (function () {
    function XAxisComponent() {
        this.rotateTicks = true;
        this.showGridLines = false;
        this.xOrient = 'bottom';
        this.xAxisOffset = 0;
        this.dimensionsChanged = new EventEmitter();
        this.xAxisClassName = 'x axis';
        this.labelOffset = 0;
        this.fill = 'none';
        this.stroke = 'stroke';
        this.tickStroke = '#ccc';
        this.strokeWidth = 'none';
        this.padding = 5;
    }
    XAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    XAxisComponent.prototype.update = function () {
        this.transform = "translate(0," + (this.xAxisOffset + this.padding + this.dims.height) + ")";
        if (typeof this.xAxisTickCount !== 'undefined') {
            this.tickArguments = [this.xAxisTickCount];
        }
    };
    XAxisComponent.prototype.emitTicksHeight = function (_a) {
        var _this = this;
        var height = _a.height;
        var newLabelOffset = height + 25 + 5;
        if (newLabelOffset !== this.labelOffset) {
            this.labelOffset = newLabelOffset;
            setTimeout(function () {
                _this.dimensionsChanged.emit({ height: height });
            }, 0);
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], XAxisComponent.prototype, "rotateTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], XAxisComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "showLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "labelText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], XAxisComponent.prototype, "ticks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "xAxisTickInterval", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "xAxisTickCount", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], XAxisComponent.prototype, "xOrient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], XAxisComponent.prototype, "xAxisOffset", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], XAxisComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild(XAxisTicksComponent, { static: false }),
        __metadata("design:type", typeof (_a = typeof XAxisTicksComponent !== "undefined" && XAxisTicksComponent) === "function" ? _a : Object)
    ], XAxisComponent.prototype, "ticksComponent", void 0);
XAxisComponent.ɵfac = function XAxisComponent_Factory(t) { return new (t || XAxisComponent)(); };
XAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisComponent, selectors: [["g", "ngx-charts-x-axis", ""]], viewQuery: function XAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(XAxisTicksComponent, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { rotateTicks: "rotateTicks", showGridLines: "showGridLines", xOrient: "xOrient", xAxisOffset: "xAxisOffset", xScale: "xScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", showLabel: "showLabel", labelText: "labelText", ticks: "ticks", xAxisTickInterval: "xAxisTickInterval", xAxisTickCount: "xAxisTickCount" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c6, decls: 3, vars: 4, consts: [["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function XAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, XAxisComponent__svg_g_1_Template, 1, 12, "g", 0);
        ɵngcc0.ɵɵtemplate(2, XAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.xAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, XAxisTicksComponent, AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-x-axis]',
                template: "\n    <svg:g [attr.class]=\"xAxisClassName\" [attr.transform]=\"transform\">\n      <svg:g\n        ngx-charts-x-axis-ticks\n        *ngIf=\"xScale\"\n        [trimTicks]=\"trimTicks\"\n        [rotateTicks]=\"rotateTicks\"\n        [maxTickLength]=\"maxTickLength\"\n        [tickFormatting]=\"tickFormatting\"\n        [tickArguments]=\"tickArguments\"\n        [tickStroke]=\"tickStroke\"\n        [scale]=\"xScale\"\n        [orient]=\"xOrient\"\n        [showGridLines]=\"showGridLines\"\n        [gridLineHeight]=\"dims.height\"\n        [width]=\"dims.width\"\n        [tickValues]=\"ticks\"\n        (dimensionsChanged)=\"emitTicksHeight($event)\"\n      />\n      <svg:g\n        ngx-charts-axis-label\n        *ngIf=\"showLabel\"\n        [label]=\"labelText\"\n        [offset]=\"labelOffset\"\n        [orient]=\"'bottom'\"\n        [height]=\"dims.height\"\n        [width]=\"dims.width\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { rotateTicks: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], xOrient: [{
            type: Input
        }], xAxisOffset: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], xScale: [{
            type: Input
        }], dims: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], showLabel: [{
            type: Input
        }], labelText: [{
            type: Input
        }], ticks: [{
            type: Input
        }], xAxisTickInterval: [{
            type: Input
        }], xAxisTickCount: [{
            type: Input
        }], ticksComponent: [{
            type: ViewChild,
            args: [XAxisTicksComponent, { static: false }]
        }] }); })();
    return XAxisComponent;
}());

/**
 * Generates a rounded rectanglar path
 *
 * @export
 * @param {*} x, y, w, h, r, tl, tr, bl, br
 * @returns {string}
 */
function roundedRect(x, y, w, h, r, _a) {
    var tl = _a[0], tr = _a[1], bl = _a[2], br = _a[3];
    var retval = '';
    w = Math.floor(w);
    h = Math.floor(h);
    w = w === 0 ? 1 : w;
    h = h === 0 ? 1 : h;
    retval = "M" + [x + r, y];
    retval += "h" + (w - 2 * r);
    if (tr) {
        retval += "a" + [r, r] + " 0 0 1 " + [r, r];
    }
    else {
        retval += "h" + r + "v" + r;
    }
    retval += "v" + (h - 2 * r);
    if (br) {
        retval += "a" + [r, r] + " 0 0 1 " + [-r, r];
    }
    else {
        retval += "v" + r + "h" + -r;
    }
    retval += "h" + (2 * r - w);
    if (bl) {
        retval += "a" + [r, r] + " 0 0 1 " + [-r, -r];
    }
    else {
        retval += "h" + -r + "v" + -r;
    }
    retval += "v" + (2 * r - h);
    if (tl) {
        retval += "a" + [r, r] + " 0 0 1 " + [r, -r];
    }
    else {
        retval += "v" + -r + "h" + r;
    }
    retval += "z";
    return retval;
}

var YAxisTicksComponent = /** @class */ (function () {
    function YAxisTicksComponent() {
        this.tickArguments = [5];
        this.tickStroke = '#ccc';
        this.trimTicks = true;
        this.maxTickLength = 16;
        this.showGridLines = false;
        this.showRefLabels = false;
        this.showRefLines = false;
        this.dimensionsChanged = new EventEmitter();
        this.innerTickSize = 6;
        this.tickPadding = 3;
        this.verticalSpacing = 20;
        this.textAnchor = 'middle';
        this.width = 0;
        this.outerTickSize = 6;
        this.rotateLabels = false;
        this.referenceLineLength = 0;
    }
    YAxisTicksComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    YAxisTicksComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () { return _this.updateDims(); });
    };
    YAxisTicksComponent.prototype.updateDims = function () {
        var _this = this;
        var width = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().width, 10);
        if (width !== this.width) {
            this.width = width;
            this.dimensionsChanged.emit({ width: width });
            setTimeout(function () { return _this.updateDims(); });
        }
    };
    YAxisTicksComponent.prototype.update = function () {
        var _this = this;
        var scale;
        var sign = this.orient === 'top' || this.orient === 'right' ? -1 : 1;
        this.tickSpacing = Math.max(this.innerTickSize, 0) + this.tickPadding;
        scale = this.scale;
        this.ticks = this.getTicks();
        if (this.tickFormatting) {
            this.tickFormat = this.tickFormatting;
        }
        else if (scale.tickFormat) {
            this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
        }
        else {
            this.tickFormat = function (d) {
                if (d.constructor.name === 'Date') {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        this.adjustedScale = scale.bandwidth
            ? function (d) {
                return scale(d) + scale.bandwidth() * 0.5;
            }
            : scale;
        if (this.showRefLines && this.referenceLines) {
            this.setReferencelines();
        }
        switch (this.orient) {
            case 'top':
                this.transform = function (tick) {
                    return 'translate(' + this.adjustedScale(tick) + ',0)';
                };
                this.textAnchor = 'middle';
                this.y2 = this.innerTickSize * sign;
                this.y1 = this.tickSpacing * sign;
                this.dy = sign < 0 ? '0em' : '.71em';
                break;
            case 'bottom':
                this.transform = function (tick) {
                    return 'translate(' + this.adjustedScale(tick) + ',0)';
                };
                this.textAnchor = 'middle';
                this.y2 = this.innerTickSize * sign;
                this.y1 = this.tickSpacing * sign;
                this.dy = sign < 0 ? '0em' : '.71em';
                break;
            case 'left':
                this.transform = function (tick) {
                    return 'translate(0,' + this.adjustedScale(tick) + ')';
                };
                this.textAnchor = 'end';
                this.x2 = this.innerTickSize * -sign;
                this.x1 = this.tickSpacing * -sign;
                this.dy = '.32em';
                break;
            case 'right':
                this.transform = function (tick) {
                    return 'translate(0,' + this.adjustedScale(tick) + ')';
                };
                this.textAnchor = 'start';
                this.x2 = this.innerTickSize * -sign;
                this.x1 = this.tickSpacing * -sign;
                this.dy = '.32em';
                break;
            default:
        }
        setTimeout(function () { return _this.updateDims(); });
    };
    YAxisTicksComponent.prototype.setReferencelines = function () {
        this.refMin = this.adjustedScale(Math.min.apply(null, this.referenceLines.map(function (item) { return item.value; })));
        this.refMax = this.adjustedScale(Math.max.apply(null, this.referenceLines.map(function (item) { return item.value; })));
        this.referenceLineLength = this.referenceLines.length;
        this.referenceAreaPath = roundedRect(0, this.refMax, this.gridLineWidth, this.refMin - this.refMax, 0, [
            false,
            false,
            false,
            false
        ]);
    };
    YAxisTicksComponent.prototype.getTicks = function () {
        var ticks;
        var maxTicks = this.getMaxTicks(20);
        var maxScaleTicks = this.getMaxTicks(50);
        if (this.tickValues) {
            ticks = this.tickValues;
        }
        else if (this.scale.ticks) {
            ticks = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
        }
        else {
            ticks = this.scale.domain();
            ticks = reduceTicks(ticks, maxTicks);
        }
        return ticks;
    };
    YAxisTicksComponent.prototype.getMaxTicks = function (tickHeight) {
        return Math.floor(this.height / tickHeight);
    };
    YAxisTicksComponent.prototype.tickTransform = function (tick) {
        return "translate(" + this.adjustedScale(tick) + "," + this.verticalSpacing + ")";
    };
    YAxisTicksComponent.prototype.gridLineTransform = function () {
        return "translate(5,0)";
    };
    YAxisTicksComponent.prototype.tickTrim = function (label) {
        return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "scale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "orient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "tickArguments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], YAxisTicksComponent.prototype, "tickValues", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "tickStroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisTicksComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], YAxisTicksComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "gridLineWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "referenceLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisTicksComponent.prototype, "showRefLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisTicksComponent.prototype, "showRefLines", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], YAxisTicksComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild('ticksel', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], YAxisTicksComponent.prototype, "ticksElement", void 0);
YAxisTicksComponent.ɵfac = function YAxisTicksComponent_Factory(t) { return new (t || YAxisTicksComponent)(); };
YAxisTicksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisTicksComponent, selectors: [["g", "ngx-charts-y-axis-ticks", ""]], viewQuery: function YAxisTicksComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c4, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksElement = _t.first);
    } }, inputs: { tickArguments: "tickArguments", tickStroke: "tickStroke", trimTicks: "trimTicks", maxTickLength: "maxTickLength", showGridLines: "showGridLines", showRefLabels: "showRefLabels", showRefLines: "showRefLines", scale: "scale", orient: "orient", tickValues: "tickValues", tickFormatting: "tickFormatting", gridLineWidth: "gridLineWidth", height: "height", referenceLines: "referenceLines" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c7, decls: 6, vars: 4, consts: [["ticksel", ""], ["class", "tick", 4, "ngFor", "ngForOf"], ["class", "reference-area", 4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "tick"], ["stroke-width", "0.01"], [1, "reference-area"], [4, "ngIf"], ["class", "gridline-path gridline-path-horizontal", "x1", "0", 4, "ngIf"], ["x1", "0", 1, "gridline-path", "gridline-path-horizontal"], ["x1", "0", 1, "refline-path", "gridline-path-horizontal"], [1, "refline-label"]], template: function YAxisTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", null, 0);
        ɵngcc0.ɵɵtemplate(2, YAxisTicksComponent__svg_g_2_Template, 5, 9, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, YAxisTicksComponent__svg_path_3_Template, 1, 2, "path", 2);
        ɵngcc0.ɵɵtemplate(4, YAxisTicksComponent__svg_g_4_Template, 2, 2, "g", 3);
        ɵngcc0.ɵɵtemplate(5, YAxisTicksComponent__svg_g_5_Template, 2, 1, "g", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.referenceLineLength > 1 && ctx.refMax && ctx.refMin && ctx.showRefLines);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.referenceLines);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisTicksComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-y-axis-ticks]',
                template: "\n    <svg:g #ticksel>\n      <svg:g *ngFor=\"let tick of ticks\" class=\"tick\" [attr.transform]=\"transform(tick)\">\n        <title>{{ tickFormat(tick) }}</title>\n        <svg:text\n          stroke-width=\"0.01\"\n          [attr.dy]=\"dy\"\n          [attr.x]=\"x1\"\n          [attr.y]=\"y1\"\n          [attr.text-anchor]=\"textAnchor\"\n          [style.font-size]=\"'12px'\"\n        >\n          {{ tickTrim(tickFormat(tick)) }}\n        </svg:text>\n      </svg:g>\n    </svg:g>\n\n    <svg:path\n      *ngIf=\"referenceLineLength > 1 && refMax && refMin && showRefLines\"\n      class=\"reference-area\"\n      [attr.d]=\"referenceAreaPath\"\n      [attr.transform]=\"gridLineTransform()\"\n    />\n    <svg:g *ngFor=\"let tick of ticks\" [attr.transform]=\"transform(tick)\">\n      <svg:g *ngIf=\"showGridLines\" [attr.transform]=\"gridLineTransform()\">\n        <svg:line\n          *ngIf=\"orient === 'left'\"\n          class=\"gridline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"gridLineWidth\"\n        />\n        <svg:line\n          *ngIf=\"orient === 'right'\"\n          class=\"gridline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"-gridLineWidth\"\n        />\n      </svg:g>\n    </svg:g>\n\n    <svg:g *ngFor=\"let refLine of referenceLines\">\n      <svg:g *ngIf=\"showRefLines\" [attr.transform]=\"transform(refLine.value)\">\n        <svg:line\n          class=\"refline-path gridline-path-horizontal\"\n          x1=\"0\"\n          [attr.x2]=\"gridLineWidth\"\n          [attr.transform]=\"gridLineTransform()\"\n        />\n        <svg:g *ngIf=\"showRefLabels\">\n          <title>{{ tickTrim(tickFormat(refLine.value)) }}</title>\n          <svg:text\n            class=\"refline-label\"\n            [attr.dy]=\"dy\"\n            [attr.y]=\"-6\"\n            [attr.x]=\"gridLineWidth\"\n            [attr.text-anchor]=\"textAnchor\"\n          >\n            {{ refLine.name }}\n          </svg:text>\n        </svg:g>\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tickArguments: [{
            type: Input
        }], tickStroke: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], showRefLabels: [{
            type: Input
        }], showRefLines: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], scale: [{
            type: Input
        }], orient: [{
            type: Input
        }], tickValues: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], gridLineWidth: [{
            type: Input
        }], height: [{
            type: Input
        }], referenceLines: [{
            type: Input
        }], ticksElement: [{
            type: ViewChild,
            args: ['ticksel', { static: false }]
        }] }); })();
    return YAxisTicksComponent;
}());

var YAxisComponent = /** @class */ (function () {
    function YAxisComponent() {
        this.showGridLines = false;
        this.yOrient = 'left';
        this.yAxisOffset = 0;
        this.dimensionsChanged = new EventEmitter();
        this.yAxisClassName = 'y axis';
        this.labelOffset = 15;
        this.fill = 'none';
        this.stroke = '#CCC';
        this.tickStroke = '#CCC';
        this.strokeWidth = 1;
        this.padding = 5;
    }
    YAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    YAxisComponent.prototype.update = function () {
        this.offset = -(this.yAxisOffset + this.padding);
        if (this.yOrient === 'right') {
            this.labelOffset = 65;
            this.transform = "translate(" + (this.offset + this.dims.width) + " , 0)";
        }
        else {
            this.offset = this.offset;
            this.transform = "translate(" + this.offset + " , 0)";
        }
        if (this.yAxisTickCount !== undefined) {
            this.tickArguments = [this.yAxisTickCount];
        }
    };
    YAxisComponent.prototype.emitTicksWidth = function (_a) {
        var _this = this;
        var width = _a.width;
        if (width !== this.labelOffset && this.yOrient === 'right') {
            this.labelOffset = width + this.labelOffset;
            setTimeout(function () {
                _this.dimensionsChanged.emit({ width: width });
            }, 0);
        }
        else if (width !== this.labelOffset) {
            this.labelOffset = width;
            setTimeout(function () {
                _this.dimensionsChanged.emit({ width: width });
            }, 0);
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], YAxisComponent.prototype, "trimTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], YAxisComponent.prototype, "maxTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "tickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], YAxisComponent.prototype, "ticks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "labelText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "yAxisTickInterval", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "yAxisTickCount", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], YAxisComponent.prototype, "yOrient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "referenceLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showRefLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "showRefLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], YAxisComponent.prototype, "yAxisOffset", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], YAxisComponent.prototype, "dimensionsChanged", void 0);
    __decorate([
        ViewChild(YAxisTicksComponent, { static: false }),
        __metadata("design:type", typeof (_a = typeof YAxisTicksComponent !== "undefined" && YAxisTicksComponent) === "function" ? _a : Object)
    ], YAxisComponent.prototype, "ticksComponent", void 0);
YAxisComponent.ɵfac = function YAxisComponent_Factory(t) { return new (t || YAxisComponent)(); };
YAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisComponent, selectors: [["g", "ngx-charts-y-axis", ""]], viewQuery: function YAxisComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(YAxisTicksComponent, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticksComponent = _t.first);
    } }, inputs: { showGridLines: "showGridLines", yOrient: "yOrient", yAxisOffset: "yAxisOffset", yScale: "yScale", dims: "dims", trimTicks: "trimTicks", maxTickLength: "maxTickLength", tickFormatting: "tickFormatting", ticks: "ticks", showLabel: "showLabel", labelText: "labelText", yAxisTickInterval: "yAxisTickInterval", yAxisTickCount: "yAxisTickCount", referenceLines: "referenceLines", showRefLines: "showRefLines", showRefLabels: "showRefLabels" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c8, decls: 3, vars: 4, consts: [["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]], template: function YAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, YAxisComponent__svg_g_1_Template, 1, 14, "g", 0);
        ɵngcc0.ɵɵtemplate(2, YAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.yAxisClassName)("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yScale);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showLabel);
    } }, directives: [ɵngcc1.NgIf, YAxisTicksComponent, AxisLabelComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-y-axis]',
                template: "\n    <svg:g [attr.class]=\"yAxisClassName\" [attr.transform]=\"transform\">\n      <svg:g\n        ngx-charts-y-axis-ticks\n        *ngIf=\"yScale\"\n        [trimTicks]=\"trimTicks\"\n        [maxTickLength]=\"maxTickLength\"\n        [tickFormatting]=\"tickFormatting\"\n        [tickArguments]=\"tickArguments\"\n        [tickValues]=\"ticks\"\n        [tickStroke]=\"tickStroke\"\n        [scale]=\"yScale\"\n        [orient]=\"yOrient\"\n        [showGridLines]=\"showGridLines\"\n        [gridLineWidth]=\"dims.width\"\n        [referenceLines]=\"referenceLines\"\n        [showRefLines]=\"showRefLines\"\n        [showRefLabels]=\"showRefLabels\"\n        [height]=\"dims.height\"\n        (dimensionsChanged)=\"emitTicksWidth($event)\"\n      />\n\n      <svg:g\n        ngx-charts-axis-label\n        *ngIf=\"showLabel\"\n        [label]=\"labelText\"\n        [offset]=\"labelOffset\"\n        [orient]=\"yOrient\"\n        [height]=\"dims.height\"\n        [width]=\"dims.width\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { showGridLines: [{
            type: Input
        }], yOrient: [{
            type: Input
        }], yAxisOffset: [{
            type: Input
        }], dimensionsChanged: [{
            type: Output
        }], yScale: [{
            type: Input
        }], dims: [{
            type: Input
        }], trimTicks: [{
            type: Input
        }], maxTickLength: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }], ticks: [{
            type: Input
        }], showLabel: [{
            type: Input
        }], labelText: [{
            type: Input
        }], yAxisTickInterval: [{
            type: Input
        }], yAxisTickCount: [{
            type: Input
        }], referenceLines: [{
            type: Input
        }], showRefLines: [{
            type: Input
        }], showRefLabels: [{
            type: Input
        }], ticksComponent: [{
            type: ViewChild,
            args: [YAxisTicksComponent, { static: false }]
        }] }); })();
    return YAxisComponent;
}());

var AxesModule = /** @class */ (function () {
    function AxesModule() {
    }
AxesModule.ɵfac = function AxesModule_Factory(t) { return new (t || AxesModule)(); };
AxesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AxesModule });
AxesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AxesModule, { declarations: function () { return [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AxesModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent],
                exports: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent]
            }]
    }], function () { return []; }, null); })();
    return AxesModule;
}());

var ColorHelper = /** @class */ (function () {
    function ColorHelper(scheme, type, domain, customColors) {
        if (typeof scheme === 'string') {
            scheme = colorSets.find(function (cs) {
                return cs.name === scheme;
            });
        }
        this.colorDomain = scheme.domain;
        this.scaleType = type;
        this.domain = domain;
        this.customColors = customColors;
        this.scale = this.generateColorScheme(scheme, type, this.domain);
    }
    ColorHelper.prototype.generateColorScheme = function (scheme, type, domain) {
        if (typeof scheme === 'string') {
            scheme = colorSets.find(function (cs) {
                return cs.name === scheme;
            });
        }
        var colorScale;
        if (type === 'quantile') {
            colorScale = scaleQuantile()
                .range(scheme.domain)
                .domain(domain);
        }
        else if (type === 'ordinal') {
            colorScale = scaleOrdinal()
                .range(scheme.domain)
                .domain(domain);
        }
        else if (type === 'linear') {
            // linear schemes must have at least 2 colors
            var colorDomain = scheme.domain.slice();
            if (colorDomain.length === 1) {
                colorDomain.push(colorDomain[0]);
                this.colorDomain = colorDomain;
            }
            var points = range(0, 1, 1.0 / colorDomain.length);
            colorScale = scaleLinear()
                .domain(points)
                .range(colorDomain);
        }
        return colorScale;
    };
    ColorHelper.prototype.getColor = function (value) {
        if (value === undefined || value === null) {
            throw new Error('Value can not be null');
        }
        if (this.scaleType === 'linear') {
            var valueScale = scaleLinear()
                .domain(this.domain)
                .range([0, 1]);
            return this.scale(valueScale(value));
        }
        else {
            if (typeof this.customColors === 'function') {
                return this.customColors(value);
            }
            var formattedValue_1 = value.toString();
            var found = void 0; // todo type customColors
            if (this.customColors && this.customColors.length > 0) {
                found = this.customColors.find(function (mapping) {
                    return mapping.name.toLowerCase() === formattedValue_1.toLowerCase();
                });
            }
            if (found) {
                return found.value;
            }
            else {
                return this.scale(value);
            }
        }
    };
    ColorHelper.prototype.getLinearGradientStops = function (value, start) {
        if (start === undefined) {
            start = this.domain[0];
        }
        var valueScale = scaleLinear()
            .domain(this.domain)
            .range([0, 1]);
        var colorValueScale = scaleBand()
            .domain(this.colorDomain)
            .range([0, 1]);
        var endColor = this.getColor(value);
        // generate the stops
        var startVal = valueScale(start);
        var startColor = this.getColor(start);
        var endVal = valueScale(value);
        var i = 1;
        var currentVal = startVal;
        var stops = [];
        stops.push({
            color: startColor,
            offset: startVal,
            originalOffset: startVal,
            opacity: 1
        });
        while (currentVal < endVal && i < this.colorDomain.length) {
            var color = this.colorDomain[i];
            var offset = colorValueScale(color);
            if (offset <= startVal) {
                i++;
                continue;
            }
            if (offset.toFixed(4) >= (endVal - colorValueScale.bandwidth()).toFixed(4)) {
                break;
            }
            stops.push({
                color: color,
                offset: offset,
                opacity: 1
            });
            currentVal = offset;
            i++;
        }
        if (stops[stops.length - 1].offset < 100) {
            stops.push({
                color: endColor,
                offset: endVal,
                opacity: 1
            });
        }
        if (endVal === startVal) {
            stops[0].offset = 0;
            stops[1].offset = 100;
        }
        else {
            // normalize the offsets into percentages
            if (stops[stops.length - 1].offset !== 100) {
                for (var _i = 0, stops_1 = stops; _i < stops_1.length; _i++) {
                    var s = stops_1[_i];
                    s.offset = ((s.offset - startVal) / (endVal - startVal)) * 100;
                }
            }
        }
        return stops;
    };
    return ColorHelper;
}());

var CircleSeriesComponent = /** @class */ (function () {
    function CircleSeriesComponent() {
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.barVisible = false;
    }
    CircleSeriesComponent.prototype.ngOnInit = function () {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = "url(#" + this.gradientId + ")";
    };
    CircleSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    CircleSeriesComponent.prototype.update = function () {
        this.circle = this.getActiveCircle();
    };
    CircleSeriesComponent.prototype.getActiveCircle = function () {
        var _this = this;
        var indexActiveDataPoint = this.data.series.findIndex(function (d) {
            var label = d.name;
            return label && _this.visibleValue && label.toString() === _this.visibleValue.toString() && d.value !== undefined;
        });
        if (indexActiveDataPoint === -1) {
            // No valid point is 'active/hovered over' at this moment.
            return undefined;
        }
        return this.mapDataPointToCircle(this.data.series[indexActiveDataPoint], indexActiveDataPoint);
    };
    CircleSeriesComponent.prototype.mapDataPointToCircle = function (d, i) {
        var seriesName = this.data.name;
        var value = d.value;
        var label = d.name;
        var tooltipLabel = formatLabel(label);
        var cx;
        if (this.scaleType === 'time') {
            cx = this.xScale(label);
        }
        else if (this.scaleType === 'linear') {
            cx = this.xScale(Number(label));
        }
        else {
            cx = this.xScale(label);
        }
        var cy = this.yScale(this.type === 'standard' ? value : d.d1);
        var radius = 5;
        var height = this.yScale.range()[0] - cy;
        var opacity = 1;
        var color;
        if (this.colors.scaleType === 'linear') {
            if (this.type === 'standard') {
                color = this.colors.getColor(value);
            }
            else {
                color = this.colors.getColor(d.d1);
            }
        }
        else {
            color = this.colors.getColor(seriesName);
        }
        var data = Object.assign({}, d, {
            series: seriesName,
            value: value,
            name: label
        });
        return {
            classNames: ["circle-data-" + i],
            value: value,
            label: label,
            data: data,
            cx: cx,
            cy: cy,
            radius: radius,
            height: height,
            tooltipLabel: tooltipLabel,
            color: color,
            opacity: opacity,
            seriesName: seriesName,
            gradientStops: this.getGradientStops(color),
            min: d.min,
            max: d.max
        };
    };
    CircleSeriesComponent.prototype.getTooltipText = function (_a) {
        var tooltipLabel = _a.tooltipLabel, value = _a.value, seriesName = _a.seriesName, min$$1 = _a.min, max$$1 = _a.max;
        return "\n      <span class=\"tooltip-label\">" + seriesName + " \u2022 " + tooltipLabel + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + this.getTooltipMinMaxText(min$$1, max$$1) + "</span>\n    ";
    };
    CircleSeriesComponent.prototype.getTooltipMinMaxText = function (min$$1, max$$1) {
        if (min$$1 !== undefined || max$$1 !== undefined) {
            var result = ' (';
            if (min$$1 !== undefined) {
                if (max$$1 === undefined) {
                    result += '≥';
                }
                result += min$$1.toLocaleString();
                if (max$$1 !== undefined) {
                    result += ' - ';
                }
            }
            else if (max$$1 !== undefined) {
                result += '≤';
            }
            if (max$$1 !== undefined) {
                result += max$$1.toLocaleString();
            }
            result += ')';
            return result;
        }
        else {
            return '';
        }
    };
    CircleSeriesComponent.prototype.getGradientStops = function (color) {
        return [
            {
                offset: 0,
                color: color,
                opacity: 0.2
            },
            {
                offset: 100,
                color: color,
                opacity: 1
            }
        ];
    };
    CircleSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    CircleSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    CircleSeriesComponent.prototype.activateCircle = function () {
        this.barVisible = true;
        this.activate.emit({ name: this.data.name });
    };
    CircleSeriesComponent.prototype.deactivateCircle = function () {
        this.barVisible = false;
        this.circle.opacity = 0;
        this.deactivate.emit({ name: this.data.name });
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof ColorHelper !== "undefined" && ColorHelper) === "function" ? _a : Object)
    ], CircleSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "visibleValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], CircleSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], CircleSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _b : Object)
    ], CircleSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleSeriesComponent.prototype, "deactivate", void 0);
CircleSeriesComponent.ɵfac = function CircleSeriesComponent_Factory(t) { return new (t || CircleSeriesComponent)(); };
CircleSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CircleSeriesComponent, selectors: [["g", "ngx-charts-circle-series", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", visibleValue: "visibleValue", activeEntries: "activeEntries", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c9, decls: 1, vars: 1, consts: [[4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], ["class", "tooltip-bar", 4, "ngIf"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"], [1, "tooltip-bar"]], template: function CircleSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CircleSeriesComponent__svg_g_0_Template, 5, 20, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.circle);
    } }, directives: function () { return [ɵngcc1.NgIf, SvgLinearGradientComponent, CircleComponent, TooltipDirective]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        opacity: 0
                    }),
                    animate(250, style({ opacity: 1 }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CircleSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-circle-series]',
                template: "\n    <svg:g *ngIf=\"circle\">\n      <defs>\n        <svg:g\n          ngx-charts-svg-linear-gradient\n          orientation=\"vertical\"\n          [name]=\"gradientId\"\n          [stops]=\"circle.gradientStops\"\n        />\n      </defs>\n      <svg:rect\n        *ngIf=\"barVisible && type === 'standard'\"\n        [@animationState]=\"'active'\"\n        [attr.x]=\"circle.cx - circle.radius\"\n        [attr.y]=\"circle.cy\"\n        [attr.width]=\"circle.radius * 2\"\n        [attr.height]=\"circle.height\"\n        [attr.fill]=\"gradientFill\"\n        class=\"tooltip-bar\"\n      />\n      <svg:g\n        ngx-charts-circle\n        class=\"circle\"\n        [cx]=\"circle.cx\"\n        [cy]=\"circle.cy\"\n        [r]=\"circle.radius\"\n        [fill]=\"circle.color\"\n        [class.active]=\"isActive({ name: circle.seriesName })\"\n        [pointerEvents]=\"circle.value === 0 ? 'none' : 'all'\"\n        [data]=\"circle.value\"\n        [classNames]=\"circle.classNames\"\n        (select)=\"onClick(circle.data)\"\n        (activate)=\"activateCircle()\"\n        (deactivate)=\"deactivateCircle()\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(circle)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"circle.data\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                opacity: 0
                            }),
                            animate(250, style({ opacity: 1 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], visibleValue: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return CircleSeriesComponent;
}());

var CircleComponent = /** @class */ (function () {
    function CircleComponent() {
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    CircleComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    CircleComponent.prototype.onMouseEnter = function () {
        this.activate.emit(this.data);
    };
    CircleComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit(this.data);
    };
    CircleComponent.prototype.ngOnChanges = function (changes) {
        this.classNames = Array.isArray(this.classNames) ?
            this.classNames.join(' ') :
            '';
        this.classNames += 'circle';
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "cx", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "cy", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "r", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "stroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "classNames", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "circleOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "pointerEvents", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CircleComponent.prototype, "deactivate", void 0);
    __decorate([
        HostListener('click'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CircleComponent.prototype, "onClick", null);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CircleComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], CircleComponent.prototype, "onMouseLeave", null);
CircleComponent.ɵfac = function CircleComponent_Factory(t) { return new (t || CircleComponent)(); };
CircleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CircleComponent, selectors: [["g", "ngx-charts-circle", ""]], hostBindings: function CircleComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function CircleComponent_click_HostBindingHandler() { return ctx.onClick(); })("mouseenter", function CircleComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function CircleComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { classNames: "classNames", cx: "cx", cy: "cy", r: "r", fill: "fill", stroke: "stroke", data: "data", circleOpacity: "circleOpacity", pointerEvents: "pointerEvents" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c11, decls: 1, vars: 8, template: function CircleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "circle");
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r)("fill", ctx.fill)("stroke", ctx.stroke)("opacity", ctx.circleOpacity)("class", ctx.classNames)("pointer-events", ctx.pointerEvents);
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CircleComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-circle]',
                template: "\n    <svg:circle\n      [attr.cx]=\"cx\"\n      [attr.cy]=\"cy\"\n      [attr.r]=\"r\"\n      [attr.fill]=\"fill\"\n      [attr.stroke]=\"stroke\"\n      [attr.opacity]=\"circleOpacity\"\n      [attr.class]=\"classNames\"\n      [attr.pointer-events]=\"pointerEvents\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], classNames: [{
            type: Input
        }], cx: [{
            type: Input
        }], cy: [{
            type: Input
        }], r: [{
            type: Input
        }], fill: [{
            type: Input
        }], stroke: [{
            type: Input
        }], data: [{
            type: Input
        }], circleOpacity: [{
            type: Input
        }], pointerEvents: [{
            type: Input
        }] }); })();
    return CircleComponent;
}());

var GridPanelComponent = /** @class */ (function () {
    function GridPanelComponent() {
    }
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "path", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelComponent.prototype, "y", void 0);
GridPanelComponent.ɵfac = function GridPanelComponent_Factory(t) { return new (t || GridPanelComponent)(); };
GridPanelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GridPanelComponent, selectors: [["g", "ngx-charts-grid-panel", ""]], inputs: { path: "path", width: "width", height: "height", x: "x", y: "y" }, attrs: _c12, decls: 1, vars: 4, consts: [["stroke", "none", 1, "gridpanel"]], template: function GridPanelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "rect", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("height", ctx.height)("width", ctx.width)("x", ctx.x)("y", ctx.y);
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridPanelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-grid-panel]',
                template: "\n    <svg:rect\n      [attr.height]=\"height\"\n      [attr.width]=\"width\"\n      [attr.x]=\"x\"\n      [attr.y]=\"y\"\n      stroke=\"none\"\n      class=\"gridpanel\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { path: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }] }); })();
    return GridPanelComponent;
}());

var GridPanelSeriesComponent = /** @class */ (function () {
    function GridPanelSeriesComponent() {
    }
    GridPanelSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    GridPanelSeriesComponent.prototype.update = function () {
        this.gridPanels = this.getGridPanels();
    };
    GridPanelSeriesComponent.prototype.getGridPanels = function () {
        var _this = this;
        return this.data.map(function (d) {
            var offset;
            var width;
            var height;
            var x;
            var y;
            var className = 'odd';
            if (_this.orient === 'vertical') {
                var position = _this.xScale(d.name);
                var positionIndex = Number.parseInt((position / _this.xScale.step()).toString(), 10);
                if (positionIndex % 2 === 1) {
                    className = 'even';
                }
                offset = _this.xScale.bandwidth() * _this.xScale.paddingInner();
                width = _this.xScale.bandwidth() + offset;
                height = _this.dims.height;
                x = _this.xScale(d.name) - offset / 2;
                y = 0;
            }
            else if (_this.orient === 'horizontal') {
                var position = _this.yScale(d.name);
                var positionIndex = Number.parseInt((position / _this.yScale.step()).toString(), 10);
                if (positionIndex % 2 === 1) {
                    className = 'even';
                }
                offset = _this.yScale.bandwidth() * _this.yScale.paddingInner();
                width = _this.dims.width;
                height = _this.yScale.bandwidth() + offset;
                x = 0;
                y = _this.yScale(d.name) - offset / 2;
            }
            return {
                name: d.name,
                class: className,
                height: height,
                width: width,
                x: x,
                y: y
            };
        });
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GridPanelSeriesComponent.prototype, "orient", void 0);
GridPanelSeriesComponent.ɵfac = function GridPanelSeriesComponent_Factory(t) { return new (t || GridPanelSeriesComponent)(); };
GridPanelSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GridPanelSeriesComponent, selectors: [["g", "ngx-charts-grid-panel-series", ""]], inputs: { data: "data", dims: "dims", xScale: "xScale", yScale: "yScale", orient: "orient" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c13, decls: 1, vars: 1, consts: [["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y", "grid-panel", "odd", "even", 4, "ngFor", "ngForOf"], ["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y"]], template: function GridPanelSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, GridPanelSeriesComponent__svg_g_0_Template, 1, 10, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.gridPanels);
    } }, directives: [ɵngcc1.NgForOf, GridPanelComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GridPanelSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-grid-panel-series]',
                template: "\n    <svg:g ngx-charts-grid-panel *ngFor=\"let gridPanel of gridPanels\"\n      [height]=\"gridPanel.height\"\n      [width]=\"gridPanel.width\"\n      [x]=\"gridPanel.x\"\n      [y]=\"gridPanel.y\"\n      [class.grid-panel]=\"true\"\n      [class.odd]=\"gridPanel.class === 'odd'\"\n      [class.even]=\"gridPanel.class === 'even'\">\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { data: [{
            type: Input
        }], dims: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], orient: [{
            type: Input
        }] }); })();
    return GridPanelSeriesComponent;
}());

var SvgLinearGradientComponent = /** @class */ (function () {
    function SvgLinearGradientComponent() {
        this.orientation = 'vertical';
    }
    SvgLinearGradientComponent.prototype.ngOnChanges = function (changes) {
        this.x1 = '0%';
        this.x2 = '0%';
        this.y1 = '0%';
        this.y2 = '0%';
        if (this.orientation === 'horizontal') {
            this.x2 = '100%';
        }
        else if (this.orientation === 'vertical') {
            this.y1 = '100%';
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SvgLinearGradientComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SvgLinearGradientComponent.prototype, "name", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], SvgLinearGradientComponent.prototype, "stops", void 0);
SvgLinearGradientComponent.ɵfac = function SvgLinearGradientComponent_Factory(t) { return new (t || SvgLinearGradientComponent)(); };
SvgLinearGradientComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SvgLinearGradientComponent, selectors: [["g", "ngx-charts-svg-linear-gradient", ""]], inputs: { orientation: "orientation", name: "name", stops: "stops" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c14, decls: 2, vars: 6, consts: [[3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgLinearGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "linearGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgLinearGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("x1", ctx.x1)("y1", ctx.y1)("x2", ctx.x2)("y2", ctx.y2);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SvgLinearGradientComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-svg-linear-gradient]',
                template: "\n    <svg:linearGradient\n      [id]=\"name\"\n      [attr.x1]=\"x1\"\n      [attr.y1]=\"y1\"\n      [attr.x2]=\"x2\"\n      [attr.y2]=\"y2\">\n      <svg:stop *ngFor=\"let stop of stops\"\n        [attr.offset]=\"stop.offset + '%'\"\n        [style.stop-color]=\"stop.color\"\n        [style.stop-opacity]=\"stop.opacity\"\n      />\n    </svg:linearGradient>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { orientation: [{
            type: Input
        }], name: [{
            type: Input
        }], stops: [{
            type: Input
        }] }); })();
    return SvgLinearGradientComponent;
}());

var SvgRadialGradientComponent = /** @class */ (function () {
    function SvgRadialGradientComponent() {
        this.endOpacity = 1;
        this.cx = 0;
        this.cy = 0;
    }
    Object.defineProperty(SvgRadialGradientComponent.prototype, "stops", {
        get: function () {
            return this.stopsInput || this.stopsDefault;
        },
        set: function (value) {
            this.stopsInput = value;
        },
        enumerable: true,
        configurable: true
    });
    SvgRadialGradientComponent.prototype.ngOnChanges = function (changes) {
        this.r = '30%';
        if (('color' in changes) ||
            ('startOpacity' in changes) ||
            ('endOpacity' in changes)) {
            this.stopsDefault = [{
                    offset: 0,
                    color: this.color,
                    opacity: this.startOpacity
                }, {
                    offset: 100,
                    color: this.color,
                    opacity: this.endOpacity
                }];
        }
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SvgRadialGradientComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SvgRadialGradientComponent.prototype, "name", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SvgRadialGradientComponent.prototype, "startOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SvgRadialGradientComponent.prototype, "endOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SvgRadialGradientComponent.prototype, "cx", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], SvgRadialGradientComponent.prototype, "cy", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], SvgRadialGradientComponent.prototype, "stops", null);
SvgRadialGradientComponent.ɵfac = function SvgRadialGradientComponent_Factory(t) { return new (t || SvgRadialGradientComponent)(); };
SvgRadialGradientComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SvgRadialGradientComponent, selectors: [["g", "ngx-charts-svg-radial-gradient", ""]], inputs: { endOpacity: "endOpacity", cx: "cx", cy: "cy", stops: "stops", color: "color", name: "name", startOpacity: "startOpacity" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c15, decls: 2, vars: 5, consts: [["gradientUnits", "userSpaceOnUse", 3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgRadialGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "radialGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgRadialGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SvgRadialGradientComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-svg-radial-gradient]',
                template: "\n    <svg:radialGradient\n      [id]=\"name\"\n      [attr.cx]=\"cx\"\n      [attr.cy]=\"cy\"\n      [attr.r]=\"r\"\n      gradientUnits=\"userSpaceOnUse\">\n      <svg:stop *ngFor=\"let stop of stops\"\n        [attr.offset]=\"stop.offset + '%'\"\n        [style.stop-color]=\"stop.color\"\n        [style.stop-opacity]=\"stop.opacity\"\n      />\n    </svg:radialGradient>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { endOpacity: [{
            type: Input
        }], cx: [{
            type: Input
        }], cy: [{
            type: Input
        }], stops: [{
            type: Input
        }], color: [{
            type: Input
        }], name: [{
            type: Input
        }], startOpacity: [{
            type: Input
        }] }); })();
    return SvgRadialGradientComponent;
}());

var Timeline = /** @class */ (function () {
    function Timeline(element, cd) {
        this.cd = cd;
        this.height = 50;
        this.select = new EventEmitter();
        this.onDomainChange = new EventEmitter();
        this.initialized = false;
        this.element = element.nativeElement;
    }
    Timeline.prototype.ngOnChanges = function (changes) {
        this.update();
        if (!this.initialized) {
            this.addBrush();
            this.initialized = true;
        }
    };
    Timeline.prototype.update = function () {
        this.dims = this.getDims();
        this.height = this.dims.height;
        var offsetY = this.view[1] - this.height;
        this.xDomain = this.getXDomain();
        this.xScale = this.getXScale();
        if (this.brush) {
            this.updateBrush();
        }
        this.transform = "translate(0 , " + offsetY + ")";
        this.filterId = 'filter' + id().toString();
        this.filter = "url(#" + this.filterId + ")";
        this.cd.markForCheck();
    };
    Timeline.prototype.getXDomain = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.name)) {
                    values.push(d.name);
                }
            }
        }
        var domain = [];
        if (this.scaleType === 'time') {
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [min$$1, max$$1];
        }
        else if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [min$$1, max$$1];
        }
        else {
            domain = values;
        }
        return domain;
    };
    Timeline.prototype.getXScale = function () {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime()
                .range([0, this.dims.width])
                .domain(this.xDomain);
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear()
                .range([0, this.dims.width])
                .domain(this.xDomain);
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint()
                .range([0, this.dims.width])
                .padding(0.1)
                .domain(this.xDomain);
        }
        return scale;
    };
    Timeline.prototype.addBrush = function () {
        var _this = this;
        if (this.brush)
            return;
        var height = this.height;
        var width = this.view[0];
        this.brush = brushX()
            .extent([[0, 0], [width, height]])
            .on('brush end', function () {
            var selection = event.selection || _this.xScale.range();
            var newDomain = selection.map(_this.xScale.invert);
            _this.onDomainChange.emit(newDomain);
            _this.cd.markForCheck();
        });
        select(this.element)
            .select('.brush')
            .call(this.brush);
    };
    Timeline.prototype.updateBrush = function () {
        if (!this.brush)
            return;
        var height = this.height;
        var width = this.view[0];
        this.brush.extent([[0, 0], [width, height]]);
        select(this.element)
            .select('.brush')
            .call(this.brush);
        select(this.element).select('.selection')
            .attr('fill', undefined)
            .attr('stroke', undefined)
            .attr('fill-opacity', undefined);
        this.cd.markForCheck();
    };
    Timeline.prototype.getDims = function () {
        var width = this.view[0];
        var dims = {
            width: width,
            height: this.height
        };
        return dims;
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "view", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "state", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "scheme", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "customColors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "miniChart", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], Timeline.prototype, "height", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], Timeline.prototype, "onDomainChange", void 0);
    Timeline = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object, typeof (_b = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _b : Object])
    ], Timeline);
Timeline.ɵfac = function Timeline_Factory(t) { return new (t || Timeline)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _b : Object)); };
Timeline.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: Timeline, selectors: [["g", "ngx-charts-timeline", ""]], inputs: { height: "height", view: "view", state: "state", results: "results", scheme: "scheme", customColors: "customColors", legend: "legend", miniChart: "miniChart", autoScale: "autoScale", scaleType: "scaleType" }, outputs: { select: "select", onDomainChange: "onDomainChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c16, ngContentSelectors: _c2, decls: 7, vars: 4, consts: [[1, "timeline"], ["in", "SourceGraphic", "type", "matrix", "values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"], [1, "embedded-chart"], ["x", "0", "y", "0", 1, "brush-background"], [1, "brush"]], template: function Timeline_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "filter");
        ɵngcc0.ɵɵelement(2, "feColorMatrix", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "g", 2);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "rect", 3);
        ɵngcc0.ɵɵelement(6, "g", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("id", ctx.filterId);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵattribute("width", ctx.view[0])("height", ctx.height);
    } }, styles: [".timeline .brush-background{fill:rgba(0,0,0,.05)}.timeline .brush .selection{fill:rgba(0,0,0,.1);stroke-width:1px;stroke:#888}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}"], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Timeline, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-timeline]',
                template: "\n    <svg:g\n      class=\"timeline\"\n      [attr.transform]=\"transform\">\n      <svg:filter [attr.id]=\"filterId\">\n        <svg:feColorMatrix in=\"SourceGraphic\"\n            type=\"matrix\"\n            values=\"0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\" />\n      </svg:filter>\n      <svg:g class=\"embedded-chart\">\n        <ng-content></ng-content>\n      </svg:g>\n      <svg:rect x=\"0\"\n        [attr.width]=\"view[0]\"\n        y=\"0\"\n        [attr.height]=\"height\"\n        class=\"brush-background\"\n      />\n      <svg:g class=\"brush\"></svg:g>\n    </svg:g>\n  ",
                styles: [".timeline .brush-background{fill:rgba(0,0,0,.05)}.timeline .brush .selection{fill:rgba(0,0,0,.1);stroke-width:1px;stroke:#888}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }, { type: typeof (_b = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _b : Object }]; }, { height: [{
            type: Input
        }], select: [{
            type: Output
        }], onDomainChange: [{
            type: Output
        }], view: [{
            type: Input
        }], state: [{
            type: Input
        }], results: [{
            type: Input
        }], scheme: [{
            type: Input
        }], customColors: [{
            type: Input
        }], legend: [{
            type: Input
        }], miniChart: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], scaleType: [{
            type: Input
        }] }); })();
    return Timeline;
}());

var AreaComponent = /** @class */ (function () {
    function AreaComponent(element) {
        this.opacity = 1;
        this.startOpacity = 0.5;
        this.endOpacity = 1;
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
        this.hasGradient = false;
        this.element = element.nativeElement;
    }
    AreaComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            this.loadAnimation();
            this.initialized = true;
        }
        else {
            this.update();
        }
    };
    AreaComponent.prototype.update = function () {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = "url(#" + this.gradientId + ")";
        if (this.gradient || this.stops) {
            this.gradientStops = this.getGradient();
            this.hasGradient = true;
        }
        else {
            this.hasGradient = false;
        }
        this.updatePathEl();
    };
    AreaComponent.prototype.loadAnimation = function () {
        this.areaPath = this.startingPath;
        setTimeout(this.update.bind(this), 100);
    };
    AreaComponent.prototype.updatePathEl = function () {
        var node = select(this.element).select('.area');
        if (this.animations) {
            node.transition().duration(750)
                .attr('d', this.path);
        }
        else {
            node.attr('d', this.path);
        }
    };
    AreaComponent.prototype.getGradient = function () {
        if (this.stops) {
            return this.stops;
        }
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: this.startOpacity
            },
            {
                offset: 100,
                color: this.fill,
                opacity: this.endOpacity
            }
        ];
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "path", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "startingPath", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "opacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "startOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "endOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "activeLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaComponent.prototype, "stops", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], AreaComponent.prototype, "select", void 0);
    AreaComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], AreaComponent);
AreaComponent.ɵfac = function AreaComponent_Factory(t) { return new (t || AreaComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
AreaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaComponent, selectors: [["g", "ngx-charts-area", ""]], inputs: { opacity: "opacity", startOpacity: "startOpacity", endOpacity: "endOpacity", gradient: "gradient", animations: "animations", data: "data", path: "path", startingPath: "startingPath", fill: "fill", activeLabel: "activeLabel", stops: "stops" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c17, decls: 2, vars: 5, consts: [[4, "ngIf"], [1, "area"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"]], template: function AreaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, AreaComponent__svg_defs_0_Template, 2, 2, "defs", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(1, "path", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("opacity", ctx.opacity);
        ɵngcc0.ɵɵattribute("d", ctx.areaPath)("fill", ctx.gradient ? ctx.gradientFill : ctx.fill);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-area]',
                template: "\n    <svg:defs *ngIf=\"gradient\">\n      <svg:g ngx-charts-svg-linear-gradient\n        orientation=\"vertical\"\n        [name]=\"gradientId\"\n        [stops]=\"gradientStops\"\n      />\n    </svg:defs>\n    <svg:path\n      class=\"area\"\n      [attr.d]=\"areaPath\"\n      [attr.fill]=\"gradient ? gradientFill : fill\"\n      [style.opacity]=\"opacity\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { opacity: [{
            type: Input
        }], startOpacity: [{
            type: Input
        }], endOpacity: [{
            type: Input
        }], gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], path: [{
            type: Input
        }], startingPath: [{
            type: Input
        }], fill: [{
            type: Input
        }], activeLabel: [{
            type: Input
        }], stops: [{
            type: Input
        }] }); })();
    return AreaComponent;
}());

// If we don't check whether 'window' and 'global' variables are defined,
// code will fail in browser/node with 'variable is undefined' error.
var root;
if (typeof window !== 'undefined') {
    root = window;
}
else if (typeof global !== 'undefined') {
    root = global;
}
// tslint:disable-next-line:variable-name
var MouseEvent = root.MouseEvent;
function createMouseEvent(name, bubbles, cancelable) {
    if (bubbles === void 0) { bubbles = false; }
    if (cancelable === void 0) { cancelable = true; }
    // Calling new of an event does not work correctly on IE. The following is a tested workaround
    // See https://stackoverflow.com/questions/27176983/dispatchevent-not-working-in-ie11
    if (typeof (MouseEvent) === 'function') {
        // Sane browsers
        return new MouseEvent(name, { bubbles: bubbles, cancelable: cancelable });
    }
    else {
        // IE
        var event$$1 = document.createEvent('MouseEvent');
        event$$1.initEvent(name, bubbles, cancelable);
        return event$$1;
    }
}

var TooltipArea = /** @class */ (function () {
    function TooltipArea() {
        this.anchorOpacity = 0;
        this.anchorPos = -1;
        this.anchorValues = [];
        this.showPercentage = false;
        this.tooltipDisabled = false;
        this.hover = new EventEmitter();
    }
    TooltipArea.prototype.getValues = function (xVal) {
        var results = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            var item = group.series.find(function (d) { return d.name.toString() === xVal.toString(); });
            var groupName = group.name;
            if (groupName instanceof Date) {
                groupName = groupName.toLocaleDateString();
            }
            if (item) {
                var label = item.name;
                var val = item.value;
                if (this.showPercentage) {
                    val = (item.d1 - item.d0).toFixed(2) + '%';
                }
                var color = void 0;
                if (this.colors.scaleType === 'linear') {
                    var v = val;
                    if (item.d1) {
                        v = item.d1;
                    }
                    color = this.colors.getColor(v);
                }
                else {
                    color = this.colors.getColor(group.name);
                }
                var data = Object.assign({}, item, {
                    value: val,
                    name: label,
                    series: groupName,
                    min: item.min,
                    max: item.max,
                    color: color
                });
                results.push(data);
            }
        }
        return results;
    };
    TooltipArea.prototype.mouseMove = function (event$$1) {
        var xPos = event$$1.pageX - event$$1.target.getBoundingClientRect().left;
        var closestIndex = this.findClosestPointIndex(xPos);
        var closestPoint = this.xSet[closestIndex];
        this.anchorPos = this.xScale(closestPoint);
        this.anchorPos = Math.max(0, this.anchorPos);
        this.anchorPos = Math.min(this.dims.width, this.anchorPos);
        this.anchorValues = this.getValues(closestPoint);
        if (this.anchorPos !== this.lastAnchorPos) {
            var ev = createMouseEvent('mouseleave');
            this.tooltipAnchor.nativeElement.dispatchEvent(ev);
            this.anchorOpacity = 0.7;
            this.hover.emit({
                value: closestPoint
            });
            this.showTooltip();
            this.lastAnchorPos = this.anchorPos;
        }
    };
    TooltipArea.prototype.findClosestPointIndex = function (xPos) {
        var minIndex = 0;
        var maxIndex = this.xSet.length - 1;
        var minDiff = Number.MAX_VALUE;
        var closestIndex = 0;
        while (minIndex <= maxIndex) {
            var currentIndex = ((minIndex + maxIndex) / 2) | 0;
            var currentElement = this.xScale(this.xSet[currentIndex]);
            var curDiff = Math.abs(currentElement - xPos);
            if (curDiff < minDiff) {
                minDiff = curDiff;
                closestIndex = currentIndex;
            }
            if (currentElement < xPos) {
                minIndex = currentIndex + 1;
            }
            else if (currentElement > xPos) {
                maxIndex = currentIndex - 1;
            }
            else {
                minDiff = 0;
                closestIndex = currentIndex;
                break;
            }
        }
        return closestIndex;
    };
    TooltipArea.prototype.showTooltip = function () {
        var event$$1 = createMouseEvent('mouseenter');
        this.tooltipAnchor.nativeElement.dispatchEvent(event$$1);
    };
    TooltipArea.prototype.hideTooltip = function () {
        var event$$1 = createMouseEvent('mouseleave');
        this.tooltipAnchor.nativeElement.dispatchEvent(event$$1);
        this.anchorOpacity = 0;
        this.lastAnchorPos = -1;
    };
    TooltipArea.prototype.getToolTipText = function (tooltipItem) {
        var result = '';
        if (tooltipItem.series !== undefined) {
            result += tooltipItem.series;
        }
        else {
            result += '???';
        }
        result += ': ';
        if (tooltipItem.value !== undefined) {
            result += tooltipItem.value.toLocaleString();
        }
        if (tooltipItem.min !== undefined || tooltipItem.max !== undefined) {
            result += ' (';
            if (tooltipItem.min !== undefined) {
                if (tooltipItem.max === undefined) {
                    result += '≥';
                }
                result += tooltipItem.min.toLocaleString();
                if (tooltipItem.max !== undefined) {
                    result += ' - ';
                }
            }
            else if (tooltipItem.max !== undefined) {
                result += '≤';
            }
            if (tooltipItem.max !== undefined) {
                result += tooltipItem.max.toLocaleString();
            }
            result += ')';
        }
        return result;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "xSet", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipArea.prototype, "showPercentage", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TooltipArea.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], TooltipArea.prototype, "tooltipTemplate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "hover", void 0);
    __decorate([
        ViewChild('tooltipAnchor', { static: false }),
        __metadata("design:type", Object)
    ], TooltipArea.prototype, "tooltipAnchor", void 0);
TooltipArea.ɵfac = function TooltipArea_Factory(t) { return new (t || TooltipArea)(); };
TooltipArea.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipArea, selectors: [["g", "ngx-charts-tooltip-area", ""]], viewQuery: function TooltipArea_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c18, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipAnchor = _t.first);
    } }, inputs: { showPercentage: "showPercentage", tooltipDisabled: "tooltipDisabled", dims: "dims", xSet: "xSet", xScale: "xScale", yScale: "yScale", results: "results", colors: "colors", tooltipTemplate: "tooltipTemplate" }, outputs: { hover: "hover" }, attrs: _c19, decls: 6, vars: 18, consts: [["y", "0", 1, "tooltip-area", 2, "opacity", "0", "cursor", "auto", 3, "mousemove", "mouseleave"], ["defaultTooltipTemplate", ""], ["y", "0", "ngx-tooltip", "", 1, "tooltip-anchor", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipSpacing", "tooltipTemplate", "tooltipContext", "tooltipImmediateExit"], ["tooltipAnchor", ""], [1, "area-tooltip-container"], ["class", "tooltip-item", 4, "ngFor", "ngForOf"], [1, "tooltip-item"], [1, "tooltip-item-color"]], template: function TooltipArea_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵelementStart(1, "rect", 0);
        ɵngcc0.ɵɵlistener("mousemove", function TooltipArea_Template__svg_rect_mousemove_1_listener($event) { return ctx.mouseMove($event); })("mouseleave", function TooltipArea_Template__svg_rect_mouseleave_1_listener() { return ctx.hideTooltip(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, TooltipArea__xhtml_ng_template_2_Template, 2, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelement(4, "rect", 2, 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        var _r0 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("x", 0)("width", ctx.dims.width)("height", ctx.dims.height);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵstyleProp("opacity", ctx.anchorOpacity)("pointer-events", "none");
        ɵngcc0.ɵɵproperty("@animationState", ctx.anchorOpacity !== 0 ? "active" : "inactive")("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", "right")("tooltipType", "tooltip")("tooltipSpacing", 15)("tooltipTemplate", ctx.tooltipTemplate ? ctx.tooltipTemplate : _r0)("tooltipContext", ctx.anchorValues)("tooltipImmediateExit", true);
        ɵngcc0.ɵɵattribute("x", ctx.anchorPos)("width", 1)("height", ctx.dims.height);
    } }, directives: [TooltipDirective, ɵngcc1.NgForOf], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition('inactive => active', [
                    style({
                        opacity: 0
                    }),
                    animate(250, style({ opacity: 0.7 }))
                ]),
                transition('active => inactive', [
                    style({
                        opacity: 0.7
                    }),
                    animate(250, style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipArea, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-tooltip-area]',
                template: "\n    <svg:g>\n      <svg:rect\n        class=\"tooltip-area\"\n        [attr.x]=\"0\"\n        y=\"0\"\n        [attr.width]=\"dims.width\"\n        [attr.height]=\"dims.height\"\n        style=\"opacity: 0; cursor: 'auto';\"\n        (mousemove)=\"mouseMove($event)\"\n        (mouseleave)=\"hideTooltip()\"\n      />\n      <xhtml:ng-template #defaultTooltipTemplate let-model=\"model\">\n        <xhtml:div class=\"area-tooltip-container\">\n          <xhtml:div *ngFor=\"let tooltipItem of model\" class=\"tooltip-item\">\n            <span class=\"tooltip-item-color\" [style.background-color]=\"tooltipItem.color\"> </span>\n            {{ getToolTipText(tooltipItem) }}\n          </xhtml:div>\n        </xhtml:div>\n      </xhtml:ng-template>\n      <svg:rect\n        #tooltipAnchor\n        [@animationState]=\"anchorOpacity !== 0 ? 'active' : 'inactive'\"\n        class=\"tooltip-anchor\"\n        [attr.x]=\"anchorPos\"\n        y=\"0\"\n        [attr.width]=\"1\"\n        [attr.height]=\"dims.height\"\n        [style.opacity]=\"anchorOpacity\"\n        [style.pointer-events]=\"'none'\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'right'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipSpacing]=\"15\"\n        [tooltipTemplate]=\"tooltipTemplate ? tooltipTemplate : defaultTooltipTemplate\"\n        [tooltipContext]=\"anchorValues\"\n        [tooltipImmediateExit]=\"true\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition('inactive => active', [
                            style({
                                opacity: 0
                            }),
                            animate(250, style({ opacity: 0.7 }))
                        ]),
                        transition('active => inactive', [
                            style({
                                opacity: 0.7
                            }),
                            animate(250, style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { showPercentage: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], hover: [{
            type: Output
        }], dims: [{
            type: Input
        }], xSet: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], results: [{
            type: Input
        }], colors: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }], tooltipAnchor: [{
            type: ViewChild,
            args: ['tooltipAnchor', { static: false }]
        }] }); })();
    return TooltipArea;
}());

// Robert Penner's easeOutExpo
function easeOutExpo(t, b, c, d) {
    return (c * (-Math.pow(2, (-10 * t) / d) + 1) * 1024) / 1023 + b;
}
/**
 * Counts from a number to the end incrementally.
 *
 * @export
 * @param {any} countFrom
 * @param {any} countTo
 * @param {any} countDecimals
 * @param {any} countDuration
 * @param {any} callback
 * @returns
 */
function count(countFrom, countTo, countDecimals, countDuration, callback) {
    var startVal = Number(countFrom);
    var endVal = Number(countTo);
    var countDown = startVal > endVal;
    var decimals = Math.max(0, countDecimals);
    var dec = Math.pow(10, decimals);
    var duration = Number(countDuration) * 1000;
    var startTime;
    function runCount(timestamp) {
        var frameVal;
        var progress = timestamp - startTime;
        if (countDown) {
            frameVal = startVal - easeOutExpo(progress, 0, startVal - endVal, duration);
        }
        else {
            frameVal = easeOutExpo(progress, startVal, endVal - startVal, duration);
        }
        if (countDown) {
            frameVal = frameVal < endVal ? endVal : frameVal;
        }
        else {
            frameVal = frameVal > endVal ? endVal : frameVal;
        }
        frameVal = Math.round(frameVal * dec) / dec;
        var tick = progress < duration;
        callback({
            value: frameVal,
            progress: progress,
            timestamp: timestamp,
            finished: !tick
        });
        if (tick) {
            return requestAnimationFrame(function (val) { return runCount(val); });
        }
    }
    return requestAnimationFrame(function (timestamp) {
        startTime = timestamp;
        return runCount(timestamp);
    });
}
/**
 * Determine decimals places
 *
 * @export
 * @param {any} countTo
 * @returns
 */
function decimalChecker(countTo) {
    var endVal = Number(countTo);
    if (endVal % 1 !== 0 && Math.abs(endVal) <= 10) {
        return 2;
    }
    return 0;
}

/**
 * Count up component
 *
 * Loosely inspired by:
 *  - https://github.com/izupet/angular2-counto
 *  - https://inorganik.github.io/countUp.js/
 *
 * @export
 * @class CountUpDirective
 */
var CountUpDirective = /** @class */ (function () {
    function CountUpDirective(cd, element) {
        this.cd = cd;
        this.countDuration = 1;
        this.countPrefix = '';
        this.countSuffix = '';
        this.countChange = new EventEmitter();
        this.countFinish = new EventEmitter();
        this.value = '';
        this._countDecimals = 0;
        this._countTo = 0;
        this._countFrom = 0;
        this.nativeElement = element.nativeElement;
    }
    Object.defineProperty(CountUpDirective.prototype, "countDecimals", {
        get: function () {
            if (this._countDecimals)
                return this._countDecimals;
            return decimalChecker(this.countTo);
        },
        set: function (val) {
            this._countDecimals = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CountUpDirective.prototype, "countTo", {
        get: function () {
            return this._countTo;
        },
        set: function (val) {
            this._countTo = parseFloat(val);
            this.start();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CountUpDirective.prototype, "countFrom", {
        get: function () {
            return this._countFrom;
        },
        set: function (val) {
            this._countFrom = parseFloat(val);
            this.start();
        },
        enumerable: true,
        configurable: true
    });
    CountUpDirective.prototype.ngOnDestroy = function () {
        cancelAnimationFrame(this.animationReq);
    };
    CountUpDirective.prototype.start = function () {
        var _this = this;
        cancelAnimationFrame(this.animationReq);
        var valueFormatting = this.valueFormatting || (function (value) { return "" + _this.countPrefix + value.toLocaleString() + _this.countSuffix; });
        var callback = function (_a) {
            var value = _a.value, progress = _a.progress, finished = _a.finished;
            _this.value = valueFormatting(value);
            _this.cd.markForCheck();
            if (!finished)
                _this.countChange.emit({ value: _this.value, progress: progress });
            if (finished)
                _this.countFinish.emit({ value: _this.value, progress: progress });
        };
        this.animationReq = count(this.countFrom, this.countTo, this.countDecimals, this.countDuration, callback);
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], CountUpDirective.prototype, "countDuration", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CountUpDirective.prototype, "countPrefix", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], CountUpDirective.prototype, "countSuffix", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CountUpDirective.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], CountUpDirective.prototype, "countDecimals", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], CountUpDirective.prototype, "countTo", null);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], CountUpDirective.prototype, "countFrom", null);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CountUpDirective.prototype, "countChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CountUpDirective.prototype, "countFinish", void 0);
    CountUpDirective = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _a : Object, typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object])
    ], CountUpDirective);
CountUpDirective.ɵfac = function CountUpDirective_Factory(t) { return new (t || CountUpDirective)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _a : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object)); };
CountUpDirective.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CountUpDirective, selectors: [["", "ngx-charts-count-up", ""]], inputs: { countDuration: "countDuration", countPrefix: "countPrefix", countSuffix: "countSuffix", countDecimals: "countDecimals", countTo: "countTo", countFrom: "countFrom", valueFormatting: "valueFormatting" }, outputs: { countChange: "countChange", countFinish: "countFinish" }, attrs: _c20, decls: 1, vars: 1, template: function CountUpDirective_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate(ctx.value);
    } }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CountUpDirective, [{
        type: Component,
        args: [{
                selector: '[ngx-charts-count-up]',
                template: "{{value}}"
            }]
    }], function () { return [{ type: typeof (_a = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _a : Object }, { type: typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object }]; }, { countDuration: [{
            type: Input
        }], countPrefix: [{
            type: Input
        }], countSuffix: [{
            type: Input
        }], countChange: [{
            type: Output
        }], countFinish: [{
            type: Output
        }], countDecimals: [{
            type: Input
        }], countTo: [{
            type: Input
        }], countFrom: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }] }); })();
    return CountUpDirective;
}());

var COMPONENTS = [
    AreaComponent,
    BaseChartComponent,
    CountUpDirective,
    TooltipArea,
    ChartComponent,
    LegendComponent,
    LegendEntryComponent,
    ScaleLegendComponent,
    CircleComponent,
    CircleSeriesComponent,
    GridPanelComponent,
    GridPanelSeriesComponent,
    SvgLinearGradientComponent,
    SvgRadialGradientComponent,
    Timeline,
    AdvancedLegendComponent
];
var ChartCommonModule = /** @class */ (function () {
    function ChartCommonModule() {
    }
ChartCommonModule.ɵfac = function ChartCommonModule_Factory(t) { return new (t || ChartCommonModule)(); };
ChartCommonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ChartCommonModule });
ChartCommonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[
            CommonModule,
            AxesModule,
            TooltipModule
        ], CommonModule, AxesModule, TooltipModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChartCommonModule, { declarations: function () { return [AreaComponent, BaseChartComponent, CountUpDirective, TooltipArea, ChartComponent, LegendComponent, LegendEntryComponent, ScaleLegendComponent, CircleComponent, CircleSeriesComponent, GridPanelComponent, GridPanelSeriesComponent, SvgLinearGradientComponent, SvgRadialGradientComponent, Timeline, AdvancedLegendComponent]; }, imports: function () { return [CommonModule, AxesModule, TooltipModule]; }, exports: function () { return [CommonModule, AxesModule, TooltipModule, AreaComponent, BaseChartComponent, CountUpDirective, TooltipArea, ChartComponent, LegendComponent, LegendEntryComponent, ScaleLegendComponent, CircleComponent, CircleSeriesComponent, GridPanelComponent, GridPanelSeriesComponent, SvgLinearGradientComponent, SvgRadialGradientComponent, Timeline, AdvancedLegendComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChartCommonModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    AxesModule,
                    TooltipModule
                ],
                declarations: COMPONENTS.slice(),
                exports: [
                    CommonModule,
                    AxesModule,
                    TooltipModule
                ].concat(COMPONENTS)
            }]
    }], function () { return []; }, null); })();
    return ChartCommonModule;
}());

function calculateViewDimensions(_a) {
    var width = _a.width, height = _a.height, margins = _a.margins, _b = _a.showXAxis, showXAxis = _b === void 0 ? false : _b, _c = _a.showYAxis, showYAxis = _c === void 0 ? false : _c, _d = _a.xAxisHeight, xAxisHeight = _d === void 0 ? 0 : _d, _e = _a.yAxisWidth, yAxisWidth = _e === void 0 ? 0 : _e, _f = _a.showXLabel, showXLabel = _f === void 0 ? false : _f, _g = _a.showYLabel, showYLabel = _g === void 0 ? false : _g, _h = _a.showLegend, showLegend = _h === void 0 ? false : _h, _j = _a.legendType, legendType = _j === void 0 ? 'ordinal' : _j, _k = _a.legendPosition, legendPosition = _k === void 0 ? 'right' : _k, _l = _a.columns, columns = _l === void 0 ? 12 : _l;
    var xOffset = margins[3];
    var chartWidth = width;
    var chartHeight = height - margins[0] - margins[2];
    if (showLegend && legendPosition === 'right') {
        if (legendType === 'ordinal') {
            columns -= 2;
        }
        else {
            columns -= 1;
        }
    }
    chartWidth = chartWidth * columns / 12;
    chartWidth = chartWidth - margins[1] - margins[3];
    if (showXAxis) {
        chartHeight -= 5;
        chartHeight -= xAxisHeight;
        if (showXLabel) {
            // text height + spacing between axis label and tick labels
            var offset = 25 + 5;
            chartHeight -= offset;
        }
    }
    if (showYAxis) {
        chartWidth -= 5;
        chartWidth -= yAxisWidth;
        xOffset += yAxisWidth;
        xOffset += 10;
        if (showYLabel) {
            // text height + spacing between axis label and tick labels
            var offset = 25 + 5;
            chartWidth -= offset;
            xOffset += offset;
        }
    }
    chartWidth = Math.max(0, chartWidth);
    chartHeight = Math.max(0, chartHeight);
    return {
        width: Math.floor(chartWidth),
        height: Math.floor(chartHeight),
        xOffset: Math.floor(xOffset)
    };
}

/**
 * Based on the data, return an array with unique values.
 *
 * @export
 * @returns array
 * @param results
 */
function getUniqueXDomainValues(results) {
    var valueSet = new Set();
    for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
        var result = results_1[_i];
        for (var _a = 0, _b = result.series; _a < _b.length; _a++) {
            var d = _b[_a];
            valueSet.add(d.name);
        }
    }
    return Array.from(valueSet);
}
/**
 * Get the scaleType of enumerable of values.
 * @param values
 * @returns {string} 'time', 'linear' or 'ordinal'
 */
function getScaleType(values, checkDateType) {
    if (checkDateType === void 0) { checkDateType = true; }
    if (checkDateType) {
        var allDates = values.every(function (value) { return value instanceof Date; });
        if (allDates) {
            return 'time';
        }
    }
    var allNumbers = values.every(function (value) { return typeof value === 'number'; });
    if (allNumbers) {
        return 'linear';
    }
    return 'ordinal';
}

var AreaChartComponent = /** @class */ (function (_super) {
    __extends(AreaChartComponent, _super);
    function AreaChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.baseValue = 'auto';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    AreaChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + ", " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    AreaChartComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    AreaChartComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
        }
        var min$$1;
        var max$$1;
        if (this.scaleType === 'time' || this.scaleType === 'linear') {
            min$$1 = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, values);
            max$$1 = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, values);
        }
        if (this.scaleType === 'time') {
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    AreaChartComponent.prototype.getYDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        var values = domain.slice();
        if (!this.autoScale) {
            values.push(0);
        }
        if (this.baseValue !== 'auto') {
            values.push(this.baseValue);
        }
        var min$$1 = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, values);
        var max$$1 = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, values);
        return [min$$1, max$$1];
    };
    AreaChartComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    AreaChartComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime();
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear();
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint().padding(0.1);
        }
        scale.range([0, width]).domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartComponent.prototype.getScaleType = function (values) {
        var date = true;
        var num = true;
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value = values_1[_i];
            if (!this.isDate(value)) {
                date = false;
            }
            if (typeof value !== 'number') {
                num = false;
            }
        }
        if (date) {
            return 'time';
        }
        if (num) {
            return 'linear';
        }
        return 'ordinal';
    };
    AreaChartComponent.prototype.isDate = function (value) {
        if (value instanceof Date) {
            return true;
        }
        return false;
    };
    AreaChartComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    AreaChartComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    AreaChartComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    AreaChartComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    AreaChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    AreaChartComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    AreaChartComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    AreaChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    AreaChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    AreaChartComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "state", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "baseValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AreaChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AreaChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AreaChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], AreaChartComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AreaChartComponent.prototype, "hideCircles", null);
AreaChartComponent.ɵfac = function AreaChartComponent_Factory(t) { return ɵAreaChartComponent_BaseFactory(t || AreaChartComponent); };
AreaChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaChartComponent, selectors: [["ngx-charts-area-chart"]], contentQueries: function AreaChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", state: "state", xAxis: "xAxis", yAxis: "yAxis", baseValue: "baseValue", autoScale: "autoScale", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "activeEntries", "scaleType", "gradient", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartComponent__svg_g_8_Template, 2, 10, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartComponent__svg_g_9_Template, 3, 9, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, AreaSeriesComponent, TooltipArea, CircleSeriesComponent, Timeline]; }, styles: [_c24], encapsulation: 2, changeDetection: 0 });
var ɵAreaChartComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(AreaChartComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-area-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [baseValue]=\"baseValue\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [gradient]=\"gradient\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [baseValue]=\"baseValue\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], state: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], baseValue: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return AreaChartComponent;
}(BaseChartComponent));

var AreaChartNormalizedComponent = /** @class */ (function (_super) {
    __extends(AreaChartNormalizedComponent, _super);
    function AreaChartNormalizedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    AreaChartNormalizedComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        var _loop_1 = function (i) {
            var val = this_1.xSet[i];
            var d0 = 0;
            var total = 0;
            for (var _i = 0, _a = this_1.results; _i < _a.length; _i++) {
                var group = _a[_i];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    total += d.value;
                }
            }
            for (var _b = 0, _c = this_1.results; _b < _c.length; _b++) {
                var group = _c[_b];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    d.d0 = d0;
                    d.d1 = d0 + d.value;
                    d0 += d.value;
                }
                else {
                    d = {
                        name: val,
                        value: 0,
                        d0: d0,
                        d1: d0
                    };
                    group.series.push(d);
                }
                if (total > 0) {
                    d.d0 = (d.d0 * 100) / total;
                    d.d1 = (d.d1 * 100) / total;
                }
                else {
                    d.d0 = 0;
                    d.d1 = 0;
                }
            }
        };
        var this_1 = this;
        for (var i = 0; i < this.xSet.length; i++) {
            _loop_1(i);
        }
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    AreaChartNormalizedComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    AreaChartNormalizedComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'time') {
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    AreaChartNormalizedComponent.prototype.getYDomain = function () {
        return [0, 100];
    };
    AreaChartNormalizedComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    AreaChartNormalizedComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime();
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear();
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint().padding(0.1);
        }
        scale.range([0, width]).domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartNormalizedComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartNormalizedComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    AreaChartNormalizedComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    AreaChartNormalizedComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    AreaChartNormalizedComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    AreaChartNormalizedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    AreaChartNormalizedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    AreaChartNormalizedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    AreaChartNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    AreaChartNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    AreaChartNormalizedComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartNormalizedComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartNormalizedComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartNormalizedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartNormalizedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartNormalizedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartNormalizedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartNormalizedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartNormalizedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartNormalizedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartNormalizedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartNormalizedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartNormalizedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AreaChartNormalizedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AreaChartNormalizedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AreaChartNormalizedComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], AreaChartNormalizedComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AreaChartNormalizedComponent.prototype, "hideCircles", null);
AreaChartNormalizedComponent.ɵfac = function AreaChartNormalizedComponent_Factory(t) { return ɵAreaChartNormalizedComponent_BaseFactory(t || AreaChartNormalizedComponent); };
AreaChartNormalizedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaChartNormalizedComponent, selectors: [["ngx-charts-area-chart-normalized"]], contentQueries: function AreaChartNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartNormalizedComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartNormalizedComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", "normalized", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "activeEntries", "gradient", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "showPercentage", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", "type", "stacked", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", "normalized", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartNormalizedComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartNormalizedComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartNormalizedComponent__svg_g_8_Template, 2, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartNormalizedComponent__svg_g_9_Template, 3, 10, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartNormalizedComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, AreaSeriesComponent, TooltipArea, CircleSeriesComponent, Timeline]; }, styles: [_c24], encapsulation: 2, changeDetection: 0 });
var ɵAreaChartNormalizedComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(AreaChartNormalizedComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaChartNormalizedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-area-chart-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [scaleType]=\"scaleType\"\n              [activeEntries]=\"activeEntries\"\n              [gradient]=\"gradient\"\n              normalized=\"true\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [showPercentage]=\"true\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                type=\"stacked\"\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            normalized=\"true\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return AreaChartNormalizedComponent;
}(BaseChartComponent));

var AreaChartStackedComponent = /** @class */ (function (_super) {
    __extends(AreaChartStackedComponent, _super);
    function AreaChartStackedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    AreaChartStackedComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        var _loop_1 = function (i) {
            var val = this_1.xSet[i];
            var d0 = 0;
            for (var _i = 0, _a = this_1.results; _i < _a.length; _i++) {
                var group = _a[_i];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    d.d0 = d0;
                    d.d1 = d0 + d.value;
                    d0 += d.value;
                }
                else {
                    d = {
                        name: val,
                        value: 0,
                        d0: d0,
                        d1: d0
                    };
                    group.series.push(d);
                }
            }
        };
        var this_1 = this;
        for (var i = 0; i < this.xSet.length; i++) {
            _loop_1(i);
        }
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    AreaChartStackedComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    AreaChartStackedComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
        }
        var min$$1;
        var max$$1;
        if (this.scaleType === 'time' || this.scaleType === 'linear') {
            min$$1 = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, values);
            max$$1 = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, values);
        }
        if (this.scaleType === 'time') {
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    AreaChartStackedComponent.prototype.getYDomain = function () {
        var _this = this;
        var domain = [];
        var _loop_2 = function (i) {
            var val = this_2.xSet[i];
            var sum = 0;
            for (var _i = 0, _a = this_2.results; _i < _a.length; _i++) {
                var group = _a[_i];
                var d = group.series.find(function (item) {
                    var a = item.name;
                    var b = val;
                    if (_this.scaleType === 'time') {
                        a = a.valueOf();
                        b = b.valueOf();
                    }
                    return a === b;
                });
                if (d) {
                    sum += d.value;
                }
            }
            domain.push(sum);
        };
        var this_2 = this;
        for (var i = 0; i < this.xSet.length; i++) {
            _loop_2(i);
        }
        var min$$1 = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, domain);
        return [min$$1, max$$1];
    };
    AreaChartStackedComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    AreaChartStackedComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime();
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear();
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint().padding(0.1);
        }
        scale.range([0, width]).domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartStackedComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    AreaChartStackedComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    AreaChartStackedComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    AreaChartStackedComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    AreaChartStackedComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    AreaChartStackedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    AreaChartStackedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    AreaChartStackedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    AreaChartStackedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    AreaChartStackedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    AreaChartStackedComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartStackedComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    AreaChartStackedComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartStackedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartStackedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartStackedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AreaChartStackedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartStackedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaChartStackedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaChartStackedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaChartStackedComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], AreaChartStackedComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AreaChartStackedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AreaChartStackedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AreaChartStackedComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], AreaChartStackedComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], AreaChartStackedComponent.prototype, "hideCircles", null);
AreaChartStackedComponent.ɵfac = function AreaChartStackedComponent_Factory(t) { return ɵAreaChartStackedComponent_BaseFactory(t || AreaChartStackedComponent); };
AreaChartStackedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaChartStackedComponent, selectors: [["ngx-charts-area-chart-stacked"]], contentQueries: function AreaChartStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function AreaChartStackedComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function AreaChartStackedComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-area-series", "", "stacked", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "activeEntries", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], ["ngx-charts-circle-series", "", "type", "stacked", 3, "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange"], ["ngx-charts-area-series", "", "stacked", "true", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "curve", "animations"]], template: function AreaChartStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, AreaChartStackedComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, AreaChartStackedComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, AreaChartStackedComponent__svg_g_8_Template, 2, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(9, AreaChartStackedComponent__svg_g_9_Template, 3, 10, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, AreaChartStackedComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, AreaSeriesComponent, TooltipArea, CircleSeriesComponent, Timeline]; }, styles: [_c24], encapsulation: 2, changeDetection: 0 });
var ɵAreaChartStackedComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(AreaChartStackedComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaChartStackedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-area-chart-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"area-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n            <svg:g\n              ngx-charts-area-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [scaleType]=\"scaleType\"\n              [gradient]=\"gradient\"\n              [activeEntries]=\"activeEntries\"\n              stacked=\"true\"\n              [curve]=\"curve\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n              <svg:g\n                ngx-charts-circle-series\n                type=\"stacked\"\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [activeEntries]=\"activeEntries\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event, series)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [legend]=\"legend\"\n        [scaleType]=\"scaleType\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-area-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [gradient]=\"gradient\"\n            stacked=\"true\"\n            [curve]=\"curve\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return AreaChartStackedComponent;
}(BaseChartComponent));

var AreaSeriesComponent = /** @class */ (function () {
    function AreaSeriesComponent() {
        this.baseValue = 'auto';
        this.stacked = false;
        this.normalized = false;
        this.animations = true;
        this.select = new EventEmitter();
    }
    AreaSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    AreaSeriesComponent.prototype.update = function () {
        var _this = this;
        this.updateGradient();
        var currentArea;
        var startingArea;
        var xProperty = function (d) {
            var label = d.name;
            return _this.xScale(label);
        };
        if (this.stacked || this.normalized) {
            currentArea = area()
                .x(xProperty)
                .y0(function (d, i) { return _this.yScale(d.d0); })
                .y1(function (d, i) { return _this.yScale(d.d1); });
            startingArea = area()
                .x(xProperty)
                .y0(function (d) { return _this.yScale.range()[0]; })
                .y1(function (d) { return _this.yScale.range()[0]; });
        }
        else {
            currentArea = area()
                .x(xProperty)
                .y0(function () { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); })
                .y1(function (d) { return _this.yScale(d.value); });
            startingArea = area()
                .x(xProperty)
                .y0(function (d) { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); })
                .y1(function (d) { return _this.baseValue === 'auto' ? _this.yScale.range()[0] : _this.yScale(_this.baseValue); });
        }
        currentArea.curve(this.curve);
        startingArea.curve(this.curve);
        this.opacity = .8;
        var data = this.data.series;
        if (this.scaleType === 'linear') {
            data = sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            data = sortByTime(data, 'name');
        }
        else {
            data = sortByDomain(data, 'name', 'asc', this.xScale.domain());
        }
        this.path = currentArea(data);
        this.startingPath = startingArea(data);
    };
    AreaSeriesComponent.prototype.updateGradient = function () {
        if (this.colors.scaleType === 'linear') {
            this.hasGradient = true;
            if (this.stacked || this.normalized) {
                var d0values = this.data.series.map(function (d) { return d.d0; });
                var d1values = this.data.series.map(function (d) { return d.d1; });
                var max$$1 = Math.max.apply(Math, d1values);
                var min$$1 = Math.min.apply(Math, d0values);
                this.gradientStops = this.colors.getLinearGradientStops(max$$1, min$$1);
            }
            else {
                var values = this.data.series.map(function (d) { return d.value; });
                var max$$1 = Math.max.apply(Math, values);
                this.gradientStops = this.colors.getLinearGradientStops(max$$1);
            }
        }
        else {
            this.hasGradient = false;
            this.gradientStops = undefined;
        }
    };
    AreaSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    AreaSeriesComponent.prototype.isInactive = function (entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item === undefined;
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "baseValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaSeriesComponent.prototype, "stacked", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaSeriesComponent.prototype, "normalized", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AreaSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AreaSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], AreaSeriesComponent.prototype, "select", void 0);
AreaSeriesComponent.ɵfac = function AreaSeriesComponent_Factory(t) { return new (t || AreaSeriesComponent)(); };
AreaSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AreaSeriesComponent, selectors: [["g", "ngx-charts-area-series", ""]], inputs: { baseValue: "baseValue", stacked: "stacked", normalized: "normalized", animations: "animations", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", gradient: "gradient", curve: "curve", activeEntries: "activeEntries" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c25, decls: 1, vars: 12, consts: [["ngx-charts-area", "", 1, "area-series", 3, "data", "path", "fill", "stops", "startingPath", "opacity", "gradient", "animations"]], template: function AreaSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.path)("fill", ctx.colors.getColor(ctx.data.name))("stops", ctx.gradientStops)("startingPath", ctx.startingPath)("opacity", ctx.opacity)("gradient", ctx.gradient || ctx.hasGradient)("animations", ctx.animations);
    } }, directives: [AreaComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-area-series]',
                template: "\n    <svg:g ngx-charts-area\n      class=\"area-series\"\n      [data]=\"data\"\n      [path]=\"path\"\n      [fill]=\"colors.getColor(data.name)\"\n      [stops]=\"gradientStops\"\n      [startingPath]=\"startingPath\"\n      [opacity]=\"opacity\"\n      [gradient]=\"gradient || hasGradient\"\n      [animations]=\"animations\"\n      [class.active]=\"isActive(data)\"\n      [class.inactive]=\"isInactive(data)\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { baseValue: [{
            type: Input
        }], stacked: [{
            type: Input
        }], normalized: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], gradient: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }] }); })();
    return AreaSeriesComponent;
}());

var AreaChartModule = /** @class */ (function () {
    function AreaChartModule() {
    }
AreaChartModule.ɵfac = function AreaChartModule_Factory(t) { return new (t || AreaChartModule)(); };
AreaChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AreaChartModule });
AreaChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AreaChartModule, { declarations: [AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent], imports: [ChartCommonModule], exports: [AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    AreaChartComponent,
                    AreaChartNormalizedComponent,
                    AreaChartStackedComponent,
                    AreaSeriesComponent
                ],
                exports: [
                    AreaChartComponent,
                    AreaChartNormalizedComponent,
                    AreaChartStackedComponent,
                    AreaSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return AreaChartModule;
}());

var BarComponent = /** @class */ (function () {
    function BarComponent(element) {
        this.roundEdges = true;
        this.gradient = false;
        this.offset = 0;
        this.isActive = false;
        this.animations = true;
        this.noBarWhenZero = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.initialized = false;
        this.hasGradient = false;
        this.hideBar = false;
        this.element = element.nativeElement;
    }
    BarComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            this.loadAnimation();
            this.initialized = true;
        }
        else {
            this.update();
        }
    };
    BarComponent.prototype.update = function () {
        this.gradientId = 'grad' + id().toString();
        this.gradientFill = "url(#" + this.gradientId + ")";
        if (this.gradient || this.stops) {
            this.gradientStops = this.getGradient();
            this.hasGradient = true;
        }
        else {
            this.hasGradient = false;
        }
        this.updatePathEl();
        this.checkToHideBar();
    };
    BarComponent.prototype.loadAnimation = function () {
        this.path = this.getStartingPath();
        setTimeout(this.update.bind(this), 100);
    };
    BarComponent.prototype.updatePathEl = function () {
        var node = select(this.element).select('.bar');
        var path = this.getPath();
        if (this.animations) {
            node
                .transition()
                .duration(500)
                .attr('d', path);
        }
        else {
            node.attr('d', path);
        }
    };
    BarComponent.prototype.getGradient = function () {
        if (this.stops) {
            return this.stops;
        }
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: this.getStartOpacity()
            },
            {
                offset: 100,
                color: this.fill,
                opacity: 1
            }
        ];
    };
    BarComponent.prototype.getStartingPath = function () {
        if (!this.animations) {
            return this.getPath();
        }
        var radius = this.getRadius();
        var path;
        if (this.roundEdges) {
            if (this.orientation === 'vertical') {
                radius = Math.min(this.height, radius);
                path = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
            }
            else if (this.orientation === 'horizontal') {
                radius = Math.min(this.width, radius);
                path = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
            }
        }
        else {
            if (this.orientation === 'vertical') {
                path = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
            }
            else if (this.orientation === 'horizontal') {
                path = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
            }
        }
        return path;
    };
    BarComponent.prototype.getPath = function () {
        var radius = this.getRadius();
        var path;
        if (this.roundEdges) {
            if (this.orientation === 'vertical') {
                radius = Math.min(this.height, radius);
                path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
            }
            else if (this.orientation === 'horizontal') {
                radius = Math.min(this.width, radius);
                path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
            }
        }
        else {
            path = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
        }
        return path;
    };
    BarComponent.prototype.getRadius = function () {
        var radius = 0;
        if (this.roundEdges && this.height > 5 && this.width > 5) {
            radius = Math.floor(Math.min(5, this.height / 2, this.width / 2));
        }
        return radius;
    };
    BarComponent.prototype.getStartOpacity = function () {
        if (this.roundEdges) {
            return 0.2;
        }
        else {
            return 0.5;
        }
    };
    Object.defineProperty(BarComponent.prototype, "edges", {
        get: function () {
            var edges = [false, false, false, false];
            if (this.roundEdges) {
                if (this.orientation === 'vertical') {
                    if (this.data.value > 0) {
                        edges = [true, true, false, false];
                    }
                    else {
                        edges = [false, false, true, true];
                    }
                }
                else if (this.orientation === 'horizontal') {
                    if (this.data.value > 0) {
                        edges = [false, true, false, true];
                    }
                    else {
                        edges = [true, false, true, false];
                    }
                }
            }
            return edges;
        },
        enumerable: true,
        configurable: true
    });
    BarComponent.prototype.onMouseEnter = function () {
        this.activate.emit(this.data);
    };
    BarComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit(this.data);
    };
    BarComponent.prototype.checkToHideBar = function () {
        this.hideBar =
            this.noBarWhenZero &&
                ((this.orientation === 'vertical' && this.height === 0) ||
                    (this.orientation === 'horizontal' && this.width === 0));
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "orientation", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "offset", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "isActive", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarComponent.prototype, "stops", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarComponent.prototype, "ariaLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BarComponent.prototype, "deactivate", void 0);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], BarComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], BarComponent.prototype, "onMouseLeave", null);
    BarComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], BarComponent);
BarComponent.ɵfac = function BarComponent_Factory(t) { return new (t || BarComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
BarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarComponent, selectors: [["g", "ngx-charts-bar", ""]], hostBindings: function BarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function BarComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function BarComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { roundEdges: "roundEdges", gradient: "gradient", offset: "offset", isActive: "isActive", animations: "animations", noBarWhenZero: "noBarWhenZero", fill: "fill", data: "data", width: "width", height: "height", x: "x", y: "y", orientation: "orientation", stops: "stops", ariaLabel: "ariaLabel" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c26, decls: 2, vars: 8, consts: [[4, "ngIf"], ["stroke", "none", "role", "img", "tabIndex", "-1", 1, "bar", 3, "click"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"]], template: function BarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BarComponent__svg_defs_0_Template, 2, 3, "defs", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "path", 1);
        ɵngcc0.ɵɵlistener("click", function BarComponent_Template__svg_path_click_1_listener() { return ctx.select.emit(ctx.data); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive)("hidden", ctx.hideBar);
        ɵngcc0.ɵɵattribute("d", ctx.path)("aria-label", ctx.ariaLabel)("fill", ctx.hasGradient ? ctx.gradientFill : ctx.fill);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bar]',
                template: "\n    <svg:defs *ngIf=\"hasGradient\">\n      <svg:g ngx-charts-svg-linear-gradient [orientation]=\"orientation\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n    </svg:defs>\n    <svg:path\n      class=\"bar\"\n      stroke=\"none\"\n      role=\"img\"\n      tabIndex=\"-1\"\n      [class.active]=\"isActive\"\n      [class.hidden]=\"hideBar\"\n      [attr.d]=\"path\"\n      [attr.aria-label]=\"ariaLabel\"\n      [attr.fill]=\"hasGradient ? gradientFill : fill\"\n      (click)=\"select.emit(data)\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { roundEdges: [{
            type: Input
        }], gradient: [{
            type: Input
        }], offset: [{
            type: Input
        }], isActive: [{
            type: Input
        }], animations: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], fill: [{
            type: Input
        }], data: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], orientation: [{
            type: Input
        }], stops: [{
            type: Input
        }], ariaLabel: [{
            type: Input
        }] }); })();
    return BarComponent;
}());

var BarHorizontalComponent = /** @class */ (function (_super) {
    __extends(BarHorizontalComponent, _super);
    function BarHorizontalComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        return _this;
    }
    BarHorizontalComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        }
        this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontalComponent.prototype.getXScale = function () {
        this.xDomain = this.getXDomain();
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.xDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontalComponent.prototype.getYScale = function () {
        this.yDomain = this.getYDomain();
        var spacing = this.yDomain.length / (this.dims.height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .domain(this.yDomain);
    };
    BarHorizontalComponent.prototype.getXDomain = function () {
        var values = this.results.map(function (d) { return d.value; });
        var min$$1 = this.xScaleMin ? Math.min.apply(Math, [this.xScaleMin].concat(values)) : Math.min.apply(Math, [0].concat(values));
        var max$$1 = this.xScaleMax ? Math.max.apply(Math, [this.xScaleMax].concat(values)) : Math.max.apply(Math, [0].concat(values));
        return [min$$1, max$$1];
    };
    BarHorizontalComponent.prototype.getYDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    BarHorizontalComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    BarHorizontalComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.yDomain;
        }
        else {
            domain = this.xDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontalComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.yDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.xDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontalComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontalComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontalComponent.prototype.onDataLabelMaxWidthChanged = function (event$$1) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event$$1.size.width);
        }
        else {
            this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event$$1.size.width);
        }
        if (event$$1.index === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarHorizontalComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontalComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontalComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontalComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontalComponent.prototype, "tooltipTemplate", void 0);
BarHorizontalComponent.ɵfac = function BarHorizontalComponent_Factory(t) { return ɵBarHorizontalComponent_BaseFactory(t || BarHorizontalComponent); };
BarHorizontalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalComponent, selectors: [["ngx-charts-bar-horizontal"]], contentQueries: function BarHorizontalComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", xScaleMax: "xScaleMax", xScaleMin: "xScaleMin", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 25, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-horizontal", "", 3, "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "activeEntries", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"]], template: function BarHorizontalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(4, "g", 4);
        ɵngcc0.ɵɵlistener("select", function BarHorizontalComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("activate", function BarHorizontalComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function BarHorizontalComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); })("dataLabelWidthChanged", function BarHorizontalComponent_Template__svg_g_dataLabelWidthChanged_4_listener($event) { return ctx.onDataLabelMaxWidthChanged($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(22, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("noBarWhenZero", ctx.noBarWhenZero);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, SeriesHorizontal, XAxisComponent, YAxisComponent]; }, styles: [_c24], encapsulation: 2, changeDetection: 0 });
var ɵBarHorizontalComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarHorizontalComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-horizontal\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [series]=\"results\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [activeEntries]=\"activeEntries\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n          (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event)\"\n        ></svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontalComponent;
}(BaseChartComponent));

var BarHorizontal2DComponent = /** @class */ (function (_super) {
    __extends(BarHorizontal2DComponent, _super);
    function BarHorizontal2DComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.groupPadding = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        return _this;
    }
    BarHorizontal2DComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        }
        this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valuesDomain = this.getValueDomain();
        this.groupScale = this.getGroupScale();
        this.innerScale = this.getInnerScale();
        this.valueScale = this.getValueScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontal2DComponent.prototype.getGroupScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .paddingOuter(spacing / 2)
            .domain(this.groupDomain);
    };
    BarHorizontal2DComponent.prototype.getInnerScale = function () {
        var height = this.groupScale.bandwidth();
        var spacing = this.innerDomain.length / (height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, height])
            .paddingInner(spacing)
            .domain(this.innerDomain);
    };
    BarHorizontal2DComponent.prototype.getValueScale = function () {
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valuesDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontal2DComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarHorizontal2DComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarHorizontal2DComponent.prototype.getValueDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.xScaleMax ? Math.max.apply(Math, [this.xScaleMax].concat(domain)) : Math.max.apply(Math, [0].concat(domain));
        return [min$$1, max$$1];
    };
    BarHorizontal2DComponent.prototype.groupTransform = function (group) {
        return "translate(0, " + this.groupScale(group.label) + ")";
    };
    BarHorizontal2DComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarHorizontal2DComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarHorizontal2DComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valuesDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontal2DComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valuesDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontal2DComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontal2DComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontal2DComponent.prototype.onDataLabelMaxWidthChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event$$1.size.width);
        }
        else {
            this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event$$1.size.width);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarHorizontal2DComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontal2DComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontal2DComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontal2DComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontal2DComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontal2DComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontal2DComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontal2DComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontal2DComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontal2DComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "groupPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontal2DComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontal2DComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontal2DComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontal2DComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontal2DComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontal2DComponent.prototype, "tooltipTemplate", void 0);
BarHorizontal2DComponent.ɵfac = function BarHorizontal2DComponent_Factory(t) { return ɵBarHorizontal2DComponent_BaseFactory(t || BarHorizontal2DComponent); };
BarHorizontal2DComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontal2DComponent, selectors: [["ngx-charts-bar-horizontal-2d"]], contentQueries: function BarHorizontal2DComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", groupPadding: "groupPadding", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", xScaleMax: "xScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 17, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", "orient", "horizontal", 3, "xScale", "yScale", "data", "dims"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", 3, "xScale", "activeEntries", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"]], template: function BarHorizontal2DComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontal2DComponent__svg_g_3_Template, 1, 10, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontal2DComponent__svg_g_4_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(5, BarHorizontal2DComponent__svg_g_5_Template, 2, 17, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(14, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.valueScale)("yScale", ctx.groupScale)("data", ctx.results)("dims", ctx.dims);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, GridPanelSeriesComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesHorizontal]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarHorizontal2DComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(BarHorizontal2DComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarHorizontal2DComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-2d',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-grid-panel-series\n          [xScale]=\"valueScale\"\n          [yScale]=\"groupScale\"\n          [data]=\"results\"\n          [dims]=\"dims\"\n          orient=\"horizontal\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"valueScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"groupScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            [xScale]=\"valueScale\"\n            [activeEntries]=\"activeEntries\"\n            [yScale]=\"innerScale\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [roundEdges]=\"roundEdges\"\n            [animations]=\"animations\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], groupPadding: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontal2DComponent;
}(BaseChartComponent));

var BarHorizontalNormalizedComponent = /** @class */ (function (_super) {
    __extends(BarHorizontalNormalizedComponent, _super);
    function BarHorizontalNormalizedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        return _this;
    }
    BarHorizontalNormalizedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontalNormalizedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarHorizontalNormalizedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarHorizontalNormalizedComponent.prototype.getValueDomain = function () {
        return [0, 100];
    };
    BarHorizontalNormalizedComponent.prototype.getYScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarHorizontalNormalizedComponent.prototype.getXScale = function () {
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontalNormalizedComponent.prototype.groupTransform = function (group) {
        return "translate(0, " + this.yScale(group.name) + ")";
    };
    BarHorizontalNormalizedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarHorizontalNormalizedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarHorizontalNormalizedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontalNormalizedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontalNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontalNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontalNormalizedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontalNormalizedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalNormalizedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalNormalizedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalNormalizedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalNormalizedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalNormalizedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalNormalizedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalNormalizedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalNormalizedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalNormalizedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalNormalizedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontalNormalizedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontalNormalizedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontalNormalizedComponent.prototype, "tooltipTemplate", void 0);
BarHorizontalNormalizedComponent.ɵfac = function BarHorizontalNormalizedComponent_Factory(t) { return ɵBarHorizontalNormalizedComponent_BaseFactory(t || BarHorizontalNormalizedComponent); };
BarHorizontalNormalizedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalNormalizedComponent, selectors: [["ngx-charts-bar-horizontal-normalized"]], contentQueries: function BarHorizontalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", "type", "normalized", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate"]], template: function BarHorizontalNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalNormalizedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalNormalizedComponent__svg_g_3_Template, 1, 8, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontalNormalizedComponent__svg_g_4_Template, 2, 14, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesHorizontal]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarHorizontalNormalizedComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalNormalizedComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarHorizontalNormalizedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            type=\"normalized\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontalNormalizedComponent;
}(BaseChartComponent));

var BarHorizontalStackedComponent = /** @class */ (function (_super) {
    __extends(BarHorizontalStackedComponent, _super);
    function BarHorizontalStackedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        return _this;
    }
    BarHorizontalStackedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxWidth = { negative: 0, positive: 0 };
        }
        this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarHorizontalStackedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarHorizontalStackedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarHorizontalStackedComponent.prototype.getValueDomain = function () {
        var domain = [];
        var smallest = 0;
        var biggest = 0;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            var smallestSum = 0;
            var biggestSum = 0;
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (d.value < 0) {
                    smallestSum += d.value;
                }
                else {
                    biggestSum += d.value;
                }
                smallest = d.value < smallest ? d.value : smallest;
                biggest = d.value > biggest ? d.value : biggest;
            }
            domain.push(smallestSum);
            domain.push(biggestSum);
        }
        domain.push(smallest);
        domain.push(biggest);
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.xScaleMax ? Math.max.apply(Math, [this.xScaleMax].concat(domain)) : Math.max.apply(Math, domain);
        return [min$$1, max$$1];
    };
    BarHorizontalStackedComponent.prototype.getYScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.height])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarHorizontalStackedComponent.prototype.getXScale = function () {
        var scale = scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarHorizontalStackedComponent.prototype.groupTransform = function (group) {
        return "translate(0, " + this.yScale(group.name) + ")";
    };
    BarHorizontalStackedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarHorizontalStackedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarHorizontalStackedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarHorizontalStackedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarHorizontalStackedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarHorizontalStackedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarHorizontalStackedComponent.prototype.onDataLabelMaxWidthChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event$$1.size.width);
        }
        else {
            this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event$$1.size.width);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarHorizontalStackedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarHorizontalStackedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalStackedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalStackedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalStackedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarHorizontalStackedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalStackedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalStackedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalStackedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarHorizontalStackedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarHorizontalStackedComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarHorizontalStackedComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarHorizontalStackedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarHorizontalStackedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarHorizontalStackedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarHorizontalStackedComponent.prototype, "tooltipTemplate", void 0);
BarHorizontalStackedComponent.ɵfac = function BarHorizontalStackedComponent_Factory(t) { return ɵBarHorizontalStackedComponent_BaseFactory(t || BarHorizontalStackedComponent); };
BarHorizontalStackedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarHorizontalStackedComponent, selectors: [["ngx-charts-bar-horizontal-stacked"]], contentQueries: function BarHorizontalStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", xScaleMax: "xScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "dimensionsChanged"], ["ngx-charts-series-horizontal", "", "type", "stacked", 3, "xScale", "yScale", "colors", "series", "activeEntries", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelWidthChanged"]], template: function BarHorizontalStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarHorizontalStackedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarHorizontalStackedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarHorizontalStackedComponent__svg_g_4_Template, 2, 16, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesHorizontal]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarHorizontalStackedComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(BarHorizontalStackedComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarHorizontalStackedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-horizontal-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [yAxisOffset]=\"dataLabelMaxWidth.negative\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-horizontal\n            type=\"stacked\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [activeEntries]=\"activeEntries\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelWidthChanged)=\"onDataLabelMaxWidthChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarHorizontalStackedComponent;
}(BaseChartComponent));

var BarVerticalComponent = /** @class */ (function (_super) {
    __extends(BarVerticalComponent, _super);
    function BarVerticalComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        return _this;
    }
    BarVerticalComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        }
        this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        if (this.showDataLabel) {
            this.dims.height -= this.dataLabelMaxHeight.negative;
        }
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
    };
    BarVerticalComponent.prototype.getXScale = function () {
        this.xDomain = this.getXDomain();
        var spacing = this.xDomain.length / (this.dims.width / this.barPadding + 1);
        return scaleBand()
            .range([0, this.dims.width])
            .paddingInner(spacing)
            .domain(this.xDomain);
    };
    BarVerticalComponent.prototype.getYScale = function () {
        this.yDomain = this.getYDomain();
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.yDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVerticalComponent.prototype.getXDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    BarVerticalComponent.prototype.getYDomain = function () {
        var values = this.results.map(function (d) { return d.value; });
        var min$$1 = this.yScaleMin ? Math.min.apply(Math, [this.yScaleMin].concat(values)) : Math.min.apply(Math, [0].concat(values));
        if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
            min$$1 = Math.min.apply(Math, [min$$1].concat(this.yAxisTicks));
        }
        var max$$1 = this.yScaleMax ? Math.max.apply(Math, [this.yScaleMax].concat(values)) : Math.max.apply(Math, [0].concat(values));
        if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
            max$$1 = Math.max.apply(Math, [max$$1].concat(this.yAxisTicks));
        }
        return [min$$1, max$$1];
    };
    BarVerticalComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    BarVerticalComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.xDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVerticalComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.xDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVerticalComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVerticalComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVerticalComponent.prototype.onDataLabelMaxHeightChanged = function (event$$1) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event$$1.size.height);
        }
        else {
            this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event$$1.size.height);
        }
        if (event$$1.index === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarVerticalComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVerticalComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVerticalComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVerticalComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVerticalComponent.prototype, "tooltipTemplate", void 0);
BarVerticalComponent.ɵfac = function BarVerticalComponent_Factory(t) { return ɵBarVerticalComponent_BaseFactory(t || BarVerticalComponent); };
BarVerticalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVerticalComponent, selectors: [["ngx-charts-bar-vertical"]], contentQueries: function BarVerticalComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", yScaleMax: "yScaleMax", yScaleMin: "yScaleMin", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 25, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-vertical", "", 3, "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "activeEntries", "roundEdges", "animations", "noBarWhenZero", "activate", "deactivate", "select", "dataLabelHeightChanged"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"]], template: function BarVerticalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(4, "g", 4);
        ɵngcc0.ɵɵlistener("activate", function BarVerticalComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function BarVerticalComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); })("select", function BarVerticalComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("dataLabelHeightChanged", function BarVerticalComponent_Template__svg_g_dataLabelHeightChanged_4_listener($event) { return ctx.onDataLabelMaxHeightChanged($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(22, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("noBarWhenZero", ctx.noBarWhenZero);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, SeriesVerticalComponent, XAxisComponent, YAxisComponent]; }, styles: [_c24], encapsulation: 2, changeDetection: 0 });
var ɵBarVerticalComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(BarVerticalComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarVerticalComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-vertical\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [series]=\"results\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [activeEntries]=\"activeEntries\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n          (select)=\"onClick($event)\"\n          (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event)\"\n        ></svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVerticalComponent;
}(BaseChartComponent));

var BarVertical2DComponent = /** @class */ (function (_super) {
    __extends(BarVertical2DComponent, _super);
    function BarVertical2DComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.scaleType = 'ordinal';
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.groupPadding = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.roundEdges = true;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        return _this;
    }
    BarVertical2DComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        }
        this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.showDataLabel) {
            this.dims.height -= this.dataLabelMaxHeight.negative;
        }
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valuesDomain = this.getValueDomain();
        this.groupScale = this.getGroupScale();
        this.innerScale = this.getInnerScale();
        this.valueScale = this.getValueScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
    };
    BarVertical2DComponent.prototype.onDataLabelMaxHeightChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event$$1.size.height);
        }
        else {
            this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event$$1.size.height);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarVertical2DComponent.prototype.getGroupScale = function () {
        var spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .paddingInner(spacing)
            .paddingOuter(spacing / 2)
            .domain(this.groupDomain);
    };
    BarVertical2DComponent.prototype.getInnerScale = function () {
        var width = this.groupScale.bandwidth();
        var spacing = this.innerDomain.length / (width / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, width])
            .paddingInner(spacing)
            .domain(this.innerDomain);
    };
    BarVertical2DComponent.prototype.getValueScale = function () {
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.valuesDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVertical2DComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarVertical2DComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarVertical2DComponent.prototype.getValueDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.yScaleMax ? Math.max.apply(Math, [this.yScaleMax].concat(domain)) : Math.max.apply(Math, [0].concat(domain));
        return [min$$1, max$$1];
    };
    BarVertical2DComponent.prototype.groupTransform = function (group) {
        return "translate(" + this.groupScale(group.label) + ", 0)";
    };
    BarVertical2DComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarVertical2DComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarVertical2DComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valuesDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVertical2DComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valuesDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVertical2DComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVertical2DComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVertical2DComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVertical2DComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVertical2DComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVertical2DComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVertical2DComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVertical2DComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVertical2DComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVertical2DComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVertical2DComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVertical2DComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "groupPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVertical2DComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVertical2DComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVertical2DComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVertical2DComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVertical2DComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVertical2DComponent.prototype, "tooltipTemplate", void 0);
BarVertical2DComponent.ɵfac = function BarVertical2DComponent_Factory(t) { return ɵBarVertical2DComponent_BaseFactory(t || BarVertical2DComponent); };
BarVertical2DComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVertical2DComponent, selectors: [["ngx-charts-bar-vertical-2d"]], contentQueries: function BarVertical2DComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", scaleType: "scaleType", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", groupPadding: "groupPadding", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", yScaleMax: "yScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 17, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", "orient", "vertical", 3, "xScale", "yScale", "data", "dims"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-vertical", "", 3, "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", 3, "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged"]], template: function BarVertical2DComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVertical2DComponent__svg_g_3_Template, 1, 10, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVertical2DComponent__svg_g_4_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(5, BarVertical2DComponent__svg_g_5_Template, 1, 17, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(14, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.groupScale)("yScale", ctx.valueScale)("data", ctx.results)("dims", ctx.dims);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, GridPanelSeriesComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesVerticalComponent]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarVertical2DComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(BarVertical2DComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarVertical2DComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-2d',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-grid-panel-series\n          [xScale]=\"groupScale\"\n          [yScale]=\"valueScale\"\n          [data]=\"results\"\n          [dims]=\"dims\"\n          orient=\"vertical\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"groupScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"valueScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-series-vertical\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n          [activeEntries]=\"activeEntries\"\n          [xScale]=\"innerScale\"\n          [yScale]=\"valueScale\"\n          [colors]=\"colors\"\n          [series]=\"group.series\"\n          [dims]=\"dims\"\n          [gradient]=\"gradient\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [showDataLabel]=\"showDataLabel\"\n          [dataLabelFormatting]=\"dataLabelFormatting\"\n          [seriesName]=\"group.name\"\n          [roundEdges]=\"roundEdges\"\n          [animations]=\"animations\"\n          [noBarWhenZero]=\"noBarWhenZero\"\n          (select)=\"onClick($event, group)\"\n          (activate)=\"onActivate($event, group)\"\n          (deactivate)=\"onDeactivate($event, group)\"\n          (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], groupPadding: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVertical2DComponent;
}(BaseChartComponent));

var BarVerticalNormalizedComponent = /** @class */ (function (_super) {
    __extends(BarVerticalNormalizedComponent, _super);
    function BarVerticalNormalizedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        return _this;
    }
    BarVerticalNormalizedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    BarVerticalNormalizedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarVerticalNormalizedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarVerticalNormalizedComponent.prototype.getValueDomain = function () {
        return [0, 100];
    };
    BarVerticalNormalizedComponent.prototype.getXScale = function () {
        var spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarVerticalNormalizedComponent.prototype.getYScale = function () {
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVerticalNormalizedComponent.prototype.groupTransform = function (group) {
        return "translate(" + this.xScale(group.name) + ", 0)";
    };
    BarVerticalNormalizedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarVerticalNormalizedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarVerticalNormalizedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVerticalNormalizedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVerticalNormalizedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVerticalNormalizedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVerticalNormalizedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVerticalNormalizedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalNormalizedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalNormalizedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalNormalizedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalNormalizedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalNormalizedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalNormalizedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalNormalizedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalNormalizedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalNormalizedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalNormalizedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVerticalNormalizedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVerticalNormalizedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVerticalNormalizedComponent.prototype, "tooltipTemplate", void 0);
BarVerticalNormalizedComponent.ɵfac = function BarVerticalNormalizedComponent_Factory(t) { return ɵBarVerticalNormalizedComponent_BaseFactory(t || BarVerticalNormalizedComponent); };
BarVerticalNormalizedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVerticalNormalizedComponent, selectors: [["ngx-charts-bar-vertical-normalized"]], contentQueries: function BarVerticalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", "type", "normalized", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate"]], template: function BarVerticalNormalizedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalNormalizedComponent__svg_g_2_Template, 1, 9, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalNormalizedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVerticalNormalizedComponent__svg_g_4_Template, 2, 14, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesVerticalComponent]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarVerticalNormalizedComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(BarVerticalNormalizedComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarVerticalNormalizedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-normalized',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-vertical\n            type=\"normalized\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVerticalNormalizedComponent;
}(BaseChartComponent));

var BarVerticalStackedComponent = /** @class */ (function (_super) {
    __extends(BarVerticalStackedComponent, _super);
    function BarVerticalStackedComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.tooltipDisabled = false;
        _this.showGridLines = true;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.barPadding = 8;
        _this.roundDomains = false;
        _this.showDataLabel = false;
        _this.noBarWhenZero = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        return _this;
    }
    BarVerticalStackedComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        if (!this.showDataLabel) {
            this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        }
        this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.showDataLabel) {
            this.dims.height -= this.dataLabelMaxHeight.negative;
        }
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
    };
    BarVerticalStackedComponent.prototype.getGroupDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.label)) {
                domain.push(group.label);
            }
        }
        return domain;
    };
    BarVerticalStackedComponent.prototype.getInnerDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.label)) {
                    domain.push(d.label);
                }
            }
        }
        return domain;
    };
    BarVerticalStackedComponent.prototype.getValueDomain = function () {
        var domain = [];
        var smallest = 0;
        var biggest = 0;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            var smallestSum = 0;
            var biggestSum = 0;
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (d.value < 0) {
                    smallestSum += d.value;
                }
                else {
                    biggestSum += d.value;
                }
                smallest = d.value < smallest ? d.value : smallest;
                biggest = d.value > biggest ? d.value : biggest;
            }
            domain.push(smallestSum);
            domain.push(biggestSum);
        }
        domain.push(smallest);
        domain.push(biggest);
        var min$$1 = Math.min.apply(Math, [0].concat(domain));
        var max$$1 = this.yScaleMax ? Math.max.apply(Math, [this.yScaleMax].concat(domain)) : Math.max.apply(Math, domain);
        return [min$$1, max$$1];
    };
    BarVerticalStackedComponent.prototype.getXScale = function () {
        var spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .paddingInner(spacing)
            .domain(this.groupDomain);
    };
    BarVerticalStackedComponent.prototype.getYScale = function () {
        var scale = scaleLinear()
            .range([this.dims.height, 0])
            .domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BarVerticalStackedComponent.prototype.onDataLabelMaxHeightChanged = function (event$$1, groupIndex) {
        var _this = this;
        if (event$$1.size.negative) {
            this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event$$1.size.height);
        }
        else {
            this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event$$1.size.height);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(function () { return _this.update(); });
        }
    };
    BarVerticalStackedComponent.prototype.groupTransform = function (group) {
        return "translate(" + this.xScale(group.name) + ", 0)";
    };
    BarVerticalStackedComponent.prototype.onClick = function (data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    };
    BarVerticalStackedComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    BarVerticalStackedComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.innerDomain;
        }
        else {
            domain = this.valueDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    BarVerticalStackedComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BarVerticalStackedComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BarVerticalStackedComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BarVerticalStackedComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BarVerticalStackedComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalStackedComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalStackedComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalStackedComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BarVerticalStackedComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalStackedComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalStackedComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalStackedComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BarVerticalStackedComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "barPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BarVerticalStackedComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarVerticalStackedComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BarVerticalStackedComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarVerticalStackedComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BarVerticalStackedComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BarVerticalStackedComponent.prototype, "tooltipTemplate", void 0);
BarVerticalStackedComponent.ɵfac = function BarVerticalStackedComponent_Factory(t) { return ɵBarVerticalStackedComponent_BaseFactory(t || BarVerticalStackedComponent); };
BarVerticalStackedComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarVerticalStackedComponent, selectors: [["ngx-charts-bar-vertical-stacked"]], contentQueries: function BarVerticalStackedComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", schemeType: "schemeType", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", barPadding: "barPadding", roundDomains: "roundDomains", yScaleMax: "yScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", noBarWhenZero: "noBarWhenZero" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-series-vertical", "", "type", "stacked", 3, "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged"]], template: function BarVerticalStackedComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, undefined, true); })("legendLabelDeactivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, undefined, true); })("legendLabelClick", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, BarVerticalStackedComponent__svg_g_2_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, BarVerticalStackedComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, BarVerticalStackedComponent__svg_g_4_Template, 2, 16, "g", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, SeriesVerticalComponent]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1,
                        transform: '*'
                    }),
                    animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBarVerticalStackedComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(BarVerticalStackedComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarVerticalStackedComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bar-vertical-stacked',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, undefined, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, undefined, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          *ngFor=\"let group of results; let index = index; trackBy: trackBy\"\n          [@animationState]=\"'active'\"\n          [attr.transform]=\"groupTransform(group)\"\n        >\n          <svg:g\n            ngx-charts-series-vertical\n            type=\"stacked\"\n            [xScale]=\"xScale\"\n            [yScale]=\"yScale\"\n            [activeEntries]=\"activeEntries\"\n            [colors]=\"colors\"\n            [series]=\"group.series\"\n            [dims]=\"dims\"\n            [gradient]=\"gradient\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [showDataLabel]=\"showDataLabel\"\n            [dataLabelFormatting]=\"dataLabelFormatting\"\n            [seriesName]=\"group.name\"\n            [animations]=\"animations\"\n            [noBarWhenZero]=\"noBarWhenZero\"\n            (select)=\"onClick($event, group)\"\n            (activate)=\"onActivate($event, group)\"\n            (deactivate)=\"onDeactivate($event, group)\"\n            (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1,
                                transform: '*'
                            }),
                            animate(500, style({ opacity: 0, transform: 'scale(0)' }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], barPadding: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BarVerticalStackedComponent;
}(BaseChartComponent));

var D0Types;
(function (D0Types) {
    D0Types["positive"] = "positive";
    D0Types["negative"] = "negative";
})(D0Types || (D0Types = {}));
var SeriesVerticalComponent = /** @class */ (function () {
    function SeriesVerticalComponent() {
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.animations = true;
        this.showDataLabel = false;
        this.noBarWhenZero = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dataLabelHeightChanged = new EventEmitter();
        this.barsForDataLabels = [];
    }
    SeriesVerticalComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    SeriesVerticalComponent.prototype.update = function () {
        var _this = this;
        var _a;
        this.updateTooltipSettings();
        var width;
        if (this.series.length) {
            width = this.xScale.bandwidth();
        }
        width = Math.round(width);
        var yScaleMin = Math.max(this.yScale.domain()[0], 0);
        var d0 = (_a = {},
            _a[D0Types.positive] = 0,
            _a[D0Types.negative] = 0,
            _a);
        var d0Type = D0Types.positive;
        var total;
        if (this.type === 'normalized') {
            total = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
        }
        this.bars = this.series.map(function (d, index) {
            var value = d.value;
            var label = _this.getLabel(d);
            var formattedLabel = formatLabel(label);
            var roundEdges = _this.roundEdges;
            d0Type = value > 0 ? D0Types.positive : D0Types.negative;
            var bar = {
                value: value,
                label: label,
                roundEdges: roundEdges,
                data: d,
                width: width,
                formattedLabel: formattedLabel,
                height: 0,
                x: 0,
                y: 0
            };
            if (_this.type === 'standard') {
                bar.height = Math.abs(_this.yScale(value) - _this.yScale(yScaleMin));
                bar.x = _this.xScale(label);
                if (value < 0) {
                    bar.y = _this.yScale(0);
                }
                else {
                    bar.y = _this.yScale(value);
                }
            }
            else if (_this.type === 'stacked') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                bar.height = _this.yScale(offset0) - _this.yScale(offset1);
                bar.x = 0;
                bar.y = _this.yScale(offset1);
                bar.offset0 = offset0;
                bar.offset1 = offset1;
            }
            else if (_this.type === 'normalized') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                if (total > 0) {
                    offset0 = (offset0 * 100) / total;
                    offset1 = (offset1 * 100) / total;
                }
                else {
                    offset0 = 0;
                    offset1 = 0;
                }
                bar.height = _this.yScale(offset0) - _this.yScale(offset1);
                bar.x = 0;
                bar.y = _this.yScale(offset1);
                bar.offset0 = offset0;
                bar.offset1 = offset1;
                value = (offset1 - offset0).toFixed(2) + '%';
            }
            if (_this.colors.scaleType === 'ordinal') {
                bar.color = _this.colors.getColor(label);
            }
            else {
                if (_this.type === 'standard') {
                    bar.color = _this.colors.getColor(value);
                    bar.gradientStops = _this.colors.getLinearGradientStops(value);
                }
                else {
                    bar.color = _this.colors.getColor(bar.offset1);
                    bar.gradientStops = _this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
                }
            }
            var tooltipLabel = formattedLabel;
            bar.ariaLabel = formattedLabel + ' ' + value.toLocaleString();
            if (_this.seriesName) {
                tooltipLabel = _this.seriesName + " \u2022 " + formattedLabel;
                bar.data.series = _this.seriesName;
                bar.ariaLabel = _this.seriesName + ' ' + bar.ariaLabel;
            }
            bar.tooltipText = _this.tooltipDisabled
                ? undefined
                : "\n        <span class=\"tooltip-label\">" + tooltipLabel + "</span>\n        <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n      ";
            return bar;
        });
        this.updateDataLabels();
    };
    SeriesVerticalComponent.prototype.updateDataLabels = function () {
        var _this = this;
        if (this.type === 'stacked') {
            this.barsForDataLabels = [];
            var section = {};
            section.series = this.seriesName;
            var totalPositive = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d > 0 ? sum + d : sum); }, 0);
            var totalNegative = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d < 0 ? sum + d : sum); }, 0);
            section.total = totalPositive + totalNegative;
            section.x = 0;
            section.y = 0;
            if (section.total > 0) {
                section.height = this.yScale(totalPositive);
            }
            else {
                section.height = this.yScale(totalNegative);
            }
            section.width = this.xScale.bandwidth();
            this.barsForDataLabels.push(section);
        }
        else {
            this.barsForDataLabels = this.series.map(function (d) {
                var section = {};
                section.series = _this.seriesName ? _this.seriesName : d.label;
                section.total = d.value;
                section.x = _this.xScale(d.label);
                section.y = _this.yScale(0);
                section.height = _this.yScale(section.total) - _this.yScale(0);
                section.width = _this.xScale.bandwidth();
                return section;
            });
        }
    };
    SeriesVerticalComponent.prototype.updateTooltipSettings = function () {
        this.tooltipPlacement = this.tooltipDisabled ? undefined : 'top';
        this.tooltipType = this.tooltipDisabled ? undefined : 'tooltip';
    };
    SeriesVerticalComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    SeriesVerticalComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    SeriesVerticalComponent.prototype.getLabel = function (dataItem) {
        if (dataItem.label) {
            return dataItem.label;
        }
        return dataItem.name;
    };
    SeriesVerticalComponent.prototype.trackBy = function (index, bar) {
        return bar.label;
    };
    SeriesVerticalComponent.prototype.trackDataLabelBy = function (index, barLabel) {
        return index + '#' + barLabel.series + '#' + barLabel.total;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "series", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], SeriesVerticalComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SeriesVerticalComponent.prototype, "seriesName", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], SeriesVerticalComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesVerticalComponent.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesVerticalComponent.prototype, "dataLabelHeightChanged", void 0);
SeriesVerticalComponent.ɵfac = function SeriesVerticalComponent_Factory(t) { return new (t || SeriesVerticalComponent)(); };
SeriesVerticalComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesVerticalComponent, selectors: [["g", "ngx-charts-series-vertical", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", animations: "animations", showDataLabel: "showDataLabel", noBarWhenZero: "noBarWhenZero", dims: "dims", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", dataLabelFormatting: "dataLabelFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelHeightChanged: "dataLabelHeightChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c27, decls: 2, vars: 3, consts: [["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged"]], template: function SeriesVerticalComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SeriesVerticalComponent__svg_g_0_Template, 1, 22, "g", 0);
        ɵngcc0.ɵɵtemplate(1, SeriesVerticalComponent__svg_g_1_Template, 2, 2, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.bars)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showDataLabel);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, BarComponent, TooltipDirective, BarLabelComponent]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesVerticalComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-series-vertical]',
                template: "\n    <svg:g\n      ngx-charts-bar\n      *ngFor=\"let bar of bars; trackBy: trackBy\"\n      [@animationState]=\"'active'\"\n      [@.disabled]=\"!animations\"\n      [width]=\"bar.width\"\n      [height]=\"bar.height\"\n      [x]=\"bar.x\"\n      [y]=\"bar.y\"\n      [fill]=\"bar.color\"\n      [stops]=\"bar.gradientStops\"\n      [data]=\"bar.data\"\n      [orientation]=\"'vertical'\"\n      [roundEdges]=\"bar.roundEdges\"\n      [gradient]=\"gradient\"\n      [ariaLabel]=\"bar.ariaLabel\"\n      [isActive]=\"isActive(bar.data)\"\n      (select)=\"onClick($event)\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"tooltipPlacement\"\n      [tooltipType]=\"tooltipType\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"bar.data\"\n      [noBarWhenZero]=\"noBarWhenZero\"\n      [animations]=\"animations\"\n    ></svg:g>\n    <svg:g *ngIf=\"showDataLabel\">\n      <svg:g\n        ngx-charts-bar-label\n        *ngFor=\"let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy\"\n        [barX]=\"b.x\"\n        [barY]=\"b.y\"\n        [barWidth]=\"b.width\"\n        [barHeight]=\"b.height\"\n        [value]=\"b.total\"\n        [valueFormatting]=\"dataLabelFormatting\"\n        [orientation]=\"'vertical'\"\n        (dimensionsChanged)=\"dataLabelHeightChanged.emit({ size: $event, index: i })\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dataLabelHeightChanged: [{
            type: Output
        }], dims: [{
            type: Input
        }], series: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], gradient: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], seriesName: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }] }); })();
    return SeriesVerticalComponent;
}());

var SeriesHorizontal = /** @class */ (function () {
    function SeriesHorizontal() {
        this.barsForDataLabels = [];
        this.type = 'standard';
        this.tooltipDisabled = false;
        this.animations = true;
        this.showDataLabel = false;
        this.noBarWhenZero = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dataLabelWidthChanged = new EventEmitter();
    }
    SeriesHorizontal.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    SeriesHorizontal.prototype.update = function () {
        var _this = this;
        var _a;
        this.updateTooltipSettings();
        var d0 = (_a = {},
            _a[D0Types.positive] = 0,
            _a[D0Types.negative] = 0,
            _a);
        var d0Type;
        d0Type = D0Types.positive;
        var total;
        if (this.type === 'normalized') {
            total = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
        }
        var xScaleMin = Math.max(this.xScale.domain()[0], 0);
        this.bars = this.series.map(function (d, index) {
            var value = d.value;
            var label = _this.getLabel(d);
            var formattedLabel = formatLabel(label);
            var roundEdges = _this.roundEdges;
            d0Type = value > 0 ? D0Types.positive : D0Types.negative;
            var bar = {
                value: value,
                label: label,
                roundEdges: roundEdges,
                data: d,
                formattedLabel: formattedLabel
            };
            bar.height = _this.yScale.bandwidth();
            if (_this.type === 'standard') {
                bar.width = Math.abs(_this.xScale(value) - _this.xScale(xScaleMin));
                if (value < 0) {
                    bar.x = _this.xScale(value);
                }
                else {
                    bar.x = _this.xScale(xScaleMin);
                }
                bar.y = _this.yScale(label);
            }
            else if (_this.type === 'stacked') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                bar.width = _this.xScale(offset1) - _this.xScale(offset0);
                bar.x = _this.xScale(offset0);
                bar.y = 0;
                bar.offset0 = offset0;
                bar.offset1 = offset1;
            }
            else if (_this.type === 'normalized') {
                var offset0 = d0[d0Type];
                var offset1 = offset0 + value;
                d0[d0Type] += value;
                if (total > 0) {
                    offset0 = (offset0 * 100) / total;
                    offset1 = (offset1 * 100) / total;
                }
                else {
                    offset0 = 0;
                    offset1 = 0;
                }
                bar.width = _this.xScale(offset1) - _this.xScale(offset0);
                bar.x = _this.xScale(offset0);
                bar.y = 0;
                bar.offset0 = offset0;
                bar.offset1 = offset1;
                value = (offset1 - offset0).toFixed(2) + '%';
            }
            if (_this.colors.scaleType === 'ordinal') {
                bar.color = _this.colors.getColor(label);
            }
            else {
                if (_this.type === 'standard') {
                    bar.color = _this.colors.getColor(value);
                    bar.gradientStops = _this.colors.getLinearGradientStops(value);
                }
                else {
                    bar.color = _this.colors.getColor(bar.offset1);
                    bar.gradientStops = _this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
                }
            }
            var tooltipLabel = formattedLabel;
            bar.ariaLabel = formattedLabel + ' ' + value.toLocaleString();
            if (_this.seriesName) {
                tooltipLabel = _this.seriesName + " \u2022 " + formattedLabel;
                bar.data.series = _this.seriesName;
                bar.ariaLabel = _this.seriesName + ' ' + bar.ariaLabel;
            }
            bar.tooltipText = _this.tooltipDisabled
                ? undefined
                : "\n        <span class=\"tooltip-label\">" + tooltipLabel + "</span>\n        <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n      ";
            return bar;
        });
        this.updateDataLabels();
    };
    SeriesHorizontal.prototype.updateDataLabels = function () {
        var _this = this;
        if (this.type === 'stacked') {
            this.barsForDataLabels = [];
            var section = {};
            section.series = this.seriesName;
            var totalPositive = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d > 0 ? sum + d : sum); }, 0);
            var totalNegative = this.series.map(function (d) { return d.value; }).reduce(function (sum, d) { return (d < 0 ? sum + d : sum); }, 0);
            section.total = totalPositive + totalNegative;
            section.x = 0;
            section.y = 0;
            // if total is positive then we show it on the right, otherwise on the left
            if (section.total > 0) {
                section.width = this.xScale(totalPositive);
            }
            else {
                section.width = this.xScale(totalNegative);
            }
            section.height = this.yScale.bandwidth();
            this.barsForDataLabels.push(section);
        }
        else {
            this.barsForDataLabels = this.series.map(function (d) {
                var section = {};
                section.series = _this.seriesName ? _this.seriesName : d.label;
                section.total = d.value;
                section.x = _this.xScale(0);
                section.y = _this.yScale(d.label);
                section.width = _this.xScale(section.total) - _this.xScale(0);
                section.height = _this.yScale.bandwidth();
                return section;
            });
        }
    };
    SeriesHorizontal.prototype.updateTooltipSettings = function () {
        this.tooltipPlacement = this.tooltipDisabled ? undefined : 'top';
        this.tooltipType = this.tooltipDisabled ? undefined : 'tooltip';
    };
    SeriesHorizontal.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    SeriesHorizontal.prototype.getLabel = function (dataItem) {
        if (dataItem.label) {
            return dataItem.label;
        }
        return dataItem.name;
    };
    SeriesHorizontal.prototype.trackBy = function (index, bar) {
        return bar.label;
    };
    SeriesHorizontal.prototype.trackDataLabelBy = function (index, barLabel) {
        return index + '#' + barLabel.series + '#' + barLabel.total;
    };
    SeriesHorizontal.prototype.click = function (data) {
        this.select.emit(data);
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "series", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], SeriesHorizontal.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], SeriesHorizontal.prototype, "seriesName", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], SeriesHorizontal.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "roundEdges", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "showDataLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "dataLabelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], SeriesHorizontal.prototype, "noBarWhenZero", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], SeriesHorizontal.prototype, "dataLabelWidthChanged", void 0);
SeriesHorizontal.ɵfac = function SeriesHorizontal_Factory(t) { return new (t || SeriesHorizontal)(); };
SeriesHorizontal.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesHorizontal, selectors: [["g", "ngx-charts-series-horizontal", ""]], inputs: { type: "type", tooltipDisabled: "tooltipDisabled", animations: "animations", showDataLabel: "showDataLabel", noBarWhenZero: "noBarWhenZero", dims: "dims", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", dataLabelFormatting: "dataLabelFormatting" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelWidthChanged: "dataLabelWidthChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c28, decls: 2, vars: 3, consts: [["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged"]], template: function SeriesHorizontal_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, SeriesHorizontal__svg_g_0_Template, 1, 21, "g", 0);
        ɵngcc0.ɵɵtemplate(1, SeriesHorizontal__svg_g_1_Template, 2, 2, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.bars)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showDataLabel);
    } }, directives: function () { return [ɵngcc1.NgForOf, ɵngcc1.NgIf, BarComponent, TooltipDirective, BarLabelComponent]; }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({ opacity: 0 }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesHorizontal, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-series-horizontal]',
                template: "\n    <svg:g\n      ngx-charts-bar\n      *ngFor=\"let bar of bars; trackBy: trackBy\"\n      [@animationState]=\"'active'\"\n      [width]=\"bar.width\"\n      [height]=\"bar.height\"\n      [x]=\"bar.x\"\n      [y]=\"bar.y\"\n      [fill]=\"bar.color\"\n      [stops]=\"bar.gradientStops\"\n      [data]=\"bar.data\"\n      [orientation]=\"'horizontal'\"\n      [roundEdges]=\"bar.roundEdges\"\n      (select)=\"click($event)\"\n      [gradient]=\"gradient\"\n      [isActive]=\"isActive(bar.data)\"\n      [ariaLabel]=\"bar.ariaLabel\"\n      [animations]=\"animations\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"tooltipPlacement\"\n      [tooltipType]=\"tooltipType\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"bar.data\"\n      [noBarWhenZero]=\"noBarWhenZero\"\n    ></svg:g>\n    <svg:g *ngIf=\"showDataLabel\">\n      <svg:g\n        ngx-charts-bar-label\n        *ngFor=\"let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy\"\n        [barX]=\"b.x\"\n        [barY]=\"b.y\"\n        [barWidth]=\"b.width\"\n        [barHeight]=\"b.height\"\n        [value]=\"b.total\"\n        [valueFormatting]=\"dataLabelFormatting\"\n        [orientation]=\"'horizontal'\"\n        (dimensionsChanged)=\"dataLabelWidthChanged.emit({ size: $event, index: i })\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({ opacity: 0 }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { type: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], showDataLabel: [{
            type: Input
        }], noBarWhenZero: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dataLabelWidthChanged: [{
            type: Output
        }], dims: [{
            type: Input
        }], series: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], gradient: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], seriesName: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }], roundEdges: [{
            type: Input
        }], dataLabelFormatting: [{
            type: Input
        }] }); })();
    return SeriesHorizontal;
}());

var BarLabelComponent = /** @class */ (function () {
    function BarLabelComponent(element) {
        this.dimensionsChanged = new EventEmitter();
        this.horizontalPadding = 2;
        this.verticalPadding = 5;
        this.element = element.nativeElement;
    }
    BarLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    BarLabelComponent.prototype.getSize = function () {
        var h = this.element.getBoundingClientRect().height;
        var w = this.element.getBoundingClientRect().width;
        return { height: h, width: w, negative: this.value < 0 };
    };
    BarLabelComponent.prototype.ngAfterViewInit = function () {
        this.dimensionsChanged.emit(this.getSize());
    };
    BarLabelComponent.prototype.update = function () {
        if (this.valueFormatting) {
            this.formatedValue = this.valueFormatting(this.value);
        }
        else {
            this.formatedValue = formatLabel(this.value);
        }
        if (this.orientation === 'horizontal') {
            this.x = this.barX + this.barWidth;
            if (this.value < 0) {
                this.x = this.x - this.horizontalPadding;
                this.textAnchor = 'end';
            }
            else {
                this.x = this.x + this.horizontalPadding;
                this.textAnchor = 'start';
            }
            this.y = this.barY + this.barHeight / 2;
        }
        else {
            this.x = this.barX + this.barWidth / 2;
            this.y = this.barY + this.barHeight;
            if (this.value < 0) {
                this.y = this.y + this.verticalPadding;
                this.textAnchor = 'end';
            }
            else {
                this.y = this.y - this.verticalPadding;
                this.textAnchor = 'start';
            }
            this.transform = "rotate(-45, " + this.x + " , " + this.y + ")";
        }
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barX", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barY", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "barHeight", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BarLabelComponent.prototype, "orientation", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BarLabelComponent.prototype, "dimensionsChanged", void 0);
    BarLabelComponent = __decorate([ __metadata("design:paramtypes", [typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object])
    ], BarLabelComponent);
BarLabelComponent.ɵfac = function BarLabelComponent_Factory(t) { return new (t || BarLabelComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object)); };
BarLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BarLabelComponent, selectors: [["g", "ngx-charts-bar-label", ""]], inputs: { value: "value", valueFormatting: "valueFormatting", barX: "barX", barY: "barY", barWidth: "barWidth", barHeight: "barHeight", orientation: "orientation" }, outputs: { dimensionsChanged: "dimensionsChanged" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c29, decls: 2, vars: 5, consts: [["alignment-baseline", "middle", 1, "textDataLabel"]], template: function BarLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "text", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("text-anchor", ctx.textAnchor)("transform", ctx.transform)("x", ctx.x)("y", ctx.y);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.formatedValue, " ");
    } }, styles: [".textDataLabel[_ngcontent-%COMP%]{font-size:11px}"], changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bar-label]',
                template: "  \n    <svg:text   \n      class=\"textDataLabel\" \n      alignment-baseline=\"middle\"     \n      [attr.text-anchor]=\"textAnchor\"\n      [attr.transform]=\"transform\"\n      [attr.x]=\"x\" \n      [attr.y]=\"y\">\n      {{formatedValue}}     \n    </svg:text>          \n\n  ",
                styles: [".textDataLabel{font-size:11px}"],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object }]; }, { dimensionsChanged: [{
            type: Output
        }], value: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], barX: [{
            type: Input
        }], barY: [{
            type: Input
        }], barWidth: [{
            type: Input
        }], barHeight: [{
            type: Input
        }], orientation: [{
            type: Input
        }] }); })();
    return BarLabelComponent;
}());

var BarChartModule = /** @class */ (function () {
    function BarChartModule() {
    }
BarChartModule.ɵfac = function BarChartModule_Factory(t) { return new (t || BarChartModule)(); };
BarChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BarChartModule });
BarChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BarChartModule, { declarations: [BarComponent, BarHorizontalComponent, BarHorizontal2DComponent, BarHorizontalNormalizedComponent, BarHorizontalStackedComponent, BarVerticalComponent, BarVertical2DComponent, BarVerticalNormalizedComponent, BarVerticalStackedComponent, BarLabelComponent, SeriesHorizontal, SeriesVerticalComponent], imports: [ChartCommonModule], exports: [BarComponent, BarHorizontalComponent, BarHorizontal2DComponent, BarHorizontalNormalizedComponent, BarHorizontalStackedComponent, BarVerticalComponent, BarVertical2DComponent, BarVerticalNormalizedComponent, BarVerticalStackedComponent, BarLabelComponent, SeriesHorizontal, SeriesVerticalComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BarChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    BarComponent,
                    BarHorizontalComponent,
                    BarHorizontal2DComponent,
                    BarHorizontalNormalizedComponent,
                    BarHorizontalStackedComponent,
                    BarVerticalComponent,
                    BarVertical2DComponent,
                    BarVerticalNormalizedComponent,
                    BarVerticalStackedComponent,
                    BarLabelComponent,
                    SeriesHorizontal,
                    SeriesVerticalComponent
                ],
                exports: [
                    BarComponent,
                    BarHorizontalComponent,
                    BarHorizontal2DComponent,
                    BarHorizontalNormalizedComponent,
                    BarHorizontalStackedComponent,
                    BarVerticalComponent,
                    BarVertical2DComponent,
                    BarVerticalNormalizedComponent,
                    BarVerticalStackedComponent,
                    BarLabelComponent,
                    SeriesHorizontal,
                    SeriesVerticalComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return BarChartModule;
}());

function getDomain(values, scaleType, autoScale, minVal, maxVal) {
    var domain = [];
    if (scaleType === 'linear') {
        values = values.map(function (v) { return Number(v); });
        if (!autoScale) {
            values.push(0);
        }
    }
    if (scaleType === 'time' || scaleType === 'linear') {
        var min$$1 = minVal ? minVal : Math.min.apply(Math, values);
        var max$$1 = maxVal ? maxVal : Math.max.apply(Math, values);
        domain = [min$$1, max$$1];
    }
    else {
        domain = values;
    }
    return domain;
}
function getScale(domain, range$$1, scaleType, roundDomains) {
    var scale;
    if (scaleType === 'time') {
        scale = scaleTime()
            .range(range$$1)
            .domain(domain);
    }
    else if (scaleType === 'linear') {
        scale = scaleLinear()
            .range(range$$1)
            .domain(domain);
        if (roundDomains) {
            scale = scale.nice();
        }
    }
    else if (scaleType === 'ordinal') {
        scale = scalePoint()
            .range([range$$1[0], range$$1[1]])
            .domain(domain);
    }
    return scale;
}

var BubbleChartComponent = /** @class */ (function (_super) {
    __extends(BubbleChartComponent, _super);
    function BubbleChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.showGridLines = true;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.xAxis = true;
        _this.yAxis = true;
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.maxRadius = 10;
        _this.minRadius = 3;
        _this.schemeType = 'ordinal';
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.scaleType = 'linear';
        _this.margin = [10, 20, 10, 20];
        _this.bubblePadding = [0, 0, 0, 0];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.activeEntries = [];
        return _this;
    }
    BubbleChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        this.seriesDomain = this.results.map(function (d) { return d.name; });
        this.rDomain = this.getRDomain();
        this.xDomain = this.getXDomain();
        this.yDomain = this.getYDomain();
        this.transform = "translate(" + this.dims.xOffset + "," + this.margin[0] + ")";
        var colorDomain = this.schemeType === 'ordinal' ? this.seriesDomain : this.rDomain;
        this.colors = new ColorHelper(this.scheme, this.schemeType, colorDomain, this.customColors);
        this.data = this.results;
        this.minRadius = Math.max(this.minRadius, 1);
        this.maxRadius = Math.max(this.maxRadius, 1);
        this.rScale = this.getRScale(this.rDomain, [this.minRadius, this.maxRadius]);
        this.bubblePadding = [0, 0, 0, 0];
        this.setScales();
        this.bubblePadding = this.getBubblePadding();
        this.setScales();
        this.legendOptions = this.getLegendOptions();
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    BubbleChartComponent.prototype.hideCircles = function () {
        this.deactivateAll();
    };
    BubbleChartComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    BubbleChartComponent.prototype.getBubblePadding = function () {
        var yMin = 0;
        var xMin = 0;
        var yMax = this.dims.height;
        var xMax = this.dims.width;
        for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
            var s = _a[_i];
            for (var _b = 0, _c = s.series; _b < _c.length; _b++) {
                var d = _c[_b];
                var r = this.rScale(d.r);
                var cx = this.xScaleType === 'linear' ? this.xScale(Number(d.x)) : this.xScale(d.x);
                var cy = this.yScaleType === 'linear' ? this.yScale(Number(d.y)) : this.yScale(d.y);
                xMin = Math.max(r - cx, xMin);
                yMin = Math.max(r - cy, yMin);
                yMax = Math.max(cy + r, yMax);
                xMax = Math.max(cx + r, xMax);
            }
        }
        xMax = Math.max(xMax - this.dims.width, 0);
        yMax = Math.max(yMax - this.dims.height, 0);
        return [yMin, xMax, yMax, xMin];
    };
    BubbleChartComponent.prototype.setScales = function () {
        var width = this.dims.width;
        if (this.xScaleMin === undefined && this.xScaleMax === undefined) {
            width = width - this.bubblePadding[1];
        }
        var height = this.dims.height;
        if (this.yScaleMin === undefined && this.yScaleMax === undefined) {
            height = height - this.bubblePadding[2];
        }
        this.xScale = this.getXScale(this.xDomain, width);
        this.yScale = this.getYScale(this.yDomain, height);
    };
    BubbleChartComponent.prototype.getYScale = function (domain, height) {
        return getScale(domain, [height, this.bubblePadding[0]], this.yScaleType, this.roundDomains);
    };
    BubbleChartComponent.prototype.getXScale = function (domain, width) {
        return getScale(domain, [this.bubblePadding[3], width], this.xScaleType, this.roundDomains);
    };
    BubbleChartComponent.prototype.getRScale = function (domain, range$$1) {
        var scale = scaleLinear()
            .range(range$$1)
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    BubbleChartComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            position: this.legendPosition,
            title: undefined
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.rDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    BubbleChartComponent.prototype.getXDomain = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.x)) {
                    values.push(d.x);
                }
            }
        }
        this.xScaleType = getScaleType(values);
        return getDomain(values, this.xScaleType, this.autoScale, this.xScaleMin, this.xScaleMax);
    };
    BubbleChartComponent.prototype.getYDomain = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.y)) {
                    values.push(d.y);
                }
            }
        }
        this.yScaleType = getScaleType(values);
        return getDomain(values, this.yScaleType, this.autoScale, this.yScaleMin, this.yScaleMax);
    };
    BubbleChartComponent.prototype.getRDomain = function () {
        var min$$1 = Infinity;
        var max$$1 = -Infinity;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                var value = Number(d.r) || 1;
                min$$1 = Math.min(min$$1, value);
                max$$1 = Math.max(max$$1, value);
            }
        }
        return [min$$1, max$$1];
    };
    BubbleChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    BubbleChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    BubbleChartComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    BubbleChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    BubbleChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    BubbleChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BubbleChartComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], BubbleChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BubbleChartComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BubbleChartComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "maxRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "minRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleChartComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], BubbleChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], BubbleChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], BubbleChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], BubbleChartComponent.prototype, "hideCircles", null);
BubbleChartComponent.ɵfac = function BubbleChartComponent_Factory(t) { return ɵBubbleChartComponent_BaseFactory(t || BubbleChartComponent); };
BubbleChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BubbleChartComponent, selectors: [["ngx-charts-bubble-chart"]], contentQueries: function BubbleChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, hostBindings: function BubbleChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function BubbleChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { minRadius: "minRadius", maxRadius: "maxRadius", showGridLines: "showGridLines", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", autoScale: "autoScale", schemeType: "schemeType", tooltipDisabled: "tooltipDisabled", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 20, consts: [[3, "view", "showLegend", "activeEntries", "legendOptions", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "bubble-chart", "chart"], ["ngx-charts-x-axis", "", 3, "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["x", "0", "y", "0", 1, "bubble-chart-area", 2, "fill", "rgb(255, 0, 0)", "opacity", "0", "cursor", "auto", 3, "mouseenter"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-x-axis", "", 3, "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-bubble-series", "", 3, "xScale", "yScale", "rScale", "xScaleType", "yScaleType", "xAxisLabel", "yAxisLabel", "colors", "data", "activeEntries", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"]], template: function BubbleChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, BubbleChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, BubbleChartComponent__svg_g_6_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "rect", 4);
        ɵngcc0.ɵɵlistener("mouseenter", function BubbleChartComponent_Template__svg_rect_mouseenter_7_listener() { return ctx.deactivateAll(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "g");
        ɵngcc0.ɵɵtemplate(9, BubbleChartComponent__svg_g_9_Template, 2, 13, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("activeEntries", ctx.activeEntries)("legendOptions", ctx.legendOptions)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width)("height", ctx.dims.height);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, BubbleSeriesComponent]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵBubbleChartComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(BubbleChartComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BubbleChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-bubble-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [activeEntries]=\"activeEntries\"\n      [legendOptions]=\"legendOptions\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"bubble-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [showGridLines]=\"showGridLines\"\n          [dims]=\"dims\"\n          [xScale]=\"xScale\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        />\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [showGridLines]=\"showGridLines\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        />\n        <svg:rect\n          class=\"bubble-chart-area\"\n          x=\"0\"\n          y=\"0\"\n          [attr.width]=\"dims.width\"\n          [attr.height]=\"dims.height\"\n          style=\"fill: rgb(255, 0, 0); opacity: 0; cursor: 'auto';\"\n          (mouseenter)=\"deactivateAll()\"\n        />\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of data; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-bubble-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [rScale]=\"rScale\"\n              [xScaleType]=\"xScaleType\"\n              [yScaleType]=\"yScaleType\"\n              [xAxisLabel]=\"xAxisLabel\"\n              [yAxisLabel]=\"yAxisLabel\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              (select)=\"onClick($event, series)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n            />\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({
                                opacity: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], null, { minRadius: [{
            type: Input
        }], maxRadius: [{
            type: Input
        }], hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], showGridLines: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return BubbleChartComponent;
}(BaseChartComponent));

var BubbleSeriesComponent = /** @class */ (function () {
    function BubbleSeriesComponent() {
        this.tooltipDisabled = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    BubbleSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    BubbleSeriesComponent.prototype.update = function () {
        this.circles = this.getCircles();
    };
    BubbleSeriesComponent.prototype.getCircles = function () {
        var _this = this;
        var seriesName = this.data.name;
        return this.data.series
            .map(function (d, i) {
            if (typeof d.y !== 'undefined' && typeof d.x !== 'undefined') {
                var y = d.y;
                var x = d.x;
                var r = d.r;
                var radius = _this.rScale(r || 1);
                var tooltipLabel = formatLabel(d.name);
                var cx = _this.xScaleType === 'linear' ? _this.xScale(Number(x)) : _this.xScale(x);
                var cy = _this.yScaleType === 'linear' ? _this.yScale(Number(y)) : _this.yScale(y);
                var color = _this.colors.scaleType === 'linear' ? _this.colors.getColor(r) : _this.colors.getColor(seriesName);
                var isActive = !_this.activeEntries.length ? true : _this.isActive({ name: seriesName });
                var opacity = isActive ? 1 : 0.3;
                var data = Object.assign({}, d, {
                    series: seriesName,
                    name: d.name,
                    value: d.y,
                    x: d.x,
                    radius: d.r
                });
                return {
                    data: data,
                    x: x,
                    y: y,
                    r: r,
                    classNames: ["circle-data-" + i],
                    value: y,
                    label: x,
                    cx: cx,
                    cy: cy,
                    radius: radius,
                    tooltipLabel: tooltipLabel,
                    color: color,
                    opacity: opacity,
                    seriesName: seriesName,
                    isActive: isActive,
                    transform: "translate(" + cx + "," + cy + ")"
                };
            }
        })
            .filter(function (circle) { return circle !== undefined; });
    };
    BubbleSeriesComponent.prototype.getTooltipText = function (circle) {
        var hasRadius = typeof circle.r !== 'undefined';
        var hasTooltipLabel = circle.tooltipLabel && circle.tooltipLabel.length;
        var hasSeriesName = circle.seriesName && circle.seriesName.length;
        var radiusValue = hasRadius ? formatLabel(circle.r) : '';
        var xAxisLabel = this.xAxisLabel && this.xAxisLabel !== '' ? this.xAxisLabel + ":" : '';
        var yAxisLabel = this.yAxisLabel && this.yAxisLabel !== '' ? this.yAxisLabel + ":" : '';
        var x = formatLabel(circle.x);
        var y = formatLabel(circle.y);
        var name = hasSeriesName && hasTooltipLabel
            ? circle.seriesName + " \u2022 " + circle.tooltipLabel
            : circle.seriesName + circle.tooltipLabel;
        var tooltipTitle = hasSeriesName || hasTooltipLabel ? "<span class=\"tooltip-label\">" + name + "</span>" : '';
        return "\n      " + tooltipTitle + "\n      <span class=\"tooltip-label\">\n        <label>" + xAxisLabel + "</label> " + x + "<br />\n        <label>" + yAxisLabel + "</label> " + y + "\n      </span>\n      <span class=\"tooltip-val\">\n        " + radiusValue + "\n      </span>\n    ";
    };
    BubbleSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    BubbleSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    BubbleSeriesComponent.prototype.isVisible = function (circle) {
        if (this.activeEntries.length > 0) {
            return this.isActive({ name: circle.seriesName });
        }
        return circle.opacity !== 0;
    };
    BubbleSeriesComponent.prototype.activateCircle = function (circle) {
        circle.barVisible = true;
        this.activate.emit({ name: this.data.name });
    };
    BubbleSeriesComponent.prototype.deactivateCircle = function (circle) {
        circle.barVisible = false;
        this.deactivate.emit({ name: this.data.name });
    };
    BubbleSeriesComponent.prototype.trackBy = function (index, circle) {
        return circle.data.series + " " + circle.data.name;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "rScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "xScaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "yScaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "visibleValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], BubbleSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleSeriesComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], BubbleSeriesComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], BubbleSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], BubbleSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], BubbleSeriesComponent.prototype, "deactivate", void 0);
BubbleSeriesComponent.ɵfac = function BubbleSeriesComponent_Factory(t) { return new (t || BubbleSeriesComponent)(); };
BubbleSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: BubbleSeriesComponent, selectors: [["g", "ngx-charts-bubble-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", data: "data", xScale: "xScale", yScale: "yScale", rScale: "rScale", xScaleType: "xScaleType", yScaleType: "yScaleType", colors: "colors", visibleValue: "visibleValue", activeEntries: "activeEntries", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c30, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function BubbleSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, BubbleSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.circles)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, CircleComponent, TooltipDirective], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        opacity: 0,
                        transform: 'scale(0)'
                    }),
                    animate(250, style({ opacity: 1, transform: 'scale(1)' }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BubbleSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-bubble-series]',
                template: "\n    <svg:g *ngFor=\"let circle of circles; trackBy: trackBy\">\n      <svg:g [attr.transform]=\"circle.transform\">\n        <svg:g\n          ngx-charts-circle\n          [@animationState]=\"'active'\"\n          class=\"circle\"\n          [cx]=\"0\"\n          [cy]=\"0\"\n          [r]=\"circle.radius\"\n          [fill]=\"circle.color\"\n          [style.opacity]=\"circle.opacity\"\n          [class.active]=\"circle.isActive\"\n          [pointerEvents]=\"'all'\"\n          [data]=\"circle.value\"\n          [classNames]=\"circle.classNames\"\n          (select)=\"onClick(circle.data)\"\n          (activate)=\"activateCircle(circle)\"\n          (deactivate)=\"deactivateCircle(circle)\"\n          ngx-tooltip\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipPlacement]=\"'top'\"\n          [tooltipType]=\"'tooltip'\"\n          [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(circle)\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipContext]=\"circle.data\"\n        />\n      </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                opacity: 0,
                                transform: 'scale(0)'
                            }),
                            animate(250, style({ opacity: 1, transform: 'scale(1)' }))
                        ])
                    ])
                ]
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], rScale: [{
            type: Input
        }], xScaleType: [{
            type: Input
        }], yScaleType: [{
            type: Input
        }], colors: [{
            type: Input
        }], visibleValue: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return BubbleSeriesComponent;
}());

var BubbleChartModule = /** @class */ (function () {
    function BubbleChartModule() {
    }
BubbleChartModule.ɵfac = function BubbleChartModule_Factory(t) { return new (t || BubbleChartModule)(); };
BubbleChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: BubbleChartModule });
BubbleChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BubbleChartModule, { declarations: [BubbleChartComponent, BubbleSeriesComponent], imports: [ChartCommonModule], exports: [BubbleChartComponent, BubbleSeriesComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BubbleChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    BubbleChartComponent,
                    BubbleSeriesComponent
                ],
                exports: [
                    BubbleChartComponent,
                    BubbleSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return BubbleChartModule;
}());

var ForceDirectedGraphComponent = /** @class */ (function (_super) {
    __extends(ForceDirectedGraphComponent, _super);
    function ForceDirectedGraphComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.force = forceSimulation()
            .force('charge', forceManyBody())
            .force('collide', forceCollide(5))
            .force('x', forceX())
            .force('y', forceY());
        _this.forceLink = forceLink().id(function (node) { return node.value; });
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.nodes = [];
        _this.links = [];
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [0, 0, 0, 0];
        _this.results = [];
        _this.groupResultsBy = function (node) { return node.value; };
        return _this;
    }
    ForceDirectedGraphComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showLegend: this.legend,
            legendPosition: this.legendPosition
        });
        this.seriesDomain = this.getSeriesDomain();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "\n      translate(" + (this.dims.xOffset + this.dims.width / 2) + ", " + (this.margin[0] + this.dims.height / 2) + ")\n    ";
        if (this.force) {
            this.force
                .nodes(this.nodes)
                .force('link', this.forceLink.links(this.links))
                .alpha(0.5)
                .restart();
        }
    };
    ForceDirectedGraphComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    ForceDirectedGraphComponent.prototype.onActivate = function (event$$1) {
        if (this.activeEntries.indexOf(event$$1) > -1)
            return;
        this.activeEntries = [event$$1].concat(this.activeEntries);
        this.activate.emit({ value: event$$1, entries: this.activeEntries });
    };
    ForceDirectedGraphComponent.prototype.onDeactivate = function (event$$1) {
        var idx = this.activeEntries.indexOf(event$$1);
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: event$$1, entries: this.activeEntries });
    };
    ForceDirectedGraphComponent.prototype.getSeriesDomain = function () {
        var _this = this;
        return this.nodes
            .map(function (d) { return _this.groupResultsBy(d); })
            .reduce(function (nodes, node) { return (nodes.includes(node) ? nodes : nodes.concat([node])); }, [])
            .sort();
    };
    ForceDirectedGraphComponent.prototype.trackLinkBy = function (index, link) {
        return link.index;
    };
    ForceDirectedGraphComponent.prototype.trackNodeBy = function (index, node) {
        return node.value;
    };
    ForceDirectedGraphComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.seriesDomain, this.customColors);
    };
    ForceDirectedGraphComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: 'ordinal',
            domain: this.seriesDomain,
            colors: this.colors,
            title: this.legendTitle,
            position: this.legendPosition
        };
    };
    ForceDirectedGraphComponent.prototype.onDragStart = function (node, $event) {
        this.force.alphaTarget(0.3).restart();
        this.draggingNode = node;
        this.draggingStart = { x: $event.x - node.x, y: $event.y - node.y };
        this.draggingNode.fx = $event.x - this.draggingStart.x;
        this.draggingNode.fy = $event.y - this.draggingStart.y;
    };
    ForceDirectedGraphComponent.prototype.onDrag = function ($event) {
        if (!this.draggingNode)
            return;
        this.draggingNode.fx = $event.x - this.draggingStart.x;
        this.draggingNode.fy = $event.y - this.draggingStart.y;
    };
    ForceDirectedGraphComponent.prototype.onDragEnd = function ($event) {
        if (!this.draggingNode)
            return;
        this.force.alphaTarget(0);
        this.draggingNode.fx = undefined;
        this.draggingNode.fy = undefined;
        this.draggingNode = undefined;
    };
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ForceDirectedGraphComponent.prototype, "force", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], ForceDirectedGraphComponent.prototype, "forceLink", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ForceDirectedGraphComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ForceDirectedGraphComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], ForceDirectedGraphComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ForceDirectedGraphComponent.prototype, "nodes", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof Array !== "undefined" && Array) === "function" ? _a : Object)
    ], ForceDirectedGraphComponent.prototype, "links", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], ForceDirectedGraphComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], ForceDirectedGraphComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], ForceDirectedGraphComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], ForceDirectedGraphComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('linkTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], ForceDirectedGraphComponent.prototype, "linkTemplate", void 0);
    __decorate([
        ContentChild('nodeTemplate', { static: false }),
        __metadata("design:type", typeof (_e = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _e : Object)
    ], ForceDirectedGraphComponent.prototype, "nodeTemplate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_f = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _f : Object)
    ], ForceDirectedGraphComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ViewChild(ChartComponent, { read: ElementRef, static: false }),
        __metadata("design:type", typeof (_g = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _g : Object)
    ], ForceDirectedGraphComponent.prototype, "chart", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], ForceDirectedGraphComponent.prototype, "groupResultsBy", void 0);
    __decorate([
        HostListener('document:mousemove', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [typeof (_h = typeof MouseEvent !== "undefined" && MouseEvent) === "function" ? _h : Object]),
        __metadata("design:returntype", void 0)
    ], ForceDirectedGraphComponent.prototype, "onDrag", null);
    __decorate([
        HostListener('document:mouseup', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [typeof (_j = typeof MouseEvent !== "undefined" && MouseEvent) === "function" ? _j : Object]),
        __metadata("design:returntype", void 0)
    ], ForceDirectedGraphComponent.prototype, "onDragEnd", null);
ForceDirectedGraphComponent.ɵfac = function ForceDirectedGraphComponent_Factory(t) { return ɵForceDirectedGraphComponent_BaseFactory(t || ForceDirectedGraphComponent); };
ForceDirectedGraphComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ForceDirectedGraphComponent, selectors: [["ngx-charts-force-directed-graph"]], contentQueries: function ForceDirectedGraphComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c31, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c32, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.linkTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, viewQuery: function ForceDirectedGraphComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(ChartComponent, 1, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chart = _t.first);
    } }, hostBindings: function ForceDirectedGraphComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousemove", function ForceDirectedGraphComponent_mousemove_HostBindingHandler($event) { return ctx.onDrag($event); }, false, ɵngcc0.ɵɵresolveDocument)("mouseup", function ForceDirectedGraphComponent_mouseup_HostBindingHandler($event) { return ctx.onDragEnd($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { activeEntries: "activeEntries", force: "force", forceLink: "forceLink", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", nodes: "nodes", links: "links", tooltipDisabled: "tooltipDisabled", groupResultsBy: "groupResultsBy" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 12, consts: [[3, "view", "showLegend", "legendOptions", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "force-directed-graph", "chart"], [1, "links"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "nodes"], ["ngx-tooltip", "", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "mousedown", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["strokeWidth", "1", "class", "edge", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["strokeWidth", "1", 1, "edge"], ["ngx-tooltip", "", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "mousedown", "click"], ["r", "5", 4, "ngIf"], ["r", "5"]], template: function ForceDirectedGraphComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function ForceDirectedGraphComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function ForceDirectedGraphComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function ForceDirectedGraphComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵtemplate(3, ForceDirectedGraphComponent__svg_g_3_Template, 3, 2, "g", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 4);
        ɵngcc0.ɵɵtemplate(5, ForceDirectedGraphComponent__svg_g_5_Template, 3, 11, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(9, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.links)("ngForTrackBy", ctx.trackLinkBy);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.nodes)("ngForTrackBy", ctx.trackNodeBy);
    } }, directives: [ChartComponent, ɵngcc1.NgForOf, ɵngcc1.NgIf, TooltipDirective], styles: [_c24, ".force-directed-graph .edge{stroke:#333}"], encapsulation: 2, changeDetection: 0 });
var ɵForceDirectedGraphComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(ForceDirectedGraphComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ForceDirectedGraphComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-force-directed-graph',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"force-directed-graph chart\">\n        <svg:g class=\"links\">\n          <svg:g *ngFor=\"let link of links; trackBy: trackLinkBy\">\n            <ng-template\n              *ngIf=\"linkTemplate\"\n              [ngTemplateOutlet]=\"linkTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: link }\"\n            ></ng-template>\n            <svg:line\n              *ngIf=\"!linkTemplate\"\n              strokeWidth=\"1\"\n              class=\"edge\"\n              [attr.x1]=\"link.source.x\"\n              [attr.y1]=\"link.source.y\"\n              [attr.x2]=\"link.target.x\"\n              [attr.y2]=\"link.target.y\"\n            />\n          </svg:g>\n        </svg:g>\n        <svg:g class=\"nodes\">\n          <svg:g\n            *ngFor=\"let node of nodes; trackBy: trackNodeBy\"\n            [attr.transform]=\"'translate(' + node.x + ',' + node.y + ')'\"\n            [attr.fill]=\"colors.getColor(groupResultsBy(node))\"\n            [attr.stroke]=\"colors.getColor(groupResultsBy(node))\"\n            (mousedown)=\"onDragStart(node, $event)\"\n            (click)=\"onClick({ name: node.value })\"\n            ngx-tooltip\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipPlacement]=\"'top'\"\n            [tooltipType]=\"'tooltip'\"\n            [tooltipTitle]=\"tooltipTemplate ? undefined : node.value\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [tooltipContext]=\"node\"\n          >\n            <ng-template\n              *ngIf=\"nodeTemplate\"\n              [ngTemplateOutlet]=\"nodeTemplate\"\n              [ngTemplateOutletContext]=\"{ $implicit: node }\"\n            ></ng-template>\n            <svg:circle *ngIf=\"!nodeTemplate\" r=\"5\" />\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".force-directed-graph .edge{stroke:#333}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { activeEntries: [{
            type: Input
        }], onDrag: [{
            type: HostListener,
            args: ['document:mousemove', ['$event']]
        }], onDragEnd: [{
            type: HostListener,
            args: ['document:mouseup', ['$event']]
        }], force: [{
            type: Input
        }], forceLink: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], nodes: [{
            type: Input
        }], links: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], linkTemplate: [{
            type: ContentChild,
            args: ['linkTemplate', { static: false }]
        }], nodeTemplate: [{
            type: ContentChild,
            args: ['nodeTemplate', { static: false }]
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], chart: [{
            type: ViewChild,
            args: [ChartComponent, { read: ElementRef, static: false }]
        }], groupResultsBy: [{
            type: Input
        }] }); })();
    return ForceDirectedGraphComponent;
}(BaseChartComponent));

var ForceDirectedGraphModule = /** @class */ (function () {
    function ForceDirectedGraphModule() {
    }
ForceDirectedGraphModule.ɵfac = function ForceDirectedGraphModule_Factory(t) { return new (t || ForceDirectedGraphModule)(); };
ForceDirectedGraphModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ForceDirectedGraphModule });
ForceDirectedGraphModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ForceDirectedGraphModule, { declarations: [ForceDirectedGraphComponent], imports: [ChartCommonModule], exports: [ForceDirectedGraphComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ForceDirectedGraphModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    ForceDirectedGraphComponent,
                ],
                exports: [
                    ForceDirectedGraphComponent,
                ]
            }]
    }], function () { return []; }, null); })();
    return ForceDirectedGraphModule;
}());

var HeatMapCellComponent = /** @class */ (function () {
    function HeatMapCellComponent(element) {
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.element = element.nativeElement;
    }
    HeatMapCellComponent.prototype.ngOnChanges = function (changes) {
        this.transform = "translate(" + this.x + " , " + this.y + ")";
        this.startOpacity = 0.3;
        this.gradientId = 'grad' + id().toString();
        this.gradientUrl = "url(#" + this.gradientId + ")";
        this.gradientStops = this.getGradientStops();
        if (this.animations) {
            this.loadAnimation();
        }
    };
    HeatMapCellComponent.prototype.getGradientStops = function () {
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: this.startOpacity
            },
            {
                offset: 100,
                color: this.fill,
                opacity: 1
            }
        ];
    };
    HeatMapCellComponent.prototype.loadAnimation = function () {
        var node = select(this.element).select('.cell');
        node.attr('opacity', 0);
        this.animateToCurrentForm();
    };
    HeatMapCellComponent.prototype.animateToCurrentForm = function () {
        var node = select(this.element).select('.cell');
        node
            .transition()
            .duration(750)
            .attr('opacity', 1);
    };
    HeatMapCellComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    HeatMapCellComponent.prototype.onMouseEnter = function () {
        this.activate.emit(this.data);
    };
    HeatMapCellComponent.prototype.onMouseLeave = function () {
        this.deactivate.emit(this.data);
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapCellComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapCellComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatMapCellComponent.prototype, "deactivate", void 0);
    __decorate([
        HostListener('mouseenter'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeatMapCellComponent.prototype, "onMouseEnter", null);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], HeatMapCellComponent.prototype, "onMouseLeave", null);
    HeatMapCellComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], HeatMapCellComponent);
HeatMapCellComponent.ɵfac = function HeatMapCellComponent_Factory(t) { return new (t || HeatMapCellComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
HeatMapCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeatMapCellComponent, selectors: [["g", "ngx-charts-heat-map-cell", ""]], hostBindings: function HeatMapCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function HeatMapCellComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function HeatMapCellComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); });
    } }, inputs: { gradient: "gradient", animations: "animations", fill: "fill", x: "x", y: "y", width: "width", height: "height", data: "data", label: "label" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c33, decls: 3, vars: 5, consts: [[1, "cell"], [4, "ngIf"], ["rx", "3", 1, "cell", 2, "cursor", "pointer", 3, "click"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"]], template: function HeatMapCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, HeatMapCellComponent__svg_defs_1_Template, 2, 2, "defs", 1);
        ɵngcc0.ɵɵelementStart(2, "rect", 2);
        ɵngcc0.ɵɵlistener("click", function HeatMapCellComponent_Template__svg_rect_click_2_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeatMapCellComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-heat-map-cell]',
                template: "\n    <svg:g [attr.transform]=\"transform\" class=\"cell\">\n      <defs *ngIf=\"gradient\">\n        <svg:g ngx-charts-svg-linear-gradient orientation=\"vertical\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n      </defs>\n      <svg:rect\n        [attr.fill]=\"gradient ? gradientUrl : fill\"\n        rx=\"3\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        class=\"cell\"\n        style=\"cursor: pointer\"\n        (click)=\"onClick()\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], fill: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], data: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();
    return HeatMapCellComponent;
}());

var HeatCellSeriesComponent = /** @class */ (function () {
    function HeatCellSeriesComponent() {
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    HeatCellSeriesComponent.prototype.ngOnInit = function () {
        if (!this.tooltipText) {
            this.tooltipText = this.getTooltipText;
        }
    };
    HeatCellSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    HeatCellSeriesComponent.prototype.update = function () {
        this.cells = this.getCells();
    };
    HeatCellSeriesComponent.prototype.getCells = function () {
        var _this = this;
        var cells = [];
        this.data.map(function (row) {
            row.series.map(function (cell) {
                var value = cell.value;
                cell.series = row.name;
                cells.push({
                    row: row,
                    cell: cell,
                    x: _this.xScale(row.name),
                    y: _this.yScale(cell.name),
                    width: _this.xScale.bandwidth(),
                    height: _this.yScale.bandwidth(),
                    fill: _this.colors.getColor(value),
                    data: value,
                    label: formatLabel(cell.name),
                    series: row.name
                });
            });
        });
        return cells;
    };
    HeatCellSeriesComponent.prototype.getTooltipText = function (_a) {
        var label = _a.label, data = _a.data, series = _a.series;
        return "\n      <span class=\"tooltip-label\">" + series + " \u2022 " + label + "</span>\n      <span class=\"tooltip-val\">" + data.toLocaleString() + "</span>\n    ";
    };
    HeatCellSeriesComponent.prototype.trackBy = function (index, item) {
        return item.tooltipText;
    };
    HeatCellSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatCellSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatCellSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], HeatCellSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatCellSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], HeatCellSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], HeatCellSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_c = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _c : Object)
    ], HeatCellSeriesComponent.prototype, "deactivate", void 0);
HeatCellSeriesComponent.ɵfac = function HeatCellSeriesComponent_Factory(t) { return new (t || HeatCellSeriesComponent)(); };
HeatCellSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeatCellSeriesComponent, selectors: [["g", "ngx-charts-heat-map-cell-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", animations: "animations", tooltipText: "tooltipText", data: "data", colors: "colors", xScale: "xScale", yScale: "yScale", gradient: "gradient", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c34, decls: 1, vars: 2, consts: [["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function HeatCellSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, HeatCellSeriesComponent__svg_g_0_Template, 1, 18, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, HeatMapCellComponent, TooltipDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeatCellSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-heat-map-cell-series]',
                template: "\n    <svg:g\n      ngx-charts-heat-map-cell\n      *ngFor=\"let c of cells; trackBy: trackBy\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [fill]=\"c.fill\"\n      [data]=\"c.data\"\n      (select)=\"onClick(c.cell)\"\n      (activate)=\"activate.emit(c.cell)\"\n      (deactivate)=\"deactivate.emit(c.cell)\"\n      [gradient]=\"gradient\"\n      [animations]=\"animations\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(c)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"{ series: c.series, name: c.label, value: c.data }\"\n    ></svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipText: [{
            type: Input
        }], data: [{
            type: Input
        }], colors: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], gradient: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return HeatCellSeriesComponent;
}());

var HeatMapComponent = /** @class */ (function (_super) {
    __extends(HeatMapComponent, _super);
    function HeatMapComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.innerPadding = 8;
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.tooltipDisabled = false;
        _this.activeEntries = [];
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.scaleType = 'linear';
        return _this;
    }
    HeatMapComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.formatDates();
        this.xDomain = this.getXDomain();
        this.yDomain = this.getYDomain();
        this.valueDomain = this.getValueDomain();
        this.scaleType = getScaleType(this.valueDomain, false);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.scaleType,
            legendPosition: this.legendPosition
        });
        if (this.scaleType === 'linear') {
            var min$$1 = this.min;
            var max$$1 = this.max;
            if (!this.min) {
                min$$1 = Math.min.apply(Math, [0].concat(this.valueDomain));
            }
            if (!this.max) {
                max$$1 = Math.max.apply(Math, this.valueDomain);
            }
            this.valueDomain = [min$$1, max$$1];
        }
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.rects = this.getRects();
    };
    HeatMapComponent.prototype.getXDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            if (!domain.includes(group.name)) {
                domain.push(group.name);
            }
        }
        return domain;
    };
    HeatMapComponent.prototype.getYDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.name)) {
                    domain.push(d.name);
                }
            }
        }
        return domain;
    };
    HeatMapComponent.prototype.getValueDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var group = _a[_i];
            for (var _b = 0, _c = group.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        return domain;
    };
    HeatMapComponent.prototype.getDimension = function (value, index, N, L) {
        if (index === void 0) { index = 0; }
        if (typeof value === 'string') {
            value = value
                .replace('[', '')
                .replace(']', '')
                .replace('px', '')
                .replace('\'', '');
            if (value.includes(',')) {
                value = value.split(',');
            }
        }
        if (Array.isArray(value) && typeof index === 'number') {
            return this.getDimension(value[index], null, N, L);
        }
        if (typeof value === 'string' && value.includes('%')) {
            return +value.replace('%', '') / 100;
        }
        return N / (L / +value + 1);
    };
    HeatMapComponent.prototype.getXScale = function () {
        var f = this.getDimension(this.innerPadding, 0, this.xDomain.length, this.dims.width);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .domain(this.xDomain)
            .paddingInner(f);
    };
    HeatMapComponent.prototype.getYScale = function () {
        var f = this.getDimension(this.innerPadding, 1, this.yDomain.length, this.dims.height);
        return scaleBand()
            .rangeRound([this.dims.height, 0])
            .domain(this.yDomain)
            .paddingInner(f);
    };
    HeatMapComponent.prototype.getRects = function () {
        var _this = this;
        var rects = [];
        this.xDomain.map(function (xVal) {
            _this.yDomain.map(function (yVal) {
                rects.push({
                    x: _this.xScale(xVal),
                    y: _this.yScale(yVal),
                    rx: 3,
                    width: _this.xScale.bandwidth(),
                    height: _this.yScale.bandwidth(),
                    fill: 'rgba(200,200,200,0.03)'
                });
            });
        });
        return rects;
    };
    HeatMapComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    HeatMapComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, this.scaleType, this.valueDomain);
    };
    HeatMapComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: this.scaleType,
            domain: this.valueDomain,
            colors: this.scaleType === 'ordinal' ? this.colors : this.colors.scale,
            title: this.scaleType === 'ordinal' ? this.legendTitle : undefined,
            position: this.legendPosition
        };
    };
    HeatMapComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    HeatMapComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    HeatMapComponent.prototype.onActivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        var items = this.results
            .map(function (g) { return g.series; })
            .flat()
            .filter(function (i) {
            if (fromLegend) {
                return i.label === item.name;
            }
            else {
                return i.name === item.name && i.series === item.series;
            }
        });
        this.activeEntries = items.slice();
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    HeatMapComponent.prototype.onDeactivate = function (event$$1, group, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        var item = Object.assign({}, event$$1);
        if (group) {
            item.series = group.name;
        }
        this.activeEntries = this.activeEntries.filter(function (i) {
            if (fromLegend) {
                return i.label !== item.name;
            }
            else {
                return !(i.name === item.name && i.series === item.series);
            }
        });
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], HeatMapComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], HeatMapComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "innerPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], HeatMapComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], HeatMapComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], HeatMapComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], HeatMapComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], HeatMapComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], HeatMapComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], HeatMapComponent.prototype, "activeEntries", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], HeatMapComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], HeatMapComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], HeatMapComponent.prototype, "tooltipTemplate", void 0);
HeatMapComponent.ɵfac = function HeatMapComponent_Factory(t) { return ɵHeatMapComponent_BaseFactory(t || HeatMapComponent); };
HeatMapComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HeatMapComponent, selectors: [["ngx-charts-heat-map"]], contentQueries: function HeatMapComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", gradient: "gradient", innerPadding: "innerPadding", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", tooltipDisabled: "tooltipDisabled", tooltipText: "tooltipText", min: "min", max: "max" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 6, vars: 20, consts: [[3, "view", "showLegend", "animations", "legendOptions", "legendLabelClick"], [1, "heat-map", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["ngx-charts-heat-map-cell-series", "", 3, "xScale", "yScale", "colors", "data", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText", "select", "activate", "deactivate"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"]], template: function HeatMapComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function HeatMapComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, HeatMapComponent__svg_g_2_Template, 1, 9, "g", 2);
        ɵngcc0.ɵɵtemplate(3, HeatMapComponent__svg_g_3_Template, 1, 8, "g", 3);
        ɵngcc0.ɵɵtemplate(4, HeatMapComponent__svg_rect_4_Template, 1, 6, "rect", 4);
        ɵngcc0.ɵɵelementStart(5, "g", 5);
        ɵngcc0.ɵɵlistener("select", function HeatMapComponent_Template__svg_g_select_5_listener($event) { return ctx.onClick($event); })("activate", function HeatMapComponent_Template__svg_g_activate_5_listener($event) { return ctx.onActivate($event); })("deactivate", function HeatMapComponent_Template__svg_g_deactivate_5_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("animations", ctx.animations)("legendOptions", ctx.legendOptions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.rects);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("data", ctx.results)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
    } }, directives: [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, HeatCellSeriesComponent, XAxisComponent, YAxisComponent], styles: [_c24], encapsulation: 2, changeDetection: 0 });
var ɵHeatMapComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(HeatMapComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeatMapComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-heat-map',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [animations]=\"animations\"\n      [legendOptions]=\"legendOptions\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"heat-map chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:rect\n          *ngFor=\"let rect of rects\"\n          [attr.x]=\"rect.x\"\n          [attr.y]=\"rect.y\"\n          [attr.rx]=\"rect.rx\"\n          [attr.width]=\"rect.width\"\n          [attr.height]=\"rect.height\"\n          [attr.fill]=\"rect.fill\"\n        />\n        <svg:g\n          ngx-charts-heat-map-cell-series\n          [xScale]=\"xScale\"\n          [yScale]=\"yScale\"\n          [colors]=\"colors\"\n          [data]=\"results\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipText]=\"tooltipText\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], gradient: [{
            type: Input
        }], innerPadding: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return HeatMapComponent;
}(BaseChartComponent));

var HeatMapModule = /** @class */ (function () {
    function HeatMapModule() {
    }
HeatMapModule.ɵfac = function HeatMapModule_Factory(t) { return new (t || HeatMapModule)(); };
HeatMapModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: HeatMapModule });
HeatMapModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(HeatMapModule, { declarations: [HeatMapCellComponent, HeatCellSeriesComponent, HeatMapComponent], imports: [ChartCommonModule], exports: [HeatMapCellComponent, HeatCellSeriesComponent, HeatMapComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(HeatMapModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    HeatMapCellComponent,
                    HeatCellSeriesComponent,
                    HeatMapComponent
                ],
                exports: [
                    HeatMapCellComponent,
                    HeatCellSeriesComponent,
                    HeatMapComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return HeatMapModule;
}());

var LineComponent = /** @class */ (function () {
    function LineComponent(element) {
        this.element = element;
        this.fill = 'none';
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
    }
    LineComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            this.initialized = true;
            this.initialPath = this.path;
        }
        else {
            this.updatePathEl();
        }
    };
    LineComponent.prototype.updatePathEl = function () {
        var node = select(this.element.nativeElement).select('.line');
        if (this.animations) {
            node
                .transition().duration(750)
                .attr('d', this.path);
        }
        else {
            node.attr('d', this.path);
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "path", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "stroke", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], LineComponent.prototype, "select", void 0);
    LineComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], LineComponent);
LineComponent.ɵfac = function LineComponent_Factory(t) { return new (t || LineComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
LineComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineComponent, selectors: [["g", "ngx-charts-line", ""]], inputs: { fill: "fill", animations: "animations", path: "path", stroke: "stroke", data: "data" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c36, decls: 1, vars: 4, consts: [["stroke-width", "1.5px", 1, "line"]], template: function LineComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "path", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("@animationState", "active");
        ɵngcc0.ɵɵattribute("d", ctx.initialPath)("fill", ctx.fill)("stroke", ctx.stroke);
    } }, encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':enter', [
                    style({
                        strokeDasharray: 2000,
                        strokeDashoffset: 2000
                    }),
                    animate(1000, style({
                        strokeDashoffset: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LineComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-line]',
                template: "\n    <svg:path\n      [@animationState]=\"'active'\"\n      class=\"line\"\n      [attr.d]=\"initialPath\"\n      [attr.fill]=\"fill\"\n      [attr.stroke]=\"stroke\"\n      stroke-width=\"1.5px\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':enter', [
                            style({
                                strokeDasharray: 2000,
                                strokeDashoffset: 2000
                            }),
                            animate(1000, style({
                                strokeDashoffset: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { fill: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], path: [{
            type: Input
        }], stroke: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
    return LineComponent;
}());

var LineChartComponent = /** @class */ (function (_super) {
    __extends(LineChartComponent, _super);
    function LineChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveLinear;
        _this.activeEntries = [];
        _this.trimXAxisTicks = true;
        _this.trimYAxisTicks = true;
        _this.rotateXAxisTicks = true;
        _this.maxXAxisTickLength = 16;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.showRefLines = false;
        _this.showRefLabels = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        _this.timelineHeight = 50;
        _this.timelinePadding = 10;
        return _this;
    }
    LineChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        if (this.timeline) {
            this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
        }
        this.xDomain = this.getXDomain();
        if (this.filteredDomain) {
            this.xDomain = this.filteredDomain;
        }
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
        this.yScale = this.getYScale(this.yDomain, this.dims.height);
        this.updateTimeline();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        this.clipPathId = 'clip' + id().toString();
        this.clipPath = "url(#" + this.clipPathId + ")";
    };
    LineChartComponent.prototype.updateTimeline = function () {
        if (this.timeline) {
            this.timelineWidth = this.dims.width;
            this.timelineXDomain = this.getXDomain();
            this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
            this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
            this.timelineTransform = "translate(" + this.dims.xOffset + ", " + -this.margin[2] + ")";
        }
    };
    LineChartComponent.prototype.getXDomain = function () {
        var values = getUniqueXDomainValues(this.results);
        this.scaleType = getScaleType(values);
        var domain = [];
        if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
        }
        var min$$1;
        var max$$1;
        if (this.scaleType === 'time' || this.scaleType === 'linear') {
            min$$1 = this.xScaleMin ? this.xScaleMin : Math.min.apply(Math, values);
            max$$1 = this.xScaleMax ? this.xScaleMax : Math.max.apply(Math, values);
        }
        if (this.scaleType === 'time') {
            domain = [new Date(min$$1), new Date(max$$1)];
            this.xSet = values.slice().sort(function (a, b) {
                var aDate = a.getTime();
                var bDate = b.getTime();
                if (aDate > bDate)
                    return 1;
                if (bDate > aDate)
                    return -1;
                return 0;
            });
        }
        else if (this.scaleType === 'linear') {
            domain = [min$$1, max$$1];
            this.xSet = values.slice().sort(function (a, b) { return a - b; });
        }
        else {
            domain = values;
            this.xSet = values;
        }
        return domain;
    };
    LineChartComponent.prototype.getYDomain = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (domain.indexOf(d.value) < 0) {
                    domain.push(d.value);
                }
                if (d.min !== undefined) {
                    this.hasRange = true;
                    if (domain.indexOf(d.min) < 0) {
                        domain.push(d.min);
                    }
                }
                if (d.max !== undefined) {
                    this.hasRange = true;
                    if (domain.indexOf(d.max) < 0) {
                        domain.push(d.max);
                    }
                }
            }
        }
        var values = domain.slice();
        if (!this.autoScale) {
            values.push(0);
        }
        var min$$1 = this.yScaleMin ? this.yScaleMin : Math.min.apply(Math, values);
        var max$$1 = this.yScaleMax ? this.yScaleMax : Math.max.apply(Math, values);
        return [min$$1, max$$1];
    };
    LineChartComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    LineChartComponent.prototype.getXScale = function (domain, width) {
        var scale;
        if (this.scaleType === 'time') {
            scale = scaleTime()
                .range([0, width])
                .domain(domain);
        }
        else if (this.scaleType === 'linear') {
            scale = scaleLinear()
                .range([0, width])
                .domain(domain);
            if (this.roundDomains) {
                scale = scale.nice();
            }
        }
        else if (this.scaleType === 'ordinal') {
            scale = scalePoint()
                .range([0, width])
                .padding(0.1)
                .domain(domain);
        }
        return scale;
    };
    LineChartComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([height, 0])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    LineChartComponent.prototype.updateDomain = function (domain) {
        this.filteredDomain = domain;
        this.xDomain = this.filteredDomain;
        this.xScale = this.getXScale(this.xDomain, this.dims.width);
    };
    LineChartComponent.prototype.updateHoveredVertical = function (item) {
        this.hoveredVertical = item.value;
        this.deactivateAll();
    };
    LineChartComponent.prototype.hideCircles = function () {
        this.hoveredVertical = null;
        this.deactivateAll();
    };
    LineChartComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    LineChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    LineChartComponent.prototype.setColors = function () {
        var domain;
        if (this.schemeType === 'ordinal') {
            domain = this.seriesDomain;
        }
        else {
            domain = this.yDomain;
        }
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    LineChartComponent.prototype.getLegendOptions = function () {
        var opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: undefined,
            position: this.legendPosition
        };
        if (opts.scaleType === 'ordinal') {
            opts.domain = this.seriesDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.yDomain;
            opts.colors = this.colors.scale;
        }
        return opts;
    };
    LineChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    LineChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    LineChartComponent.prototype.onActivate = function (item) {
        this.deactivateAll();
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item];
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    LineChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    LineChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "timeline", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LineChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "trimXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "rotateXAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "maxXAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineChartComponent.prototype, "xAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineChartComponent.prototype, "yAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "showRefLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "referenceLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineChartComponent.prototype, "showRefLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineChartComponent.prototype, "xScaleMax", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "yScaleMin", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineChartComponent.prototype, "yScaleMax", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], LineChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], LineChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], LineChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ContentChild('seriesTooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_d = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _d : Object)
    ], LineChartComponent.prototype, "seriesTooltipTemplate", void 0);
    __decorate([
        HostListener('mouseleave'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], LineChartComponent.prototype, "hideCircles", null);
LineChartComponent.ɵfac = function LineChartComponent_Factory(t) { return ɵLineChartComponent_BaseFactory(t || LineChartComponent); };
LineChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineChartComponent, selectors: [["ngx-charts-line-chart"]], contentQueries: function LineChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c22, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, hostBindings: function LineChartComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseleave", function LineChartComponent_mouseleave_HostBindingHandler() { return ctx.hideCircles(); });
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", autoScale: "autoScale", timeline: "timeline", gradient: "gradient", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", rangeFillOpacity: "rangeFillOpacity", trimXAxisTicks: "trimXAxisTicks", trimYAxisTicks: "trimYAxisTicks", rotateXAxisTicks: "rotateXAxisTicks", maxXAxisTickLength: "maxXAxisTickLength", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", showRefLines: "showRefLines", referenceLines: "referenceLines", showRefLabels: "showRefLabels", xScaleMin: "xScaleMin", xScaleMax: "xScaleMax", yScaleMin: "yScaleMin", yScaleMax: "yScaleMax" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 20, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "line-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "scaleType", "legend", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "dimensionsChanged"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "dimensionsChanged"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "hasRange", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate", "hover"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "visibleValue", "activeEntries", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "scaleType", "legend", "onDomainChange"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "curve", "hasRange", "animations"]], template: function LineChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function LineChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵelementStart(2, "clipPath");
        ɵngcc0.ɵɵelement(3, "rect");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "g", 1);
        ɵngcc0.ɵɵtemplate(5, LineChartComponent__svg_g_5_Template, 1, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(6, LineChartComponent__svg_g_6_Template, 1, 12, "g", 3);
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵtemplate(8, LineChartComponent__svg_g_8_Template, 2, 11, "g", 4);
        ɵngcc0.ɵɵtemplate(9, LineChartComponent__svg_g_9_Template, 3, 9, "g", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, LineChartComponent__svg_g_10_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.clipPathId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("clip-path", ctx.clipPath);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.tooltipDisabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, XAxisComponent, YAxisComponent, LineSeriesComponent, TooltipArea, CircleSeriesComponent, Timeline]; }, styles: [_c24], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵLineChartComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(LineChartComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LineChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-line-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:defs>\n        <svg:clipPath [attr.id]=\"clipPathId\">\n          <svg:rect\n            [attr.width]=\"dims.width + 10\"\n            [attr.height]=\"dims.height + 10\"\n            [attr.transform]=\"'translate(-5, -5)'\"\n          />\n        </svg:clipPath>\n      </svg:defs>\n      <svg:g [attr.transform]=\"transform\" class=\"line-chart chart\">\n        <svg:g\n          ngx-charts-x-axis\n          *ngIf=\"xAxis\"\n          [xScale]=\"xScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showXAxisLabel\"\n          [labelText]=\"xAxisLabel\"\n          [trimTicks]=\"trimXAxisTicks\"\n          [rotateTicks]=\"rotateXAxisTicks\"\n          [maxTickLength]=\"maxXAxisTickLength\"\n          [tickFormatting]=\"xAxisTickFormatting\"\n          [ticks]=\"xAxisTicks\"\n          (dimensionsChanged)=\"updateXAxisHeight($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          *ngIf=\"yAxis\"\n          [yScale]=\"yScale\"\n          [dims]=\"dims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          [ticks]=\"yAxisTicks\"\n          [referenceLines]=\"referenceLines\"\n          [showRefLines]=\"showRefLines\"\n          [showRefLabels]=\"showRefLabels\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g [attr.clip-path]=\"clipPath\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-line-series\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [curve]=\"curve\"\n              [rangeFillOpacity]=\"rangeFillOpacity\"\n              [hasRange]=\"hasRange\"\n              [animations]=\"animations\"\n            />\n          </svg:g>\n\n          <svg:g *ngIf=\"!tooltipDisabled\" (mouseleave)=\"hideCircles()\">\n            <svg:g\n              ngx-charts-tooltip-area\n              [dims]=\"dims\"\n              [xSet]=\"xSet\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [results]=\"results\"\n              [colors]=\"colors\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"seriesTooltipTemplate\"\n              (hover)=\"updateHoveredVertical($event)\"\n            />\n\n            <svg:g *ngFor=\"let series of results\">\n              <svg:g\n                ngx-charts-circle-series\n                [xScale]=\"xScale\"\n                [yScale]=\"yScale\"\n                [colors]=\"colors\"\n                [data]=\"series\"\n                [scaleType]=\"scaleType\"\n                [visibleValue]=\"hoveredVertical\"\n                [activeEntries]=\"activeEntries\"\n                [tooltipDisabled]=\"tooltipDisabled\"\n                [tooltipTemplate]=\"tooltipTemplate\"\n                (select)=\"onClick($event)\"\n                (activate)=\"onActivate($event)\"\n                (deactivate)=\"onDeactivate($event)\"\n              />\n            </svg:g>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n      <svg:g\n        ngx-charts-timeline\n        *ngIf=\"timeline && scaleType != 'ordinal'\"\n        [attr.transform]=\"timelineTransform\"\n        [results]=\"results\"\n        [view]=\"[timelineWidth, height]\"\n        [height]=\"timelineHeight\"\n        [scheme]=\"scheme\"\n        [customColors]=\"customColors\"\n        [scaleType]=\"scaleType\"\n        [legend]=\"legend\"\n        (onDomainChange)=\"updateDomain($event)\"\n      >\n        <svg:g *ngFor=\"let series of results; trackBy: trackBy\">\n          <svg:g\n            ngx-charts-line-series\n            [xScale]=\"timelineXScale\"\n            [yScale]=\"timelineYScale\"\n            [colors]=\"colors\"\n            [data]=\"series\"\n            [scaleType]=\"scaleType\"\n            [curve]=\"curve\"\n            [hasRange]=\"hasRange\"\n            [animations]=\"animations\"\n          />\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({
                                opacity: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], null, { hideCircles: [{
            type: HostListener,
            args: ['mouseleave']
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], timeline: [{
            type: Input
        }], gradient: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], trimXAxisTicks: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], rotateXAxisTicks: [{
            type: Input
        }], maxXAxisTickLength: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], xAxisTicks: [{
            type: Input
        }], yAxisTicks: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], showRefLines: [{
            type: Input
        }], referenceLines: [{
            type: Input
        }], showRefLabels: [{
            type: Input
        }], xScaleMin: [{
            type: Input
        }], xScaleMax: [{
            type: Input
        }], yScaleMin: [{
            type: Input
        }], yScaleMax: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], seriesTooltipTemplate: [{
            type: ContentChild,
            args: ['seriesTooltipTemplate', { static: false }]
        }] }); })();
    return LineChartComponent;
}(BaseChartComponent));

var LineSeriesComponent = /** @class */ (function () {
    function LineSeriesComponent() {
        this.animations = true;
    }
    LineSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    LineSeriesComponent.prototype.update = function () {
        this.updateGradients();
        var data = this.sortData(this.data.series);
        var lineGen = this.getLineGenerator();
        this.path = lineGen(data) || '';
        var areaGen = this.getAreaGenerator();
        this.areaPath = areaGen(data) || '';
        if (this.hasRange) {
            var range$$1 = this.getRangeGenerator();
            this.outerPath = range$$1(data) || '';
        }
        if (this.hasGradient) {
            this.stroke = this.gradientUrl;
            var values = this.data.series.map(function (d) { return d.value; });
            var max$$1 = Math.max.apply(Math, values);
            var min$$1 = Math.min.apply(Math, values);
            if (max$$1 === min$$1) {
                this.stroke = this.colors.getColor(max$$1);
            }
        }
        else {
            this.stroke = this.colors.getColor(this.data.name);
        }
    };
    LineSeriesComponent.prototype.getLineGenerator = function () {
        var _this = this;
        return line()
            .x(function (d) {
            var label = d.name;
            var value;
            if (_this.scaleType === 'time') {
                value = _this.xScale(label);
            }
            else if (_this.scaleType === 'linear') {
                value = _this.xScale(Number(label));
            }
            else {
                value = _this.xScale(label);
            }
            return value;
        })
            .y(function (d) { return _this.yScale(d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.getRangeGenerator = function () {
        var _this = this;
        return area()
            .x(function (d) {
            var label = d.name;
            var value;
            if (_this.scaleType === 'time') {
                value = _this.xScale(label);
            }
            else if (_this.scaleType === 'linear') {
                value = _this.xScale(Number(label));
            }
            else {
                value = _this.xScale(label);
            }
            return value;
        })
            .y0(function (d) { return _this.yScale(typeof d.min === 'number' ? d.min : d.value); })
            .y1(function (d) { return _this.yScale(typeof d.max === 'number' ? d.max : d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.getAreaGenerator = function () {
        var _this = this;
        var xProperty = function (d) {
            var label = d.name;
            return _this.xScale(label);
        };
        return area()
            .x(xProperty)
            .y0(function () { return _this.yScale.range()[0]; })
            .y1(function (d) { return _this.yScale(d.value); })
            .curve(this.curve);
    };
    LineSeriesComponent.prototype.sortData = function (data) {
        if (this.scaleType === 'linear') {
            data = sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            data = sortByTime(data, 'name');
        }
        else {
            data = sortByDomain(data, 'name', 'asc', this.xScale.domain());
        }
        return data;
    };
    LineSeriesComponent.prototype.updateGradients = function () {
        if (this.colors.scaleType === 'linear') {
            this.hasGradient = true;
            this.gradientId = 'grad' + id().toString();
            this.gradientUrl = "url(#" + this.gradientId + ")";
            var values = this.data.series.map(function (d) { return d.value; });
            var max$$1 = Math.max.apply(Math, values);
            var min$$1 = Math.min.apply(Math, values);
            this.gradientStops = this.colors.getLinearGradientStops(max$$1, min$$1);
            this.areaGradientStops = this.colors.getLinearGradientStops(max$$1);
        }
        else {
            this.hasGradient = false;
            this.gradientStops = undefined;
            this.areaGradientStops = undefined;
        }
    };
    LineSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    LineSeriesComponent.prototype.isInactive = function (entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item === undefined;
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LineSeriesComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], LineSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LineSeriesComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineSeriesComponent.prototype, "hasRange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], LineSeriesComponent.prototype, "animations", void 0);
LineSeriesComponent.ɵfac = function LineSeriesComponent_Factory(t) { return new (t || LineSeriesComponent)(); };
LineSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LineSeriesComponent, selectors: [["g", "ngx-charts-line-series", ""]], inputs: { animations: "animations", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", curve: "curve", activeEntries: "activeEntries", rangeFillOpacity: "rangeFillOpacity", hasRange: "hasRange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c37, decls: 6, vars: 22, consts: [["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops", 4, "ngIf"], ["ngx-charts-area", "", 1, "line-highlight", 3, "data", "path", "fill", "opacity", "startOpacity", "gradient", "stops", "animations"], ["ngx-charts-line", "", 1, "line-series", 3, "data", "path", "stroke", "animations"], ["ngx-charts-area", "", "class", "line-series-range", 3, "data", "path", "fill", "active", "inactive", "opacity", "animations", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], ["ngx-charts-area", "", 1, "line-series-range", 3, "data", "path", "fill", "opacity", "animations"]], template: function LineSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵtemplate(2, LineSeriesComponent__svg_g_2_Template, 1, 2, "g", 0);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "g", 1);
        ɵngcc0.ɵɵelement(4, "g", 2);
        ɵngcc0.ɵɵtemplate(5, LineSeriesComponent__svg_g_5_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.areaPath)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.colors.getColor(ctx.data.name))("opacity", 0.25)("startOpacity", 0)("gradient", true)("stops", ctx.areaGradientStops)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
        ɵngcc0.ɵɵproperty("data", ctx.data)("path", ctx.path)("stroke", ctx.stroke)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasRange);
    } }, directives: [ɵngcc1.NgIf, AreaComponent, LineComponent, SvgLinearGradientComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LineSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-line-series]',
                template: "\n    <svg:g>\n      <defs>\n        <svg:g ngx-charts-svg-linear-gradient *ngIf=\"hasGradient\"\n          orientation=\"vertical\"\n          [name]=\"gradientId\"\n          [stops]=\"gradientStops\"\n        />\n      </defs>\n      <svg:g ngx-charts-area\n        class=\"line-highlight\"\n        [data]=\"data\"\n        [path]=\"areaPath\"\n        [fill]=\"hasGradient ? gradientUrl : colors.getColor(data.name)\"\n        [opacity]=\"0.25\"\n        [startOpacity]=\"0\"\n        [gradient]=\"true\"\n        [stops]=\"areaGradientStops\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n        [animations]=\"animations\"\n      />\n      <svg:g ngx-charts-line\n        class=\"line-series\"\n        [data]=\"data\"\n        [path]=\"path\"\n        [stroke]=\"stroke\"\n        [animations]=\"animations\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n      />\n     <svg:g ngx-charts-area\n        *ngIf=\"hasRange\"\n        class=\"line-series-range\"\n        [data]=\"data\"\n        [path]=\"outerPath\"\n        [fill]=\"hasGradient ? gradientUrl : colors.getColor(data.name)\"\n        [class.active]=\"isActive(data)\"\n        [class.inactive]=\"isInactive(data)\"\n        [opacity]=\"rangeFillOpacity\"\n        [animations]=\"animations\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { animations: [{
            type: Input
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], hasRange: [{
            type: Input
        }] }); })();
    return LineSeriesComponent;
}());

var LineChartModule = /** @class */ (function () {
    function LineChartModule() {
    }
LineChartModule.ɵfac = function LineChartModule_Factory(t) { return new (t || LineChartModule)(); };
LineChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LineChartModule });
LineChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LineChartModule, { declarations: [LineComponent, LineChartComponent, LineSeriesComponent], imports: [ChartCommonModule], exports: [LineComponent, LineChartComponent, LineSeriesComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LineChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    LineComponent,
                    LineChartComponent,
                    LineSeriesComponent
                ],
                exports: [
                    LineComponent,
                    LineChartComponent,
                    LineSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return LineChartModule;
}());

var twoPI = 2 * Math.PI;
var PolarChartComponent = /** @class */ (function (_super) {
    __extends(PolarChartComponent, _super);
    function PolarChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.showGridLines = true;
        _this.curve = curveCardinalClosed;
        _this.activeEntries = [];
        _this.rangeFillOpacity = 0.15;
        _this.trimYAxisTicks = true;
        _this.maxYAxisTickLength = 16;
        _this.roundDomains = false;
        _this.tooltipDisabled = false;
        _this.showSeriesOnHover = true;
        _this.gradient = false;
        _this.yAxisMinScale = 0;
        _this.labelTrim = true;
        _this.labelTrimSize = 10;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [10, 20, 10, 20];
        _this.xAxisHeight = 0;
        _this.yAxisWidth = 0;
        return _this;
    }
    PolarChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.setDims();
        this.setScales();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        this.setTicks();
    };
    PolarChartComponent.prototype.setDims = function () {
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
            legendPosition: this.legendPosition
        });
        var halfWidth = Math.floor(this.dims.width / 2);
        var halfHeight = Math.floor(this.dims.height / 2);
        var outerRadius = (this.outerRadius = Math.min(halfHeight / 1.5, halfWidth / 1.5));
        var yOffset = Math.max(0, halfHeight - outerRadius);
        this.yAxisDims = __assign({}, this.dims, { width: halfWidth });
        this.transform = "translate(" + this.dims.xOffset + ", " + this.margin[0] + ")";
        this.transformYAxis = "translate(0, " + yOffset + ")";
        this.labelOffset = this.dims.height + 40;
        this.transformPlot = "translate(" + halfWidth + ", " + halfHeight + ")";
    };
    PolarChartComponent.prototype.setScales = function () {
        var xValues = this.getXValues();
        this.scaleType = getScaleType(xValues);
        this.xDomain = this.filteredDomain || this.getXDomain(xValues);
        this.yDomain = this.getYDomain();
        this.seriesDomain = this.getSeriesDomain();
        this.xScale = this.getXScale(this.xDomain, twoPI);
        this.yScale = this.getYScale(this.yDomain, this.outerRadius);
        this.yAxisScale = this.getYScale(this.yDomain.reverse(), this.outerRadius);
    };
    PolarChartComponent.prototype.setTicks = function () {
        var _this = this;
        var tickFormat;
        if (this.xAxisTickFormatting) {
            tickFormat = this.xAxisTickFormatting;
        }
        else if (this.xScale.tickFormat) {
            tickFormat = this.xScale.tickFormat.apply(this.xScale, [5]);
        }
        else {
            tickFormat = function (d) {
                if (isDate(d)) {
                    return d.toLocaleDateString();
                }
                return d.toLocaleString();
            };
        }
        var outerRadius = this.outerRadius;
        var s = 1.1;
        this.thetaTicks = this.xDomain.map(function (d) {
            var startAngle = _this.xScale(d);
            var dd = s * outerRadius * (startAngle > Math.PI ? -1 : 1);
            var label = tickFormat(d);
            var startPos = [outerRadius * Math.sin(startAngle), -outerRadius * Math.cos(startAngle)];
            var pos = [dd, s * startPos[1]];
            return {
                innerRadius: 0,
                outerRadius: outerRadius,
                startAngle: startAngle,
                endAngle: startAngle,
                value: outerRadius,
                label: label,
                startPos: startPos,
                pos: pos
            };
        });
        var minDistance = 10;
        for (var i = 0; i < this.thetaTicks.length - 1; i++) {
            var a = this.thetaTicks[i];
            for (var j = i + 1; j < this.thetaTicks.length; j++) {
                var b = this.thetaTicks[j];
                if (b.pos[0] * a.pos[0] > 0) {
                    var o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
                    if (o > 0) {
                        b.pos[1] += Math.sign(b.pos[0]) * o;
                    }
                }
            }
        }
        this.radiusTicks = this.yAxisScale.ticks(Math.floor(this.dims.height / 50)).map(function (d) { return _this.yScale(d); });
    };
    PolarChartComponent.prototype.getXValues = function () {
        var values = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (!values.includes(d.name)) {
                    values.push(d.name);
                }
            }
        }
        return values;
    };
    PolarChartComponent.prototype.getXDomain = function (values) {
        if (values === void 0) { values = this.getXValues(); }
        if (this.scaleType === 'time') {
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            return [min$$1, max$$1];
        }
        else if (this.scaleType === 'linear') {
            values = values.map(function (v) { return Number(v); });
            var min$$1 = Math.min.apply(Math, values);
            var max$$1 = Math.max.apply(Math, values);
            return [min$$1, max$$1];
        }
        return values;
    };
    PolarChartComponent.prototype.getYValues = function () {
        var domain = [];
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var results = _a[_i];
            for (var _b = 0, _c = results.series; _b < _c.length; _b++) {
                var d = _c[_b];
                if (domain.indexOf(d.value) < 0) {
                    domain.push(d.value);
                }
                if (d.min !== undefined) {
                    if (domain.indexOf(d.min) < 0) {
                        domain.push(d.min);
                    }
                }
                if (d.max !== undefined) {
                    if (domain.indexOf(d.max) < 0) {
                        domain.push(d.max);
                    }
                }
            }
        }
        return domain;
    };
    PolarChartComponent.prototype.getYDomain = function (domain) {
        if (domain === void 0) { domain = this.getYValues(); }
        var min$$1 = Math.min.apply(Math, domain);
        var max$$1 = Math.max.apply(Math, [this.yAxisMinScale].concat(domain));
        min$$1 = Math.max(0, min$$1);
        if (!this.autoScale) {
            min$$1 = Math.min(0, min$$1);
        }
        return [min$$1, max$$1];
    };
    PolarChartComponent.prototype.getSeriesDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    PolarChartComponent.prototype.getXScale = function (domain, width) {
        switch (this.scaleType) {
            case 'time':
                return scaleTime()
                    .range([0, width])
                    .domain(domain);
            case 'linear':
                var scale = scaleLinear()
                    .range([0, width])
                    .domain(domain);
                return this.roundDomains ? scale.nice() : scale;
            default:
                return scalePoint()
                    .range([0, width - twoPI / domain.length])
                    .padding(0)
                    .domain(domain);
        }
    };
    PolarChartComponent.prototype.getYScale = function (domain, height) {
        var scale = scaleLinear()
            .range([0, height])
            .domain(domain);
        return this.roundDomains ? scale.nice() : scale;
    };
    PolarChartComponent.prototype.onClick = function (data, series) {
        if (series) {
            data.series = series.name;
        }
        this.select.emit(data);
    };
    PolarChartComponent.prototype.setColors = function () {
        var domain = this.schemeType === 'ordinal' ? this.seriesDomain : this.yDomain.reverse();
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    };
    PolarChartComponent.prototype.getLegendOptions = function () {
        if (this.schemeType === 'ordinal') {
            return {
                scaleType: this.schemeType,
                colors: this.colors,
                domain: this.seriesDomain,
                title: this.legendTitle,
                position: this.legendPosition
            };
        }
        return {
            scaleType: this.schemeType,
            colors: this.colors.scale,
            domain: this.yDomain,
            title: undefined,
            position: this.legendPosition
        };
    };
    PolarChartComponent.prototype.updateYAxisWidth = function (_a) {
        var width = _a.width;
        this.yAxisWidth = width;
        this.update();
    };
    PolarChartComponent.prototype.updateXAxisHeight = function (_a) {
        var height = _a.height;
        this.xAxisHeight = height;
        this.update();
    };
    PolarChartComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = this.showSeriesOnHover ? [item].concat(this.activeEntries) : this.activeEntries;
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    PolarChartComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    PolarChartComponent.prototype.deactivateAll = function () {
        this.activeEntries = this.activeEntries.slice();
        for (var _i = 0, _a = this.activeEntries; _i < _a.length; _i++) {
            var entry = _a[_i];
            this.deactivate.emit({ value: entry, entries: [] });
        }
        this.activeEntries = [];
    };
    PolarChartComponent.prototype.trackBy = function (index, item) {
        return item.name;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "xAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "yAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showXAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showYAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "xAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "yAxisLabel", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "autoScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showGridLines", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarChartComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PolarChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PolarChartComponent.prototype, "schemeType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "trimYAxisTicks", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "maxYAxisTickLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PolarChartComponent.prototype, "xAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PolarChartComponent.prototype, "yAxisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "roundDomains", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "showSeriesOnHover", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "yAxisMinScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarChartComponent.prototype, "labelTrim", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarChartComponent.prototype, "labelTrimSize", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], PolarChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], PolarChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], PolarChartComponent.prototype, "tooltipTemplate", void 0);
PolarChartComponent.ɵfac = function PolarChartComponent_Factory(t) { return ɵPolarChartComponent_BaseFactory(t || PolarChartComponent); };
PolarChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PolarChartComponent, selectors: [["ngx-charts-polar-chart"]], contentQueries: function PolarChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", autoScale: "autoScale", showGridLines: "showGridLines", curve: "curve", schemeType: "schemeType", rangeFillOpacity: "rangeFillOpacity", trimYAxisTicks: "trimYAxisTicks", maxYAxisTickLength: "maxYAxisTickLength", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", roundDomains: "roundDomains", tooltipDisabled: "tooltipDisabled", showSeriesOnHover: "showSeriesOnHover", gradient: "gradient", yAxisMinScale: "yAxisMinScale", labelTrim: "labelTrim", labelTrimSize: "labelTrimSize" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 18, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "polar-chart", "chart"], ["cx", "0", "cy", "0", 1, "polar-chart-background"], [4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "gridline-path radial-gridline-path", "cx", "0", "cy", "0", 4, "ngFor", "ngForOf"], ["cx", "0", "cy", "0", 1, "gridline-path", "radial-gridline-path"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize", 4, "ngFor", "ngForOf"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "dimensionsChanged"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"], ["ngx-charts-polar-series", "", 3, "gradient", "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "animations", "tooltipDisabled", "tooltipTemplate", "select", "activate", "deactivate"]], template: function PolarChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function PolarChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g");
        ɵngcc0.ɵɵelement(3, "circle", 2);
        ɵngcc0.ɵɵtemplate(4, PolarChartComponent__svg_g_4_Template, 2, 1, "g", 3);
        ɵngcc0.ɵɵtemplate(5, PolarChartComponent__svg_g_5_Template, 2, 1, "g", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, PolarChartComponent__svg_g_6_Template, 1, 9, "g", 4);
        ɵngcc0.ɵɵtemplate(7, PolarChartComponent__svg_g_7_Template, 1, 5, "g", 5);
        ɵngcc0.ɵɵelementStart(8, "g");
        ɵngcc0.ɵɵtemplate(9, PolarChartComponent__svg_g_9_Template, 2, 13, "g", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(15, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transformPlot);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("r", ctx.outerRadius);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showGridLines);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.yAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.xAxis && ctx.showXAxisLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transformPlot);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgIf, ɵngcc1.NgForOf, PieLabelComponent, YAxisComponent, AxisLabelComponent, PolarSeriesComponent]; }, styles: [_c24, _c41, ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area{pointer-events:none}.polar-series-path{pointer-events:none}"], encapsulation: 2, data: { animation: [
            trigger('animationState', [
                transition(':leave', [
                    style({
                        opacity: 1
                    }),
                    animate(500, style({
                        opacity: 0
                    }))
                ])
            ])
        ] }, changeDetection: 0 });
var ɵPolarChartComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(PolarChartComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PolarChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-polar-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:g class=\"polar-chart chart\" [attr.transform]=\"transform\">\n        <svg:g [attr.transform]=\"transformPlot\">\n          <svg:circle class=\"polar-chart-background\" cx=\"0\" cy=\"0\" [attr.r]=\"this.outerRadius\" />\n          <svg:g *ngIf=\"showGridLines\">\n            <svg:circle\n              *ngFor=\"let r of radiusTicks\"\n              class=\"gridline-path radial-gridline-path\"\n              cx=\"0\"\n              cy=\"0\"\n              [attr.r]=\"r\"\n            />\n          </svg:g>\n          <svg:g *ngIf=\"xAxis\">\n            <svg:g\n              ngx-charts-pie-label\n              *ngFor=\"let tick of thetaTicks\"\n              [data]=\"tick\"\n              [radius]=\"outerRadius\"\n              [label]=\"tick.label\"\n              [max]=\"outerRadius\"\n              [value]=\"showGridLines ? 1 : outerRadius\"\n              [explodeSlices]=\"true\"\n              [animations]=\"animations\"\n              [labelTrim]=\"labelTrim\"\n              [labelTrimSize]=\"labelTrimSize\"\n            ></svg:g>\n          </svg:g>\n        </svg:g>\n        <svg:g\n          ngx-charts-y-axis\n          [attr.transform]=\"transformYAxis\"\n          *ngIf=\"yAxis\"\n          [yScale]=\"yAxisScale\"\n          [dims]=\"yAxisDims\"\n          [showGridLines]=\"showGridLines\"\n          [showLabel]=\"showYAxisLabel\"\n          [labelText]=\"yAxisLabel\"\n          [trimTicks]=\"trimYAxisTicks\"\n          [maxTickLength]=\"maxYAxisTickLength\"\n          [tickFormatting]=\"yAxisTickFormatting\"\n          (dimensionsChanged)=\"updateYAxisWidth($event)\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-axis-label\n          *ngIf=\"xAxis && showXAxisLabel\"\n          [label]=\"xAxisLabel\"\n          [offset]=\"labelOffset\"\n          [orient]=\"'bottom'\"\n          [height]=\"dims.height\"\n          [width]=\"dims.width\"\n        ></svg:g>\n        <svg:g [attr.transform]=\"transformPlot\">\n          <svg:g *ngFor=\"let series of results; trackBy: trackBy\" [@animationState]=\"'active'\">\n            <svg:g\n              ngx-charts-polar-series\n              [gradient]=\"gradient\"\n              [xScale]=\"xScale\"\n              [yScale]=\"yScale\"\n              [colors]=\"colors\"\n              [data]=\"series\"\n              [activeEntries]=\"activeEntries\"\n              [scaleType]=\"scaleType\"\n              [curve]=\"curve\"\n              [rangeFillOpacity]=\"rangeFillOpacity\"\n              [animations]=\"animations\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              (select)=\"onClick($event)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n            />\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [
                    ".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}",
                    ".pie-label{font-size:11px}.pie-label.animation{animation:750ms ease-in fadeIn}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d 750ms}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}",
                    ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area{pointer-events:none}.polar-series-path{pointer-events:none}"
                ],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    trigger('animationState', [
                        transition(':leave', [
                            style({
                                opacity: 1
                            }),
                            animate(500, style({
                                opacity: 0
                            }))
                        ])
                    ])
                ]
            }]
    }], null, { activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], xAxis: [{
            type: Input
        }], yAxis: [{
            type: Input
        }], showXAxisLabel: [{
            type: Input
        }], showYAxisLabel: [{
            type: Input
        }], xAxisLabel: [{
            type: Input
        }], yAxisLabel: [{
            type: Input
        }], autoScale: [{
            type: Input
        }], showGridLines: [{
            type: Input
        }], curve: [{
            type: Input
        }], schemeType: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], trimYAxisTicks: [{
            type: Input
        }], maxYAxisTickLength: [{
            type: Input
        }], xAxisTickFormatting: [{
            type: Input
        }], yAxisTickFormatting: [{
            type: Input
        }], roundDomains: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], showSeriesOnHover: [{
            type: Input
        }], gradient: [{
            type: Input
        }], yAxisMinScale: [{
            type: Input
        }], labelTrim: [{
            type: Input
        }], labelTrimSize: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return PolarChartComponent;
}(BaseChartComponent));

var PolarSeriesComponent = /** @class */ (function () {
    function PolarSeriesComponent() {
        this.tooltipDisabled = false;
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.circleRadius = 3;
    }
    PolarSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PolarSeriesComponent.prototype.update = function () {
        var _this = this;
        this.updateGradients();
        var line$$1 = this.getLineGenerator();
        var data = this.sortData(this.data.series);
        var seriesName = this.data.name;
        var linearScaleType = this.colors.scaleType === 'linear';
        var min$$1 = this.yScale.domain()[0];
        this.seriesColor = this.colors.getColor(linearScaleType ? min$$1 : seriesName);
        this.path = line$$1(data) || '';
        this.circles = data.map(function (d) {
            var a = _this.getAngle(d);
            var r = _this.getRadius(d);
            var value = d.value;
            var color = _this.colors.getColor(linearScaleType ? Math.abs(value) : seriesName);
            var cData = Object.assign({}, d, {
                series: seriesName,
                value: value,
                name: d.name
            });
            return {
                data: cData,
                cx: r * Math.sin(a),
                cy: -r * Math.cos(a),
                value: value,
                color: color,
                label: d.name
            };
        });
        this.active = this.isActive(this.data);
        this.inactive = this.isInactive(this.data);
        this.tooltipText = this.tooltipText || (function (c) { return _this.defaultTooltipText(c); });
    };
    PolarSeriesComponent.prototype.getAngle = function (d) {
        var label = d.name;
        if (this.scaleType === 'time') {
            return this.xScale(label);
        }
        else if (this.scaleType === 'linear') {
            return this.xScale(Number(label));
        }
        return this.xScale(label);
    };
    PolarSeriesComponent.prototype.getRadius = function (d) {
        return this.yScale(d.value);
    };
    PolarSeriesComponent.prototype.getLineGenerator = function () {
        var _this = this;
        return lineRadial()
            .angle(function (d) { return _this.getAngle(d); })
            .radius(function (d) { return _this.getRadius(d); })
            .curve(this.curve);
    };
    PolarSeriesComponent.prototype.sortData = function (data) {
        if (this.scaleType === 'linear') {
            return sortLinear(data, 'name');
        }
        else if (this.scaleType === 'time') {
            return sortByTime(data, 'name');
        }
        return sortByDomain(data, 'name', 'asc', this.xScale.domain());
    };
    PolarSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item !== undefined;
    };
    PolarSeriesComponent.prototype.isInactive = function (entry) {
        if (!this.activeEntries || this.activeEntries.length === 0)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name;
        });
        return item === undefined;
    };
    PolarSeriesComponent.prototype.defaultTooltipText = function (_a) {
        var label = _a.label, value = _a.value;
        return "\n      <span class=\"tooltip-label\">" + this.data.name + " \u2022 " + label + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n    ";
    };
    PolarSeriesComponent.prototype.updateGradients = function () {
        this.hasGradient = this.gradient || this.colors.scaleType === 'linear';
        if (!this.hasGradient) {
            return;
        }
        this.gradientId = 'grad' + id().toString();
        this.gradientUrl = "url(#" + this.gradientId + ")";
        if (this.colors.scaleType === 'linear') {
            var values = this.data.series.map(function (d) { return d.value; });
            var max$$1 = Math.max.apply(Math, values);
            var min$$1 = Math.min.apply(Math, values);
            this.gradientStops = this.colors.getLinearGradientStops(max$$1, min$$1);
        }
        else {
            this.gradientStops = undefined;
        }
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "name", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "xScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "yScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "scaleType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "curve", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PolarSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PolarSeriesComponent.prototype, "rangeFillOpacity", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PolarSeriesComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], PolarSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PolarSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PolarSeriesComponent.prototype, "deactivate", void 0);
PolarSeriesComponent.ɵfac = function PolarSeriesComponent_Factory(t) { return new (t || PolarSeriesComponent)(); };
PolarSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PolarSeriesComponent, selectors: [["g", "ngx-charts-polar-series", ""]], inputs: { tooltipDisabled: "tooltipDisabled", gradient: "gradient", animations: "animations", tooltipText: "tooltipText", name: "name", data: "data", xScale: "xScale", yScale: "yScale", colors: "colors", scaleType: "scaleType", curve: "curve", activeEntries: "activeEntries", rangeFillOpacity: "rangeFillOpacity", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c38, decls: 5, vars: 11, consts: [[1, "polar-charts-series"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity", "endOpacity", "stops", 4, "ngIf"], ["ngx-charts-line", "", 1, "polar-series-path", 3, "path", "stroke", "fill", "animations"], ["ngx-charts-circle", "", "class", "circle", "ngx-tooltip", "", "tooltipType", "tooltip", 3, "cx", "cy", "r", "fill", "opacity", "tooltipDisabled", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity", "endOpacity", "stops"], ["ngx-charts-circle", "", "ngx-tooltip", "", "tooltipType", "tooltip", 1, "circle", 3, "cx", "cy", "r", "fill", "tooltipDisabled", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function PolarSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "defs");
        ɵngcc0.ɵɵtemplate(2, PolarSeriesComponent__svg_g_2_Template, 1, 5, "g", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "g", 2);
        ɵngcc0.ɵɵtemplate(4, PolarSeriesComponent__svg_g_4_Template, 1, 11, "g", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasGradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("active", ctx.active)("inactive", ctx.inactive);
        ɵngcc0.ɵɵproperty("path", ctx.path)("stroke", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("animations", ctx.animations);
        ɵngcc0.ɵɵattribute("fill-opacity", ctx.rangeFillOpacity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.circles);
    } }, directives: [ɵngcc1.NgIf, LineComponent, ɵngcc1.NgForOf, SvgRadialGradientComponent, CircleComponent, TooltipDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PolarSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-polar-series]',
                template: "\n    <svg:g class=\"polar-charts-series\">\n      <defs>\n        <svg:g\n          ngx-charts-svg-radial-gradient\n          *ngIf=\"hasGradient\"\n          orientation=\"vertical\"\n          [color]=\"seriesColor\"\n          [name]=\"gradientId\"\n          [startOpacity]=\"0.25\"\n          [endOpacity]=\"1\"\n          [stops]=\"gradientStops\"\n        />\n      </defs>\n      <svg:g\n        ngx-charts-line\n        class=\"polar-series-path\"\n        [path]=\"path\"\n        [stroke]=\"hasGradient ? gradientUrl : seriesColor\"\n        [class.active]=\"active\"\n        [class.inactive]=\"inactive\"\n        [attr.fill-opacity]=\"rangeFillOpacity\"\n        [fill]=\"hasGradient ? gradientUrl : seriesColor\"\n        [animations]=\"animations\"\n      />\n      <svg:g\n        ngx-charts-circle\n        *ngFor=\"let circle of circles\"\n        class=\"circle\"\n        [cx]=\"circle.cx\"\n        [cy]=\"circle.cy\"\n        [r]=\"circleRadius\"\n        [fill]=\"circle.color\"\n        [style.opacity]=\"inactive ? 0.2 : 1\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        tooltipType=\"tooltip\"\n        [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(circle)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"circle.data\"\n        (select)=\"select.emit(circle.data)\"\n        (activate)=\"activate.emit({ name: circle.data.series })\"\n        (deactivate)=\"deactivate.emit({ name: circle.data.series })\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { tooltipDisabled: [{
            type: Input
        }], gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipText: [{
            type: Input
        }], name: [{
            type: Input
        }], data: [{
            type: Input
        }], xScale: [{
            type: Input
        }], yScale: [{
            type: Input
        }], colors: [{
            type: Input
        }], scaleType: [{
            type: Input
        }], curve: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], rangeFillOpacity: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return PolarSeriesComponent;
}());

var AdvancedPieChartComponent = /** @class */ (function (_super) {
    __extends(AdvancedPieChartComponent, _super);
    function AdvancedPieChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.label = 'Total';
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [20, 20, 20, 20];
        return _this;
    }
    AdvancedPieChartComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: (this.width * 4) / 12.0,
            height: this.height,
            margins: this.margin
        });
        this.formatDates();
        this.domain = this.getDomain();
        this.setColors();
        var xOffset = this.dims.width / 2;
        var yOffset = this.margin[0] + this.dims.height / 2;
        this.legendWidth = this.width - this.dims.width - this.margin[1];
        this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2.5;
        this.innerRadius = this.outerRadius * 0.75;
        this.transform = "translate(" + xOffset + " , " + yOffset + ")";
    };
    AdvancedPieChartComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    AdvancedPieChartComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    AdvancedPieChartComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    AdvancedPieChartComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    AdvancedPieChartComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AdvancedPieChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], AdvancedPieChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], AdvancedPieChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], AdvancedPieChartComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], AdvancedPieChartComponent.prototype, "label", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], AdvancedPieChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], AdvancedPieChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], AdvancedPieChartComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedPieChartComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedPieChartComponent.prototype, "nameFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], AdvancedPieChartComponent.prototype, "percentageFormatting", void 0);
AdvancedPieChartComponent.ɵfac = function AdvancedPieChartComponent_Factory(t) { return ɵAdvancedPieChartComponent_BaseFactory(t || AdvancedPieChartComponent); };
AdvancedPieChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AdvancedPieChartComponent, selectors: [["ngx-charts-advanced-pie-chart"]], contentQueries: function AdvancedPieChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { activeEntries: "activeEntries", gradient: "gradient", tooltipDisabled: "tooltipDisabled", tooltipText: "tooltipText", label: "label", valueFormatting: "valueFormatting", nameFormatting: "nameFormatting", percentageFormatting: "percentageFormatting" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 7, vars: 37, consts: [[1, "advanced-pie", "chart"], [3, "view", "showLegend", "animations"], [1, "pie", "chart"], ["ngx-charts-pie-series", "", 3, "colors", "series", "innerRadius", "activeEntries", "outerRadius", "gradient", "tooltipDisabled", "tooltipTemplate", "tooltipText", "animations", "select", "activate", "deactivate"], [1, "advanced-pie-legend-wrapper"], [3, "data", "colors", "width", "label", "animations", "valueFormatting", "labelFormatting", "percentageFormatting", "select", "activate", "deactivate"]], template: function AdvancedPieChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵelementStart(2, "ngx-charts-chart", 1);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(3, "g", 2);
        ɵngcc0.ɵɵelementStart(4, "g", 3);
        ɵngcc0.ɵɵlistener("select", function AdvancedPieChartComponent_Template__svg_g_select_4_listener($event) { return ctx.onClick($event); })("activate", function AdvancedPieChartComponent_Template__svg_g_activate_4_listener($event) { return ctx.onActivate($event); })("deactivate", function AdvancedPieChartComponent_Template__svg_g_deactivate_4_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "ngx-charts-advanced-legend", 5);
        ɵngcc0.ɵɵlistener("select", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_select_6_listener($event) { return ctx.onClick($event); })("activate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_activate_6_listener($event) { return ctx.onActivate($event, undefined, true); })("deactivate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_deactivate_6_listener($event) { return ctx.onDeactivate($event, undefined, true); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px")("height", ctx.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.dims.width, "px")("height", ctx.dims.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(34, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("series", ctx.results)("innerRadius", ctx.innerRadius)("activeEntries", ctx.activeEntries)("outerRadius", ctx.outerRadius)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.width - ctx.dims.width, "px")("height", ctx.height, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("data", ctx.results)("colors", ctx.colors)("width", ctx.width - ctx.dims.width - ctx.margin[1])("label", ctx.label)("animations", ctx.animations)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.nameFormatting)("percentageFormatting", ctx.percentageFormatting);
    } }, directives: function () { return [ChartComponent, PieSeriesComponent, AdvancedLegendComponent]; }, styles: [_c24, ".advanced-pie{display:inline-block;float:left}.advanced-pie-legend-wrapper{display:inline-block}"], encapsulation: 2, changeDetection: 0 });
var ɵAdvancedPieChartComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(AdvancedPieChartComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AdvancedPieChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-advanced-pie-chart',
                template: "\n    <div [style.width.px]=\"width\" [style.height.px]=\"height\">\n      <div class=\"advanced-pie chart\" [style.width.px]=\"dims.width\" [style.height.px]=\"dims.height\">\n        <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n          <svg:g [attr.transform]=\"transform\" class=\"pie chart\">\n            <svg:g\n              ngx-charts-pie-series\n              [colors]=\"colors\"\n              [series]=\"results\"\n              [innerRadius]=\"innerRadius\"\n              [activeEntries]=\"activeEntries\"\n              [outerRadius]=\"outerRadius\"\n              [gradient]=\"gradient\"\n              [tooltipDisabled]=\"tooltipDisabled\"\n              [tooltipTemplate]=\"tooltipTemplate\"\n              [tooltipText]=\"tooltipText\"\n              (select)=\"onClick($event)\"\n              (activate)=\"onActivate($event)\"\n              (deactivate)=\"onDeactivate($event)\"\n              [animations]=\"animations\"\n            ></svg:g>\n          </svg:g>\n        </ngx-charts-chart>\n      </div>\n      <div class=\"advanced-pie-legend-wrapper\" [style.width.px]=\"width - dims.width\" [style.height.px]=\"height\">\n        <ngx-charts-advanced-legend\n          [data]=\"results\"\n          [colors]=\"colors\"\n          [width]=\"width - dims.width - margin[1]\"\n          [label]=\"label\"\n          [animations]=\"animations\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"nameFormatting\"\n          [percentageFormatting]=\"percentageFormatting\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event, undefined, true)\"\n          (deactivate)=\"onDeactivate($event, undefined, true)\"\n        >\n        </ngx-charts-advanced-legend>\n      </div>\n    </div>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".advanced-pie{display:inline-block;float:left}.advanced-pie-legend-wrapper{display:inline-block}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { activeEntries: [{
            type: Input
        }], gradient: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], label: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], valueFormatting: [{
            type: Input
        }], nameFormatting: [{
            type: Input
        }], percentageFormatting: [{
            type: Input
        }] }); })();
    return AdvancedPieChartComponent;
}(BaseChartComponent));

var PieLabelComponent = /** @class */ (function () {
    function PieLabelComponent() {
        this.animations = true;
        this.labelTrim = true;
        this.labelTrimSize = 10;
        this.isIE = /(edge|msie|trident)/i.test(navigator.userAgent);
        this.trimLabel = trimLabel;
    }
    PieLabelComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieLabelComponent.prototype.update = function () {
        var startRadius = this.radius;
        if (this.explodeSlices) {
            startRadius = this.radius * this.value / this.max;
        }
        var innerArc = arc()
            .innerRadius(startRadius)
            .outerRadius(startRadius);
        // Calculate innerPos then scale outer position to match label position
        var innerPos = innerArc.centroid(this.data);
        var scale = this.data.pos[1] / innerPos[1];
        if (this.data.pos[1] === 0 || innerPos[1] === 0) {
            scale = 1;
        }
        var outerPos = [scale * innerPos[0], scale * innerPos[1]];
        this.line = "M" + innerPos + "L" + outerPos + "L" + this.data.pos;
    };
    Object.defineProperty(PieLabelComponent.prototype, "textX", {
        get: function () {
            return this.data.pos[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "textY", {
        get: function () {
            return this.data.pos[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "styleTransform", {
        get: function () {
            return this.isIE ? null : "translate3d(" + this.textX + "px," + this.textY + "px, 0)";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "attrTransform", {
        get: function () {
            return !this.isIE ? null : "translate(" + this.textX + "," + this.textY + ")";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieLabelComponent.prototype, "textTransition", {
        get: function () {
            return this.isIE || !this.animations ? null : 'transform 0.75s';
        },
        enumerable: true,
        configurable: true
    });
    PieLabelComponent.prototype.textAnchor = function () {
        return this.midAngle(this.data) < Math.PI ? 'start' : 'end';
    };
    PieLabelComponent.prototype.midAngle = function (d) {
        return d.startAngle + (d.endAngle - d.startAngle) / 2;
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "radius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieLabelComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieLabelComponent.prototype, "animations", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieLabelComponent.prototype, "labelTrim", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieLabelComponent.prototype, "labelTrimSize", void 0);
    PieLabelComponent = __decorate([ __metadata("design:paramtypes", [])
    ], PieLabelComponent);
PieLabelComponent.ɵfac = function PieLabelComponent_Factory(t) { return new (t || PieLabelComponent)(); };
PieLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieLabelComponent, selectors: [["g", "ngx-charts-pie-label", ""]], inputs: { animations: "animations", labelTrim: "labelTrim", labelTrimSize: "labelTrimSize", data: "data", radius: "radius", label: "label", color: "color", max: "max", value: "value", explodeSlices: "explodeSlices" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c39, decls: 6, vars: 17, consts: [["dy", ".35em", 1, "pie-label"], ["fill", "none", 1, "pie-label-line", "line"]], template: function PieLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "title");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(2, "g");
        ɵngcc0.ɵɵelementStart(3, "text", 0);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "path", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("transform", ctx.styleTransform)("transition", ctx.textTransition);
        ɵngcc0.ɵɵattribute("transform", ctx.attrTransform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", ctx.textAnchor())("shape-rendering", "crispEdges");
        ɵngcc0.ɵɵclassProp("animation", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.labelTrim ? ctx.trimLabel(ctx.label, ctx.labelTrimSize) : ctx.label, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("animation", ctx.animations);
        ɵngcc0.ɵɵattribute("d", ctx.line)("stroke", ctx.color);
    } }, encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieLabelComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-label]',
                template: "\n    <title>{{label}}</title>\n    <svg:g\n      [attr.transform]=\"attrTransform\"\n      [style.transform]=\"styleTransform\"\n      [style.transition]=\"textTransition\">\n      <svg:text\n        class=\"pie-label\"\n        [class.animation]=\"animations\"\n        dy=\".35em\"\n        [style.textAnchor]=\"textAnchor()\"\n        [style.shapeRendering]=\"'crispEdges'\">\n        {{labelTrim ? trimLabel(label, labelTrimSize) : label}}\n      </svg:text>\n    </svg:g>\n    <svg:path\n      [attr.d]=\"line\"\n      [attr.stroke]=\"color\"\n      fill=\"none\"\n      class=\"pie-label-line line\"\n      [class.animation]=\"animations\">\n    </svg:path>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { animations: [{
            type: Input
        }], labelTrim: [{
            type: Input
        }], labelTrimSize: [{
            type: Input
        }], data: [{
            type: Input
        }], radius: [{
            type: Input
        }], label: [{
            type: Input
        }], color: [{
            type: Input
        }], max: [{
            type: Input
        }], value: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }] }); })();
    return PieLabelComponent;
}());

var PieArcComponent = /** @class */ (function () {
    function PieArcComponent(element) {
        this.startAngle = 0;
        this.endAngle = Math.PI * 2;
        this.cornerRadius = 0;
        this.explodeSlices = false;
        this.gradient = false;
        this.animate = true;
        this.pointerEvents = true;
        this.isActive = false;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dblclick = new EventEmitter();
        this.initialized = false;
        this.element = element.nativeElement;
    }
    PieArcComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieArcComponent.prototype.getGradient = function () {
        return this.gradient ? this.gradientFill : this.fill;
    };
    PieArcComponent.prototype.getPointerEvents = function () {
        return this.pointerEvents ? 'auto' : 'none';
    };
    PieArcComponent.prototype.update = function () {
        var calc = this.calculateArc();
        this.startOpacity = 0.5;
        this.radialGradientId = 'linearGrad' + id().toString();
        this.gradientFill = "url(#" + this.radialGradientId + ")";
        if (this.animate) {
            if (this.initialized) {
                this.updateAnimation();
            }
            else {
                this.loadAnimation();
                this.initialized = true;
            }
        }
        else {
            this.path = calc.startAngle(this.startAngle).endAngle(this.endAngle)();
        }
    };
    PieArcComponent.prototype.calculateArc = function () {
        var outerRadius = this.outerRadius;
        if (this.explodeSlices && this.innerRadius === 0) {
            outerRadius = (this.outerRadius * this.value) / this.max;
        }
        return arc()
            .innerRadius(this.innerRadius)
            .outerRadius(outerRadius)
            .cornerRadius(this.cornerRadius);
    };
    PieArcComponent.prototype.loadAnimation = function () {
        var node = select(this.element)
            .selectAll('.arc')
            .data([{ startAngle: this.startAngle, endAngle: this.endAngle }]);
        var calc = this.calculateArc();
        node
            .transition()
            .attrTween('d', function (d) {
            this._current = this._current || d;
            var copyOfD = Object.assign({}, d);
            copyOfD.endAngle = copyOfD.startAngle;
            var interpolater = interpolate(copyOfD, copyOfD);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        })
            .transition()
            .duration(750)
            .attrTween('d', function (d) {
            this._current = this._current || d;
            var interpolater = interpolate(this._current, d);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        });
    };
    PieArcComponent.prototype.updateAnimation = function () {
        var node = select(this.element)
            .selectAll('.arc')
            .data([{ startAngle: this.startAngle, endAngle: this.endAngle }]);
        var calc = this.calculateArc();
        node
            .transition()
            .duration(750)
            .attrTween('d', function (d) {
            this._current = this._current || d;
            var interpolater = interpolate(this._current, d);
            this._current = interpolater(0);
            return function (t) {
                return calc(interpolater(t));
            };
        });
    };
    PieArcComponent.prototype.onClick = function () {
        var _this = this;
        clearTimeout(this._timeout);
        this._timeout = setTimeout(function () { return _this.select.emit(_this.data); }, 200);
    };
    PieArcComponent.prototype.onDblClick = function (event$$1) {
        event$$1.preventDefault();
        event$$1.stopPropagation();
        clearTimeout(this._timeout);
        this.dblclick.emit({
            data: this.data,
            nativeEvent: event$$1
        });
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieArcComponent.prototype, "startAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieArcComponent.prototype, "endAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "innerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "outerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieArcComponent.prototype, "cornerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "animate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "pointerEvents", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieArcComponent.prototype, "isActive", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieArcComponent.prototype, "dblclick", void 0);
    PieArcComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], PieArcComponent);
PieArcComponent.ɵfac = function PieArcComponent_Factory(t) { return new (t || PieArcComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
PieArcComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieArcComponent, selectors: [["g", "ngx-charts-pie-arc", ""]], inputs: { startAngle: "startAngle", endAngle: "endAngle", cornerRadius: "cornerRadius", explodeSlices: "explodeSlices", gradient: "gradient", animate: "animate", pointerEvents: "pointerEvents", isActive: "isActive", fill: "fill", innerRadius: "innerRadius", outerRadius: "outerRadius", value: "value", max: "max", data: "data" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dblclick: "dblclick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c40, decls: 3, vars: 7, consts: [[1, "arc-group"], [4, "ngIf"], [1, "arc", 3, "click", "dblclick", "mouseenter", "mouseleave"], ["ngx-charts-svg-radial-gradient", "", "orientation", "vertical", 3, "color", "name", "startOpacity"]], template: function PieArcComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, PieArcComponent__svg_defs_1_Template, 2, 3, "defs", 1);
        ɵngcc0.ɵɵelementStart(2, "path", 2);
        ɵngcc0.ɵɵlistener("click", function PieArcComponent_Template__svg_path_click_2_listener() { return ctx.onClick(); })("dblclick", function PieArcComponent_Template__svg_path_dblclick_2_listener($event) { return ctx.onDblClick($event); })("mouseenter", function PieArcComponent_Template__svg_path_mouseenter_2_listener() { return ctx.activate.emit(ctx.data); })("mouseleave", function PieArcComponent_Template__svg_path_mouseleave_2_listener() { return ctx.deactivate.emit(ctx.data); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("pointer-events", ctx.getPointerEvents());
        ɵngcc0.ɵɵclassProp("active", ctx.isActive);
        ɵngcc0.ɵɵattribute("d", ctx.path)("fill", ctx.getGradient());
    } }, directives: [ɵngcc1.NgIf, SvgRadialGradientComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieArcComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-arc]',
                template: "\n    <svg:g class=\"arc-group\">\n      <svg:defs *ngIf=\"gradient\">\n        <svg:g ngx-charts-svg-radial-gradient\n          [color]=\"fill\"\n          orientation=\"vertical\"\n          [name]=\"radialGradientId\"\n          [startOpacity]=\"startOpacity\"\n        />\n      </svg:defs>\n      <svg:path\n        [attr.d]=\"path\"\n        class=\"arc\"\n        [class.active]=\"isActive\"\n        [attr.fill]=\"getGradient()\"\n        (click)=\"onClick()\"\n        (dblclick)=\"onDblClick($event)\"\n        (mouseenter)=\"activate.emit(data)\"\n        (mouseleave)=\"deactivate.emit(data)\"\n        [style.pointer-events]=\"getPointerEvents()\"\n      />\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { startAngle: [{
            type: Input
        }], endAngle: [{
            type: Input
        }], cornerRadius: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }], gradient: [{
            type: Input
        }], animate: [{
            type: Input
        }], pointerEvents: [{
            type: Input
        }], isActive: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dblclick: [{
            type: Output
        }], fill: [{
            type: Input
        }], innerRadius: [{
            type: Input
        }], outerRadius: [{
            type: Input
        }], value: [{
            type: Input
        }], max: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
    return PieArcComponent;
}());

var PieChartComponent = /** @class */ (function (_super) {
    __extends(PieChartComponent, _super);
    function PieChartComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.labels = false;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.explodeSlices = false;
        _this.doughnut = false;
        _this.arcWidth = 0.25;
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.trimLabels = true;
        _this.maxLabelLength = 10;
        _this.dblclick = new EventEmitter();
        _this.select = new EventEmitter();
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        return _this;
    }
    PieChartComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        if (this.labels && this.hasNoOptionalMarginsSet()) {
            this.margins = [30, 80, 30, 80];
        }
        else if (!this.labels && this.hasNoOptionalMarginsSet()) {
            this.margins = [20, 20, 20, 20];
        }
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margins,
            showLegend: this.legend,
            legendPosition: this.legendPosition
        });
        this.formatDates();
        var xOffset = this.margins[3] + this.dims.width / 2;
        var yOffset = this.margins[0] + this.dims.height / 2;
        this.translation = "translate(" + xOffset + ", " + yOffset + ")";
        this.outerRadius = Math.min(this.dims.width, this.dims.height);
        if (this.labels) {
            this.outerRadius /= 3;
        }
        else {
            this.outerRadius /= 2;
        }
        this.innerRadius = 0;
        if (this.doughnut) {
            this.innerRadius = this.outerRadius * (1 - this.arcWidth);
        }
        this.domain = this.getDomain();
        this.data = this.results.sort(function (a, b) {
            return _this.domain.indexOf(a.name) - _this.domain.indexOf(b.name);
        });
        this.setColors();
        this.legendOptions = this.getLegendOptions();
    };
    PieChartComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    PieChartComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    PieChartComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    PieChartComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: 'ordinal',
            domain: this.domain,
            colors: this.colors,
            title: this.legendTitle,
            position: this.legendPosition
        };
    };
    PieChartComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    PieChartComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    PieChartComponent.prototype.hasNoOptionalMarginsSet = function () {
        return !this.margins || this.margins.length <= 0;
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "labels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PieChartComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PieChartComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "doughnut", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "arcWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieChartComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieChartComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieChartComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieChartComponent.prototype, "trimLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieChartComponent.prototype, "maxLabelLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "tooltipText", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "dblclick", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieChartComponent.prototype, "margins", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieChartComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], PieChartComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], PieChartComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], PieChartComponent.prototype, "tooltipTemplate", void 0);
PieChartComponent.ɵfac = function PieChartComponent_Factory(t) { return ɵPieChartComponent_BaseFactory(t || PieChartComponent); };
PieChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieChartComponent, selectors: [["ngx-charts-pie-chart"]], contentQueries: function PieChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { margins: "margins", activeEntries: "activeEntries", labels: "labels", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", explodeSlices: "explodeSlices", doughnut: "doughnut", arcWidth: "arcWidth", gradient: "gradient", tooltipDisabled: "tooltipDisabled", labelFormatting: "labelFormatting", trimLabels: "trimLabels", maxLabelLength: "maxLabelLength", tooltipText: "tooltipText" }, outputs: { dblclick: "dblclick", select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 24, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick"], [1, "pie-chart", "chart"], ["ngx-charts-pie-series", "", 3, "colors", "series", "showLabels", "labelFormatting", "trimLabels", "maxLabelLength", "activeEntries", "innerRadius", "outerRadius", "explodeSlices", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText", "dblclick", "select", "activate", "deactivate"]], template: function PieChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelActivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event, true); })("legendLabelDeactivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event, true); })("legendLabelClick", function PieChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("dblclick", function PieChartComponent_Template__svg_g_dblclick_2_listener($event) { return ctx.dblclick.emit($event); })("select", function PieChartComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); })("activate", function PieChartComponent_Template__svg_g_activate_2_listener($event) { return ctx.onActivate($event); })("deactivate", function PieChartComponent_Template__svg_g_deactivate_2_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(21, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.translation);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("series", ctx.data)("showLabels", ctx.labels)("labelFormatting", ctx.labelFormatting)("trimLabels", ctx.trimLabels)("maxLabelLength", ctx.maxLabelLength)("activeEntries", ctx.activeEntries)("innerRadius", ctx.innerRadius)("outerRadius", ctx.outerRadius)("explodeSlices", ctx.explodeSlices)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
    } }, directives: function () { return [ChartComponent, PieSeriesComponent]; }, styles: [_c24, _c41], encapsulation: 2, changeDetection: 0 });
var ɵPieChartComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(PieChartComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieChartComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-pie-chart',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelActivate)=\"onActivate($event, true)\"\n      (legendLabelDeactivate)=\"onDeactivate($event, true)\"\n      (legendLabelClick)=\"onClick($event)\"\n    >\n      <svg:g [attr.transform]=\"translation\" class=\"pie-chart chart\">\n        <svg:g\n          ngx-charts-pie-series\n          [colors]=\"colors\"\n          [series]=\"data\"\n          [showLabels]=\"labels\"\n          [labelFormatting]=\"labelFormatting\"\n          [trimLabels]=\"trimLabels\"\n          [maxLabelLength]=\"maxLabelLength\"\n          [activeEntries]=\"activeEntries\"\n          [innerRadius]=\"innerRadius\"\n          [outerRadius]=\"outerRadius\"\n          [explodeSlices]=\"explodeSlices\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [tooltipText]=\"tooltipText\"\n          (dblclick)=\"dblclick.emit($event)\"\n          (select)=\"onClick($event)\"\n          (activate)=\"onActivate($event)\"\n          (deactivate)=\"onDeactivate($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-label{font-size:11px}.pie-label.animation{animation:750ms ease-in fadeIn}@keyframes fadeIn{from{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d 750ms}@keyframes drawOut{from{stroke-dashoffset:100%}to{stroke-dashoffset:0}}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { margins: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], labels: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }], doughnut: [{
            type: Input
        }], arcWidth: [{
            type: Input
        }], gradient: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], trimLabels: [{
            type: Input
        }], maxLabelLength: [{
            type: Input
        }], tooltipText: [{
            type: Input
        }], dblclick: [{
            type: Output
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return PieChartComponent;
}(BaseChartComponent));

function gridSize(dims, len, minWidth) {
    var rows = 1;
    var cols = len;
    var width = dims.width;
    if (width > minWidth) {
        while (width / cols < minWidth) {
            rows += 1;
            cols = Math.ceil(len / rows);
        }
    }
    return [cols, rows];
}
function gridLayout(dims, data, minWidth, designatedTotal) {
    var xScale = scaleBand();
    var yScale = scaleBand();
    var width = dims.width;
    var height = dims.height;
    var _a = gridSize(dims, data.length, minWidth), columns = _a[0], rows = _a[1];
    var xDomain = [];
    var yDomain = [];
    for (var i = 0; i < rows; i++) {
        yDomain.push(i);
    }
    for (var i = 0; i < columns; i++) {
        xDomain.push(i);
    }
    xScale.domain(xDomain);
    yScale.domain(yDomain);
    xScale.rangeRound([0, width], 0.1);
    yScale.rangeRound([0, height], 0.1);
    var res = [];
    var total = designatedTotal ? designatedTotal : getTotal(data);
    var cardWidth = xScale.bandwidth();
    var cardHeight = yScale.bandwidth();
    for (var i = 0; i < data.length; i++) {
        res[i] = {};
        res[i].data = {
            name: data[i] ? data[i].name : '',
            value: data[i] ? data[i].value : undefined,
            extra: data[i] ? data[i].extra : undefined,
            label: data[i] ? data[i].label : ''
        };
        res[i].x = xScale(i % columns);
        res[i].y = yScale(Math.floor(i / columns));
        res[i].width = cardWidth;
        res[i].height = cardHeight;
        res[i].data.percent = total > 0 ? res[i].data.value / total : 0;
        res[i].data.total = total;
    }
    return res;
}
function getTotal(results) {
    return results.map(function (d) { return (d ? d.value : 0); }).reduce(function (sum, val) { return sum + val; }, 0);
}

var PieGridComponent = /** @class */ (function (_super) {
    __extends(PieGridComponent, _super);
    function PieGridComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.tooltipDisabled = false;
        _this.label = 'Total';
        _this.minWidth = 150;
        _this.activeEntries = [];
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.margin = [20, 20, 20, 20];
        return _this;
    }
    PieGridComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.formatDates();
        this.domain = this.getDomain();
        this.data = gridLayout(this.dims, this.results, this.minWidth, this.designatedTotal);
        this.transform = "translate(" + this.margin[3] + " , " + this.margin[0] + ")";
        this.series = this.getSeries();
        this.setColors();
        this.tooltipText = this.tooltipText || this.defaultTooltipText;
    };
    PieGridComponent.prototype.defaultTooltipText = function (_a) {
        var data = _a.data;
        var label = trimLabel(formatLabel(data.name));
        var val = data.value.toLocaleString();
        return "\n      <span class=\"tooltip-label\">" + label + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
    };
    PieGridComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    PieGridComponent.prototype.getSeries = function () {
        var _this = this;
        var total = this.designatedTotal ? this.designatedTotal : this.getTotal();
        return this.data.map(function (d) {
            var baselineLabelHeight = 20;
            var padding = 10;
            var name = d.data.name;
            var label = formatLabel(name);
            var value = d.data.value;
            var radius = min([d.width - padding, d.height - baselineLabelHeight]) / 2 - 5;
            var innerRadius = radius * 0.9;
            var count = 0;
            var colors = function () {
                count += 1;
                if (count === 1) {
                    return 'rgba(100,100,100,0.3)';
                }
                else {
                    return _this.colorScale.getColor(label);
                }
            };
            var xPos = d.x + (d.width - padding) / 2;
            var yPos = d.y + (d.height - baselineLabelHeight) / 2;
            return {
                transform: "translate(" + xPos + ", " + yPos + ")",
                colors: colors,
                innerRadius: innerRadius,
                outerRadius: radius,
                name: name,
                label: trimLabel(label),
                total: value,
                value: value,
                percent: format('.1%')(d.data.percent),
                data: [
                    d,
                    {
                        data: {
                            other: true,
                            value: total - value,
                            name: d.data.name
                        }
                    }
                ]
            };
        });
    };
    PieGridComponent.prototype.getTotal = function () {
        return this.results.map(function (d) { return d.value; }).reduce(function (sum, d) { return sum + d; }, 0);
    };
    PieGridComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    PieGridComponent.prototype.setColors = function () {
        this.colorScale = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    PieGridComponent.prototype.onActivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    PieGridComponent.prototype.onDeactivate = function (item, fromLegend) {
        if (fromLegend === void 0) { fromLegend = false; }
        item = this.results.find(function (d) {
            if (fromLegend) {
                return d.label === item.name;
            }
            else {
                return d.name === item.name;
            }
        });
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    var _a, _b, _c;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieGridComponent.prototype, "designatedTotal", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieGridComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PieGridComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], PieGridComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieGridComponent.prototype, "minWidth", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieGridComponent.prototype, "activeEntries", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], PieGridComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], PieGridComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], PieGridComponent.prototype, "tooltipTemplate", void 0);
PieGridComponent.ɵfac = function PieGridComponent_Factory(t) { return ɵPieGridComponent_BaseFactory(t || PieGridComponent); };
PieGridComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieGridComponent, selectors: [["ngx-charts-pie-grid"]], contentQueries: function PieGridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { tooltipText: "tooltipText", activeEntries: "activeEntries", designatedTotal: "designatedTotal", tooltipDisabled: "tooltipDisabled", label: "label", minWidth: "minWidth" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 8, consts: [[3, "view", "showLegend", "animations"], [1, "pie-grid", "chart"], ["class", "pie-grid-item", 4, "ngFor", "ngForOf"], [1, "pie-grid-item"], ["ngx-charts-pie-grid-series", "", "ngx-tooltip", "", 3, "colors", "data", "innerRadius", "outerRadius", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 4, "ngIf"], ["dy", "0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 3, "countTo", "countPrefix", 4, "ngIf"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", 4, "ngIf"], ["dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 1, "label", "percent-label", 3, "countTo", "countSuffix"], ["dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label", "percent-label"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 1, "label", 3, "countTo", "countPrefix"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", 1, "label"]], template: function PieGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, PieGridComponent__svg_g_2_Template, 8, 19, "g", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(5, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.series);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgForOf, PieGridSeriesComponent, TooltipDirective, ɵngcc1.NgIf, CountUpDirective]; }, styles: [_c24, ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}"], encapsulation: 2, changeDetection: 0 });
var ɵPieGridComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(PieGridComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieGridComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-pie-grid',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"pie-grid chart\">\n        <svg:g *ngFor=\"let series of series\" class=\"pie-grid-item\" [attr.transform]=\"series.transform\">\n          <svg:g\n            ngx-charts-pie-grid-series\n            [colors]=\"series.colors\"\n            [data]=\"series.data\"\n            [innerRadius]=\"series.innerRadius\"\n            [outerRadius]=\"series.outerRadius\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event)\"\n            ngx-tooltip\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipPlacement]=\"'top'\"\n            [tooltipType]=\"'tooltip'\"\n            [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText({ data: series })\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [tooltipContext]=\"series.data[0].data\"\n            (activate)=\"onActivate($event)\"\n            (deactivate)=\"onDeactivate($event)\"\n          />\n          <svg:text\n            *ngIf=\"animations\"\n            class=\"label percent-label\"\n            dy=\"-0.5em\"\n            x=\"0\"\n            y=\"5\"\n            ngx-charts-count-up\n            [countTo]=\"series.percent\"\n            [countSuffix]=\"'%'\"\n            text-anchor=\"middle\"\n          ></svg:text>\n          <svg:text *ngIf=\"!animations\" class=\"label percent-label\" dy=\"-0.5em\" x=\"0\" y=\"5\" text-anchor=\"middle\">\n            {{ series.percent.toLocaleString() }}\n          </svg:text>\n          <svg:text class=\"label\" dy=\"0.5em\" x=\"0\" y=\"5\" text-anchor=\"middle\">\n            {{ series.label }}\n          </svg:text>\n          <svg:text\n            *ngIf=\"animations\"\n            class=\"label\"\n            dy=\"1.23em\"\n            x=\"0\"\n            [attr.y]=\"series.outerRadius\"\n            text-anchor=\"middle\"\n            ngx-charts-count-up\n            [countTo]=\"series.total\"\n            [countPrefix]=\"label + ': '\"\n          ></svg:text>\n          <svg:text\n            *ngIf=\"!animations\"\n            class=\"label\"\n            dy=\"1.23em\"\n            x=\"0\"\n            [attr.y]=\"series.outerRadius\"\n            text-anchor=\"middle\"\n          >\n            {{ label }}: {{ series.total.toLocaleString() }}\n          </svg:text>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { tooltipText: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], designatedTotal: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], label: [{
            type: Input
        }], minWidth: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return PieGridComponent;
}(BaseChartComponent));

var PieGridSeriesComponent = /** @class */ (function () {
    function PieGridSeriesComponent(element) {
        this.innerRadius = 70;
        this.outerRadius = 80;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.element = element.nativeElement;
    }
    PieGridSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieGridSeriesComponent.prototype.update = function () {
        this.layout = pie()
            .value(function (d) { return d.data.value; })
            .sort(null);
        this.arcs = this.getArcs();
    };
    PieGridSeriesComponent.prototype.getArcs = function () {
        var _this = this;
        return this.layout(this.data).map(function (arc$$1, index) {
            var label = arc$$1.data.data.name;
            var other = arc$$1.data.data.other;
            if (index === 0) {
                arc$$1.startAngle = 0;
            }
            var color = _this.colors(label);
            return {
                data: arc$$1.data.data,
                class: 'arc ' + 'arc' + index,
                fill: color,
                startAngle: other ? 0 : arc$$1.startAngle,
                endAngle: arc$$1.endAngle,
                animate: _this.animations && !other,
                pointerEvents: !other
            };
        });
    };
    PieGridSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(this.data[0].data);
    };
    PieGridSeriesComponent.prototype.trackBy = function (index, item) {
        return item.data.name;
    };
    PieGridSeriesComponent.prototype.label = function (arc$$1) {
        return arc$$1.data.name;
    };
    PieGridSeriesComponent.prototype.color = function (arc$$1) {
        return this.colors(this.label(arc$$1));
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "innerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "outerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieGridSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieGridSeriesComponent.prototype, "deactivate", void 0);
    PieGridSeriesComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], PieGridSeriesComponent);
PieGridSeriesComponent.ɵfac = function PieGridSeriesComponent_Factory(t) { return new (t || PieGridSeriesComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
PieGridSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieGridSeriesComponent, selectors: [["g", "ngx-charts-pie-grid-series", ""]], inputs: { innerRadius: "innerRadius", outerRadius: "outerRadius", animations: "animations", colors: "colors", data: "data" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c43, decls: 2, vars: 2, consts: [[1, "pie-grid-arcs"], ["ngx-charts-pie-arc", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-arc", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate", "select", "activate", "deactivate"]], template: function PieGridSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵtemplate(1, PieGridSeriesComponent__svg_g_1_Template, 1, 11, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, PieArcComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieGridSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-grid-series]',
                template: "\n    <svg:g class=\"pie-grid-arcs\">\n      <svg:g\n        ngx-charts-pie-arc\n        *ngFor=\"let arc of arcs; trackBy: trackBy\"\n        [attr.class]=\"arc.class\"\n        [startAngle]=\"arc.startAngle\"\n        [endAngle]=\"arc.endAngle\"\n        [innerRadius]=\"innerRadius\"\n        [outerRadius]=\"outerRadius\"\n        [fill]=\"color(arc)\"\n        [value]=\"arc.data.value\"\n        [data]=\"arc.data\"\n        [gradient]=\"false\"\n        [pointerEvents]=\"arc.pointerEvents\"\n        [animate]=\"arc.animate\"\n        (select)=\"onClick($event)\"\n        (activate)=\"activate.emit($event)\"\n        (deactivate)=\"deactivate.emit($event)\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { innerRadius: [{
            type: Input
        }], outerRadius: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], colors: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
    return PieGridSeriesComponent;
}());

var PieSeriesComponent = /** @class */ (function () {
    function PieSeriesComponent() {
        this.series = [];
        this.innerRadius = 60;
        this.outerRadius = 80;
        this.trimLabels = true;
        this.maxLabelLength = 10;
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.dblclick = new EventEmitter();
    }
    PieSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    PieSeriesComponent.prototype.update = function () {
        var pieGenerator = pie()
            .value(function (d) { return d.value; })
            .sort(null);
        var arcData = pieGenerator(this.series);
        this.max = max(arcData, function (d) {
            return d.value;
        });
        this.data = this.calculateLabelPositions(arcData);
        this.tooltipText = this.tooltipText || this.defaultTooltipText;
    };
    PieSeriesComponent.prototype.midAngle = function (d) {
        return d.startAngle + (d.endAngle - d.startAngle) / 2;
    };
    PieSeriesComponent.prototype.outerArc = function () {
        var factor = 1.5;
        return arc()
            .innerRadius(this.outerRadius * factor)
            .outerRadius(this.outerRadius * factor);
    };
    PieSeriesComponent.prototype.calculateLabelPositions = function (pieData) {
        var _this = this;
        var factor = 1.5;
        var minDistance = 10;
        var labelPositions = pieData;
        labelPositions.forEach(function (d) {
            d.pos = _this.outerArc().centroid(d);
            d.pos[0] = factor * _this.outerRadius * (_this.midAngle(d) < Math.PI ? 1 : -1);
        });
        for (var i = 0; i < labelPositions.length - 1; i++) {
            var a = labelPositions[i];
            if (!this.labelVisible(a)) {
                continue;
            }
            for (var j = i + 1; j < labelPositions.length; j++) {
                var b = labelPositions[j];
                if (!this.labelVisible(b)) {
                    continue;
                }
                // if they're on the same side
                if (b.pos[0] * a.pos[0] > 0) {
                    // if they're overlapping
                    var o = minDistance - Math.abs(b.pos[1] - a.pos[1]);
                    if (o > 0) {
                        // push the second up or down
                        b.pos[1] += Math.sign(b.pos[0]) * o;
                    }
                }
            }
        }
        return labelPositions;
    };
    PieSeriesComponent.prototype.labelVisible = function (myArc) {
        return this.showLabels && myArc.endAngle - myArc.startAngle > Math.PI / 30;
    };
    PieSeriesComponent.prototype.getTooltipTitle = function (a) {
        return this.tooltipTemplate ? undefined : this.tooltipText(a);
    };
    PieSeriesComponent.prototype.labelText = function (myArc) {
        if (this.labelFormatting) {
            return this.labelFormatting(myArc.data.name);
        }
        return this.label(myArc);
    };
    PieSeriesComponent.prototype.label = function (myArc) {
        return formatLabel(myArc.data.name);
    };
    PieSeriesComponent.prototype.defaultTooltipText = function (myArc) {
        var label = this.label(myArc);
        var val = formatLabel(myArc.data.value);
        return "\n      <span class=\"tooltip-label\">" + label + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
    };
    PieSeriesComponent.prototype.color = function (myArc) {
        return this.colors.getColor(this.label(myArc));
    };
    PieSeriesComponent.prototype.trackBy = function (index, item) {
        return item.data.name;
    };
    PieSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    PieSeriesComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "series", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "innerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "outerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "explodeSlices", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "showLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], PieSeriesComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "trimLabels", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], PieSeriesComponent.prototype, "maxLabelLength", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], PieSeriesComponent.prototype, "tooltipText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], PieSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], PieSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "deactivate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], PieSeriesComponent.prototype, "dblclick", void 0);
PieSeriesComponent.ɵfac = function PieSeriesComponent_Factory(t) { return new (t || PieSeriesComponent)(); };
PieSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PieSeriesComponent, selectors: [["g", "ngx-charts-pie-series", ""]], inputs: { series: "series", innerRadius: "innerRadius", outerRadius: "outerRadius", trimLabels: "trimLabels", maxLabelLength: "maxLabelLength", tooltipDisabled: "tooltipDisabled", animations: "animations", tooltipText: "tooltipText", colors: "colors", dims: "dims", explodeSlices: "explodeSlices", showLabels: "showLabels", gradient: "gradient", activeEntries: "activeEntries", labelFormatting: "labelFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dblclick: "dblclick" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c44, decls: 1, vars: 2, consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations", 4, "ngIf"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "gradient", "data", "max", "explodeSlices", "isActive", "animate", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", "dblclick"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations"]], template: function PieSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, PieSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, PieArcComponent, TooltipDirective, PieLabelComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-pie-series]',
                template: "\n    <svg:g *ngFor=\"let arc of data; trackBy: trackBy\">\n      <svg:g\n        ngx-charts-pie-label\n        *ngIf=\"labelVisible(arc)\"\n        [data]=\"arc\"\n        [radius]=\"outerRadius\"\n        [color]=\"color(arc)\"\n        [label]=\"labelText(arc)\"\n        [labelTrim]=\"trimLabels\"\n        [labelTrimSize]=\"maxLabelLength\"\n        [max]=\"max\"\n        [value]=\"arc.value\"\n        [explodeSlices]=\"explodeSlices\"\n        [animations]=\"animations\"\n      ></svg:g>\n      <svg:g\n        ngx-charts-pie-arc\n        [startAngle]=\"arc.startAngle\"\n        [endAngle]=\"arc.endAngle\"\n        [innerRadius]=\"innerRadius\"\n        [outerRadius]=\"outerRadius\"\n        [fill]=\"color(arc)\"\n        [value]=\"arc.data.value\"\n        [gradient]=\"gradient\"\n        [data]=\"arc.data\"\n        [max]=\"max\"\n        [explodeSlices]=\"explodeSlices\"\n        [isActive]=\"isActive(arc.data)\"\n        [animate]=\"animations\"\n        (select)=\"onClick($event)\"\n        (activate)=\"activate.emit($event)\"\n        (deactivate)=\"deactivate.emit($event)\"\n        (dblclick)=\"dblclick.emit($event)\"\n        ngx-tooltip\n        [tooltipDisabled]=\"tooltipDisabled\"\n        [tooltipPlacement]=\"'top'\"\n        [tooltipType]=\"'tooltip'\"\n        [tooltipTitle]=\"getTooltipTitle(arc)\"\n        [tooltipTemplate]=\"tooltipTemplate\"\n        [tooltipContext]=\"arc.data\"\n      ></svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { series: [{
            type: Input
        }], innerRadius: [{
            type: Input
        }], outerRadius: [{
            type: Input
        }], trimLabels: [{
            type: Input
        }], maxLabelLength: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], dblclick: [{
            type: Output
        }], tooltipText: [{
            type: Input
        }], colors: [{
            type: Input
        }], dims: [{
            type: Input
        }], explodeSlices: [{
            type: Input
        }], showLabels: [{
            type: Input
        }], gradient: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return PieSeriesComponent;
}());

var PieChartModule = /** @class */ (function () {
    function PieChartModule() {
    }
PieChartModule.ɵfac = function PieChartModule_Factory(t) { return new (t || PieChartModule)(); };
PieChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PieChartModule });
PieChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PieChartModule, { declarations: [AdvancedPieChartComponent, PieLabelComponent, PieArcComponent, PieChartComponent, PieGridComponent, PieGridSeriesComponent, PieSeriesComponent], imports: [ChartCommonModule], exports: [AdvancedPieChartComponent, PieLabelComponent, PieArcComponent, PieChartComponent, PieGridComponent, PieGridSeriesComponent, PieSeriesComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PieChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    AdvancedPieChartComponent,
                    PieLabelComponent,
                    PieArcComponent,
                    PieChartComponent,
                    PieGridComponent,
                    PieGridSeriesComponent,
                    PieSeriesComponent
                ],
                exports: [
                    AdvancedPieChartComponent,
                    PieLabelComponent,
                    PieArcComponent,
                    PieChartComponent,
                    PieGridComponent,
                    PieGridSeriesComponent,
                    PieSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return PieChartModule;
}());

var PolarChartModule = /** @class */ (function () {
    function PolarChartModule() {
    }
PolarChartModule.ɵfac = function PolarChartModule_Factory(t) { return new (t || PolarChartModule)(); };
PolarChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: PolarChartModule });
PolarChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule, PieChartModule, LineChartModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PolarChartModule, { declarations: [PolarChartComponent, PolarSeriesComponent], imports: [ChartCommonModule, PieChartModule, LineChartModule], exports: [PolarChartComponent, PolarSeriesComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PolarChartModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule, PieChartModule, LineChartModule],
                declarations: [
                    PolarChartComponent,
                    PolarSeriesComponent
                ],
                exports: [
                    PolarChartComponent,
                    PolarSeriesComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return PolarChartModule;
}());

var CardComponent = /** @class */ (function () {
    function CardComponent(element, cd, zone) {
        this.cd = cd;
        this.zone = zone;
        this.animations = true;
        this.select = new EventEmitter();
        this.value = '';
        this.textFontSize = 12;
        this.textTransform = '';
        this.initialized = false;
        this.bandHeight = 10;
        this.textPadding = [10, 20, 5, 20];
        this.labelFontSize = 15;
        this.element = element.nativeElement;
    }
    CardComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    CardComponent.prototype.ngOnDestroy = function () {
        cancelAnimationFrame(this.animationReq);
    };
    CardComponent.prototype.update = function () {
        var _this = this;
        this.zone.run(function () {
            var hasValue = _this.data && typeof _this.data.value !== 'undefined';
            var valueFormatting = _this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
            var labelFormatting = _this.labelFormatting || (function (card) { return trimLabel(card.label, 55); });
            _this.transform = "translate(" + _this.x + " , " + _this.y + ")";
            _this.textWidth = Math.max(0, _this.width) - _this.textPadding[1] - _this.textPadding[3];
            _this.cardWidth = Math.max(0, _this.width);
            _this.cardHeight = Math.max(0, _this.height);
            _this.label = _this.label ? _this.label : _this.data.name;
            var cardData = {
                label: _this.label,
                data: _this.data,
                value: _this.data.value
            };
            _this.formattedLabel = labelFormatting(cardData);
            _this.transformBand = "translate(0 , " + (_this.cardHeight - _this.bandHeight) + ")";
            var value = hasValue ? valueFormatting(cardData) : '';
            _this.value = _this.paddedValue(value);
            _this.setPadding();
            _this.bandPath = roundedRect(0, 0, _this.cardWidth, _this.bandHeight, 3, [false, false, true, true]);
            setTimeout(function () {
                _this.scaleText();
                _this.value = value;
                if (hasValue && !_this.initialized) {
                    setTimeout(function () { return _this.startCount(); }, 20);
                }
            }, 8);
        });
    };
    CardComponent.prototype.paddedValue = function (value) {
        if (this.medianSize && this.medianSize > value.length) {
            value += '\u2007'.repeat(this.medianSize - value.length);
        }
        return value;
    };
    CardComponent.prototype.startCount = function () {
        var _this = this;
        if (!this.initialized && this.animations) {
            cancelAnimationFrame(this.animationReq);
            var val_1 = this.data.value;
            var decs = decimalChecker(val_1);
            var valueFormatting_1 = this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
            var callback = function (_a) {
                var value = _a.value, finished = _a.finished;
                _this.zone.run(function () {
                    value = finished ? val_1 : value;
                    _this.value = valueFormatting_1({ label: _this.label, data: _this.data, value: value });
                    if (!finished) {
                        _this.value = _this.paddedValue(_this.value);
                    }
                    _this.cd.markForCheck();
                });
            };
            this.animationReq = count(0, val_1, decs, 1, callback);
            this.initialized = true;
        }
    };
    CardComponent.prototype.scaleText = function () {
        var _this = this;
        this.zone.run(function () {
            var _a = _this.textEl.nativeElement.getBoundingClientRect(), width = _a.width, height = _a.height;
            if (width === 0 || height === 0) {
                return;
            }
            var textPadding = (_this.textPadding[1] = _this.textPadding[3] = _this.cardWidth / 8);
            var availableWidth = _this.cardWidth - 2 * textPadding;
            var availableHeight = _this.cardHeight / 3;
            var resizeScale = Math.min(availableWidth / width, availableHeight / height);
            _this.textFontSize = Math.floor(_this.textFontSize * resizeScale);
            _this.labelFontSize = Math.min(_this.textFontSize, 15);
            _this.setPadding();
            _this.cd.markForCheck();
        });
    };
    CardComponent.prototype.setPadding = function () {
        this.textPadding[1] = this.textPadding[3] = this.cardWidth / 8;
        var padding = this.cardHeight / 2;
        this.textPadding[0] = padding - this.textFontSize - this.labelFontSize / 2;
        this.textPadding[2] = padding - this.labelFontSize;
    };
    CardComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "color", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "bandColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "textColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], CardComponent.prototype, "medianSize", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], CardComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CardComponent.prototype, "select", void 0);
    __decorate([
        ViewChild('textEl', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], CardComponent.prototype, "textEl", void 0);
    CardComponent = __decorate([ __metadata("design:paramtypes", [typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object, typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object, typeof (_d = typeof NgZone !== "undefined" && NgZone) === "function" ? _d : Object])
    ], CardComponent);
CardComponent.ɵfac = function CardComponent_Factory(t) { return new (t || CardComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object), ɵngcc0.ɵɵdirectiveInject(typeof (_d = typeof NgZone !== "undefined" && NgZone) === "function" ? _d : Object)); };
CardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardComponent, selectors: [["g", "ngx-charts-card", ""]], viewQuery: function CardComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c45, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textEl = _t.first);
    } }, inputs: { animations: "animations", color: "color", bandColor: "bandColor", textColor: "textColor", x: "x", y: "y", width: "width", height: "height", label: "label", data: "data", medianSize: "medianSize", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c46, decls: 10, vars: 25, consts: [[1, "cell", 3, "click"], ["rx", "3", "ry", "3", 1, "card"], ["class", "card-band", "stroke", "none", 4, "ngIf"], ["x", "5", "alignment-baseline", "hanging", 1, "trimmed-label"], [3, "innerHTML"], ["text-anchor", "start", "alignment-baseline", "hanging", 1, "value-text"], ["textEl", ""], ["stroke", "none", 1, "card-band"]], template: function CardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g", 0);
        ɵngcc0.ɵɵlistener("click", function CardComponent_Template__svg_g_click_0_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelement(1, "rect", 1);
        ɵngcc0.ɵɵtemplate(2, CardComponent__svg_path_2_Template, 1, 3, "path", 2);
        ɵngcc0.ɵɵelementStart(3, "title");
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "foreignObject", 3);
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(6, "p", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(7, "text", 5, 6);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("fill", ctx.color);
        ɵngcc0.ɵɵattribute("width", ctx.cardWidth)("height", ctx.cardHeight);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.bandColor && ctx.bandColor !== ctx.color);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("x", ctx.textPadding[3])("y", ctx.cardHeight - ctx.textPadding[2])("width", ctx.textWidth)("height", ctx.labelFontSize + ctx.textPadding[2]);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("color", ctx.textColor)("font-size", ctx.labelFontSize, "px")("line-height", ctx.labelFontSize, "px");
        ɵngcc0.ɵɵproperty("innerHTML", ctx.formattedLabel, ɵngcc0.ɵɵsanitizeHtml);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("fill", ctx.textColor)("font-size", ctx.textFontSize, "pt");
        ɵngcc0.ɵɵattribute("x", ctx.textPadding[3])("y", ctx.textPadding[0]);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.value, " ");
    } }, directives: [ɵngcc1.NgIf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-card]',
                template: "\n    <svg:g [attr.transform]=\"transform\" class=\"cell\" (click)=\"onClick()\">\n      <svg:rect class=\"card\" [style.fill]=\"color\" [attr.width]=\"cardWidth\" [attr.height]=\"cardHeight\" rx=\"3\" ry=\"3\" />\n      <svg:path\n        *ngIf=\"bandColor && bandColor !== color\"\n        class=\"card-band\"\n        [attr.fill]=\"bandColor\"\n        [attr.transform]=\"transformBand\"\n        stroke=\"none\"\n        [attr.d]=\"bandPath\"\n      />\n      <title>{{ label }}</title>\n      <svg:foreignObject\n        class=\"trimmed-label\"\n        x=\"5\"\n        [attr.x]=\"textPadding[3]\"\n        [attr.y]=\"cardHeight - textPadding[2]\"\n        [attr.width]=\"textWidth\"\n        [attr.height]=\"labelFontSize + textPadding[2]\"\n        alignment-baseline=\"hanging\"\n      >\n        <xhtml:p\n          [style.color]=\"textColor\"\n          [style.fontSize.px]=\"labelFontSize\"\n          [style.lineHeight.px]=\"labelFontSize\"\n          [innerHTML]=\"formattedLabel\"\n        >\n        </xhtml:p>\n      </svg:foreignObject>\n      <svg:text\n        #textEl\n        class=\"value-text\"\n        [attr.x]=\"textPadding[3]\"\n        [attr.y]=\"textPadding[0]\"\n        [style.fill]=\"textColor\"\n        text-anchor=\"start\"\n        alignment-baseline=\"hanging\"\n        [style.font-size.pt]=\"textFontSize\"\n      >\n        {{ value }}\n      </svg:text>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object }, { type: typeof (_c = typeof ChangeDetectorRef !== "undefined" && ChangeDetectorRef) === "function" ? _c : Object }, { type: typeof (_d = typeof NgZone !== "undefined" && NgZone) === "function" ? _d : Object }]; }, { animations: [{
            type: Input
        }], select: [{
            type: Output
        }], color: [{
            type: Input
        }], bandColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], label: [{
            type: Input
        }], data: [{
            type: Input
        }], medianSize: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], textEl: [{
            type: ViewChild,
            args: ['textEl', { static: false }]
        }] }); })();
    return CardComponent;
}());

var CardSeriesComponent = /** @class */ (function () {
    function CardSeriesComponent() {
        this.innerPadding = 15;
        this.emptyColor = 'rgba(0, 0, 0, 0)';
        this.animations = true;
        this.select = new EventEmitter();
    }
    CardSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    CardSeriesComponent.prototype.update = function () {
        if (this.data.length > 2) {
            var valueFormatting_1 = this.valueFormatting || (function (card) { return card.value.toLocaleString(); });
            var sortedLengths = this.data
                .map(function (d) {
                var hasValue = d && d.data && typeof d.data.value !== 'undefined' && d.data.value !== null;
                return hasValue
                    ? valueFormatting_1({
                        data: d.data,
                        label: d ? d.data.name : '',
                        value: d && d.data ? d.data.value : ''
                    }).length
                    : 0;
            })
                .sort(function (a, b) { return b - a; });
            var idx = Math.ceil(this.data.length / 2);
            this.medianSize = sortedLengths[idx];
        }
        var cards = this.getCards();
        this.cards = cards.filter(function (d) { return d.data.value !== null; });
        this.emptySlots = cards.filter(function (d) { return d.data.value === null; });
    };
    CardSeriesComponent.prototype.getCards = function () {
        var _this = this;
        var yPadding = typeof this.innerPadding === 'number' ? this.innerPadding : this.innerPadding[0] + this.innerPadding[2];
        var xPadding = typeof this.innerPadding === 'number' ? this.innerPadding : this.innerPadding[1] + this.innerPadding[3];
        return this.data.map(function (d, index) {
            var label = d.data.name;
            if (label && label.constructor.name === 'Date') {
                label = label.toLocaleDateString();
            }
            else {
                label = label ? label.toLocaleString() : label;
            }
            var value = d.data.value;
            var valueColor = label ? _this.colors.getColor(label) : _this.emptyColor;
            var color = _this.cardColor || valueColor || '#000';
            return {
                x: d.x,
                y: d.y,
                width: d.width - xPadding,
                height: d.height - yPadding,
                color: color,
                bandColor: _this.bandColor || valueColor,
                textColor: _this.textColor || invertColor(color),
                label: label,
                data: d.data,
                tooltipText: label + ": " + value
            };
        });
    };
    CardSeriesComponent.prototype.trackBy = function (index, card) {
        return card.label;
    };
    CardSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], CardSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], CardSeriesComponent.prototype, "slots", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "innerPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "cardColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "bandColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "emptyColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "textColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], CardSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CardSeriesComponent.prototype, "select", void 0);
CardSeriesComponent.ɵfac = function CardSeriesComponent_Factory(t) { return new (t || CardSeriesComponent)(); };
CardSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CardSeriesComponent, selectors: [["g", "ngx-charts-card-series", ""]], inputs: { innerPadding: "innerPadding", emptyColor: "emptyColor", animations: "animations", data: "data", slots: "slots", dims: "dims", colors: "colors", cardColor: "cardColor", bandColor: "bandColor", textColor: "textColor", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c47, decls: 2, vars: 4, consts: [["class", "card-empty", "rx", "3", "ry", "3", 3, "fill", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["rx", "3", "ry", "3", 1, "card-empty"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select"]], template: function CardSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CardSeriesComponent__svg_rect_0_Template, 1, 6, "rect", 0);
        ɵngcc0.ɵɵtemplate(1, CardSeriesComponent__svg_g_1_Template, 1, 13, "g", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.emptySlots)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cards)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, CardComponent], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CardSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-card-series]',
                template: "\n    <svg:rect\n      *ngFor=\"let c of emptySlots; trackBy: trackBy\"\n      class=\"card-empty\"\n      [attr.x]=\"c.x\"\n      [attr.y]=\"c.y\"\n      [style.fill]=\"emptyColor\"\n      [attr.width]=\"c.width\"\n      [attr.height]=\"c.height\"\n      rx=\"3\"\n      ry=\"3\"\n    />\n    <svg:g\n      ngx-charts-card\n      *ngFor=\"let c of cards; trackBy: trackBy\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [color]=\"c.color\"\n      [bandColor]=\"c.bandColor\"\n      [textColor]=\"c.textColor\"\n      [data]=\"c.data\"\n      [label]=\"c.label\"\n      [medianSize]=\"medianSize\"\n      [valueFormatting]=\"valueFormatting\"\n      [labelFormatting]=\"labelFormatting\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event)\"\n    />\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { innerPadding: [{
            type: Input
        }], emptyColor: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], slots: [{
            type: Input
        }], dims: [{
            type: Input
        }], colors: [{
            type: Input
        }], cardColor: [{
            type: Input
        }], bandColor: [{
            type: Input
        }], textColor: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }] }); })();
    return CardSeriesComponent;
}());

var NumberCardComponent = /** @class */ (function (_super) {
    __extends(NumberCardComponent, _super);
    function NumberCardComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.emptyColor = 'rgba(0, 0, 0, 0)';
        _this.innerPadding = 15;
        _this.margin = [10, 10, 10, 10];
        return _this;
    }
    Object.defineProperty(NumberCardComponent.prototype, "clickable", {
        get: function () {
            return !!this.select.observers.length;
        },
        enumerable: true,
        configurable: true
    });
    NumberCardComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.formatDates();
        this.domain = this.getDomain();
        this.setColors();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
        var size = gridSize(this.dims, this.results.length, 150);
        var N = size[0] * size[1];
        var data = this.results.slice();
        while (data.length < N) {
            data.push({ value: null });
        }
        this.data = gridLayout(this.dims, data, 150, this.designatedTotal);
    };
    NumberCardComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.label; });
    };
    NumberCardComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    NumberCardComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "cardColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "bandColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "emptyColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NumberCardComponent.prototype, "innerPadding", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NumberCardComponent.prototype, "textColor", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NumberCardComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], NumberCardComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], NumberCardComponent.prototype, "designatedTotal", void 0);
NumberCardComponent.ɵfac = function NumberCardComponent_Factory(t) { return ɵNumberCardComponent_BaseFactory(t || NumberCardComponent); };
NumberCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NumberCardComponent, selectors: [["ngx-charts-number-card"]], inputs: { cardColor: "cardColor", bandColor: "bandColor", emptyColor: "emptyColor", innerPadding: "innerPadding", textColor: "textColor", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", designatedTotal: "designatedTotal" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 20, consts: [[3, "view", "showLegend", "animations"], [1, "number-card", "chart"], ["ngx-charts-card-series", "", 3, "colors", "cardColor", "bandColor", "textColor", "emptyColor", "data", "dims", "innerPadding", "valueFormatting", "labelFormatting", "animations", "select"]], template: function NumberCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("select", function NumberCardComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(17, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("clickable", ctx.clickable);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("cardColor", ctx.cardColor)("bandColor", ctx.bandColor)("textColor", ctx.textColor)("emptyColor", ctx.emptyColor)("data", ctx.data)("dims", ctx.dims)("innerPadding", ctx.innerPadding)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("animations", ctx.animations);
    } }, directives: [ChartComponent, CardSeriesComponent], styles: [_c24, "ngx-charts-number-card .cell .trimmed-label{font-size:12px;pointer-events:none;overflow:hidden;text-align:left;line-height:1em}ngx-charts-number-card .cell .trimmed-label p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;padding:0;margin:0}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}"], encapsulation: 2, changeDetection: 0 });
var ɵNumberCardComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(NumberCardComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NumberCardComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-number-card',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"number-card chart\" [class.clickable]=\"clickable\">\n        <svg:g\n          ngx-charts-card-series\n          [colors]=\"colors\"\n          [cardColor]=\"cardColor\"\n          [bandColor]=\"bandColor\"\n          [textColor]=\"textColor\"\n          [emptyColor]=\"emptyColor\"\n          [data]=\"data\"\n          [dims]=\"dims\"\n          [innerPadding]=\"innerPadding\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"labelFormatting\"\n          [animations]=\"animations\"\n          (select)=\"onClick($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", "ngx-charts-number-card .cell .trimmed-label{font-size:12px;pointer-events:none;overflow:hidden;text-align:left;line-height:1em}ngx-charts-number-card .cell .trimmed-label p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;padding:0;margin:0}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { cardColor: [{
            type: Input
        }], bandColor: [{
            type: Input
        }], emptyColor: [{
            type: Input
        }], innerPadding: [{
            type: Input
        }], textColor: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], designatedTotal: [{
            type: Input
        }] }); })();
    return NumberCardComponent;
}(BaseChartComponent));

var NumberCardModule = /** @class */ (function () {
    function NumberCardModule() {
    }
NumberCardModule.ɵfac = function NumberCardModule_Factory(t) { return new (t || NumberCardModule)(); };
NumberCardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NumberCardModule });
NumberCardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NumberCardModule, { declarations: [CardComponent, CardSeriesComponent, NumberCardComponent], imports: [ChartCommonModule], exports: [CardComponent, CardSeriesComponent, NumberCardComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NumberCardModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    CardComponent,
                    CardSeriesComponent,
                    NumberCardComponent
                ],
                exports: [
                    CardComponent,
                    CardSeriesComponent,
                    NumberCardComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return NumberCardModule;
}());

var TreeMapCellComponent = /** @class */ (function () {
    function TreeMapCellComponent(element) {
        this.gradient = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.initialized = false;
        this.element = element.nativeElement;
    }
    TreeMapCellComponent.prototype.ngOnChanges = function () {
        this.update();
        this.valueFormatting = this.valueFormatting || (function (value) { return value.toLocaleString(); });
        var labelFormatting = this.labelFormatting || (function (cell) { return trimLabel(cell.label, 55); });
        var cellData = {
            data: this.data,
            label: this.label,
            value: this.value
        };
        this.formattedValue = this.valueFormatting(cellData.value);
        this.formattedLabel = labelFormatting(cellData);
        this.gradientId = 'grad' + id().toString();
        this.gradientUrl = "url(#" + this.gradientId + ")";
        this.gradientStops = this.getGradientStops();
    };
    TreeMapCellComponent.prototype.update = function () {
        if (this.initialized) {
            this.animateToCurrentForm();
        }
        else {
            if (this.animations) {
                this.loadAnimation();
            }
            this.initialized = true;
        }
    };
    TreeMapCellComponent.prototype.loadAnimation = function () {
        var node = select(this.element).select('.cell');
        node
            .attr('opacity', 0)
            .attr('x', this.x)
            .attr('y', this.y);
        this.animateToCurrentForm();
    };
    TreeMapCellComponent.prototype.getTextColor = function () {
        return invertColor(this.fill);
    };
    TreeMapCellComponent.prototype.animateToCurrentForm = function () {
        var node = select(this.element).select('.cell');
        if (this.animations) {
            node
                .transition()
                .duration(750)
                .attr('opacity', 1)
                .attr('x', this.x)
                .attr('y', this.y)
                .attr('width', this.width)
                .attr('height', this.height);
        }
        else {
            node
                .attr('opacity', 1)
                .attr('x', this.x)
                .attr('y', this.y)
                .attr('width', this.width)
                .attr('height', this.height);
        }
    };
    TreeMapCellComponent.prototype.onClick = function () {
        this.select.emit(this.data);
    };
    TreeMapCellComponent.prototype.getGradientStops = function () {
        return [
            {
                offset: 0,
                color: this.fill,
                opacity: 0.3
            },
            {
                offset: 100,
                color: this.fill,
                opacity: 1
            }
        ];
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "fill", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "x", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "y", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "width", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "height", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "label", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "valueType", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TreeMapCellComponent.prototype, "select", void 0);
    TreeMapCellComponent = __decorate([ __metadata("design:paramtypes", [typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object])
    ], TreeMapCellComponent);
TreeMapCellComponent.ɵfac = function TreeMapCellComponent_Factory(t) { return new (t || TreeMapCellComponent)(ɵngcc0.ɵɵdirectiveInject(typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)); };
TreeMapCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeMapCellComponent, selectors: [["g", "ngx-charts-tree-map-cell", ""]], inputs: { gradient: "gradient", animations: "animations", valueFormatting: "valueFormatting", data: "data", fill: "fill", x: "x", y: "y", width: "width", height: "height", label: "label", value: "value", valueType: "valueType", labelFormatting: "labelFormatting" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c48, decls: 4, vars: 9, consts: [[4, "ngIf"], [1, "cell", 3, "click"], ["class", "treemap-label", 3, "pointer-events", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", "orientation", "vertical", 3, "name", "stops"], [1, "treemap-label"], [1, "treemap-label", 3, "innerHTML"], ["class", "treemap-val", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "treemap-val", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "treemap-val", 3, "countTo", "valueFormatting"], [1, "treemap-val"]], template: function TreeMapCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, TreeMapCellComponent__svg_defs_1_Template, 2, 2, "defs", 0);
        ɵngcc0.ɵɵelementStart(2, "rect", 1);
        ɵngcc0.ɵɵlistener("click", function TreeMapCellComponent_Template__svg_rect_click_2_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, TreeMapCellComponent__svg_foreignObject_3_Template, 6, 15, "foreignObject", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.gradient);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("cursor", "pointer");
        ɵngcc0.ɵɵattribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height)("x", ctx.x)("y", ctx.y);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.width >= 70 && ctx.height >= 35);
    } }, directives: [ɵngcc1.NgIf, SvgLinearGradientComponent, CountUpDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeMapCellComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-tree-map-cell]',
                template: "\n    <svg:g>\n      <defs *ngIf=\"gradient\">\n        <svg:g ngx-charts-svg-linear-gradient orientation=\"vertical\" [name]=\"gradientId\" [stops]=\"gradientStops\" />\n      </defs>\n      <svg:rect\n        [attr.fill]=\"gradient ? gradientUrl : fill\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        [attr.x]=\"x\"\n        [attr.y]=\"y\"\n        [style.cursor]=\"'pointer'\"\n        class=\"cell\"\n        (click)=\"onClick()\"\n      />\n      <svg:foreignObject\n        *ngIf=\"width >= 70 && height >= 35\"\n        [attr.x]=\"x\"\n        [attr.y]=\"y\"\n        [attr.width]=\"width\"\n        [attr.height]=\"height\"\n        class=\"treemap-label\"\n        [style.pointer-events]=\"'none'\"\n      >\n        <xhtml:p [style.color]=\"getTextColor()\" [style.height]=\"height + 'px'\" [style.width]=\"width + 'px'\">\n          <xhtml:span class=\"treemap-label\" [innerHTML]=\"formattedLabel\"> </xhtml:span>\n          <xhtml:br />\n          <xhtml:span\n            *ngIf=\"animations\"\n            class=\"treemap-val\"\n            ngx-charts-count-up\n            [countTo]=\"value\"\n            [valueFormatting]=\"valueFormatting\"\n          >\n          </xhtml:span>\n          <xhtml:span *ngIf=\"!animations\" class=\"treemap-val\">\n            {{ formattedValue }}\n          </xhtml:span>\n        </xhtml:p>\n      </svg:foreignObject>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object }]; }, { gradient: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], valueFormatting: [{
            type: Input
        }], data: [{
            type: Input
        }], fill: [{
            type: Input
        }], x: [{
            type: Input
        }], y: [{
            type: Input
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], label: [{
            type: Input
        }], value: [{
            type: Input
        }], valueType: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }] }); })();
    return TreeMapCellComponent;
}());

var TreeMapCellSeriesComponent = /** @class */ (function () {
    function TreeMapCellSeriesComponent() {
        this.gradient = false;
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
    }
    TreeMapCellSeriesComponent.prototype.ngOnChanges = function (changes) {
        this.cells = this.getCells();
    };
    TreeMapCellSeriesComponent.prototype.getCells = function () {
        var _this = this;
        return this.data.children
            .filter(function (d) {
            return d.depth === 1;
        })
            .map(function (d, index) {
            var label = d.id;
            return {
                data: d.data,
                x: d.x0,
                y: d.y0,
                width: d.x1 - d.x0,
                height: d.y1 - d.y0,
                fill: _this.colors.getColor(label),
                label: label,
                value: d.value,
                valueType: d.valueType
            };
        });
    };
    TreeMapCellSeriesComponent.prototype.getTooltipText = function (_a) {
        var label = _a.label, value = _a.value;
        return "\n      <span class=\"tooltip-label\">" + label + "</span>\n      <span class=\"tooltip-val\">" + value.toLocaleString() + "</span>\n    ";
    };
    TreeMapCellSeriesComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    TreeMapCellSeriesComponent.prototype.trackBy = function (index, item) {
        return item.label;
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "dims", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellSeriesComponent.prototype, "gradient", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellSeriesComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], TreeMapCellSeriesComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapCellSeriesComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TreeMapCellSeriesComponent.prototype, "select", void 0);
TreeMapCellSeriesComponent.ɵfac = function TreeMapCellSeriesComponent_Factory(t) { return new (t || TreeMapCellSeriesComponent)(); };
TreeMapCellSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeMapCellSeriesComponent, selectors: [["g", "ngx-charts-tree-map-cell-series", ""]], inputs: { gradient: "gradient", tooltipDisabled: "tooltipDisabled", animations: "animations", data: "data", dims: "dims", colors: "colors", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c49, decls: 1, vars: 2, consts: [["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "data", "x", "y", "width", "height", "fill", "label", "value", "valueType", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "data", "x", "y", "width", "height", "fill", "label", "value", "valueType", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select"]], template: function TreeMapCellSeriesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TreeMapCellSeriesComponent__svg_g_0_Template, 1, 19, "g", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
    } }, directives: [ɵngcc1.NgForOf, TreeMapCellComponent, TooltipDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeMapCellSeriesComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-tree-map-cell-series]',
                template: "\n    <svg:g\n      ngx-charts-tree-map-cell\n      *ngFor=\"let c of cells; trackBy: trackBy\"\n      [data]=\"c.data\"\n      [x]=\"c.x\"\n      [y]=\"c.y\"\n      [width]=\"c.width\"\n      [height]=\"c.height\"\n      [fill]=\"c.fill\"\n      [label]=\"c.label\"\n      [value]=\"c.value\"\n      [valueType]=\"c.valueType\"\n      [valueFormatting]=\"valueFormatting\"\n      [labelFormatting]=\"labelFormatting\"\n      [gradient]=\"gradient\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : getTooltipText(c)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"c.data\"\n    ></svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { gradient: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], data: [{
            type: Input
        }], dims: [{
            type: Input
        }], colors: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return TreeMapCellSeriesComponent;
}());

var TreeMapComponent = /** @class */ (function (_super) {
    __extends(TreeMapComponent, _super);
    function TreeMapComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.tooltipDisabled = false;
        _this.gradient = false;
        _this.select = new EventEmitter();
        _this.margin = [10, 10, 10, 10];
        return _this;
    }
    TreeMapComponent.prototype.update = function () {
        _super.prototype.update.call(this);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.domain = this.getDomain();
        this.treemap = treemap().size([this.dims.width, this.dims.height]);
        var rootNode = {
            name: 'root',
            value: 0,
            isRoot: true
        };
        var root = stratify()
            .id(function (d) {
            var label = d.name;
            if (label.constructor.name === 'Date') {
                label = label.toLocaleDateString();
            }
            else {
                label = label.toLocaleString();
            }
            return label;
        })
            .parentId(function (d) { return (d.isRoot ? null : 'root'); })([rootNode].concat(this.results))
            .sum(function (d) { return d.value; });
        this.data = this.treemap(root);
        this.setColors();
        this.transform = "translate(" + this.dims.xOffset + " , " + this.margin[0] + ")";
    };
    TreeMapComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    TreeMapComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    TreeMapComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    var _a;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "labelFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], TreeMapComponent.prototype, "gradient", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], TreeMapComponent.prototype, "select", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_a = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _a : Object)
    ], TreeMapComponent.prototype, "tooltipTemplate", void 0);
TreeMapComponent.ɵfac = function TreeMapComponent_Factory(t) { return ɵTreeMapComponent_BaseFactory(t || TreeMapComponent); };
TreeMapComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TreeMapComponent, selectors: [["ngx-charts-tree-map"]], contentQueries: function TreeMapComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, inputs: { results: "results", tooltipDisabled: "tooltipDisabled", valueFormatting: "valueFormatting", labelFormatting: "labelFormatting", gradient: "gradient" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 16, consts: [[3, "view", "showLegend", "animations"], [1, "tree-map", "chart"], ["ngx-charts-tree-map-cell-series", "", 3, "colors", "data", "dims", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "labelFormatting", "gradient", "animations", "select"]], template: function TreeMapComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelementStart(2, "g", 2);
        ɵngcc0.ɵɵlistener("select", function TreeMapComponent_Template__svg_g_select_2_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(13, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("colors", ctx.colors)("data", ctx.data)("dims", ctx.dims)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("gradient", ctx.gradient)("animations", ctx.animations);
    } }, directives: [ChartComponent, TreeMapCellSeriesComponent], styles: [".tree-map .treemap-val{font-size:1.3em;padding-top:5px;display:inline-block}.tree-map .treemap-label p{display:table-cell;text-align:center;line-height:1.2em;vertical-align:middle}"], encapsulation: 2, changeDetection: 0 });
var ɵTreeMapComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(TreeMapComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeMapComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-tree-map',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\">\n      <svg:g [attr.transform]=\"transform\" class=\"tree-map chart\">\n        <svg:g\n          ngx-charts-tree-map-cell-series\n          [colors]=\"colors\"\n          [data]=\"data\"\n          [dims]=\"dims\"\n          [tooltipDisabled]=\"tooltipDisabled\"\n          [tooltipTemplate]=\"tooltipTemplate\"\n          [valueFormatting]=\"valueFormatting\"\n          [labelFormatting]=\"labelFormatting\"\n          [gradient]=\"gradient\"\n          [animations]=\"animations\"\n          (select)=\"onClick($event)\"\n        />\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".tree-map .treemap-val{font-size:1.3em;padding-top:5px;display:inline-block}.tree-map .treemap-label p{display:table-cell;text-align:center;line-height:1.2em;vertical-align:middle}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { results: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], labelFormatting: [{
            type: Input
        }], gradient: [{
            type: Input
        }], select: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }] }); })();
    return TreeMapComponent;
}(BaseChartComponent));

var TreeMapModule = /** @class */ (function () {
    function TreeMapModule() {
    }
TreeMapModule.ɵfac = function TreeMapModule_Factory(t) { return new (t || TreeMapModule)(); };
TreeMapModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TreeMapModule });
TreeMapModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TreeMapModule, { declarations: [TreeMapCellComponent, TreeMapCellSeriesComponent, TreeMapComponent], imports: [ChartCommonModule], exports: [TreeMapCellComponent, TreeMapCellSeriesComponent, TreeMapComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TreeMapModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule],
                declarations: [
                    TreeMapCellComponent,
                    TreeMapCellSeriesComponent,
                    TreeMapComponent
                ],
                exports: [
                    TreeMapCellComponent,
                    TreeMapCellSeriesComponent,
                    TreeMapComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return TreeMapModule;
}());

var LinearGaugeComponent = /** @class */ (function (_super) {
    __extends(LinearGaugeComponent, _super);
    function LinearGaugeComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.min = 0;
        _this.max = 100;
        _this.value = 0;
        _this.margin = [10, 20, 10, 20];
        _this.valueResizeScale = 1;
        _this.unitsResizeScale = 1;
        _this.valueTextTransform = '';
        _this.valueTranslate = '';
        _this.unitsTextTransform = '';
        _this.unitsTranslate = '';
        return _this;
    }
    LinearGaugeComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        _super.prototype.ngAfterViewInit.call(this);
        setTimeout(function () {
            _this.scaleText('value');
            _this.scaleText('units');
        });
    };
    LinearGaugeComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        this.hasPreviousValue = this.previousValue !== undefined;
        this.max = Math.max(this.max, this.value);
        this.min = Math.min(this.min, this.value);
        if (this.hasPreviousValue) {
            this.max = Math.max(this.max, this.previousValue);
            this.min = Math.min(this.min, this.previousValue);
        }
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin
        });
        this.valueDomain = this.getValueDomain();
        this.valueScale = this.getValueScale();
        this.displayValue = this.getDisplayValue();
        this.setColors();
        var xOffset = this.margin[3] + this.dims.width / 2;
        var yOffset = this.margin[0] + this.dims.height / 2;
        this.transform = "translate(" + xOffset + ", " + yOffset + ")";
        this.transformLine = "translate(" + (this.margin[3] + this.valueScale(this.previousValue)) + ", " + yOffset + ")";
        this.valueTranslate = "translate(0, -15)";
        this.unitsTranslate = "translate(0, 15)";
        setTimeout(function () { return _this.scaleText('value'); }, 50);
        setTimeout(function () { return _this.scaleText('units'); }, 50);
    };
    LinearGaugeComponent.prototype.getValueDomain = function () {
        return [this.min, this.max];
    };
    LinearGaugeComponent.prototype.getValueScale = function () {
        return scaleLinear()
            .range([0, this.dims.width])
            .domain(this.valueDomain);
    };
    LinearGaugeComponent.prototype.getDisplayValue = function () {
        if (this.valueFormatting) {
            return this.valueFormatting(this.value);
        }
        return this.value.toLocaleString();
    };
    LinearGaugeComponent.prototype.scaleText = function (element, repeat) {
        var _this = this;
        if (repeat === void 0) { repeat = true; }
        var el;
        var resizeScale;
        if (element === 'value') {
            el = this.valueTextEl;
            resizeScale = this.valueResizeScale;
        }
        else {
            el = this.unitsTextEl;
            resizeScale = this.unitsResizeScale;
        }
        var _a = el.nativeElement.getBoundingClientRect(), width = _a.width, height = _a.height;
        if (width === 0 || height === 0)
            return;
        var oldScale = resizeScale;
        var availableWidth = this.dims.width;
        var availableHeight = Math.max(this.dims.height / 2 - 15, 0);
        var resizeScaleWidth = Math.floor((availableWidth / (width / resizeScale)) * 100) / 100;
        var resizeScaleHeight = Math.floor((availableHeight / (height / resizeScale)) * 100) / 100;
        resizeScale = Math.min(resizeScaleHeight, resizeScaleWidth);
        if (resizeScale !== oldScale) {
            if (element === 'value') {
                this.valueResizeScale = resizeScale;
                this.valueTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
            }
            else {
                this.unitsResizeScale = resizeScale;
                this.unitsTextTransform = "scale(" + resizeScale + ", " + resizeScale + ")";
            }
            this.cd.markForCheck();
            if (repeat) {
                setTimeout(function () {
                    _this.scaleText(element, false);
                }, 50);
            }
        }
    };
    LinearGaugeComponent.prototype.onClick = function () {
        this.select.emit({
            name: 'Value',
            value: this.value
        });
    };
    LinearGaugeComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', [this.value], this.customColors);
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LinearGaugeComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LinearGaugeComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], LinearGaugeComponent.prototype, "value", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], LinearGaugeComponent.prototype, "units", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LinearGaugeComponent.prototype, "previousValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], LinearGaugeComponent.prototype, "valueFormatting", void 0);
    __decorate([
        ViewChild('valueTextEl', { static: false }),
        __metadata("design:type", typeof (_a = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _a : Object)
    ], LinearGaugeComponent.prototype, "valueTextEl", void 0);
    __decorate([
        ViewChild('unitsTextEl', { static: false }),
        __metadata("design:type", typeof (_b = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _b : Object)
    ], LinearGaugeComponent.prototype, "unitsTextEl", void 0);
LinearGaugeComponent.ɵfac = function LinearGaugeComponent_Factory(t) { return ɵLinearGaugeComponent_BaseFactory(t || LinearGaugeComponent); };
LinearGaugeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LinearGaugeComponent, selectors: [["ngx-charts-linear-gauge"]], viewQuery: function LinearGaugeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c50, 1);
        ɵngcc0.ɵɵviewQuery(_c51, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.valueTextEl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.unitsTextEl = _t.first);
    } }, inputs: { max: "max", min: "min", value: "value", units: "units", previousValue: "previousValue", valueFormatting: "valueFormatting" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 15, vars: 38, consts: [[3, "view", "showLegend", "animations", "click"], [1, "linear-gauge", "chart"], ["ngx-charts-bar", "", 1, "background-bar", 3, "width", "height", "x", "y", "data", "orientation", "roundEdges", "animations"], ["ngx-charts-bar", "", 3, "width", "height", "x", "y", "fill", "data", "orientation", "roundEdges", "animations"], ["x1", "0", "y1", "5", "x2", "0", "y2", "15", 4, "ngIf"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15", 4, "ngIf"], ["alignment-baseline", "after-edge", 1, "value"], ["valueTextEl", ""], ["alignment-baseline", "before-edge", 1, "units"], ["unitsTextEl", ""], ["x1", "0", "y1", "5", "x2", "0", "y2", "15"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15"]], template: function LinearGaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("click", function LinearGaugeComponent_Template_ngx_charts_chart_click_0_listener() { return ctx.onClick(); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵelement(2, "g", 2);
        ɵngcc0.ɵɵelement(3, "g", 3);
        ɵngcc0.ɵɵtemplate(4, LinearGaugeComponent__svg_line_4_Template, 1, 2, "line", 4);
        ɵngcc0.ɵɵtemplate(5, LinearGaugeComponent__svg_line_5_Template, 1, 2, "line", 5);
        ɵngcc0.ɵɵelementStart(6, "g");
        ɵngcc0.ɵɵelementStart(7, "g");
        ɵngcc0.ɵɵelementStart(8, "text", 6, 7);
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "g");
        ɵngcc0.ɵɵelementStart(12, "text", 8, 9);
        ɵngcc0.ɵɵtext(14);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(33, _c23, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("width", ctx.dims.width)("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("data", ɵngcc0.ɵɵpureFunction0(36, _c52))("orientation", "horizontal")("roundEdges", true)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("width", ctx.valueScale(ctx.value))("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("fill", ctx.colors.getColor(ctx.units))("data", ɵngcc0.ɵɵpureFunction0(37, _c52))("orientation", "horizontal")("roundEdges", true)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasPreviousValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasPreviousValue);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.valueTranslate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
        ɵngcc0.ɵɵattribute("transform", ctx.valueTextTransform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.displayValue, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.unitsTranslate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("text-anchor", "middle");
        ɵngcc0.ɵɵattribute("transform", ctx.unitsTextTransform);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.units, " ");
    } }, directives: [ChartComponent, BarComponent, ɵngcc1.NgIf], styles: [_c24, ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:rgba(0,0,0,.05)}.linear-gauge .units{fill:#666}"], encapsulation: 2, changeDetection: 0 });
var ɵLinearGaugeComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(LinearGaugeComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LinearGaugeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-linear-gauge',
                template: "\n    <ngx-charts-chart [view]=\"[width, height]\" [showLegend]=\"false\" [animations]=\"animations\" (click)=\"onClick()\">\n      <svg:g class=\"linear-gauge chart\">\n        <svg:g\n          ngx-charts-bar\n          class=\"background-bar\"\n          [width]=\"dims.width\"\n          [height]=\"3\"\n          [x]=\"margin[3]\"\n          [y]=\"dims.height / 2 + margin[0] - 2\"\n          [data]=\"{}\"\n          [orientation]=\"'horizontal'\"\n          [roundEdges]=\"true\"\n          [animations]=\"animations\"\n        ></svg:g>\n        <svg:g\n          ngx-charts-bar\n          [width]=\"valueScale(value)\"\n          [height]=\"3\"\n          [x]=\"margin[3]\"\n          [y]=\"dims.height / 2 + margin[0] - 2\"\n          [fill]=\"colors.getColor(units)\"\n          [data]=\"{}\"\n          [orientation]=\"'horizontal'\"\n          [roundEdges]=\"true\"\n          [animations]=\"animations\"\n        ></svg:g>\n\n        <svg:line\n          *ngIf=\"hasPreviousValue\"\n          [attr.transform]=\"transformLine\"\n          x1=\"0\"\n          y1=\"5\"\n          x2=\"0\"\n          y2=\"15\"\n          [attr.stroke]=\"colors.getColor(units)\"\n        />\n\n        <svg:line\n          *ngIf=\"hasPreviousValue\"\n          [attr.transform]=\"transformLine\"\n          x1=\"0\"\n          y1=\"-5\"\n          x2=\"0\"\n          y2=\"-15\"\n          [attr.stroke]=\"colors.getColor(units)\"\n        />\n\n        <svg:g [attr.transform]=\"transform\">\n          <svg:g [attr.transform]=\"valueTranslate\">\n            <svg:text\n              #valueTextEl\n              class=\"value\"\n              [style.textAnchor]=\"'middle'\"\n              [attr.transform]=\"valueTextTransform\"\n              alignment-baseline=\"after-edge\"\n            >\n              {{ displayValue }}\n            </svg:text>\n          </svg:g>\n\n          <svg:g [attr.transform]=\"unitsTranslate\">\n            <svg:text\n              #unitsTextEl\n              class=\"units\"\n              [style.textAnchor]=\"'middle'\"\n              [attr.transform]=\"unitsTextTransform\"\n              alignment-baseline=\"before-edge\"\n            >\n              {{ units }}\n            </svg:text>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:rgba(0,0,0,.05)}.linear-gauge .units{fill:#666}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { max: [{
            type: Input
        }], min: [{
            type: Input
        }], value: [{
            type: Input
        }], units: [{
            type: Input
        }], previousValue: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], valueTextEl: [{
            type: ViewChild,
            args: ['valueTextEl', { static: false }]
        }], unitsTextEl: [{
            type: ViewChild,
            args: ['unitsTextEl', { static: false }]
        }] }); })();
    return LinearGaugeComponent;
}(BaseChartComponent));

var GaugeComponent = /** @class */ (function (_super) {
    __extends(GaugeComponent, _super);
    function GaugeComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.legend = false;
        _this.legendTitle = 'Legend';
        _this.legendPosition = 'right';
        _this.min = 0;
        _this.max = 100;
        _this.bigSegments = 10;
        _this.smallSegments = 5;
        _this.showAxis = true;
        _this.startAngle = -120;
        _this.angleSpan = 240;
        _this.activeEntries = [];
        _this.tooltipDisabled = false;
        _this.showText = true;
        _this.activate = new EventEmitter();
        _this.deactivate = new EventEmitter();
        _this.resizeScale = 1;
        _this.rotation = '';
        _this.textTransform = 'scale(1, 1)';
        _this.cornerRadius = 10;
        return _this;
    }
    GaugeComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        _super.prototype.ngAfterViewInit.call(this);
        setTimeout(function () { return _this.scaleText(); });
    };
    GaugeComponent.prototype.update = function () {
        var _this = this;
        _super.prototype.update.call(this);
        if (!this.showAxis) {
            if (!this.margin) {
                this.margin = [10, 20, 10, 20];
            }
        }
        else {
            if (!this.margin) {
                this.margin = [60, 100, 60, 100];
            }
        }
        if (this.startAngle < 0) {
            this.startAngle = (this.startAngle % 360) + 360;
        }
        this.angleSpan = Math.min(this.angleSpan, 360);
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showLegend: this.legend,
            legendPosition: this.legendPosition
        });
        this.domain = this.getDomain();
        this.valueDomain = this.getValueDomain();
        this.valueScale = this.getValueScale();
        this.displayValue = this.getDisplayValue();
        this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2;
        this.arcs = this.getArcs();
        this.setColors();
        this.legendOptions = this.getLegendOptions();
        var xOffset = this.margin[3] + this.dims.width / 2;
        var yOffset = this.margin[0] + this.dims.height / 2;
        this.transform = "translate(" + xOffset + ", " + yOffset + ")";
        this.rotation = "rotate(" + this.startAngle + ")";
        setTimeout(function () { return _this.scaleText(); }, 50);
    };
    GaugeComponent.prototype.getArcs = function () {
        var arcs = [];
        var availableRadius = this.outerRadius * 0.7;
        var radiusPerArc = Math.min(availableRadius / this.results.length, 10);
        var arcWidth = radiusPerArc * 0.7;
        this.textRadius = this.outerRadius - this.results.length * radiusPerArc;
        this.cornerRadius = Math.floor(arcWidth / 2);
        var i = 0;
        for (var _i = 0, _a = this.results; _i < _a.length; _i++) {
            var d = _a[_i];
            var outerRadius = this.outerRadius - i * radiusPerArc;
            var innerRadius = outerRadius - arcWidth;
            var backgroundArc = {
                endAngle: (this.angleSpan * Math.PI) / 180,
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                data: {
                    value: this.max,
                    name: d.name
                }
            };
            var valueArc = {
                endAngle: (Math.min(this.valueScale(d.value), this.angleSpan) * Math.PI) / 180,
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                data: {
                    value: d.value,
                    name: d.name
                }
            };
            var arc$$1 = {
                backgroundArc: backgroundArc,
                valueArc: valueArc
            };
            arcs.push(arc$$1);
            i++;
        }
        return arcs;
    };
    GaugeComponent.prototype.getDomain = function () {
        return this.results.map(function (d) { return d.name; });
    };
    GaugeComponent.prototype.getValueDomain = function () {
        var values = this.results.map(function (d) { return d.value; });
        var dataMin = Math.min.apply(Math, values);
        var dataMax = Math.max.apply(Math, values);
        if (this.min !== undefined) {
            this.min = Math.min(this.min, dataMin);
        }
        else {
            this.min = dataMin;
        }
        if (this.max !== undefined) {
            this.max = Math.max(this.max, dataMax);
        }
        else {
            this.max = dataMax;
        }
        return [this.min, this.max];
    };
    GaugeComponent.prototype.getValueScale = function () {
        return scaleLinear()
            .range([0, this.angleSpan])
            .nice()
            .domain(this.valueDomain);
    };
    GaugeComponent.prototype.getDisplayValue = function () {
        var value = this.results.map(function (d) { return d.value; }).reduce(function (a, b) { return a + b; }, 0);
        if (this.textValue && 0 !== this.textValue.length) {
            return this.textValue.toLocaleString();
        }
        if (this.valueFormatting) {
            return this.valueFormatting(value);
        }
        return value.toLocaleString();
    };
    GaugeComponent.prototype.scaleText = function (repeat) {
        var _this = this;
        if (repeat === void 0) { repeat = true; }
        if (!this.showText) {
            return;
        }
        var width = this.textEl.nativeElement.getBoundingClientRect().width;
        var oldScale = this.resizeScale;
        if (width === 0) {
            this.resizeScale = 1;
        }
        else {
            var availableSpace = this.textRadius;
            this.resizeScale = Math.floor((availableSpace / (width / this.resizeScale)) * 100) / 100;
        }
        if (this.resizeScale !== oldScale) {
            this.textTransform = "scale(" + this.resizeScale + ", " + this.resizeScale + ")";
            this.cd.markForCheck();
            if (repeat) {
                setTimeout(function () { return _this.scaleText(false); }, 50);
            }
        }
    };
    GaugeComponent.prototype.onClick = function (data) {
        this.select.emit(data);
    };
    GaugeComponent.prototype.getLegendOptions = function () {
        return {
            scaleType: 'ordinal',
            colors: this.colors,
            domain: this.domain,
            title: this.legendTitle,
            position: this.legendPosition
        };
    };
    GaugeComponent.prototype.setColors = function () {
        this.colors = new ColorHelper(this.scheme, 'ordinal', this.domain, this.customColors);
    };
    GaugeComponent.prototype.onActivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item].concat(this.activeEntries);
        this.activate.emit({ value: item, entries: this.activeEntries });
    };
    GaugeComponent.prototype.onDeactivate = function (item) {
        var idx = this.activeEntries.findIndex(function (d) {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = this.activeEntries.slice();
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    };
    GaugeComponent.prototype.isActive = function (entry) {
        if (!this.activeEntries)
            return false;
        var item = this.activeEntries.find(function (d) {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    };
    GaugeComponent.prototype.trackBy = function (index, item) {
        return item.valueArc.data.name;
    };
    var _a, _b, _c, _d;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeComponent.prototype, "legend", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "legendTitle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "legendPosition", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "textValue", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], GaugeComponent.prototype, "units", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "bigSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "smallSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GaugeComponent.prototype, "results", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeComponent.prototype, "showAxis", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "startAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeComponent.prototype, "angleSpan", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GaugeComponent.prototype, "activeEntries", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeComponent.prototype, "axisTickFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], GaugeComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeComponent.prototype, "showText", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], GaugeComponent.prototype, "margin", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_a = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _a : Object)
    ], GaugeComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", typeof (_b = typeof EventEmitter !== "undefined" && EventEmitter) === "function" ? _b : Object)
    ], GaugeComponent.prototype, "deactivate", void 0);
    __decorate([
        ContentChild('tooltipTemplate', { static: false }),
        __metadata("design:type", typeof (_c = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _c : Object)
    ], GaugeComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        ViewChild('textEl', { static: false }),
        __metadata("design:type", typeof (_d = typeof ElementRef !== "undefined" && ElementRef) === "function" ? _d : Object)
    ], GaugeComponent.prototype, "textEl", void 0);
GaugeComponent.ɵfac = function GaugeComponent_Factory(t) { return ɵGaugeComponent_BaseFactory(t || GaugeComponent); };
GaugeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeComponent, selectors: [["ngx-charts-gauge"]], contentQueries: function GaugeComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, _c21, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipTemplate = _t.first);
    } }, viewQuery: function GaugeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c45, 1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textEl = _t.first);
    } }, inputs: { margin: "margin", startAngle: "startAngle", angleSpan: "angleSpan", min: "min", max: "max", activeEntries: "activeEntries", legend: "legend", legendTitle: "legendTitle", legendPosition: "legendPosition", textValue: "textValue", units: "units", bigSegments: "bigSegments", smallSegments: "smallSegments", results: "results", showAxis: "showAxis", axisTickFormatting: "axisTickFormatting", tooltipDisabled: "tooltipDisabled", valueFormatting: "valueFormatting", showText: "showText" }, outputs: { activate: "activate", deactivate: "deactivate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 13, consts: [[3, "view", "showLegend", "legendOptions", "activeEntries", "animations", "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"], [1, "gauge", "chart"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting", 4, "ngIf"], ["alignment-baseline", "central", 3, "textAnchor", 4, "ngIf"], ["ngx-charts-gauge-arc", "", 3, "backgroundArc", "valueArc", "cornerRadius", "colors", "isActive", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "animations", "select", "activate", "deactivate"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting"], ["alignment-baseline", "central"], ["textEl", ""], ["x", "0", "dy", "0"], ["x", "0", "dy", "1.2em"]], template: function GaugeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ngx-charts-chart", 0);
        ɵngcc0.ɵɵlistener("legendLabelClick", function GaugeComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) { return ctx.onClick($event); })("legendLabelActivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) { return ctx.onActivate($event); })("legendLabelDeactivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) { return ctx.onDeactivate($event); });
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵtemplate(2, GaugeComponent__svg_g_2_Template, 2, 10, "g", 2);
        ɵngcc0.ɵɵtemplate(3, GaugeComponent__svg_g_3_Template, 1, 9, "g", 3);
        ɵngcc0.ɵɵtemplate(4, GaugeComponent__svg_text_4_Template, 6, 5, "text", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("view", ɵngcc0.ɵɵpureFunction2(10, _c23, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("transform", ctx.transform);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showAxis);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showText);
    } }, directives: function () { return [ChartComponent, ɵngcc1.NgForOf, ɵngcc1.NgIf, GaugeArcComponent, GaugeAxisComponent]; }, styles: [_c24, ".gauge .background-arc path{fill:rgba(0,0,0,.05)}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{font-size:12px;fill:#666;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}"], encapsulation: 2, changeDetection: 0 });
var ɵGaugeComponent_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(GaugeComponent);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GaugeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-charts-gauge',
                template: "\n    <ngx-charts-chart\n      [view]=\"[width, height]\"\n      [showLegend]=\"legend\"\n      [legendOptions]=\"legendOptions\"\n      [activeEntries]=\"activeEntries\"\n      [animations]=\"animations\"\n      (legendLabelClick)=\"onClick($event)\"\n      (legendLabelActivate)=\"onActivate($event)\"\n      (legendLabelDeactivate)=\"onDeactivate($event)\"\n    >\n      <svg:g [attr.transform]=\"transform\" class=\"gauge chart\">\n        <svg:g *ngFor=\"let arc of arcs; trackBy: trackBy\" [attr.transform]=\"rotation\">\n          <svg:g\n            ngx-charts-gauge-arc\n            [backgroundArc]=\"arc.backgroundArc\"\n            [valueArc]=\"arc.valueArc\"\n            [cornerRadius]=\"cornerRadius\"\n            [colors]=\"colors\"\n            [isActive]=\"isActive(arc.valueArc.data)\"\n            [tooltipDisabled]=\"tooltipDisabled\"\n            [tooltipTemplate]=\"tooltipTemplate\"\n            [valueFormatting]=\"valueFormatting\"\n            [animations]=\"animations\"\n            (select)=\"onClick($event)\"\n            (activate)=\"onActivate($event)\"\n            (deactivate)=\"onDeactivate($event)\"\n          ></svg:g>\n        </svg:g>\n\n        <svg:g\n          ngx-charts-gauge-axis\n          *ngIf=\"showAxis\"\n          [bigSegments]=\"bigSegments\"\n          [smallSegments]=\"smallSegments\"\n          [min]=\"min\"\n          [max]=\"max\"\n          [radius]=\"outerRadius\"\n          [angleSpan]=\"angleSpan\"\n          [valueScale]=\"valueScale\"\n          [startAngle]=\"startAngle\"\n          [tickFormatting]=\"axisTickFormatting\"\n        ></svg:g>\n\n        <svg:text\n          #textEl\n          *ngIf=\"showText\"\n          [style.textAnchor]=\"'middle'\"\n          [attr.transform]=\"textTransform\"\n          alignment-baseline=\"central\"\n        >\n          <tspan x=\"0\" dy=\"0\">{{ displayValue }}</tspan>\n          <tspan x=\"0\" dy=\"1.2em\">{{ units }}</tspan>\n        </svg:text>\n      </svg:g>\n    </ngx-charts-chart>\n  ",
                styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .arc,.ngx-charts .bar,.ngx-charts .circle{cursor:pointer}.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .card.active,.ngx-charts .card:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .arc:focus,.ngx-charts .bar:focus,.ngx-charts .card:focus,.ngx-charts .cell:focus{outline:0}.ngx-charts .arc.hidden,.ngx-charts .bar.hidden,.ngx-charts .card.hidden,.ngx-charts .cell.hidden{display:none}.ngx-charts g:focus{outline:0}.ngx-charts .area-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .line-series.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .polar-series-path.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:rgba(0,0,0,.05)}", ".gauge .background-arc path{fill:rgba(0,0,0,.05)}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{font-size:12px;fill:#666;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}"],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { margin: [{
            type: Input
        }], startAngle: [{
            type: Input
        }], angleSpan: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], activeEntries: [{
            type: Input
        }], legend: [{
            type: Input
        }], legendTitle: [{
            type: Input
        }], legendPosition: [{
            type: Input
        }], textValue: [{
            type: Input
        }], units: [{
            type: Input
        }], bigSegments: [{
            type: Input
        }], smallSegments: [{
            type: Input
        }], results: [{
            type: Input
        }], showAxis: [{
            type: Input
        }], axisTickFormatting: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], showText: [{
            type: Input
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], tooltipTemplate: [{
            type: ContentChild,
            args: ['tooltipTemplate', { static: false }]
        }], textEl: [{
            type: ViewChild,
            args: ['textEl', { static: false }]
        }] }); })();
    return GaugeComponent;
}(BaseChartComponent));

var GaugeArcComponent = /** @class */ (function () {
    function GaugeArcComponent() {
        this.isActive = false;
        this.tooltipDisabled = false;
        this.animations = true;
        this.select = new EventEmitter();
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
    }
    GaugeArcComponent.prototype.tooltipText = function (arc$$1) {
        var label = formatLabel(arc$$1.data.name);
        var val;
        if (this.valueFormatting) {
            val = this.valueFormatting(arc$$1.data.value);
        }
        else {
            val = formatLabel(arc$$1.data.value);
        }
        return "\n      <span class=\"tooltip-label\">" + label + "</span>\n      <span class=\"tooltip-val\">" + val + "</span>\n    ";
    };
    var _a, _b;
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "backgroundArc", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "valueArc", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "cornerRadius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_a = typeof ColorHelper !== "undefined" && ColorHelper) === "function" ? _a : Object)
    ], GaugeArcComponent.prototype, "colors", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeArcComponent.prototype, "isActive", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeArcComponent.prototype, "tooltipDisabled", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Function)
    ], GaugeArcComponent.prototype, "valueFormatting", void 0);
    __decorate([
        Input(),
        __metadata("design:type", typeof (_b = typeof TemplateRef !== "undefined" && TemplateRef) === "function" ? _b : Object)
    ], GaugeArcComponent.prototype, "tooltipTemplate", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], GaugeArcComponent.prototype, "animations", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "select", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "activate", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], GaugeArcComponent.prototype, "deactivate", void 0);
GaugeArcComponent.ɵfac = function GaugeArcComponent_Factory(t) { return new (t || GaugeArcComponent)(); };
GaugeArcComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeArcComponent, selectors: [["g", "ngx-charts-gauge-arc", ""]], inputs: { isActive: "isActive", tooltipDisabled: "tooltipDisabled", animations: "animations", backgroundArc: "backgroundArc", valueArc: "valueArc", cornerRadius: "cornerRadius", colors: "colors", valueFormatting: "valueFormatting", tooltipTemplate: "tooltipTemplate" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate" }, attrs: _c53, decls: 2, vars: 23, consts: [["ngx-charts-pie-arc", "", 1, "background-arc", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "data", "animate", "pointerEvents"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "fill", "data", "animate", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate"]], template: function GaugeArcComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelement(0, "g", 0);
        ɵngcc0.ɵɵelementStart(1, "g", 1);
        ɵngcc0.ɵɵlistener("select", function GaugeArcComponent_Template__svg_g_select_1_listener($event) { return ctx.select.emit($event); })("activate", function GaugeArcComponent_Template__svg_g_activate_1_listener($event) { return ctx.activate.emit($event); })("deactivate", function GaugeArcComponent_Template__svg_g_deactivate_1_listener($event) { return ctx.deactivate.emit($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("startAngle", 0)("endAngle", ctx.backgroundArc.endAngle)("innerRadius", ctx.backgroundArc.innerRadius)("outerRadius", ctx.backgroundArc.outerRadius)("cornerRadius", ctx.cornerRadius)("data", ctx.backgroundArc.data)("animate", false)("pointerEvents", false);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("startAngle", 0)("endAngle", ctx.valueArc.endAngle)("innerRadius", ctx.valueArc.innerRadius)("outerRadius", ctx.valueArc.outerRadius)("cornerRadius", ctx.cornerRadius)("fill", ctx.colors.getColor(ctx.valueArc.data.name))("data", ctx.valueArc.data)("animate", ctx.animations)("isActive", ctx.isActive)("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", "top")("tooltipType", "tooltip")("tooltipTitle", ctx.tooltipTemplate ? undefined : ctx.tooltipText(ctx.valueArc))("tooltipTemplate", ctx.tooltipTemplate)("tooltipContext", ctx.valueArc.data);
    } }, directives: [PieArcComponent, TooltipDirective], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GaugeArcComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-gauge-arc]',
                template: "\n    <svg:g ngx-charts-pie-arc\n      class=\"background-arc\"\n      [startAngle]=\"0\"\n      [endAngle]=\"backgroundArc.endAngle\"\n      [innerRadius]=\"backgroundArc.innerRadius\"\n      [outerRadius]=\"backgroundArc.outerRadius\"\n      [cornerRadius]=\"cornerRadius\"\n      [data]=\"backgroundArc.data\"\n      [animate]=\"false\"\n      [pointerEvents]=\"false\">\n    </svg:g>\n    <svg:g ngx-charts-pie-arc\n      [startAngle]=\"0\"\n      [endAngle]=\"valueArc.endAngle\"\n      [innerRadius]=\"valueArc.innerRadius\"\n      [outerRadius]=\"valueArc.outerRadius\"\n      [cornerRadius]=\"cornerRadius\"\n      [fill]=\"colors.getColor(valueArc.data.name)\"\n      [data]=\"valueArc.data\"\n      [animate]=\"animations\"\n      [isActive]=\"isActive\"\n      (select)=\"select.emit($event)\"\n      (activate)=\"activate.emit($event)\"\n      (deactivate)=\"deactivate.emit($event)\"\n      ngx-tooltip\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipPlacement]=\"'top'\"\n      [tooltipType]=\"'tooltip'\"\n      [tooltipTitle]=\"tooltipTemplate ? undefined : tooltipText(valueArc)\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [tooltipContext]=\"valueArc.data\">\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { isActive: [{
            type: Input
        }], tooltipDisabled: [{
            type: Input
        }], animations: [{
            type: Input
        }], select: [{
            type: Output
        }], activate: [{
            type: Output
        }], deactivate: [{
            type: Output
        }], backgroundArc: [{
            type: Input
        }], valueArc: [{
            type: Input
        }], cornerRadius: [{
            type: Input
        }], colors: [{
            type: Input
        }], valueFormatting: [{
            type: Input
        }], tooltipTemplate: [{
            type: Input
        }] }); })();
    return GaugeArcComponent;
}());

var GaugeAxisComponent = /** @class */ (function () {
    function GaugeAxisComponent() {
        this.rotate = '';
    }
    GaugeAxisComponent.prototype.ngOnChanges = function (changes) {
        this.update();
    };
    GaugeAxisComponent.prototype.update = function () {
        this.rotationAngle = -90 + this.startAngle;
        this.rotate = "rotate(" + this.rotationAngle + ")";
        this.ticks = this.getTicks();
    };
    GaugeAxisComponent.prototype.getTicks = function () {
        var bigTickSegment = this.angleSpan / this.bigSegments;
        var smallTickSegment = bigTickSegment / (this.smallSegments);
        var tickLength = 20;
        var ticks = {
            big: [],
            small: []
        };
        var startDistance = this.radius + 10;
        var textDist = startDistance + tickLength + 10;
        for (var i = 0; i <= this.bigSegments; i++) {
            var angleDeg = i * bigTickSegment;
            var angle = angleDeg * Math.PI / 180;
            var textAnchor = this.getTextAnchor(angleDeg);
            var skip = false;
            if (i === 0 && this.angleSpan === 360) {
                skip = true;
            }
            if (!skip) {
                var text = Number.parseFloat(this.valueScale.invert(angleDeg).toString()).toLocaleString();
                if (this.tickFormatting) {
                    text = this.tickFormatting(text);
                }
                ticks.big.push({
                    line: this.getTickPath(startDistance, tickLength, angle),
                    textAnchor: textAnchor,
                    text: text,
                    textTransform: "\n            translate(" + textDist * Math.cos(angle) + ", " + textDist * Math.sin(angle) + ") rotate(" + -this.rotationAngle + ")\n          "
                });
            }
            if (i === this.bigSegments) {
                continue;
            }
            for (var j = 1; j <= this.smallSegments; j++) {
                var smallAngleDeg = angleDeg + j * smallTickSegment;
                var smallAngle = smallAngleDeg * Math.PI / 180;
                ticks.small.push({
                    line: this.getTickPath(startDistance, tickLength / 2, smallAngle)
                });
            }
        }
        return ticks;
    };
    GaugeAxisComponent.prototype.getTextAnchor = function (angle) {
        // [0, 45] = 'middle';
        // [46, 135] = 'start';
        // [136, 225] = 'middle';
        // [226, 315] = 'end';
        angle = (this.startAngle + angle) % 360;
        var textAnchor = 'middle';
        if (angle > 45 && angle <= 135) {
            textAnchor = 'start';
        }
        else if (angle > 225 && angle <= 315) {
            textAnchor = 'end';
        }
        return textAnchor;
    };
    GaugeAxisComponent.prototype.getTickPath = function (startDistance, tickLength, angle) {
        var y1 = startDistance * Math.sin(angle);
        var y2 = (startDistance + tickLength) * Math.sin(angle);
        var x1 = startDistance * Math.cos(angle);
        var x2 = (startDistance + tickLength) * Math.cos(angle);
        var points = [{ x: x1, y: y1 }, { x: x2, y: y2 }];
        var lineGenerator = line().x(function (d) { return d.x; }).y(function (d) { return d.y; });
        return lineGenerator(points);
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "bigSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "smallSegments", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "min", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "max", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeAxisComponent.prototype, "angleSpan", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], GaugeAxisComponent.prototype, "startAngle", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "radius", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "valueScale", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], GaugeAxisComponent.prototype, "tickFormatting", void 0);
GaugeAxisComponent.ɵfac = function GaugeAxisComponent_Factory(t) { return new (t || GaugeAxisComponent)(); };
GaugeAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: GaugeAxisComponent, selectors: [["g", "ngx-charts-gauge-axis", ""]], inputs: { bigSegments: "bigSegments", smallSegments: "smallSegments", min: "min", max: "max", angleSpan: "angleSpan", startAngle: "startAngle", radius: "radius", valueScale: "valueScale", tickFormatting: "tickFormatting" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c54, decls: 4, vars: 4, consts: [["class", "gauge-tick gauge-tick-large", 4, "ngFor", "ngForOf"], ["class", "gauge-tick gauge-tick-small", 4, "ngFor", "ngForOf"], [1, "gauge-tick", "gauge-tick-large"], ["alignment-baseline", "central"], [1, "gauge-tick", "gauge-tick-small"]], template: function GaugeAxisComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "g");
        ɵngcc0.ɵɵtemplate(1, GaugeAxisComponent__svg_g_1_Template, 2, 1, "g", 0);
        ɵngcc0.ɵɵtemplate(2, GaugeAxisComponent__svg_g_2_Template, 3, 4, "g", 0);
        ɵngcc0.ɵɵtemplate(3, GaugeAxisComponent__svg_g_3_Template, 2, 1, "g", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("transform", ctx.rotate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.big);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.ticks.small);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GaugeAxisComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-gauge-axis]',
                template: "\n    <svg:g [attr.transform]=\"rotate\">\n        <svg:g *ngFor=\"let tick of ticks.big\"\n            class=\"gauge-tick gauge-tick-large\">\n            <svg:path [attr.d]=\"tick.line\" />\n        </svg:g>\n        <svg:g *ngFor=\"let tick of ticks.big\"\n            class=\"gauge-tick gauge-tick-large\">\n            <svg:text\n                [style.textAnchor]=\"tick.textAnchor\"\n                [attr.transform]=\"tick.textTransform\"\n                alignment-baseline=\"central\">\n                {{tick.text}}\n            </svg:text>\n        </svg:g>\n        <svg:g *ngFor=\"let tick of ticks.small\"\n            class=\"gauge-tick gauge-tick-small\">\n            <svg:path [attr.d]=\"tick.line\" />\n        </svg:g>\n    </svg:g>\n  ",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { bigSegments: [{
            type: Input
        }], smallSegments: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], angleSpan: [{
            type: Input
        }], startAngle: [{
            type: Input
        }], radius: [{
            type: Input
        }], valueScale: [{
            type: Input
        }], tickFormatting: [{
            type: Input
        }] }); })();
    return GaugeAxisComponent;
}());

var GaugeModule = /** @class */ (function () {
    function GaugeModule() {
    }
GaugeModule.ɵfac = function GaugeModule_Factory(t) { return new (t || GaugeModule)(); };
GaugeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: GaugeModule });
GaugeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[ChartCommonModule, PieChartModule, BarChartModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GaugeModule, { declarations: [LinearGaugeComponent, GaugeComponent, GaugeArcComponent, GaugeAxisComponent], imports: [ChartCommonModule, PieChartModule, BarChartModule], exports: [LinearGaugeComponent, GaugeComponent, GaugeArcComponent, GaugeAxisComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(GaugeModule, [{
        type: NgModule,
        args: [{
                imports: [ChartCommonModule, PieChartModule, BarChartModule],
                declarations: [
                    LinearGaugeComponent,
                    GaugeComponent,
                    GaugeArcComponent,
                    GaugeAxisComponent
                ],
                exports: [
                    LinearGaugeComponent,
                    GaugeComponent,
                    GaugeArcComponent,
                    GaugeAxisComponent
                ]
            }]
    }], function () { return []; }, null); })();
    return GaugeModule;
}());

var NgxChartsModule = /** @class */ (function () {
    function NgxChartsModule() {
    }
NgxChartsModule.ɵfac = function NgxChartsModule_Factory(t) { return new (t || NgxChartsModule)(); };
NgxChartsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxChartsModule });
NgxChartsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [ChartCommonModule, AreaChartModule, BarChartModule, BubbleChartModule, ForceDirectedGraphModule, HeatMapModule, LineChartModule, PolarChartModule, NumberCardModule, PieChartModule, TreeMapModule, GaugeModule] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxChartsModule, { exports: [ChartCommonModule, AreaChartModule, BarChartModule, BubbleChartModule, ForceDirectedGraphModule, HeatMapModule, LineChartModule, PolarChartModule, NumberCardModule, PieChartModule, TreeMapModule, GaugeModule] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxChartsModule, [{
        type: NgModule,
        args: [{
                exports: [
                    ChartCommonModule,
                    AreaChartModule,
                    BarChartModule,
                    BubbleChartModule,
                    ForceDirectedGraphModule,
                    HeatMapModule,
                    LineChartModule,
                    PolarChartModule,
                    NumberCardModule,
                    PieChartModule,
                    TreeMapModule,
                    GaugeModule
                ]
            }]
    }], function () { return []; }, null); })();
    return NgxChartsModule;
}());

function tickFormat(fieldType, groupByType) {
    return function (label) {
        if (label === 'No Value' || label === 'Other') {
            return label;
        }
        if (fieldType === 'date' && groupByType === 'groupBy') {
            var formatter = timeFormat('MM/DD/YYYY');
            return formatter(label);
        }
        return label.toString();
    };
}

export { NgxChartsModule, ChartCommonModule, LegendComponent, ScaleLegendComponent, LegendEntryComponent, AdvancedLegendComponent, TooltipModule, TooltipService, TooltipContentComponent, TooltipDirective, StyleTypes, AlignmentTypes, ShowTypes, AxesModule, AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent, reduceTicks, CountUpDirective, count, decimalChecker, Timeline, ColorHelper, ChartComponent, AreaComponent, BaseChartComponent, CircleComponent, CircleSeriesComponent, gridSize, gridLayout, GridPanelComponent, GridPanelSeriesComponent, SvgLinearGradientComponent, SvgRadialGradientComponent, TooltipArea, tickFormat, trimLabel, calculateViewDimensions, formatLabel, getUniqueXDomainValues, getScaleType, AreaChartModule, AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent, BarChartModule, BarComponent, BarHorizontalComponent, BarHorizontal2DComponent, BarHorizontalNormalizedComponent, BarHorizontalStackedComponent, SeriesHorizontal, BarLabelComponent, BarVerticalComponent, BarVertical2DComponent, BarVerticalNormalizedComponent, BarVerticalStackedComponent, D0Types, SeriesVerticalComponent, BubbleChartModule, BubbleChartComponent, getDomain, getScale, BubbleSeriesComponent, ForceDirectedGraphModule, ForceDirectedGraphComponent, HeatMapModule, HeatMapComponent, HeatMapCellComponent, HeatCellSeriesComponent, LineChartModule, LineChartComponent, LineComponent, LineSeriesComponent, PolarChartModule, PolarChartComponent, PolarSeriesComponent, NumberCardModule, NumberCardComponent, CardComponent, CardSeriesComponent, PieChartModule, AdvancedPieChartComponent, PieChartComponent, PieArcComponent, PieGridComponent, PieGridSeriesComponent, PieSeriesComponent, PieLabelComponent, TreeMapModule, TreeMapComponent, TreeMapCellComponent, TreeMapCellSeriesComponent, GaugeModule, GaugeArcComponent, GaugeAxisComponent, GaugeComponent, LinearGaugeComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXNtLmpzIiwic291cmNlcyI6WyJlc20uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBRU87QUFDUDs7Ozs7Z1lBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBT087QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUVPO0FBQ1A7Ozs7O2dLQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUVPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Z0RBU3NCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQWVPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQVFPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FRTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU82QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBU2dDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBS087QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU80QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU91QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Z0RBT21CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQWlCOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT2lDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT21DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQVFPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FNTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQXVCb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBS087QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBZTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVMyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWlCd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBUytCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQW9CaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQW9CeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBb0JzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBUzZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQW9CK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQW9CdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBb0JvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBaUJnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFpQnlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQU9PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFpQ3VCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBcUI2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFrQjhCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O2dEQVdpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBU3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBZXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FtQk87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQXFCMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFld0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBeUI0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVNrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVN5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FNTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU8yQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBdUJ1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFheUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQU1PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQU80QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVM0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWV5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBTU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBT21DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBU3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBZXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQVM2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFTdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFPMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFpQm9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBa0J3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwbGljYXRpb25SZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgSW5qZWN0YWJsZSwgSW5qZWN0b3IsIElucHV0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIFZpZXdFbmNhcHN1bGF0aW9uLCBIb3N0TGlzdGVuZXIsIFZpZXdDaGlsZCwgSG9zdEJpbmRpbmcsIFJlbmRlcmVyMiwgRGlyZWN0aXZlLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgVmlld0NvbnRhaW5lclJlZiwgTmdNb2R1bGUsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgTmdab25lLCBUZW1wbGF0ZVJlZiwgQ29udGVudENoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IHRyaWdnZXIsIHN0eWxlLCBhbmltYXRlLCB0cmFuc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XHJcbmltcG9ydCB7IERvbVNhbml0aXplciB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG5pbXBvcnQgeyByZ2IgfSBmcm9tICdkMy1jb2xvcic7XHJcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IHJhbmdlLCBtaW4sIG1heCB9IGZyb20gJ2QzLWFycmF5JztcclxuaW1wb3J0IHsgc2NhbGVCYW5kLCBzY2FsZUxpbmVhciwgc2NhbGVPcmRpbmFsLCBzY2FsZVF1YW50aWxlLCBzY2FsZVRpbWUsIHNjYWxlUG9pbnQgfSBmcm9tICdkMy1zY2FsZSc7XHJcbmltcG9ydCB7IGJydXNoWCB9IGZyb20gJ2QzLWJydXNoJztcclxuaW1wb3J0IHsgc2VsZWN0LCBldmVudCB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XHJcbmltcG9ydCB7IGN1cnZlTGluZWFyLCBhcmVhLCBsaW5lLCBjdXJ2ZUNhcmRpbmFsQ2xvc2VkLCBsaW5lUmFkaWFsLCBhcmMsIHBpZSB9IGZyb20gJ2QzLXNoYXBlJztcclxuaW1wb3J0IHsgZm9yY2VDb2xsaWRlLCBmb3JjZUxpbmssIGZvcmNlTWFueUJvZHksIGZvcmNlU2ltdWxhdGlvbiwgZm9yY2VYLCBmb3JjZVkgfSBmcm9tICdkMy1mb3JjZSc7XHJcbmltcG9ydCB7IGludGVycG9sYXRlIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUnO1xyXG5pbXBvcnQgeyBmb3JtYXQgfSBmcm9tICdkMy1mb3JtYXQnO1xyXG5pbXBvcnQgeyB0cmVlbWFwLCBzdHJhdGlmeSB9IGZyb20gJ2QzLWhpZXJhcmNoeSc7XHJcbmltcG9ydCB7IHRpbWVGb3JtYXQgfSBmcm9tICdkMy10aW1lLWZvcm1hdCc7XHJcblxyXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuLy8gVGhlIGV4cG9ydCBpcyBuZWVkZWQgaGVyZSB0byBnZW5lcmF0ZSBhIHZhbGlkIHBvbHlmaWxscy5tZXRhZGF0YS5qc29uIGZpbGVcclxuZnVuY3Rpb24gbmd4Q2hhcnRzUG9seWZpbGxzKCkge1xyXG4gICAgLy8gSUUxMSBmaXhcclxuICAgIC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL3N3aW1sYW5lL25neC1jaGFydHMvaXNzdWVzLzM4NlxyXG4gICAgaWYgKHR5cGVvZiAoU1ZHRWxlbWVudCkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBTVkdFbGVtZW50LnByb3RvdHlwZS5jb250YWlucyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBTVkdFbGVtZW50LnByb3RvdHlwZS5jb250YWlucyA9IEhUTUxEaXZFbGVtZW50LnByb3RvdHlwZS5jb250YWlucztcclxuICAgIH1cclxufVxyXG5uZ3hDaGFydHNQb2x5ZmlsbHMoKTtcclxuXHJcbnZhciBQbGFjZW1lbnRUeXBlcztcclxuKGZ1bmN0aW9uIChQbGFjZW1lbnRUeXBlcykge1xyXG4gICAgUGxhY2VtZW50VHlwZXNbUGxhY2VtZW50VHlwZXNbXCJ0b3BcIl0gPSAndG9wJ10gPSBcInRvcFwiO1xyXG4gICAgUGxhY2VtZW50VHlwZXNbUGxhY2VtZW50VHlwZXNbXCJib3R0b21cIl0gPSAnYm90dG9tJ10gPSBcImJvdHRvbVwiO1xyXG4gICAgUGxhY2VtZW50VHlwZXNbUGxhY2VtZW50VHlwZXNbXCJsZWZ0XCJdID0gJ2xlZnQnXSA9IFwibGVmdFwiO1xyXG4gICAgUGxhY2VtZW50VHlwZXNbUGxhY2VtZW50VHlwZXNbXCJyaWdodFwiXSA9ICdyaWdodCddID0gXCJyaWdodFwiO1xyXG59KShQbGFjZW1lbnRUeXBlcyB8fCAoUGxhY2VtZW50VHlwZXMgPSB7fSkpO1xyXG5cclxudmFyIGNhcmV0T2Zmc2V0ID0gNztcclxuZnVuY3Rpb24gdmVydGljYWxQb3NpdGlvbihlbERpbWVuc2lvbnMsIHBvcG92ZXJEaW1lbnNpb25zLCBhbGlnbm1lbnQpIHtcclxuICAgIGlmIChhbGlnbm1lbnQgPT09ICd0b3AnKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsRGltZW5zaW9ucy50b3AgLSBjYXJldE9mZnNldDtcclxuICAgIH1cclxuICAgIGlmIChhbGlnbm1lbnQgPT09ICdib3R0b20nKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsRGltZW5zaW9ucy50b3AgKyBlbERpbWVuc2lvbnMuaGVpZ2h0IC0gcG9wb3ZlckRpbWVuc2lvbnMuaGVpZ2h0ICsgY2FyZXRPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBpZiAoYWxpZ25tZW50ID09PSAnY2VudGVyJykge1xyXG4gICAgICAgIHJldHVybiBlbERpbWVuc2lvbnMudG9wICsgZWxEaW1lbnNpb25zLmhlaWdodCAvIDIgLSBwb3BvdmVyRGltZW5zaW9ucy5oZWlnaHQgLyAyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBob3Jpem9udGFsUG9zaXRpb24oZWxEaW1lbnNpb25zLCBwb3BvdmVyRGltZW5zaW9ucywgYWxpZ25tZW50KSB7XHJcbiAgICBpZiAoYWxpZ25tZW50ID09PSAnbGVmdCcpIHtcclxuICAgICAgICByZXR1cm4gZWxEaW1lbnNpb25zLmxlZnQgLSBjYXJldE9mZnNldDtcclxuICAgIH1cclxuICAgIGlmIChhbGlnbm1lbnQgPT09ICdyaWdodCcpIHtcclxuICAgICAgICByZXR1cm4gZWxEaW1lbnNpb25zLmxlZnQgKyBlbERpbWVuc2lvbnMud2lkdGggLSBwb3BvdmVyRGltZW5zaW9ucy53aWR0aCArIGNhcmV0T2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgaWYgKGFsaWdubWVudCA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICByZXR1cm4gZWxEaW1lbnNpb25zLmxlZnQgKyBlbERpbWVuc2lvbnMud2lkdGggLyAyIC0gcG9wb3ZlckRpbWVuc2lvbnMud2lkdGggLyAyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogUG9zaXRpb24gaGVscGVyIGZvciB0aGUgcG9wb3ZlciBkaXJlY3RpdmUuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIFBvc2l0aW9uSGVscGVyXHJcbiAqL1xyXG52YXIgUG9zaXRpb25IZWxwZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQb3NpdGlvbkhlbHBlcigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHZlcnRpY2FsIGFsaWdubWVudCBwb3NpdGlvblxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7YW55fSBlbERpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSB7YW55fSBwb3BvdmVyRGltZW5zaW9uc1xyXG4gICAgICogQHBhcmFtIHthbnl9IGFsaWdubWVudFxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgUG9zaXRpb25IZWxwZXJcclxuICAgICAqL1xyXG4gICAgUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlVmVydGljYWxBbGlnbm1lbnQgPSBmdW5jdGlvbiAoZWxEaW1lbnNpb25zLCBwb3BvdmVyRGltZW5zaW9ucywgYWxpZ25tZW50KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHZlcnRpY2FsUG9zaXRpb24oZWxEaW1lbnNpb25zLCBwb3BvdmVyRGltZW5zaW9ucywgYWxpZ25tZW50KTtcclxuICAgICAgICBpZiAocmVzdWx0ICsgcG9wb3ZlckRpbWVuc2lvbnMuaGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB2ZXJ0aWNhbCBjYXJldCBwb3NpdGlvblxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7YW55fSBlbERpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSB7YW55fSBwb3BvdmVyRGltZW5zaW9uc1xyXG4gICAgICogQHBhcmFtIHthbnl9IGNhcmV0RGltZW5zaW9uc1xyXG4gICAgICogQHBhcmFtIHthbnl9IGFsaWdubWVudFxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgUG9zaXRpb25IZWxwZXJcclxuICAgICAqL1xyXG4gICAgUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlVmVydGljYWxDYXJldCA9IGZ1bmN0aW9uIChlbERpbWVuc2lvbnMsIHBvcG92ZXJEaW1lbnNpb25zLCBjYXJldERpbWVuc2lvbnMsIGFsaWdubWVudCkge1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgaWYgKGFsaWdubWVudCA9PT0gJ3RvcCcpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZWxEaW1lbnNpb25zLmhlaWdodCAvIDIgLSBjYXJldERpbWVuc2lvbnMuaGVpZ2h0IC8gMiArIGNhcmV0T2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxpZ25tZW50ID09PSAnYm90dG9tJykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBwb3BvdmVyRGltZW5zaW9ucy5oZWlnaHQgLSBlbERpbWVuc2lvbnMuaGVpZ2h0IC8gMiAtIGNhcmV0RGltZW5zaW9ucy5oZWlnaHQgLyAyIC0gY2FyZXRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbGlnbm1lbnQgPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodCAvIDIgLSBjYXJldERpbWVuc2lvbnMuaGVpZ2h0IC8gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvcG92ZXJQb3NpdGlvbiA9IHZlcnRpY2FsUG9zaXRpb24oZWxEaW1lbnNpb25zLCBwb3BvdmVyRGltZW5zaW9ucywgYWxpZ25tZW50KTtcclxuICAgICAgICBpZiAocG9wb3ZlclBvc2l0aW9uICsgcG9wb3ZlckRpbWVuc2lvbnMuaGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAocG9wb3ZlclBvc2l0aW9uICsgcG9wb3ZlckRpbWVuc2lvbnMuaGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSBob3J6IGFsaWdubWVudCBwb3NpdGlvblxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7YW55fSBlbERpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSB7YW55fSBwb3BvdmVyRGltZW5zaW9uc1xyXG4gICAgICogQHBhcmFtIHthbnl9IGFsaWdubWVudFxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgUG9zaXRpb25IZWxwZXJcclxuICAgICAqL1xyXG4gICAgUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlSG9yaXpvbnRhbEFsaWdubWVudCA9IGZ1bmN0aW9uIChlbERpbWVuc2lvbnMsIHBvcG92ZXJEaW1lbnNpb25zLCBhbGlnbm1lbnQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gaG9yaXpvbnRhbFBvc2l0aW9uKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIGFsaWdubWVudCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCArIHBvcG92ZXJEaW1lbnNpb25zLndpZHRoID4gd2luZG93LmlubmVyV2lkdGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gd2luZG93LmlubmVyV2lkdGggLSBwb3BvdmVyRGltZW5zaW9ucy53aWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSBob3J6IGNhcmV0IHBvc2l0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHthbnl9IGVsRGltZW5zaW9uc1xyXG4gICAgICogQHBhcmFtIHthbnl9IHBvcG92ZXJEaW1lbnNpb25zXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gY2FyZXREaW1lbnNpb25zXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gYWxpZ25tZW50XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBQb3NpdGlvbkhlbHBlclxyXG4gICAgICovXHJcbiAgICBQb3NpdGlvbkhlbHBlci5jYWxjdWxhdGVIb3Jpem9udGFsQ2FyZXQgPSBmdW5jdGlvbiAoZWxEaW1lbnNpb25zLCBwb3BvdmVyRGltZW5zaW9ucywgY2FyZXREaW1lbnNpb25zLCBhbGlnbm1lbnQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIGlmIChhbGlnbm1lbnQgPT09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBlbERpbWVuc2lvbnMud2lkdGggLyAyIC0gY2FyZXREaW1lbnNpb25zLndpZHRoIC8gMiArIGNhcmV0T2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxpZ25tZW50ID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHBvcG92ZXJEaW1lbnNpb25zLndpZHRoIC0gZWxEaW1lbnNpb25zLndpZHRoIC8gMiAtIGNhcmV0RGltZW5zaW9ucy53aWR0aCAvIDIgLSBjYXJldE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsaWdubWVudCA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcG9wb3ZlckRpbWVuc2lvbnMud2lkdGggLyAyIC0gY2FyZXREaW1lbnNpb25zLndpZHRoIC8gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvcG92ZXJQb3NpdGlvbiA9IGhvcml6b250YWxQb3NpdGlvbihlbERpbWVuc2lvbnMsIHBvcG92ZXJEaW1lbnNpb25zLCBhbGlnbm1lbnQpO1xyXG4gICAgICAgIGlmIChwb3BvdmVyUG9zaXRpb24gKyBwb3BvdmVyRGltZW5zaW9ucy53aWR0aCA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAocG9wb3ZlclBvc2l0aW9uICsgcG9wb3ZlckRpbWVuc2lvbnMud2lkdGggLSB3aW5kb3cuaW5uZXJXaWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIGVsZW1lbnQncyBwb3NpdGlvbiBzaG91bGQgYmUgZmxpcHBlZFxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7YW55fSBlbERpbWVuc2lvbnNcclxuICAgICAqIEBwYXJhbSB7YW55fSBwb3BvdmVyRGltZW5zaW9uc1xyXG4gICAgICogQHBhcmFtIHthbnl9IHBsYWNlbWVudFxyXG4gICAgICogQHBhcmFtIHthbnl9IHNwYWNpbmdcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBQb3NpdGlvbkhlbHBlclxyXG4gICAgICovXHJcbiAgICBQb3NpdGlvbkhlbHBlci5zaG91bGRGbGlwID0gZnVuY3Rpb24gKGVsRGltZW5zaW9ucywgcG9wb3ZlckRpbWVuc2lvbnMsIHBsYWNlbWVudCwgc3BhY2luZykge1xyXG4gICAgICAgIHZhciBmbGlwID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICBpZiAoZWxEaW1lbnNpb25zLmxlZnQgKyBlbERpbWVuc2lvbnMud2lkdGggKyBwb3BvdmVyRGltZW5zaW9ucy53aWR0aCArIHNwYWNpbmcgPiB3aW5kb3cuaW5uZXJXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgZmxpcCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgIGlmIChlbERpbWVuc2lvbnMubGVmdCAtIHBvcG92ZXJEaW1lbnNpb25zLndpZHRoIC0gc3BhY2luZyA8IDApIHtcclxuICAgICAgICAgICAgICAgIGZsaXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwbGFjZW1lbnQgPT09ICd0b3AnKSB7XHJcbiAgICAgICAgICAgIGlmIChlbERpbWVuc2lvbnMudG9wIC0gcG9wb3ZlckRpbWVuc2lvbnMuaGVpZ2h0IC0gc3BhY2luZyA8IDApIHtcclxuICAgICAgICAgICAgICAgIGZsaXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XHJcbiAgICAgICAgICAgIGlmIChlbERpbWVuc2lvbnMudG9wICsgZWxEaW1lbnNpb25zLmhlaWdodCArIHBvcG92ZXJEaW1lbnNpb25zLmhlaWdodCArIHNwYWNpbmcgPiB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGZsaXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmbGlwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gY2FyZXRcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gcGxhY2VtZW50XHJcbiAgICAgKiBAcGFyYW0ge2FueX0gZWxtRGltXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gaG9zdERpbVxyXG4gICAgICogQHBhcmFtIHthbnl9IGNhcmV0RGltZW5zaW9uc1xyXG4gICAgICogQHBhcmFtIHthbnl9IGFsaWdubWVudFxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIFBvc2l0aW9uSGVscGVyXHJcbiAgICAgKi9cclxuICAgIFBvc2l0aW9uSGVscGVyLnBvc2l0aW9uQ2FyZXQgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBlbG1EaW0sIGhvc3REaW0sIGNhcmV0RGltZW5zaW9ucywgYWxpZ25tZW50KSB7XHJcbiAgICAgICAgdmFyIHRvcCA9IDA7XHJcbiAgICAgICAgdmFyIGxlZnQgPSAwO1xyXG4gICAgICAgIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSAtNztcclxuICAgICAgICAgICAgdG9wID0gUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlVmVydGljYWxDYXJldChob3N0RGltLCBlbG1EaW0sIGNhcmV0RGltZW5zaW9ucywgYWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGxhY2VtZW50ID09PSBQbGFjZW1lbnRUeXBlcy5sZWZ0KSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBlbG1EaW0ud2lkdGg7XHJcbiAgICAgICAgICAgIHRvcCA9IFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZVZlcnRpY2FsQ2FyZXQoaG9zdERpbSwgZWxtRGltLCBjYXJldERpbWVuc2lvbnMsIGFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMudG9wKSB7XHJcbiAgICAgICAgICAgIHRvcCA9IGVsbURpbS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGxlZnQgPSBQb3NpdGlvbkhlbHBlci5jYWxjdWxhdGVIb3Jpem9udGFsQ2FyZXQoaG9zdERpbSwgZWxtRGltLCBjYXJldERpbWVuc2lvbnMsIGFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gUGxhY2VtZW50VHlwZXMuYm90dG9tKSB7XHJcbiAgICAgICAgICAgIHRvcCA9IC03O1xyXG4gICAgICAgICAgICBsZWZ0ID0gUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlSG9yaXpvbnRhbENhcmV0KGhvc3REaW0sIGVsbURpbSwgY2FyZXREaW1lbnNpb25zLCBhbGlnbm1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gY29udGVudFxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7YW55fSBwbGFjZW1lbnRcclxuICAgICAqIEBwYXJhbSB7YW55fSBlbG1EaW1cclxuICAgICAqIEBwYXJhbSB7YW55fSBob3N0RGltXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gc3BhY2luZ1xyXG4gICAgICogQHBhcmFtIHthbnl9IGFsaWdubWVudFxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIFBvc2l0aW9uSGVscGVyXHJcbiAgICAgKi9cclxuICAgIFBvc2l0aW9uSGVscGVyLnBvc2l0aW9uQ29udGVudCA9IGZ1bmN0aW9uIChwbGFjZW1lbnQsIGVsbURpbSwgaG9zdERpbSwgc3BhY2luZywgYWxpZ25tZW50KSB7XHJcbiAgICAgICAgdmFyIHRvcCA9IDA7XHJcbiAgICAgICAgdmFyIGxlZnQgPSAwO1xyXG4gICAgICAgIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBob3N0RGltLmxlZnQgKyBob3N0RGltLndpZHRoICsgc3BhY2luZztcclxuICAgICAgICAgICAgdG9wID0gUG9zaXRpb25IZWxwZXIuY2FsY3VsYXRlVmVydGljYWxBbGlnbm1lbnQoaG9zdERpbSwgZWxtRGltLCBhbGlnbm1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLmxlZnQpIHtcclxuICAgICAgICAgICAgbGVmdCA9IGhvc3REaW0ubGVmdCAtIGVsbURpbS53aWR0aCAtIHNwYWNpbmc7XHJcbiAgICAgICAgICAgIHRvcCA9IFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZVZlcnRpY2FsQWxpZ25tZW50KGhvc3REaW0sIGVsbURpbSwgYWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGxhY2VtZW50ID09PSBQbGFjZW1lbnRUeXBlcy50b3ApIHtcclxuICAgICAgICAgICAgdG9wID0gaG9zdERpbS50b3AgLSBlbG1EaW0uaGVpZ2h0IC0gc3BhY2luZztcclxuICAgICAgICAgICAgbGVmdCA9IFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZUhvcml6b250YWxBbGlnbm1lbnQoaG9zdERpbSwgZWxtRGltLCBhbGlnbm1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwbGFjZW1lbnQgPT09IFBsYWNlbWVudFR5cGVzLmJvdHRvbSkge1xyXG4gICAgICAgICAgICB0b3AgPSBob3N0RGltLnRvcCArIGhvc3REaW0uaGVpZ2h0ICsgc3BhY2luZztcclxuICAgICAgICAgICAgbGVmdCA9IFBvc2l0aW9uSGVscGVyLmNhbGN1bGF0ZUhvcml6b250YWxBbGlnbm1lbnQoaG9zdERpbSwgZWxtRGltLCBhbGlnbm1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lIHBsYWNlbWVudCBiYXNlZCBvbiBmbGlwXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHthbnl9IHBsYWNlbWVudFxyXG4gICAgICogQHBhcmFtIHthbnl9IGVsbURpbVxyXG4gICAgICogQHBhcmFtIHthbnl9IGhvc3REaW1cclxuICAgICAqIEBwYXJhbSB7YW55fSBzcGFjaW5nXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgUG9zaXRpb25IZWxwZXJcclxuICAgICAqL1xyXG4gICAgUG9zaXRpb25IZWxwZXIuZGV0ZXJtaW5lUGxhY2VtZW50ID0gZnVuY3Rpb24gKHBsYWNlbWVudCwgZWxtRGltLCBob3N0RGltLCBzcGFjaW5nKSB7XHJcbiAgICAgICAgdmFyIHNob3VsZEZsaXAgPSBQb3NpdGlvbkhlbHBlci5zaG91bGRGbGlwKGhvc3REaW0sIGVsbURpbSwgcGxhY2VtZW50LCBzcGFjaW5nKTtcclxuICAgICAgICBpZiAoc2hvdWxkRmxpcCkge1xyXG4gICAgICAgICAgICBpZiAocGxhY2VtZW50ID09PSBQbGFjZW1lbnRUeXBlcy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsYWNlbWVudFR5cGVzLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2VtZW50ID09PSBQbGFjZW1lbnRUeXBlcy5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGxhY2VtZW50VHlwZXMucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2VtZW50ID09PSBQbGFjZW1lbnRUeXBlcy50b3ApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbGFjZW1lbnRUeXBlcy5ib3R0b207XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2VtZW50ID09PSBQbGFjZW1lbnRUeXBlcy5ib3R0b20pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQbGFjZW1lbnRUeXBlcy50b3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBsYWNlbWVudDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUG9zaXRpb25IZWxwZXI7XHJcbn0oKSk7XHJcblxyXG52YXIgU3R5bGVUeXBlcztcclxuKGZ1bmN0aW9uIChTdHlsZVR5cGVzKSB7XHJcbiAgICBTdHlsZVR5cGVzW1N0eWxlVHlwZXNbXCJwb3BvdmVyXCJdID0gJ3BvcG92ZXInXSA9IFwicG9wb3ZlclwiO1xyXG4gICAgU3R5bGVUeXBlc1tTdHlsZVR5cGVzW1widG9vbHRpcFwiXSA9ICd0b29sdGlwJ10gPSBcInRvb2x0aXBcIjtcclxufSkoU3R5bGVUeXBlcyB8fCAoU3R5bGVUeXBlcyA9IHt9KSk7XHJcblxyXG52YXIgQWxpZ25tZW50VHlwZXM7XHJcbihmdW5jdGlvbiAoQWxpZ25tZW50VHlwZXMpIHtcclxuICAgIEFsaWdubWVudFR5cGVzW0FsaWdubWVudFR5cGVzW1wibGVmdFwiXSA9ICdsZWZ0J10gPSBcImxlZnRcIjtcclxuICAgIEFsaWdubWVudFR5cGVzW0FsaWdubWVudFR5cGVzW1wiY2VudGVyXCJdID0gJ2NlbnRlciddID0gXCJjZW50ZXJcIjtcclxuICAgIEFsaWdubWVudFR5cGVzW0FsaWdubWVudFR5cGVzW1wicmlnaHRcIl0gPSAncmlnaHQnXSA9IFwicmlnaHRcIjtcclxufSkoQWxpZ25tZW50VHlwZXMgfHwgKEFsaWdubWVudFR5cGVzID0ge30pKTtcclxuXHJcbnZhciBTaG93VHlwZXM7XHJcbihmdW5jdGlvbiAoU2hvd1R5cGVzKSB7XHJcbiAgICBTaG93VHlwZXNbU2hvd1R5cGVzW1wiYWxsXCJdID0gJ2FsbCddID0gXCJhbGxcIjtcclxuICAgIFNob3dUeXBlc1tTaG93VHlwZXNbXCJmb2N1c1wiXSA9ICdmb2N1cyddID0gXCJmb2N1c1wiO1xyXG4gICAgU2hvd1R5cGVzW1Nob3dUeXBlc1tcIm1vdXNlb3ZlclwiXSA9ICdtb3VzZW92ZXInXSA9IFwibW91c2VvdmVyXCI7XHJcbn0pKFNob3dUeXBlcyB8fCAoU2hvd1R5cGVzID0ge30pKTtcclxuXHJcbi8qKlxyXG4gKiBJbmplY3Rpb24gc2VydmljZSBpcyBhIGhlbHBlciB0byBhcHBlbmQgY29tcG9uZW50c1xyXG4gKiBkeW5hbWljYWxseSB0byBhIGtub3duIGxvY2F0aW9uIGluIHRoZSBET00sIG1vc3RcclxuICogbm90ZWFibHkgZm9yIGRpYWxvZ3MvdG9vbHRpcHMgYXBwZW5kaW5nIHRvIGJvZHkuXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIEluamVjdGlvblNlcnZpY2VcclxuICovXHJcbnZhciBJbmplY3Rpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW5qZWN0aW9uU2VydmljZShhcHBsaWNhdGlvblJlZiwgY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBpbmplY3Rvcikge1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25SZWYgPSBhcHBsaWNhdGlvblJlZjtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcclxuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XHJcbiAgICB9XHJcbiAgICBJbmplY3Rpb25TZXJ2aWNlXzEgPSBJbmplY3Rpb25TZXJ2aWNlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgZGVmYXVsdCBnbG9iYWwgcm9vdCB2aWV3IGNvbnRhaW5lci4gVGhpcyBpcyB1c2VmdWwgZm9yXHJcbiAgICAgKiB0aGluZ3MgbGlrZSBuZ1VwZ3JhZGUgdGhhdCBkb2Vzbid0IGhhdmUgYSBBcHBsaWNhdGlvblJlZiByb290LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250YWluZXJcclxuICAgICAqL1xyXG4gICAgSW5qZWN0aW9uU2VydmljZS5zZXRHbG9iYWxSb290Vmlld0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcclxuICAgICAgICBJbmplY3Rpb25TZXJ2aWNlXzEuZ2xvYmFsUm9vdFZpZXdDb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByb290IHZpZXcgY29udGFpbmVyIHRvIGluamVjdCB0aGUgY29tcG9uZW50IHRvLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtDb21wb25lbnRSZWY8YW55Pn1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgSW5qZWN0aW9uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBJbmplY3Rpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRSb290Vmlld0NvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcm9vdENvbXBvbmVudHMgPSB0aGlzLmFwcGxpY2F0aW9uUmVmLmNvbXBvbmVudHM7XHJcbiAgICAgICAgLy8gZml4IGNhbm5vdCByZWFkIGxlbmd0aCBvZiB1bmRlZmluZWRcclxuICAgICAgICBpZiAocm9vdENvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgaWYgKHJvb3RDb21wb25lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHJldHVybiByb290Q29tcG9uZW50c1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lcilcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICAgICAgICBpZiAoSW5qZWN0aW9uU2VydmljZV8xLmdsb2JhbFJvb3RWaWV3Q29udGFpbmVyKVxyXG4gICAgICAgICAgICByZXR1cm4gSW5qZWN0aW9uU2VydmljZV8xLmdsb2JhbFJvb3RWaWV3Q29udGFpbmVyO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmlldyBDb250YWluZXIgbm90IGZvdW5kISBuZ1VwZ3JhZGUgbmVlZHMgdG8gbWFudWFsbHkgc2V0IHRoaXMgdmlhIHNldFJvb3RWaWV3Q29udGFpbmVyLicpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IHJvb3QgdmlldyBjb250YWluZXIuIFRoaXMgaXMgdXNlZnVsIGZvclxyXG4gICAgICogdGhpbmdzIGxpa2UgbmdVcGdyYWRlIHRoYXQgZG9lc24ndCBoYXZlIGEgQXBwbGljYXRpb25SZWYgcm9vdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gY29udGFpbmVyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIEluamVjdGlvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgSW5qZWN0aW9uU2VydmljZS5wcm90b3R5cGUuc2V0Um9vdFZpZXdDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaHRtbCBlbGVtZW50IGZvciBhIGNvbXBvbmVudCByZWYuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtDb21wb25lbnRSZWY8YW55Pn0gY29tcG9uZW50UmVmXHJcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIEluamVjdGlvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgSW5qZWN0aW9uU2VydmljZS5wcm90b3R5cGUuZ2V0Q29tcG9uZW50Um9vdE5vZGUgPSBmdW5jdGlvbiAoY29tcG9uZW50UmVmKSB7XHJcbiAgICAgICAgLy8gdGhlIHRvcCBtb3N0IGNvbXBvbmVudCByb290IG5vZGUgaGFzIG5vIGBob3N0Vmlld2BcclxuICAgICAgICBpZiAoIWNvbXBvbmVudFJlZi5ob3N0VmlldylcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZi5ob3N0Vmlldy5yb290Tm9kZXNbMF07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByb290IGNvbXBvbmVudCBjb250YWluZXIgaHRtbCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgSW5qZWN0aW9uU2VydmljZVxyXG4gICAgICovXHJcbiAgICBJbmplY3Rpb25TZXJ2aWNlLnByb3RvdHlwZS5nZXRSb290Vmlld0NvbnRhaW5lck5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50Um9vdE5vZGUodGhpcy5nZXRSb290Vmlld0NvbnRhaW5lcigpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFByb2plY3RzIHRoZSBiaW5kaW5ncyBvbnRvIHRoZSBjb21wb25lbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0NvbXBvbmVudFJlZjxhbnk+fSBjb21wb25lbnRcclxuICAgICAqIEBwYXJhbSB7Kn0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge0NvbXBvbmVudFJlZjxhbnk+fVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBJbmplY3Rpb25TZXJ2aWNlXHJcbiAgICAgKi9cclxuICAgIEluamVjdGlvblNlcnZpY2UucHJvdG90eXBlLnByb2plY3RDb21wb25lbnRCaW5kaW5ncyA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGJpbmRpbmdzKSB7XHJcbiAgICAgICAgaWYgKGJpbmRpbmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChiaW5kaW5ncy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmdLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYmluZGluZ3MuaW5wdXRzKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgYmluZGluZ0tleXNfMSA9IGJpbmRpbmdLZXlzOyBfaSA8IGJpbmRpbmdLZXlzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRpbmdOYW1lID0gYmluZGluZ0tleXNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lmluc3RhbmNlW2JpbmRpbmdOYW1lXSA9IGJpbmRpbmdzLmlucHV0c1tiaW5kaW5nTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJpbmRpbmdzLm91dHB1dHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJpbmRpbmdzLm91dHB1dHMpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBldmVudEtleXNfMSA9IGV2ZW50S2V5czsgX2EgPCBldmVudEtleXNfMS5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnRLZXlzXzFbX2FdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pbnN0YW5jZVtldmVudE5hbWVdID0gYmluZGluZ3Mub3V0cHV0c1tldmVudE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIGEgY29tcG9uZW50IHRvIGEgYWRqYWNlbnQgbG9jYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICogQHBhcmFtIHtUeXBlPFQ+fSBjb21wb25lbnRDbGFzc1xyXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9ucz17fV1cclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gW2xvY2F0aW9uPXRoaXMuZ2V0Um9vdFZpZXdDb250YWluZXJOb2RlKCldXHJcbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50UmVmPGFueT59XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIEluamVjdGlvblNlcnZpY2VcclxuICAgICAqL1xyXG4gICAgSW5qZWN0aW9uU2VydmljZS5wcm90b3R5cGUuYXBwZW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzLCBiaW5kaW5ncywgbG9jYXRpb24pIHtcclxuICAgICAgICBpZiAoYmluZGluZ3MgPT09IHZvaWQgMCkgeyBiaW5kaW5ncyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uID09PSB2b2lkIDApIHsgbG9jYXRpb24gPSB0aGlzLmdldFJvb3RWaWV3Q29udGFpbmVyTm9kZSgpOyB9XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnRDbGFzcyk7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudEZhY3RvcnkuY3JlYXRlKHRoaXMuaW5qZWN0b3IpO1xyXG4gICAgICAgIHZhciBhcHBSZWYgPSB0aGlzLmFwcGxpY2F0aW9uUmVmO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRSb290Tm9kZSA9IHRoaXMuZ2V0Q29tcG9uZW50Um9vdE5vZGUoY29tcG9uZW50UmVmKTtcclxuICAgICAgICAvLyBwcm9qZWN0IHRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlXHJcbiAgICAgICAgdGhpcy5wcm9qZWN0Q29tcG9uZW50QmluZGluZ3MoY29tcG9uZW50UmVmLCBiaW5kaW5ncyk7XHJcbiAgICAgICAgYXBwUmVmLmF0dGFjaFZpZXcoY29tcG9uZW50UmVmLmhvc3RWaWV3KTtcclxuICAgICAgICBjb21wb25lbnRSZWYub25EZXN0cm95KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgYXBwUmVmLmRldGFjaFZpZXcoY29tcG9uZW50UmVmLmhvc3RWaWV3KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyB1c2UgdGhlIHJlbmRlcmVyIHRvIGFwcGVuZCB0aGUgZWxlbWVudCBmb3IgdW5pdnNlcmFsIHN1cHBvcnRcclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBjb21wb25lbnRSZWYuaW5zdGFuY2UucmVuZGVyZXI7XHJcbiAgICAgICAgcmVuZGVyZXIuYXBwZW5kQ2hpbGQobG9jYXRpb24sIGNvbXBvbmVudFJvb3ROb2RlKTtcclxuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmO1xyXG4gICAgfTtcclxuICAgIHZhciBJbmplY3Rpb25TZXJ2aWNlXzEsIF9hLCBfYiwgX2M7XHJcbiAgICBJbmplY3Rpb25TZXJ2aWNlLmdsb2JhbFJvb3RWaWV3Q29udGFpbmVyID0gbnVsbDtcclxuICAgIEluamVjdGlvblNlcnZpY2UgPSBJbmplY3Rpb25TZXJ2aWNlXzEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEFwcGxpY2F0aW9uUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEFwcGxpY2F0aW9uUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QsIHR5cGVvZiAoX2IgPSB0eXBlb2YgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyICE9PSBcInVuZGVmaW5lZFwiICYmIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0LCB0eXBlb2YgKF9jID0gdHlwZW9mIEluamVjdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIEluamVjdG9yKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3RdKVxyXG4gICAgXSwgSW5qZWN0aW9uU2VydmljZSk7XHJcbiAgICByZXR1cm4gSW5qZWN0aW9uU2VydmljZTtcclxufSgpKTtcclxuXHJcbnZhciBJbmplY3Rpb25SZWdpc3RlcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbmplY3Rpb25SZWdpc3RlcnkoaW5qZWN0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHRoaXMuaW5qZWN0aW9uU2VydmljZSA9IGluamVjdGlvblNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0cyA9IHt9O1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIEluamVjdGlvblJlZ2lzdGVyeS5wcm90b3R5cGUuZ2V0QnlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSB0aGlzLnR5cGU7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzLmdldCh0eXBlKTtcclxuICAgIH07XHJcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChiaW5kaW5ncykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUJ5VHlwZSh0aGlzLnR5cGUsIGJpbmRpbmdzKTtcclxuICAgIH07XHJcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmNyZWF0ZUJ5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBiaW5kaW5ncykge1xyXG4gICAgICAgIGJpbmRpbmdzID0gdGhpcy5hc3NpZ25EZWZhdWx0cyhiaW5kaW5ncyk7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuaW5qZWN0Q29tcG9uZW50KHR5cGUsIGJpbmRpbmdzKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyKHR5cGUsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcclxuICAgIH07XHJcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICB2YXIgY29tcHNCeVR5cGUgPSB0aGlzLmNvbXBvbmVudHMuZ2V0KGluc3RhbmNlLmNvbXBvbmVudFR5cGUpO1xyXG4gICAgICAgIGlmIChjb21wc0J5VHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gY29tcHNCeVR5cGUuaW5kZXhPZihpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGlmIChpZHggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBzQnlUeXBlW2lkeF07XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgY29tcHNCeVR5cGUuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0aW9uUmVnaXN0ZXJ5LnByb3RvdHlwZS5kZXN0cm95QWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGVzdHJveUJ5VHlwZSh0aGlzLnR5cGUpO1xyXG4gICAgfTtcclxuICAgIEluamVjdGlvblJlZ2lzdGVyeS5wcm90b3R5cGUuZGVzdHJveUJ5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdmFyIGNvbXBzID0gdGhpcy5jb21wb25lbnRzLmdldCh0eXBlKTtcclxuICAgICAgICBpZiAoY29tcHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjb21wc18xID0gY29tcHM7IF9pIDwgY29tcHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wID0gY29tcHNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koY29tcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5qZWN0aW9uUmVnaXN0ZXJ5LnByb3RvdHlwZS5hc3NpZ25EZWZhdWx0cyA9IGZ1bmN0aW9uIChiaW5kaW5ncykge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMuZGVmYXVsdHMsIGlucHV0cyA9IF9hLmlucHV0cywgb3V0cHV0cyA9IF9hLm91dHB1dHM7XHJcbiAgICAgICAgaWYgKCFiaW5kaW5ncy5pbnB1dHMgJiYgIWJpbmRpbmdzLm91dHB1dHMpIHtcclxuICAgICAgICAgICAgYmluZGluZ3MgPSB7IGlucHV0czogYmluZGluZ3MgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlucHV0cykge1xyXG4gICAgICAgICAgICBiaW5kaW5ncy5pbnB1dHMgPSBPYmplY3QuYXNzaWduKGlucHV0cywgYmluZGluZ3MuaW5wdXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG91dHB1dHMpIHtcclxuICAgICAgICAgICAgYmluZGluZ3Mub3V0cHV0cyA9IE9iamVjdC5hc3NpZ24ob3V0cHV0cywgYmluZGluZ3Mub3V0cHV0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiaW5kaW5ncztcclxuICAgIH07XHJcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLmluamVjdENvbXBvbmVudCA9IGZ1bmN0aW9uICh0eXBlLCBiaW5kaW5ncykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluamVjdGlvblNlcnZpY2UuYXBwZW5kQ29tcG9uZW50KHR5cGUsIGJpbmRpbmdzKTtcclxuICAgIH07XHJcbiAgICBJbmplY3Rpb25SZWdpc3RlcnkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHR5cGUsIGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb21wb25lbnRzLmhhcyh0eXBlKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMuc2V0KHR5cGUsIFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHR5cGVzID0gdGhpcy5jb21wb25lbnRzLmdldCh0eXBlKTtcclxuICAgICAgICB0eXBlcy5wdXNoKGNvbXBvbmVudCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEluamVjdGlvblJlZ2lzdGVyeTtcclxufSgpKTtcclxuXHJcbi8qKlxyXG4gKiBUaHJvdHRsZSBhIGZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHsqfSAgICAgIGZ1bmNcclxuICogQHBhcmFtIHtudW1iZXJ9IHdhaXRcclxuICogQHBhcmFtIHsqfSAgICAgIFtvcHRpb25zXVxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB2YXIgY29udGV4dDtcclxuICAgIHZhciBhcmdzO1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcclxuICAgIHZhciBwcmV2aW91cyA9IDA7XHJcbiAgICBmdW5jdGlvbiBsYXRlcigpIHtcclxuICAgICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogK25ldyBEYXRlKCk7XHJcbiAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vdyA9ICtuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xyXG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xyXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFRocm90dGxlIGRlY29yYXRvclxyXG4gKlxyXG4gKiAgY2xhc3MgTXlDbGFzcyB7XHJcbiAqICAgIHRocm90dGxlYWJsZSgxMClcclxuICogICAgbXlGbigpIHsgLi4uIH1cclxuICogIH1cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cclxuICogQHBhcmFtIHsqfSBbb3B0aW9uc11cclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIHRocm90dGxlYWJsZShkdXJhdGlvbiwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlubmVyRGVjb3JhdG9yKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0dGVyKCkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRocm90dGxlKGRlc2NyaXB0b3IudmFsdWUsIGR1cmF0aW9uLCBvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbn1cclxuXHJcbnZhciBUb29sdGlwQ29udGVudENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRvb2x0aXBDb250ZW50Q29tcG9uZW50KGVsZW1lbnQsIHJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcImNzc0NsYXNzZXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY2x6ID0gJ25neC1jaGFydHMtdG9vbHRpcC1jb250ZW50JztcclxuICAgICAgICAgICAgY2x6ICs9IFwiIHBvc2l0aW9uLVwiICsgdGhpcy5wbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgIGNseiArPSBcIiB0eXBlLVwiICsgdGhpcy50eXBlO1xyXG4gICAgICAgICAgICBjbHogKz0gXCIgXCIgKyB0aGlzLmNzc0NsYXNzO1xyXG4gICAgICAgICAgICByZXR1cm4gY2x6O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMucG9zaXRpb24uYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG5hdGl2ZUVsbSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xyXG4gICAgICAgIHZhciBob3N0RGltID0gdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgaWYgKCFob3N0RGltLmhlaWdodCAmJiAhaG9zdERpbS53aWR0aClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBlbG1EaW0gPSBuYXRpdmVFbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgdGhpcy5jaGVja0ZsaXAoaG9zdERpbSwgZWxtRGltKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uQ29udGVudChuYXRpdmVFbG0sIGhvc3REaW0sIGVsbURpbSk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0NhcmV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25DYXJldChob3N0RGltLCBlbG1EaW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlbmRlcmVyLmFkZENsYXNzKG5hdGl2ZUVsbSwgJ2FuaW1hdGUnKTsgfSwgMSk7XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLnBvc2l0aW9uQ29udGVudCA9IGZ1bmN0aW9uIChuYXRpdmVFbG0sIGhvc3REaW0sIGVsbURpbSkge1xyXG4gICAgICAgIHZhciBfYSA9IFBvc2l0aW9uSGVscGVyLnBvc2l0aW9uQ29udGVudCh0aGlzLnBsYWNlbWVudCwgZWxtRGltLCBob3N0RGltLCB0aGlzLnNwYWNpbmcsIHRoaXMuYWxpZ25tZW50KSwgdG9wID0gX2EudG9wLCBsZWZ0ID0gX2EubGVmdDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKG5hdGl2ZUVsbSwgJ3RvcCcsIHRvcCArIFwicHhcIik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShuYXRpdmVFbG0sICdsZWZ0JywgbGVmdCArIFwicHhcIik7XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLnBvc2l0aW9uQ2FyZXQgPSBmdW5jdGlvbiAoaG9zdERpbSwgZWxtRGltKSB7XHJcbiAgICAgICAgdmFyIGNhcmV0RWxtID0gdGhpcy5jYXJldEVsbS5uYXRpdmVFbGVtZW50O1xyXG4gICAgICAgIHZhciBjYXJldERpbWVuc2lvbnMgPSBjYXJldEVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB2YXIgX2EgPSBQb3NpdGlvbkhlbHBlci5wb3NpdGlvbkNhcmV0KHRoaXMucGxhY2VtZW50LCBlbG1EaW0sIGhvc3REaW0sIGNhcmV0RGltZW5zaW9ucywgdGhpcy5hbGlnbm1lbnQpLCB0b3AgPSBfYS50b3AsIGxlZnQgPSBfYS5sZWZ0O1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoY2FyZXRFbG0sICd0b3AnLCB0b3AgKyBcInB4XCIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoY2FyZXRFbG0sICdsZWZ0JywgbGVmdCArIFwicHhcIik7XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLmNoZWNrRmxpcCA9IGZ1bmN0aW9uIChob3N0RGltLCBlbG1EaW0pIHtcclxuICAgICAgICB0aGlzLnBsYWNlbWVudCA9IFBvc2l0aW9uSGVscGVyLmRldGVybWluZVBsYWNlbWVudCh0aGlzLnBsYWNlbWVudCwgZWxtRGltLCBob3N0RGltLCB0aGlzLnNwYWNpbmcpO1xyXG4gICAgfTtcclxuICAgIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZS5vbldpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJob3N0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dDYXJldFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBTdHlsZVR5cGVzICE9PSBcInVuZGVmaW5lZFwiICYmIFN0eWxlVHlwZXMpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIFBsYWNlbWVudFR5cGVzICE9PSBcInVuZGVmaW5lZFwiICYmIFBsYWNlbWVudFR5cGVzKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2VtZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIEFsaWdubWVudFR5cGVzICE9PSBcInVuZGVmaW5lZFwiICYmIEFsaWdubWVudFR5cGVzKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWxpZ25tZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcImNzc0NsYXNzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudC5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFZpZXdDaGlsZCgnY2FyZXRFbG0nLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjYXJldEVsbVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdEJpbmRpbmcoJ2NsYXNzJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG4gICAgXSwgVG9vbHRpcENvbnRlbnRDb21wb25lbnQucHJvdG90eXBlLCBcImNzc0NsYXNzZXNcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpyZXNpemUnKSxcclxuICAgICAgICB0aHJvdHRsZWFibGUoMTAwKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIFRvb2x0aXBDb250ZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvbldpbmRvd1Jlc2l6ZVwiLCBudWxsKTtcclxuICAgIFRvb2x0aXBDb250ZW50Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtdG9vbHRpcC1jb250ZW50JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxkaXY+XFxuICAgICAgPHNwYW4gI2NhcmV0RWxtIFtoaWRkZW5dPVxcXCIhc2hvd0NhcmV0XFxcIiBjbGFzcz1cXFwidG9vbHRpcC1jYXJldCBwb3NpdGlvbi17eyB0aGlzLnBsYWNlbWVudCB9fVxcXCI+IDwvc3Bhbj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgPHNwYW4gKm5nSWY9XFxcIiF0aXRsZVxcXCI+XFxuICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XFxcInRlbXBsYXRlXFxcIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVxcXCJ7IG1vZGVsOiBjb250ZXh0IH1cXFwiPiA8L25nLXRlbXBsYXRlPlxcbiAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgPHNwYW4gKm5nSWY9XFxcInRpdGxlXFxcIiBbaW5uZXJIVE1MXT1cXFwidGl0bGVcXFwiPiA8L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50e3Bvc2l0aW9uOmZpeGVkO2JvcmRlci1yYWRpdXM6M3B4O3otaW5kZXg6NTAwMDtkaXNwbGF5OmJsb2NrO2ZvbnQtd2VpZ2h0OjQwMDtvcGFjaXR5OjA7cG9pbnRlci1ldmVudHM6bm9uZSFpbXBvcnRhbnR9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnR5cGUtcG9wb3ZlcntiYWNrZ3JvdW5kOiNmZmY7Y29sb3I6IzA2MDcwOTtib3JkZXI6MXB4IHNvbGlkICM3MjgwOWI7Ym94LXNoYWRvdzowIDFweCAzcHggMCByZ2JhKDAsMCwwLC4yKSwwIDFweCAxcHggMCByZ2JhKDAsMCwwLC4xNCksMCAycHggMXB4IC0xcHggcmdiYSgwLDAsMCwuMTIpO2ZvbnQtc2l6ZToxM3B4O3BhZGRpbmc6NHB4fS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC50eXBlLXBvcG92ZXIgLnRvb2x0aXAtY2FyZXR7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo1MDAxO3dpZHRoOjA7aGVpZ2h0OjB9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnR5cGUtcG9wb3ZlciAudG9vbHRpcC1jYXJldC5wb3NpdGlvbi1sZWZ0e2JvcmRlci10b3A6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjdweCBzb2xpZCAjZmZmfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC50eXBlLXBvcG92ZXIgLnRvb2x0aXAtY2FyZXQucG9zaXRpb24tdG9we2JvcmRlci1sZWZ0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci10b3A6N3B4IHNvbGlkICNmZmZ9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnR5cGUtcG9wb3ZlciAudG9vbHRpcC1jYXJldC5wb3NpdGlvbi1yaWdodHtib3JkZXItdG9wOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6N3B4IHNvbGlkICNmZmZ9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnR5cGUtcG9wb3ZlciAudG9vbHRpcC1jYXJldC5wb3NpdGlvbi1ib3R0b217Ym9yZGVyLWxlZnQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgI2ZmZn0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQudHlwZS10b29sdGlwe2NvbG9yOiNmZmY7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC43NSk7Zm9udC1zaXplOjEycHg7cGFkZGluZzowIDEwcHg7dGV4dC1hbGlnbjpjZW50ZXI7cG9pbnRlci1ldmVudHM6YXV0b30ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQudHlwZS10b29sdGlwIC50b29sdGlwLWNhcmV0LnBvc2l0aW9uLWxlZnR7Ym9yZGVyLXRvcDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6N3B4IHNvbGlkIHJnYmEoMCwwLDAsLjc1KX0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQudHlwZS10b29sdGlwIC50b29sdGlwLWNhcmV0LnBvc2l0aW9uLXRvcHtib3JkZXItbGVmdDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItdG9wOjdweCBzb2xpZCByZ2JhKDAsMCwwLC43NSl9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50LnR5cGUtdG9vbHRpcCAudG9vbHRpcC1jYXJldC5wb3NpdGlvbi1yaWdodHtib3JkZXItdG9wOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQ6N3B4IHNvbGlkIHJnYmEoMCwwLDAsLjc1KX0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQudHlwZS10b29sdGlwIC50b29sdGlwLWNhcmV0LnBvc2l0aW9uLWJvdHRvbXtib3JkZXItbGVmdDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCByZ2JhKDAsMCwwLC43NSl9Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50IC50b29sdGlwLWxhYmVse2Rpc3BsYXk6YmxvY2s7bGluZS1oZWlnaHQ6MWVtO3BhZGRpbmc6OHB4IDVweCA1cHggNXB4O2ZvbnQtc2l6ZToxZW19Lm5neC1jaGFydHMtdG9vbHRpcC1jb250ZW50IC50b29sdGlwLXZhbHtkaXNwbGF5OmJsb2NrO2ZvbnQtc2l6ZToxLjNlbTtsaW5lLWhlaWdodDoxZW07cGFkZGluZzowIDVweCA4cHggNXB4fS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudCAudG9vbHRpcC1jYXJldHtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjUwMDE7d2lkdGg6MDtoZWlnaHQ6MH0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQucG9zaXRpb24tcmlnaHR7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDEwcHgsMCwwKX0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQucG9zaXRpb24tbGVmdHt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTEwcHgsMCwwKX0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQucG9zaXRpb24tdG9we3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLC0xMHB4LDApfS5uZ3gtY2hhcnRzLXRvb2x0aXAtY29udGVudC5wb3NpdGlvbi1ib3R0b217dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMTBweCwwKX0ubmd4LWNoYXJ0cy10b29sdGlwLWNvbnRlbnQuYW5pbWF0ZXtvcGFjaXR5OjE7dHJhbnNpdGlvbjpvcGFjaXR5IC4zcyx0cmFuc2Zvcm0gLjNzO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7cG9pbnRlci1ldmVudHM6YXV0b30uYXJlYS10b29sdGlwLWNvbnRhaW5lcntwYWRkaW5nOjVweCAwO3BvaW50ZXItZXZlbnRzOm5vbmV9LnRvb2x0aXAtaXRlbXt0ZXh0LWFsaWduOmxlZnQ7bGluZS1oZWlnaHQ6MS4yZW07cGFkZGluZzo1cHggMH0udG9vbHRpcC1pdGVtIC50b29sdGlwLWl0ZW0tY29sb3J7ZGlzcGxheTppbmxpbmUtYmxvY2s7aGVpZ2h0OjEycHg7d2lkdGg6MTJweDttYXJnaW4tcmlnaHQ6NXB4O2NvbG9yOiM1YjY0NmI7Ym9yZGVyLXJhZGl1czozcHh9XCJdXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9kID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9kIDogT2JqZWN0LCB0eXBlb2YgKF9lID0gdHlwZW9mIFJlbmRlcmVyMiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZW5kZXJlcjIpID09PSBcImZ1bmN0aW9uXCIgPyBfZSA6IE9iamVjdF0pXHJcbiAgICBdLCBUb29sdGlwQ29udGVudENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gVG9vbHRpcENvbnRlbnRDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgVG9vbHRpcFNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVG9vbHRpcFNlcnZpY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUb29sdGlwU2VydmljZShpbmplY3Rpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5qZWN0aW9uU2VydmljZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pbmplY3Rpb25TZXJ2aWNlID0gaW5qZWN0aW9uU2VydmljZTtcclxuICAgICAgICBfdGhpcy50eXBlID0gVG9vbHRpcENvbnRlbnRDb21wb25lbnQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgdmFyIF9hO1xyXG4gICAgVG9vbHRpcFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEluamVjdGlvblNlcnZpY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgSW5qZWN0aW9uU2VydmljZSkgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcclxuICAgIF0sIFRvb2x0aXBTZXJ2aWNlKTtcclxuICAgIHJldHVybiBUb29sdGlwU2VydmljZTtcclxufShJbmplY3Rpb25SZWdpc3RlcnkpKTtcclxuXHJcbnZhciBUb29sdGlwRGlyZWN0aXZlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVG9vbHRpcERpcmVjdGl2ZSh0b29sdGlwU2VydmljZSwgdmlld0NvbnRhaW5lclJlZiwgcmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLnRvb2x0aXBTZXJ2aWNlID0gdG9vbHRpcFNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy50b29sdGlwQ3NzQ2xhc3MgPSAnJztcclxuICAgICAgICB0aGlzLnRvb2x0aXBUaXRsZSA9ICcnO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcEFwcGVuZFRvQm9keSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50b29sdGlwU3BhY2luZyA9IDEwO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50b29sdGlwU2hvd0NhcmV0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRvb2x0aXBQbGFjZW1lbnQgPSBQbGFjZW1lbnRUeXBlcy50b3A7XHJcbiAgICAgICAgdGhpcy50b29sdGlwQWxpZ25tZW50ID0gQWxpZ25tZW50VHlwZXMuY2VudGVyO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFR5cGUgPSBTdHlsZVR5cGVzLnBvcG92ZXI7XHJcbiAgICAgICAgdGhpcy50b29sdGlwQ2xvc2VPbkNsaWNrT3V0c2lkZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50b29sdGlwQ2xvc2VPbk1vdXNlTGVhdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcEhpZGVUaW1lb3V0ID0gMzAwO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFNob3dUaW1lb3V0ID0gMTAwO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFNob3dFdmVudCA9IFNob3dUeXBlcy5hbGw7XHJcbiAgICAgICAgdGhpcy50b29sdGlwSW1tZWRpYXRlRXhpdCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2hvdyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmhpZGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGlzdGVuc0ZvckZvY3VzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9vbHRpcFNob3dFdmVudCA9PT0gU2hvd1R5cGVzLmFsbCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwU2hvd0V2ZW50ID09PSBTaG93VHlwZXMuZm9jdXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGlzdGVuc0ZvckhvdmVyXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9vbHRpcFNob3dFdmVudCA9PT0gU2hvd1R5cGVzLmFsbCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwU2hvd0V2ZW50ID09PSBTaG93VHlwZXMubW91c2VvdmVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oaWRlVG9vbHRpcCh0cnVlKTtcclxuICAgIH07XHJcbiAgICBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZS5vbkZvY3VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbnNGb3JGb2N1cykge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dUb29sdGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLm9uQmx1ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0ZW5zRm9yRm9jdXMpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWRlVG9vbHRpcCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUub25Nb3VzZUVudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbnNGb3JIb3Zlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dUb29sdGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLm9uTW91c2VMZWF2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0ZW5zRm9ySG92ZXIgJiYgdGhpcy50b29sdGlwQ2xvc2VPbk1vdXNlTGVhdmUpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnREb20gPSB0aGlzLmNvbXBvbmVudC5pbnN0YW5jZS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbnMgPSBjb250ZW50RG9tLmNvbnRhaW5zKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZVRvb2x0aXAodGhpcy50b29sdGlwSW1tZWRpYXRlRXhpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLm9uTW91c2VDbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0ZW5zRm9ySG92ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWRlVG9vbHRpcCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUuc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQgfHwgdGhpcy50b29sdGlwRGlzYWJsZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgdGltZSA9IGltbWVkaWF0ZSA/IDAgOiB0aGlzLnRvb2x0aXBTaG93VGltZW91dDtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcclxuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudG9vbHRpcFNlcnZpY2UuZGVzdHJveUFsbCgpO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF90aGlzLmNyZWF0ZUJvdW5kT3B0aW9ucygpO1xyXG4gICAgICAgICAgICBfdGhpcy5jb21wb25lbnQgPSBfdGhpcy50b29sdGlwU2VydmljZS5jcmVhdGUob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8vIGFkZCBhIHRpbnkgdGltZW91dCB0byBhdm9pZCBldmVudCByZS10cmlnZ2Vyc1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRIaWRlTGlzdGVuZXJzKF90aGlzLmNvbXBvbmVudC5pbnN0YW5jZS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAxMCk7XHJcbiAgICAgICAgICAgIF90aGlzLnNob3cuZW1pdCh0cnVlKTtcclxuICAgICAgICB9LCB0aW1lKTtcclxuICAgIH07XHJcbiAgICBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZS5hZGRIaWRlTGlzdGVuZXJzID0gZnVuY3Rpb24gKHRvb2x0aXApIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIG9uIG1vdXNlIGVudGVyLCBjYW5jZWwgdGhlIGhpZGUgdHJpZ2dlcmVkIGJ5IHRoZSBsZWF2ZVxyXG4gICAgICAgIHRoaXMubW91c2VFbnRlckNvbnRlbnRFdmVudCA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRvb2x0aXAsICdtb3VzZWVudGVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY29udGVudCBtb3VzZSBsZWF2ZSBsaXN0ZW5lclxyXG4gICAgICAgIGlmICh0aGlzLnRvb2x0aXBDbG9zZU9uTW91c2VMZWF2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlTGVhdmVDb250ZW50RXZlbnQgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0b29sdGlwLCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmhpZGVUb29sdGlwKF90aGlzLnRvb2x0aXBJbW1lZGlhdGVFeGl0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnRlbnQgY2xvc2Ugb24gY2xpY2sgb3V0c2lkZVxyXG4gICAgICAgIGlmICh0aGlzLnRvb2x0aXBDbG9zZU9uQ2xpY2tPdXRzaWRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0V2ZW50ID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oZG9jdW1lbnQsICdjbGljaycsIGZ1bmN0aW9uIChldmVudCQkMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5zID0gdG9vbHRpcC5jb250YWlucyhldmVudCQkMS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWlucylcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oaWRlVG9vbHRpcCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUuaGlkZVRvb2x0aXAgPSBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoaW1tZWRpYXRlID09PSB2b2lkIDApIHsgaW1tZWRpYXRlID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGRlc3Ryb3lGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV2ZW50c1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMubW91c2VMZWF2ZUNvbnRlbnRFdmVudClcclxuICAgICAgICAgICAgICAgIF90aGlzLm1vdXNlTGVhdmVDb250ZW50RXZlbnQoKTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm1vdXNlRW50ZXJDb250ZW50RXZlbnQpXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5tb3VzZUVudGVyQ29udGVudEV2ZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5kb2N1bWVudENsaWNrRXZlbnQpXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kb2N1bWVudENsaWNrRXZlbnQoKTtcclxuICAgICAgICAgICAgLy8gZW1pdCBldmVudHNcclxuICAgICAgICAgICAgX3RoaXMuaGlkZS5lbWl0KHRydWUpO1xyXG4gICAgICAgICAgICAvLyBkZXN0cm95IGNvbXBvbmVudFxyXG4gICAgICAgICAgICBfdGhpcy50b29sdGlwU2VydmljZS5kZXN0cm95KF90aGlzLmNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xyXG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZGVzdHJveUZuLCB0aGlzLnRvb2x0aXBIaWRlVGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZXN0cm95Rm4oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUuY3JlYXRlQm91bmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLnRvb2x0aXBUaXRsZSxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMudG9vbHRpcFRlbXBsYXRlLFxyXG4gICAgICAgICAgICBob3N0OiB0aGlzLnZpZXdDb250YWluZXJSZWYuZWxlbWVudCxcclxuICAgICAgICAgICAgcGxhY2VtZW50OiB0aGlzLnRvb2x0aXBQbGFjZW1lbnQsXHJcbiAgICAgICAgICAgIGFsaWdubWVudDogdGhpcy50b29sdGlwQWxpZ25tZW50LFxyXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnRvb2x0aXBUeXBlLFxyXG4gICAgICAgICAgICBzaG93Q2FyZXQ6IHRoaXMudG9vbHRpcFNob3dDYXJldCxcclxuICAgICAgICAgICAgY3NzQ2xhc3M6IHRoaXMudG9vbHRpcENzc0NsYXNzLFxyXG4gICAgICAgICAgICBzcGFjaW5nOiB0aGlzLnRvb2x0aXBTcGFjaW5nLFxyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLnRvb2x0aXBDb250ZXh0XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwQ3NzQ2xhc3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBUaXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBBcHBlbmRUb0JvZHlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBTcGFjaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcFNob3dDYXJldFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBQbGFjZW1lbnRUeXBlcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBQbGFjZW1lbnRUeXBlcykgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcFBsYWNlbWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBBbGlnbm1lbnRUeXBlcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBBbGlnbm1lbnRUeXBlcykgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcEFsaWdubWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBTdHlsZVR5cGVzICE9PSBcInVuZGVmaW5lZFwiICYmIFN0eWxlVHlwZXMpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcENsb3NlT25DbGlja091dHNpZGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwQ2xvc2VPbk1vdXNlTGVhdmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBIaWRlVGltZW91dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcFNob3dUaW1lb3V0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2QgPSB0eXBlb2YgU2hvd1R5cGVzICE9PSBcInVuZGVmaW5lZFwiICYmIFNob3dUeXBlcykgPT09IFwiZnVuY3Rpb25cIiA/IF9kIDogT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcFNob3dFdmVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcENvbnRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b29sdGlwSW1tZWRpYXRlRXhpdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInNob3dcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJoaWRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ2ZvY3VzaW4nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uRm9jdXNcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ2JsdXInKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIm9uQmx1clwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwib25Nb3VzZUVudGVyXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJywgWyckZXZlbnQudGFyZ2V0J10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwib25Nb3VzZUxlYXZlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdjbGljaycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwib25Nb3VzZUNsaWNrXCIsIG51bGwpO1xyXG4gICAgVG9vbHRpcERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25neC10b29sdGlwXScgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9lID0gdHlwZW9mIFRvb2x0aXBTZXJ2aWNlICE9PSBcInVuZGVmaW5lZFwiICYmIFRvb2x0aXBTZXJ2aWNlKSA9PT0gXCJmdW5jdGlvblwiID8gX2UgOiBPYmplY3QsIHR5cGVvZiAoX2YgPSB0eXBlb2YgVmlld0NvbnRhaW5lclJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBWaWV3Q29udGFpbmVyUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2YgOiBPYmplY3QsIHR5cGVvZiAoX2cgPSB0eXBlb2YgUmVuZGVyZXIyICE9PSBcInVuZGVmaW5lZFwiICYmIFJlbmRlcmVyMikgPT09IFwiZnVuY3Rpb25cIiA/IF9nIDogT2JqZWN0XSlcclxuICAgIF0sIFRvb2x0aXBEaXJlY3RpdmUpO1xyXG4gICAgcmV0dXJuIFRvb2x0aXBEaXJlY3RpdmU7XHJcbn0oKSk7XHJcblxyXG52YXIgVG9vbHRpcE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRvb2x0aXBNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBUb29sdGlwTW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtUb29sdGlwQ29udGVudENvbXBvbmVudCwgVG9vbHRpcERpcmVjdGl2ZV0sXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW0luamVjdGlvblNlcnZpY2UsIFRvb2x0aXBTZXJ2aWNlXSxcclxuICAgICAgICAgICAgZXhwb3J0czogW1Rvb2x0aXBDb250ZW50Q29tcG9uZW50LCBUb29sdGlwRGlyZWN0aXZlXSxcclxuICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXHJcbiAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogW1Rvb2x0aXBDb250ZW50Q29tcG9uZW50XVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBUb29sdGlwTW9kdWxlKTtcclxuICAgIHJldHVybiBUb29sdGlwTW9kdWxlO1xyXG59KCkpO1xyXG5cclxudmFyIENoYXJ0Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2hhcnRDb21wb25lbnQodmNyLCB0b29sdGlwU2VydmljZSkge1xyXG4gICAgICAgIHRoaXMudmNyID0gdmNyO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFNlcnZpY2UgPSB0b29sdGlwU2VydmljZTtcclxuICAgICAgICB0aGlzLnNob3dMZWdlbmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGVnZW5kTGFiZWxDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZExhYmVsQWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRMYWJlbERlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy50b29sdGlwU2VydmljZS5pbmplY3Rpb25TZXJ2aWNlLnNldFJvb3RWaWV3Q29udGFpbmVyKHRoaXMudmNyKTtcclxuICAgIH1cclxuICAgIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsZWdlbmRDb2x1bW5zID0gMDtcclxuICAgICAgICBpZiAodGhpcy5zaG93TGVnZW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVnZW5kVHlwZSA9IHRoaXMuZ2V0TGVnZW5kVHlwZSgpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubGVnZW5kT3B0aW9ucyB8fCB0aGlzLmxlZ2VuZE9wdGlvbnMucG9zaXRpb24gPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZ2VuZFR5cGUgPT09ICdzY2FsZUxlZ2VuZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWdlbmRDb2x1bW5zID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZENvbHVtbnMgPSAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGFydENvbHVtbnMgPSAxMiAtIGxlZ2VuZENvbHVtbnM7XHJcbiAgICAgICAgdGhpcy5jaGFydFdpZHRoID0gTWF0aC5mbG9vcigodGhpcy52aWV3WzBdICogY2hhcnRDb2x1bW5zIC8gMTIuMCkpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kV2lkdGggPSAoIXRoaXMubGVnZW5kT3B0aW9ucyB8fCB0aGlzLmxlZ2VuZE9wdGlvbnMucG9zaXRpb24gPT09ICdyaWdodCcpXHJcbiAgICAgICAgICAgID8gTWF0aC5mbG9vcigodGhpcy52aWV3WzBdICogbGVnZW5kQ29sdW1ucyAvIDEyLjApKVxyXG4gICAgICAgICAgICA6IHRoaXMuY2hhcnRXaWR0aDtcclxuICAgIH07XHJcbiAgICBDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kVHlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWdlbmRPcHRpb25zLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzY2FsZUxlZ2VuZCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2xlZ2VuZCc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidmlld1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dMZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRPcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZERhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRMYWJlbENsaWNrXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kTGFiZWxBY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZExhYmVsRGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgQ2hhcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtUb29sdGlwU2VydmljZV0sXHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1jaGFydCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8ZGl2XFxuICAgICAgY2xhc3M9XFxcIm5neC1jaGFydHMtb3V0ZXJcXFwiXFxuICAgICAgW3N0eWxlLndpZHRoLnB4XT1cXFwidmlld1swXVxcXCJcXG4gICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgW0AuZGlzYWJsZWRdPVxcXCIhYW5pbWF0aW9uc1xcXCI+XFxuICAgICAgPHN2Z1xcbiAgICAgICAgY2xhc3M9XFxcIm5neC1jaGFydHNcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcImNoYXJ0V2lkdGhcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJ2aWV3WzFdXFxcIj5cXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICA8L3N2Zz5cXG4gICAgICA8bmd4LWNoYXJ0cy1zY2FsZS1sZWdlbmRcXG4gICAgICAgICpuZ0lmPVxcXCJzaG93TGVnZW5kICYmIGxlZ2VuZFR5cGUgPT09ICdzY2FsZUxlZ2VuZCdcXFwiXFxuICAgICAgICBjbGFzcz1cXFwiY2hhcnQtbGVnZW5kXFxcIlxcbiAgICAgICAgW2hvcml6b250YWxdPVxcXCJsZWdlbmRPcHRpb25zICYmIGxlZ2VuZE9wdGlvbnMucG9zaXRpb24gPT09ICdiZWxvdydcXFwiXFxuICAgICAgICBbdmFsdWVSYW5nZV09XFxcImxlZ2VuZE9wdGlvbnMuZG9tYWluXFxcIlxcbiAgICAgICAgW2NvbG9yc109XFxcImxlZ2VuZE9wdGlvbnMuY29sb3JzXFxcIlxcbiAgICAgICAgW2hlaWdodF09XFxcInZpZXdbMV1cXFwiXFxuICAgICAgICBbd2lkdGhdPVxcXCJsZWdlbmRXaWR0aFxcXCI+XFxuICAgICAgPC9uZ3gtY2hhcnRzLXNjYWxlLWxlZ2VuZD5cXG4gICAgICA8bmd4LWNoYXJ0cy1sZWdlbmRcXG4gICAgICAgICpuZ0lmPVxcXCJzaG93TGVnZW5kICYmIGxlZ2VuZFR5cGUgPT09ICdsZWdlbmQnXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcImNoYXJ0LWxlZ2VuZFxcXCJcXG4gICAgICAgIFtob3Jpem9udGFsXT1cXFwibGVnZW5kT3B0aW9ucyAmJiBsZWdlbmRPcHRpb25zLnBvc2l0aW9uID09PSAnYmVsb3cnXFxcIlxcbiAgICAgICAgW2RhdGFdPVxcXCJsZWdlbmRPcHRpb25zLmRvbWFpblxcXCJcXG4gICAgICAgIFt0aXRsZV09XFxcImxlZ2VuZE9wdGlvbnMudGl0bGVcXFwiXFxuICAgICAgICBbY29sb3JzXT1cXFwibGVnZW5kT3B0aW9ucy5jb2xvcnNcXFwiXFxuICAgICAgICBbaGVpZ2h0XT1cXFwidmlld1sxXVxcXCJcXG4gICAgICAgIFt3aWR0aF09XFxcImxlZ2VuZFdpZHRoXFxcIlxcbiAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgKGxhYmVsQ2xpY2spPVxcXCJsZWdlbmRMYWJlbENsaWNrLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAgIChsYWJlbEFjdGl2YXRlKT1cXFwibGVnZW5kTGFiZWxBY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICAobGFiZWxEZWFjdGl2YXRlKT1cXFwibGVnZW5kTGFiZWxEZWFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCI+XFxuICAgICAgPC9uZ3gtY2hhcnRzLWxlZ2VuZD5cXG4gICAgPC9kaXY+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKCc1MDBtcyAxMDBtcycsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSlcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfZCA9IHR5cGVvZiBWaWV3Q29udGFpbmVyUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFZpZXdDb250YWluZXJSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdCwgdHlwZW9mIChfZSA9IHR5cGVvZiBUb29sdGlwU2VydmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUb29sdGlwU2VydmljZSkgPT09IFwiZnVuY3Rpb25cIiA/IF9lIDogT2JqZWN0XSlcclxuICAgIF0sIENoYXJ0Q29tcG9uZW50KTtcclxuICAgIHJldHVybiBDaGFydENvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbi8qKlxyXG4gKiBGb3JtYXRzIGEgbGFiZWwgZ2l2ZW4gYSBkYXRlLCBudW1iZXIgb3Igc3RyaW5nLlxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7Kn0gbGFiZWxcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIGZvcm1hdExhYmVsKGxhYmVsKSB7XHJcbiAgICBpZiAobGFiZWwgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgbGFiZWwgPSBsYWJlbC50b0xvY2FsZURhdGVTdHJpbmcoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxhYmVsID0gbGFiZWwudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsYWJlbDtcclxufVxyXG5cclxudmFyIExlZ2VuZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIExlZ2VuZENvbXBvbmVudChjZCkge1xyXG4gICAgICAgIHRoaXMuY2QgPSBjZDtcclxuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxhYmVsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5sYWJlbEFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMubGFiZWxEZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kRW50cmllcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kRW50cmllcyA9IHRoaXMuZ2V0TGVnZW5kRW50cmllcygpO1xyXG4gICAgfTtcclxuICAgIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kRW50cmllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChsYWJlbCkge1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCk7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSBpdGVtcy5maW5kSW5kZXgoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsID09PSBmb3JtYXR0ZWRMYWJlbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkTGFiZWw6IGZvcm1hdHRlZExhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzXzEuY29sb3JzLmdldENvbG9yKGxhYmVsKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmRhdGE7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IF9hW19pXTtcclxuICAgICAgICAgICAgX2xvb3BfMShsYWJlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpdGVtcztcclxuICAgIH07XHJcbiAgICBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5sYWJlbCA9PT0gZC5uYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5sYWJlbEFjdGl2YXRlLmVtaXQoaXRlbSk7XHJcbiAgICB9O1xyXG4gICAgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLmxhYmVsRGVhY3RpdmF0ZS5lbWl0KGl0ZW0pO1xyXG4gICAgfTtcclxuICAgIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9yaXpvbnRhbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbENsaWNrXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsQWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxEZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBMZWdlbmRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtbGVnZW5kJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxkaXYgW3N0eWxlLndpZHRoLnB4XT1cXFwid2lkdGhcXFwiPlxcbiAgICAgIDxoZWFkZXIgY2xhc3M9XFxcImxlZ2VuZC10aXRsZVxcXCIgKm5nSWY9XFxcInRpdGxlPy5sZW5ndGggPiAwXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsZWdlbmQtdGl0bGUtdGV4dFxcXCI+e3t0aXRsZX19PC9zcGFuPlxcbiAgICAgIDwvaGVhZGVyPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImxlZ2VuZC13cmFwXFxcIj5cXG4gICAgICAgIDx1bCBjbGFzcz1cXFwibGVnZW5kLWxhYmVsc1xcXCJcXG4gICAgICAgICAgICBbY2xhc3MuaG9yaXpvbnRhbC1sZWdlbmRdPVxcXCJob3Jpem9udGFsXFxcIlxcbiAgICAgICAgICBbc3R5bGUubWF4LWhlaWdodC5weF09XFxcImhlaWdodCAtIDQ1XFxcIj5cXG4gICAgICAgICAgPGxpXFxuICAgICAgICAgICAgKm5nRm9yPVxcXCJsZXQgZW50cnkgb2YgbGVnZW5kRW50cmllczsgdHJhY2tCeTogdHJhY2tCeVxcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwibGVnZW5kLWxhYmVsXFxcIj5cXG4gICAgICAgICAgICA8bmd4LWNoYXJ0cy1sZWdlbmQtZW50cnlcXG4gICAgICAgICAgICAgIFtsYWJlbF09XFxcImVudHJ5LmxhYmVsXFxcIlxcbiAgICAgICAgICAgICAgW2Zvcm1hdHRlZExhYmVsXT1cXFwiZW50cnkuZm9ybWF0dGVkTGFiZWxcXFwiXFxuICAgICAgICAgICAgICBbY29sb3JdPVxcXCJlbnRyeS5jb2xvclxcXCJcXG4gICAgICAgICAgICAgIFtpc0FjdGl2ZV09XFxcImlzQWN0aXZlKGVudHJ5KVxcXCJcXG4gICAgICAgICAgICAgIChzZWxlY3QpPVxcXCJsYWJlbENsaWNrLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGUoJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgPC9uZ3gtY2hhcnRzLWxlZ2VuZC1lbnRyeT5cXG4gICAgICAgICAgPC9saT5cXG4gICAgICAgIDwvdWw+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLmNoYXJ0LWxlZ2VuZHtkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjA7d2lkdGg6YXV0byFpbXBvcnRhbnR9LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLXRpdGxle3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW47bWFyZ2luLWxlZnQ6MTBweDttYXJnaW4tYm90dG9tOjVweDtmb250LXNpemU6MTRweDtmb250LXdlaWdodDo3MDB9LmNoYXJ0LWxlZ2VuZCBsaSwuY2hhcnQtbGVnZW5kIHVse3BhZGRpbmc6MDttYXJnaW46MDtsaXN0LXN0eWxlOm5vbmV9LmNoYXJ0LWxlZ2VuZCAuaG9yaXpvbnRhbC1sZWdlbmQgbGl7ZGlzcGxheTppbmxpbmUtYmxvY2t9LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLXdyYXB7d2lkdGg6Y2FsYygxMDAlIC0gMTBweCl9LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLWxhYmVsc3tsaW5lLWhlaWdodDo4NSU7bGlzdC1zdHlsZTpub25lO3RleHQtYWxpZ246bGVmdDtmbG9hdDpsZWZ0O3dpZHRoOjEwMCU7Ym9yZGVyLXJhZGl1czozcHg7b3ZlcmZsb3cteTphdXRvO292ZXJmbG93LXg6aGlkZGVuO3doaXRlLXNwYWNlOm5vd3JhcDtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjA1KX0uY2hhcnQtbGVnZW5kIC5sZWdlbmQtbGFiZWx7Y3Vyc29yOnBvaW50ZXI7Zm9udC1zaXplOjkwJTttYXJnaW46OHB4O2NvbG9yOiNhZmI3Yzh9LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLWxhYmVsOmhvdmVye2NvbG9yOiMwMDA7LXdlYmtpdC10cmFuc2l0aW9uOi4yczstbW96LXRyYW5zaXRpb246LjJzO3RyYW5zaXRpb246LjJzfS5jaGFydC1sZWdlbmQgLmxlZ2VuZC1sYWJlbCAuYWN0aXZlIC5sZWdlbmQtbGFiZWwtdGV4dHtjb2xvcjojMDAwfS5jaGFydC1sZWdlbmQgLmxlZ2VuZC1sYWJlbC1jb2xvcntkaXNwbGF5OmlubGluZS1ibG9jaztoZWlnaHQ6MTVweDt3aWR0aDoxNXB4O21hcmdpbi1yaWdodDo1cHg7Y29sb3I6IzViNjQ2Yjtib3JkZXItcmFkaXVzOjNweH0uY2hhcnQtbGVnZW5kIC5sZWdlbmQtbGFiZWwtdGV4dHtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjp0b3A7bGluZS1oZWlnaHQ6MTVweDtmb250LXNpemU6MTJweDt3aWR0aDpjYWxjKDEwMCUgLSAyMHB4KTt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW59LmNoYXJ0LWxlZ2VuZCAubGVnZW5kLXRpdGxlLXRleHR7dmVydGljYWwtYWxpZ246Ym90dG9tO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xpbmUtaGVpZ2h0OjE2cHg7b3ZlcmZsb3c6aGlkZGVuO3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2QgPSB0eXBlb2YgQ2hhbmdlRGV0ZWN0b3JSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgQ2hhbmdlRGV0ZWN0b3JSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdF0pXHJcbiAgICBdLCBMZWdlbmRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIExlZ2VuZENvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBTY2FsZUxlZ2VuZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNjYWxlTGVnZW5kQ29tcG9uZW50KHNhbml0aXplcikge1xyXG4gICAgICAgIHRoaXMuc2FuaXRpemVyID0gc2FuaXRpemVyO1xyXG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgU2NhbGVMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB2YXIgZ3JhZGllbnRWYWx1ZXMgPSB0aGlzLmdyYWRpZW50U3RyaW5nKHRoaXMuY29sb3JzLnJhbmdlKCksIHRoaXMuY29sb3JzLmRvbWFpbigpKTtcclxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gKHRoaXMuaG9yaXpvbnRhbCkgPyAncmlnaHQnIDogJ2JvdHRvbSc7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudCA9IHRoaXMuc2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RTdHlsZShcImxpbmVhci1ncmFkaWVudCh0byBcIiArIGRpcmVjdGlvbiArIFwiLCBcIiArIGdyYWRpZW50VmFsdWVzICsgXCIpXCIpO1xyXG4gICAgfTtcclxuICAgIFNjYWxlTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS5ncmFkaWVudFN0cmluZyA9IGZ1bmN0aW9uIChjb2xvcnMsIHNwbGl0cykge1xyXG4gICAgICAgIHNwbGl0cy5wdXNoKDEpO1xyXG4gICAgICAgIHZhciBwYWlycyA9IFtdO1xyXG4gICAgICAgIGNvbG9ycy5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xyXG4gICAgICAgICAgICBwYWlycy5wdXNoKGMgKyBcIiBcIiArIE1hdGgucm91bmQoc3BsaXRzW2ldICogMTAwKSArIFwiJVwiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGFpcnMuam9pbignLCAnKTtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTY2FsZUxlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVSYW5nZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2NhbGVMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2NhbGVMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2NhbGVMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTY2FsZUxlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9yaXpvbnRhbFwiLCB2b2lkIDApO1xyXG4gICAgU2NhbGVMZWdlbmRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtc2NhbGUtbGVnZW5kJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxkaXZcXG4gICAgICBjbGFzcz1cXFwic2NhbGUtbGVnZW5kXFxcIlxcbiAgICAgIFtjbGFzcy5ob3Jpem9udGFsLWxlZ2VuZF09XFxcImhvcml6b250YWxcXFwiXFxuICAgICAgW3N0eWxlLmhlaWdodC5weF09XFxcImhvcml6b250YWwgPyB1bmRlZmluZWQgOiBoZWlnaHRcXFwiXFxuICAgICAgW3N0eWxlLndpZHRoLnB4XT1cXFwid2lkdGhcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInNjYWxlLWxlZ2VuZC1sYWJlbFxcXCI+XFxuICAgICAgICA8c3Bhbj57eyB2YWx1ZVJhbmdlWzFdLnRvTG9jYWxlU3RyaW5nKCkgfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdlxcbiAgICAgICAgY2xhc3M9XFxcInNjYWxlLWxlZ2VuZC13cmFwXFxcIlxcbiAgICAgICAgW3N0eWxlLmJhY2tncm91bmRdPVxcXCJncmFkaWVudFxcXCI+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwic2NhbGUtbGVnZW5kLWxhYmVsXFxcIj5cXG4gICAgICAgIDxzcGFuPnt7IHZhbHVlUmFuZ2VbMF0udG9Mb2NhbGVTdHJpbmcoKSB9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIuY2hhcnQtbGVnZW5ke2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MDt3aWR0aDphdXRvIWltcG9ydGFudH0uY2hhcnQtbGVnZW5kIC5zY2FsZS1sZWdlbmR7dGV4dC1hbGlnbjpjZW50ZXI7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0uY2hhcnQtbGVnZW5kIC5zY2FsZS1sZWdlbmQtd3JhcHtkaXNwbGF5OmlubGluZS1ibG9jaztmbGV4OjE7d2lkdGg6MzBweDtib3JkZXItcmFkaXVzOjVweDttYXJnaW46MCBhdXRvfS5jaGFydC1sZWdlbmQgLnNjYWxlLWxlZ2VuZC1sYWJlbHtmb250LXNpemU6MTJweH0uY2hhcnQtbGVnZW5kIC5ob3Jpem9udGFsLWxlZ2VuZC5zY2FsZS1sZWdlbmR7ZmxleC1kaXJlY3Rpb246cm93fS5jaGFydC1sZWdlbmQgLmhvcml6b250YWwtbGVnZW5kIC5zY2FsZS1sZWdlbmQtd3JhcHt3aWR0aDphdXRvO2hlaWdodDozMHB4O21hcmdpbjowIDE2cHh9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBEb21TYW5pdGl6ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRG9tU2FuaXRpemVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxyXG4gICAgXSwgU2NhbGVMZWdlbmRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFNjYWxlTGVnZW5kQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIExlZ2VuZEVudHJ5Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGVnZW5kRW50cnlDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMudG9nZ2xlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltbWVkTGFiZWxcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZWRMYWJlbCB8fCAnKGVtcHR5KSc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUub25Nb3VzZUVudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IG5hbWU6IHRoaXMubGFiZWwgfSk7XHJcbiAgICB9O1xyXG4gICAgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLm9uTW91c2VMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IG5hbWU6IHRoaXMubGFiZWwgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmb3JtYXR0ZWRMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIExlZ2VuZEVudHJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0FjdGl2ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2QgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9kIDogT2JqZWN0KVxyXG4gICAgXSwgTGVnZW5kRW50cnlDb21wb25lbnQucHJvdG90eXBlLCBcInRvZ2dsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUVudGVyXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBMZWdlbmRFbnRyeUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUxlYXZlXCIsIG51bGwpO1xyXG4gICAgTGVnZW5kRW50cnlDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtbGVnZW5kLWVudHJ5JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzcGFuIFxcbiAgICAgIFt0aXRsZV09XFxcImZvcm1hdHRlZExhYmVsXFxcIlxcbiAgICAgIHRhYmluZGV4PVxcXCItMVxcXCJcXG4gICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiaXNBY3RpdmVcXFwiXFxuICAgICAgKGNsaWNrKT1cXFwic2VsZWN0LmVtaXQoZm9ybWF0dGVkTGFiZWwpXFxcIj5cXG4gICAgICA8c3BhblxcbiAgICAgICAgY2xhc3M9XFxcImxlZ2VuZC1sYWJlbC1jb2xvclxcXCJcXG4gICAgICAgIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cXFwiY29sb3JcXFwiXFxuICAgICAgICAoY2xpY2spPVxcXCJ0b2dnbGUuZW1pdChmb3JtYXR0ZWRMYWJlbClcXFwiPlxcbiAgICAgIDwvc3Bhbj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwibGVnZW5kLWxhYmVsLXRleHRcXFwiPlxcbiAgICAgICAge3t0cmltbWVkTGFiZWx9fVxcbiAgICAgIDwvc3Bhbj5cXG4gICAgPC9zcGFuPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIExlZ2VuZEVudHJ5Q29tcG9uZW50KTtcclxuICAgIHJldHVybiBMZWdlbmRFbnRyeUNvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbmZ1bmN0aW9uIHRyaW1MYWJlbChzLCBtYXgkJDEpIHtcclxuICAgIGlmIChtYXgkJDEgPT09IHZvaWQgMCkgeyBtYXgkJDEgPSAxNjsgfVxyXG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHMgKyAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzID0gcy50cmltKCk7XHJcbiAgICBpZiAocy5sZW5ndGggPD0gbWF4JCQxKSB7XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcy5zbGljZSgwLCBtYXgkJDEpICsgXCIuLi5cIjtcclxuICAgIH1cclxufVxyXG5cclxudmFyIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQWR2YW5jZWRMZWdlbmRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9ICdUb3RhbCc7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gW107XHJcbiAgICAgICAgdGhpcy5sYWJlbEZvcm1hdHRpbmcgPSBmdW5jdGlvbiAobGFiZWwpIHsgcmV0dXJuIGxhYmVsOyB9O1xyXG4gICAgICAgIHRoaXMucGVyY2VudGFnZUZvcm1hdHRpbmcgPSBmdW5jdGlvbiAocGVyY2VudGFnZSkgeyByZXR1cm4gcGVyY2VudGFnZTsgfTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZUZvcm1hdHRpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7IH07XHJcbiAgICB9XHJcbiAgICBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLmdldFRvdGFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgZCkgeyByZXR1cm4gc3VtICsgZDsgfSwgMCk7XHJcbiAgICB9O1xyXG4gICAgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRvdGFsID0gdGhpcy5nZXRUb3RhbCgpO1xyXG4gICAgICAgIHRoaXMucm91bmRlZFRvdGFsID0gdGhpcy50b3RhbDtcclxuICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdGhpcy5nZXRMZWdlbmRJdGVtcygpO1xyXG4gICAgfTtcclxuICAgIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRJdGVtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGZvcm1hdExhYmVsKGQubmFtZSk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGQudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IF90aGlzLmNvbG9ycy5nZXRDb2xvcihsYWJlbCk7XHJcbiAgICAgICAgICAgIHZhciBwZXJjZW50YWdlID0gX3RoaXMudG90YWwgPiAwID8gKHZhbHVlIC8gX3RoaXMudG90YWwpICogMTAwIDogMDtcclxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZExhYmVsID0gdHlwZW9mIF90aGlzLmxhYmVsRm9ybWF0dGluZyA9PT0gJ2Z1bmN0aW9uJyA/IF90aGlzLmxhYmVsRm9ybWF0dGluZyhsYWJlbCkgOiBsYWJlbDtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIF92YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGZvcm1hdHRlZExhYmVsLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheUxhYmVsOiB0cmltTGFiZWwoZm9ybWF0dGVkTGFiZWwsIDIwKSxcclxuICAgICAgICAgICAgICAgIG9yaWdpYWxMYWJlbDogZC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgcGVyY2VudGFnZTogX3RoaXMucGVyY2VudGFnZUZvcm1hdHRpbmcgPyBfdGhpcy5wZXJjZW50YWdlRm9ybWF0dGluZyhwZXJjZW50YWdlKSA6IHBlcmNlbnRhZ2UudG9Mb2NhbGVTdHJpbmcoKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5mb3JtYXR0ZWRMYWJlbDtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbiAgICBdLCBBZHZhbmNlZExlZ2VuZENvbXBvbmVudC5wcm90b3R5cGUsIFwicGVyY2VudGFnZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWFkdmFuY2VkLWxlZ2VuZCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhZHZhbmNlZC1waWUtbGVnZW5kXFxcIiBbc3R5bGUud2lkdGgucHhdPVxcXCJ3aWR0aFxcXCI+XFxuICAgICAgPGRpdlxcbiAgICAgICAgKm5nSWY9XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICBjbGFzcz1cXFwidG90YWwtdmFsdWVcXFwiXFxuICAgICAgICBuZ3gtY2hhcnRzLWNvdW50LXVwXFxuICAgICAgICBbY291bnRUb109XFxcInJvdW5kZWRUb3RhbFxcXCJcXG4gICAgICAgIFt2YWx1ZUZvcm1hdHRpbmddPVxcXCJ2YWx1ZUZvcm1hdHRpbmdcXFwiXFxuICAgICAgPjwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInRvdGFsLXZhbHVlXFxcIiAqbmdJZj1cXFwiIWFuaW1hdGlvbnNcXFwiPlxcbiAgICAgICAge3sgdmFsdWVGb3JtYXR0aW5nID8gdmFsdWVGb3JtYXR0aW5nKHJvdW5kZWRUb3RhbCkgOiBkZWZhdWx0VmFsdWVGb3JtYXR0aW5nKHJvdW5kZWRUb3RhbCkgfX1cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJ0b3RhbC1sYWJlbFxcXCI+XFxuICAgICAgICB7eyBsYWJlbCB9fVxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImxlZ2VuZC1pdGVtcy1jb250YWluZXJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibGVnZW5kLWl0ZW1zXFxcIj5cXG4gICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGxlZ2VuZEl0ZW0gb2YgbGVnZW5kSXRlbXM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgICAgICAgdGFiaW5kZXg9XFxcIi0xXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJsZWdlbmQtaXRlbVxcXCJcXG4gICAgICAgICAgICAobW91c2VlbnRlcik9XFxcImFjdGl2YXRlLmVtaXQobGVnZW5kSXRlbS5kYXRhKVxcXCJcXG4gICAgICAgICAgICAobW91c2VsZWF2ZSk9XFxcImRlYWN0aXZhdGUuZW1pdChsZWdlbmRJdGVtLmRhdGEpXFxcIlxcbiAgICAgICAgICAgIChjbGljayk9XFxcInNlbGVjdC5lbWl0KGxlZ2VuZEl0ZW0uZGF0YSlcXFwiXFxuICAgICAgICAgID5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtLWNvbG9yXFxcIiBbc3R5bGUuYm9yZGVyLWxlZnQtY29sb3JdPVxcXCJsZWdlbmRJdGVtLmNvbG9yXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAqbmdJZj1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJpdGVtLXZhbHVlXFxcIlxcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1jb3VudC11cFxcbiAgICAgICAgICAgICAgW2NvdW50VG9dPVxcXCJsZWdlbmRJdGVtLl92YWx1ZVxcXCJcXG4gICAgICAgICAgICAgIFt2YWx1ZUZvcm1hdHRpbmddPVxcXCJ2YWx1ZUZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgICAgPjwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XFxcIiFhbmltYXRpb25zXFxcIiBjbGFzcz1cXFwiaXRlbS12YWx1ZVxcXCI+XFxuICAgICAgICAgICAgICB7eyB2YWx1ZUZvcm1hdHRpbmcgPyB2YWx1ZUZvcm1hdHRpbmcobGVnZW5kSXRlbS52YWx1ZSkgOiBkZWZhdWx0VmFsdWVGb3JtYXR0aW5nKGxlZ2VuZEl0ZW0udmFsdWUpIH19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbS1sYWJlbFxcXCI+e3sgbGVnZW5kSXRlbS5kaXNwbGF5TGFiZWwgfX08L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICAqbmdJZj1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJpdGVtLXBlcmNlbnRcXFwiXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLWNvdW50LXVwXFxuICAgICAgICAgICAgICBbY291bnRUb109XFxcImxlZ2VuZEl0ZW0ucGVyY2VudGFnZVxcXCJcXG4gICAgICAgICAgICAgIFtjb3VudFN1ZmZpeF09XFxcIiclJ1xcXCJcXG4gICAgICAgICAgICA+PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cXFwiIWFuaW1hdGlvbnNcXFwiIGNsYXNzPVxcXCJpdGVtLXBlcmNlbnRcXFwiPnt7IGxlZ2VuZEl0ZW0ucGVyY2VudGFnZS50b0xvY2FsZVN0cmluZygpIH19JTwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIFwiLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5hZHZhbmNlZC1waWUtbGVnZW5ke2Zsb2F0OmxlZnQ7cG9zaXRpb246cmVsYXRpdmU7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlKDAsLTUwJSl9LmFkdmFuY2VkLXBpZS1sZWdlbmQgLnRvdGFsLXZhbHVle2ZvbnQtc2l6ZTozNnB4fS5hZHZhbmNlZC1waWUtbGVnZW5kIC50b3RhbC1sYWJlbHtmb250LXNpemU6MjRweDttYXJnaW4tYm90dG9tOjE5cHh9LmFkdmFuY2VkLXBpZS1sZWdlbmQgLmxlZ2VuZC1pdGVtcy1jb250YWluZXJ7d2lkdGg6MTAwJX0uYWR2YW5jZWQtcGllLWxlZ2VuZCAubGVnZW5kLWl0ZW1zLWNvbnRhaW5lciAubGVnZW5kLWl0ZW1ze3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzphdXRvfS5hZHZhbmNlZC1waWUtbGVnZW5kIC5sZWdlbmQtaXRlbXMtY29udGFpbmVyIC5sZWdlbmQtaXRlbXMgLmxlZ2VuZC1pdGVte21hcmdpbi1yaWdodDoyMHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrO2N1cnNvcjpwb2ludGVyfS5hZHZhbmNlZC1waWUtbGVnZW5kIC5sZWdlbmQtaXRlbXMtY29udGFpbmVyIC5sZWdlbmQtaXRlbXMgLmxlZ2VuZC1pdGVtOmZvY3Vze291dGxpbmU6MH0uYWR2YW5jZWQtcGllLWxlZ2VuZCAubGVnZW5kLWl0ZW1zLWNvbnRhaW5lciAubGVnZW5kLWl0ZW1zIC5sZWdlbmQtaXRlbTpob3Zlcntjb2xvcjojMDAwOy13ZWJraXQtdHJhbnNpdGlvbjouMnM7LW1vei10cmFuc2l0aW9uOi4yczt0cmFuc2l0aW9uOi4yc30uYWR2YW5jZWQtcGllLWxlZ2VuZCAubGVnZW5kLWl0ZW1zLWNvbnRhaW5lciAubGVnZW5kLWl0ZW1zIC5sZWdlbmQtaXRlbSAuaXRlbS12YWx1ZXtmb250LXNpemU6MjRweDttYXJnaW4tdG9wOi02cHg7bWFyZ2luLWxlZnQ6MTFweH0uYWR2YW5jZWQtcGllLWxlZ2VuZCAubGVnZW5kLWl0ZW1zLWNvbnRhaW5lciAubGVnZW5kLWl0ZW1zIC5sZWdlbmQtaXRlbSAuaXRlbS1sYWJlbHtmb250LXNpemU6MTRweDtvcGFjaXR5Oi43O21hcmdpbi1sZWZ0OjExcHg7bWFyZ2luLXRvcDotNnB4fS5hZHZhbmNlZC1waWUtbGVnZW5kIC5sZWdlbmQtaXRlbXMtY29udGFpbmVyIC5sZWdlbmQtaXRlbXMgLmxlZ2VuZC1pdGVtIC5pdGVtLXBlcmNlbnR7Zm9udC1zaXplOjI0cHg7b3BhY2l0eTouNzttYXJnaW4tbGVmdDoxMXB4fS5hZHZhbmNlZC1waWUtbGVnZW5kIC5sZWdlbmQtaXRlbXMtY29udGFpbmVyIC5sZWdlbmQtaXRlbXMgLmxlZ2VuZC1pdGVtIC5pdGVtLWNvbG9ye2JvcmRlci1sZWZ0OjRweCBzb2xpZDt3aWR0aDo0cHg7aGVpZ2h0OjQycHg7ZmxvYXQ6bGVmdDttYXJnaW4tcmlnaHQ6N3B4fVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEFkdmFuY2VkTGVnZW5kQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIGNhY2hlID0ge307XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBzaG9ydCBpZC5cclxuICpcclxuICogRGVzY3JpcHRpb246XHJcbiAqICAgQSA0LWNoYXJhY3RlciBhbHBoYW51bWVyaWMgc2VxdWVuY2UgKDM2NCA9IDEuNiBtaWxsaW9uKVxyXG4gKiAgIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgSmF2YVNjcmlwdCBzcGVjaWZpYyBtb2RlbHMuXHJcbiAqICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MjQ4NjY2L2hvdy10by1nZW5lcmF0ZS1zaG9ydC11aWQtbGlrZS1heDRqOXotaW4tanNcclxuICpcclxuICogICBFeGFtcGxlOiBgZWJnZmBcclxuICovXHJcbmZ1bmN0aW9uIGlkKCkge1xyXG4gICAgdmFyIG5ld0lkID0gKCcwMDAwJyArIChNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMzYsIDQpIDw8IDApLnRvU3RyaW5nKDM2KSkuc2xpY2UoLTQpO1xyXG4gICAgLy8gYXBwZW5kIGEgJ2EnIGJlY2F1c2UgbmVvIGdldHMgbWFkXHJcbiAgICBuZXdJZCA9IFwiYVwiICsgbmV3SWQ7XHJcbiAgICAvLyBlbnN1cmUgbm90IGFscmVhZHkgdXNlZFxyXG4gICAgaWYgKCFjYWNoZVtuZXdJZF0pIHtcclxuICAgICAgICBjYWNoZVtuZXdJZF0gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBuZXdJZDtcclxuICAgIH1cclxuICAgIHJldHVybiBpZCgpO1xyXG59XHJcblxyXG52YXIgY29sb3JTZXRzID0gW1xyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICd2aXZpZCcsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxyXG4gICAgICAgIGRvbWFpbjogW1xyXG4gICAgICAgICAgICAnIzY0N2M4YScsICcjM2Y1MWI1JywgJyMyMTk2ZjMnLCAnIzAwYjg2MicsICcjYWZkZjBhJywgJyNhN2I2MWEnLCAnI2YzZTU2MicsICcjZmY5ODAwJywgJyNmZjU3MjInLCAnI2ZmNDUxNCdcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICduYXR1cmFsJyxcclxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdyb3VwOiAnT3JkaW5hbCcsXHJcbiAgICAgICAgZG9tYWluOiBbXHJcbiAgICAgICAgICAgICcjYmY5ZDc2JywgJyNlOTk0NTAnLCAnI2Q4OWY1OScsICcjZjJkZmE3JywgJyNhNWQ3YzYnLCAnIzc3OTRiMScsICcjYWZhZmFmJywgJyM3MDcxNjAnLCAnI2JhOTM4MycsICcjZDlkNWMzJ1xyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2Nvb2wnLFxyXG4gICAgICAgIHNlbGVjdGFibGU6IHRydWUsXHJcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyNhODM4NWQnLCAnIzdhYTNlNScsICcjYTI3ZWE4JywgJyNhYWUzZjUnLCAnI2FkY2RlZCcsICcjYTk1OTYzJywgJyM4Nzk2YzAnLCAnIzdlZDNlZCcsICcjNTBhYmNjJywgJyNhZDY4ODYnXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnZmlyZScsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxyXG4gICAgICAgIGRvbWFpbjogW1xyXG4gICAgICAgICAgICAnI2ZmM2QwMCcsICcjYmYzNjBjJywgJyNmZjhmMDAnLCAnI2ZmNmYwMCcsICcjZmY1NzIyJywgJyNlNjUxMDAnLCAnI2ZmY2EyOCcsICcjZmZhYjAwJ1xyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ3NvbGFyJyxcclxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdyb3VwOiAnQ29udGludW91cycsXHJcbiAgICAgICAgZG9tYWluOiBbXHJcbiAgICAgICAgICAgICcjZmZmOGUxJywgJyNmZmVjYjMnLCAnI2ZmZTA4MicsICcjZmZkNTRmJywgJyNmZmNhMjgnLCAnI2ZmYzEwNycsICcjZmZiMzAwJywgJyNmZmEwMDAnLCAnI2ZmOGYwMCcsICcjZmY2ZjAwJ1xyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2FpcicsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogdHJ1ZSxcclxuICAgICAgICBncm91cDogJ0NvbnRpbnVvdXMnLFxyXG4gICAgICAgIGRvbWFpbjogW1xyXG4gICAgICAgICAgICAnI2UxZjVmZScsICcjYjNlNWZjJywgJyM4MWQ0ZmEnLCAnIzRmYzNmNycsICcjMjliNmY2JywgJyMwM2E5ZjQnLCAnIzAzOWJlNScsICcjMDI4OGQxJywgJyMwMjc3YmQnLCAnIzAxNTc5YidcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdhcXVhJyxcclxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdyb3VwOiAnQ29udGludW91cycsXHJcbiAgICAgICAgZG9tYWluOiBbXHJcbiAgICAgICAgICAgICcjZTBmN2ZhJywgJyNiMmViZjInLCAnIzgwZGVlYScsICcjNGRkMGUxJywgJyMyNmM2ZGEnLCAnIzAwYmNkNCcsICcjMDBhY2MxJywgJyMwMDk3YTcnLCAnIzAwODM4ZicsICcjMDA2MDY0J1xyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2ZsYW1lJyxcclxuICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcclxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxyXG4gICAgICAgIGRvbWFpbjogW1xyXG4gICAgICAgICAgICAnI0ExMEEyOCcsICcjRDMzNDJEJywgJyNFRjZENDknLCAnI0ZBQUQ2NycsICcjRkRERTkwJywgJyNEQkVEOTEnLCAnI0E5RDc3MCcsICcjNkNCQTY3JywgJyMyQzk2NTMnLCAnIzE0NjczOCdcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdvY2VhbicsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyMxRDY4RkInLCAnIzMzQzBGQycsICcjNEFGRkZFJywgJyNBRkZGRkYnLCAnI0ZGRkM2MycsICcjRkRCRDJEJywgJyNGQzhBMjUnLCAnI0ZBNEYxRScsICcjRkExNDFCJywgJyNCQTM4RDEnXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnZm9yZXN0JyxcclxuICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcclxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxyXG4gICAgICAgIGRvbWFpbjogW1xyXG4gICAgICAgICAgICAnIzU1QzIyRCcsICcjQzFGMzNEJywgJyMzQ0MwOTknLCAnI0FGRkZGRicsICcjOENGQzlEJywgJyM3NkNGRkEnLCAnI0JBNjBGQicsICcjRUU2NDkwJywgJyNDNDJBMUMnLCAnI0ZDOUYzMidcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdob3Jpem9uJyxcclxuICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcclxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxyXG4gICAgICAgIGRvbWFpbjogW1xyXG4gICAgICAgICAgICAnIzI1OTdGQicsICcjNjVFQkZEJywgJyM5OUZERDAnLCAnI0ZDRUU0QicsICcjRkVGQ0ZBJywgJyNGREQ2RTMnLCAnI0ZDQjFBOCcsICcjRUY2RjdCJywgJyNDQjk2RTgnLCAnI0VGREVFMCdcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICduZW9ucycsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyNGRjMzMzMnLCAnI0ZGMzNGRicsICcjQ0MzM0ZGJywgJyMwMDAwRkYnLCAnIzMzQ0NGRicsICcjMzNGRkZGJywgJyMzM0ZGNjYnLCAnI0NDRkYzMycsICcjRkZDQzAwJywgJyNGRjY2MDAnXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAncGljbmljJyxcclxuICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcclxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxyXG4gICAgICAgIGRvbWFpbjogW1xyXG4gICAgICAgICAgICAnI0ZBQzUxRCcsICcjNjZCRDZEJywgJyNGQUEwMjYnLCAnIzI5QkI5QycsICcjRTk2QjU2JywgJyM1NUFDRDInLCAnI0I3MzMyRicsICcjMkM4M0M5JywgJyM5MTY2QjgnLCAnIzkyRTdFOCdcclxuICAgICAgICBdXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICduaWdodCcsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ3JvdXA6ICdPcmRpbmFsJyxcclxuICAgICAgICBkb21haW46IFtcclxuICAgICAgICAgICAgJyMyQjFCNUEnLCAnIzUwMTM1NicsICcjMTgzMzU2JywgJyMyODIwM0YnLCAnIzM5MUIzQycsICcjMUUyQjNDJywgJyMxMjA2MzQnLFxyXG4gICAgICAgICAgICAnIzJEMDQzMicsICcjMDUxOTMyJywgJyM0NTMwODAnLCAnIzc1MjY3RCcsICcjMkM1MDdEJywgJyM0QjM4ODAnLCAnIzc1MkY3RCcsICcjMzU1NDdEJ1xyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ25pZ2h0TGlnaHRzJyxcclxuICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcclxuICAgICAgICBncm91cDogJ09yZGluYWwnLFxyXG4gICAgICAgIGRvbWFpbjogW1xyXG4gICAgICAgICAgICAnIzRlMzFhNScsICcjOWMyNWE3JywgJyMzMDY1YWInLCAnIzU3NDY4YicsICcjOTA0NDk3JywgJyM0NjY0OGInLFxyXG4gICAgICAgICAgICAnIzMyMTE4ZCcsICcjYTAwZmIzJywgJyMxMDUyYTInLCAnIzZlNTFiZCcsICcjYjYzY2MzJywgJyM2Yzk3Y2InLCAnIzg2NzFjMScsICcjYjQ1NWJlJywgJyM3NDk2YzMnXHJcbiAgICAgICAgXVxyXG4gICAgfVxyXG5dO1xyXG5cclxuZnVuY3Rpb24gc29ydExpbmVhcihkYXRhLCBwcm9wZXJ0eSwgZGlyZWN0aW9uKSB7XHJcbiAgICBpZiAoZGlyZWN0aW9uID09PSB2b2lkIDApIHsgZGlyZWN0aW9uID0gJ2FzYyc7IH1cclxuICAgIHJldHVybiBkYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnYXNjJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYVtwcm9wZXJ0eV0gLSBiW3Byb3BlcnR5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiW3Byb3BlcnR5XSAtIGFbcHJvcGVydHldO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHNvcnRCeURvbWFpbihkYXRhLCBwcm9wZXJ0eSwgZGlyZWN0aW9uLCBkb21haW4pIHtcclxuICAgIGlmIChkaXJlY3Rpb24gPT09IHZvaWQgMCkgeyBkaXJlY3Rpb24gPSAnYXNjJzsgfVxyXG4gICAgcmV0dXJuIGRhdGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciBhVmFsID0gYVtwcm9wZXJ0eV07XHJcbiAgICAgICAgdmFyIGJWYWwgPSBiW3Byb3BlcnR5XTtcclxuICAgICAgICB2YXIgYUlkeCA9IGRvbWFpbi5pbmRleE9mKGFWYWwpO1xyXG4gICAgICAgIHZhciBiSWR4ID0gZG9tYWluLmluZGV4T2YoYlZhbCk7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2FzYycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFJZHggLSBiSWR4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJJZHggLSBhSWR4O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHNvcnRCeVRpbWUoZGF0YSwgcHJvcGVydHksIGRpcmVjdGlvbikge1xyXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdm9pZCAwKSB7IGRpcmVjdGlvbiA9ICdhc2MnOyB9XHJcbiAgICByZXR1cm4gZGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgdmFyIGFEYXRlID0gYVtwcm9wZXJ0eV0uZ2V0VGltZSgpO1xyXG4gICAgICAgIHZhciBiRGF0ZSA9IGJbcHJvcGVydHldLmdldFRpbWUoKTtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnYXNjJykge1xyXG4gICAgICAgICAgICBpZiAoYURhdGUgPiBiRGF0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICBpZiAoYkRhdGUgPiBhRGF0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoYURhdGUgPiBiRGF0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgaWYgKGJEYXRlID4gYURhdGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBY2NlcHRzIGEgY29sb3IgKHN0cmluZykgYW5kIHJldHVybnMgYSBpbnZlcnRlZCBoZXggY29sb3IgKHN0cmluZylcclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85NjAwMjk1L2F1dG9tYXRpY2FsbHktY2hhbmdlLXRleHQtY29sb3ItdG8tYXNzdXJlLXJlYWRhYmlsaXR5XHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHthbnl9IHZhbHVlXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBpbnZlcnRDb2xvcih2YWx1ZSkge1xyXG4gICAgdmFyIGNvbG9yID0gcmdiKHZhbHVlKTtcclxuICAgIHZhciByID0gY29sb3IuciwgZyA9IGNvbG9yLmcsIGIgPSBjb2xvci5iLCBvcGFjaXR5ID0gY29sb3Iub3BhY2l0eTtcclxuICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgeWlxID0gKChyICogMjk5KSArIChnICogNTg3KSArIChiICogMTE0KSkgLyAxMDAwO1xyXG4gICAgdmFyIGRlcHRoID0gKHlpcSA+PSAxMjgpID8gLS44IDogLjg7XHJcbiAgICByZXR1cm4gc2hhZGVSR0JDb2xvcihjb2xvciwgZGVwdGgpO1xyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhIHJnYiwgaXQgd2lsbCBkYXJrZW4vbGlnaHRlblxyXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU1NjAyNDgvcHJvZ3JhbW1hdGljYWxseS1saWdodGVuLW9yLWRhcmtlbi1hLWhleC1jb2xvci1vci1yZ2ItYW5kLWJsZW5kLWNvbG9yc1xyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7YW55fSB7IHIsIGcsIGIgfVxyXG4gKiBAcGFyYW0ge2FueX0gcGVyY2VudFxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZnVuY3Rpb24gc2hhZGVSR0JDb2xvcihfYSwgcGVyY2VudCkge1xyXG4gICAgdmFyIHIgPSBfYS5yLCBnID0gX2EuZywgYiA9IF9hLmI7XHJcbiAgICB2YXIgdCA9IHBlcmNlbnQgPCAwID8gMCA6IDI1NTtcclxuICAgIHZhciBwID0gcGVyY2VudCA8IDAgPyBwZXJjZW50ICogLTEgOiBwZXJjZW50O1xyXG4gICAgciA9IChNYXRoLnJvdW5kKCh0IC0gcikgKiBwKSArIHIpO1xyXG4gICAgZyA9IChNYXRoLnJvdW5kKCh0IC0gZykgKiBwKSArIGcpO1xyXG4gICAgYiA9IChNYXRoLnJvdW5kKCh0IC0gYikgKiBwKSArIGIpO1xyXG4gICAgcmV0dXJuIFwicmdiKFwiICsgciArIFwiLCBcIiArIGcgKyBcIiwgXCIgKyBiICsgXCIpXCI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWaXNpYmlsaXR5IE9ic2VydmVyXHJcbiAqL1xyXG52YXIgVmlzaWJpbGl0eU9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmlzaWJpbGl0eU9ic2VydmVyKGVsZW1lbnQsIHpvbmUpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ydW5DaGVjaygpO1xyXG4gICAgfVxyXG4gICAgVmlzaWJpbGl0eU9ic2VydmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xyXG4gICAgfTtcclxuICAgIFZpc2liaWxpdHlPYnNlcnZlci5wcm90b3R5cGUub25WaXNpYmlsaXR5Q2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gdHJpZ2dlciB6b25lIHJlY2FsYyBmb3IgY29sdW1uc1xyXG4gICAgICAgIHRoaXMuem9uZS5ydW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBfdGhpcy52aXNpYmxlLmVtaXQodHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVmlzaWJpbGl0eU9ic2VydmVyLnByb3RvdHlwZS5ydW5DaGVjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFfdGhpcy5lbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvb2Zmc2V0aGVpZ2h0LXZpc2liaWxpdHlcclxuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCBvZmZzZXRIZWlnaHQgPSBfYS5vZmZzZXRIZWlnaHQsIG9mZnNldFdpZHRoID0gX2Eub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXRIZWlnaHQgJiYgb2Zmc2V0V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLm9uVmlzaWJpbGl0eUNoYW5nZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hlY2soKTsgfSwgMTAwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjaGVjaygpOyB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBWaXNpYmlsaXR5T2JzZXJ2ZXIucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcclxuICAgIHJldHVybiBWaXNpYmlsaXR5T2JzZXJ2ZXI7XHJcbn0oKSk7XHJcblxyXG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcclxuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xyXG59XHJcblxyXG52YXIgQmFzZUNoYXJ0Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmFzZUNoYXJ0Q29tcG9uZW50KGNoYXJ0RWxlbWVudCwgem9uZSwgY2QpIHtcclxuICAgICAgICB0aGlzLmNoYXJ0RWxlbWVudCA9IGNoYXJ0RWxlbWVudDtcclxuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xyXG4gICAgICAgIHRoaXMuY2QgPSBjZDtcclxuICAgICAgICB0aGlzLnNjaGVtZSA9ICdjb29sJztcclxuICAgICAgICB0aGlzLnNjaGVtZVR5cGUgPSAnb3JkaW5hbCc7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYmluZFdpbmRvd1Jlc2l6ZUV2ZW50KCk7XHJcbiAgICAgICAgLy8gbGlzdGVuIGZvciB2aXNpYmlsaXR5IG9mIHRoZSBlbGVtZW50IGZvciBoaWRkZW4gYnkgZGVmYXVsdCBzY2VuYXJpb1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eU9ic2VydmVyID0gbmV3IFZpc2liaWxpdHlPYnNlcnZlcih0aGlzLmNoYXJ0RWxlbWVudCwgdGhpcy56b25lKTtcclxuICAgICAgICB0aGlzLnZpc2liaWxpdHlPYnNlcnZlci52aXNpYmxlLnN1YnNjcmliZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcclxuICAgIH07XHJcbiAgICBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgaWYgKHRoaXMudmlzaWJpbGl0eU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eU9ic2VydmVyLnZpc2libGUudW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5T2JzZXJ2ZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlc3VsdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHRzID0gdGhpcy5jbG9uZURhdGEodGhpcy5yZXN1bHRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnZpZXdbMF07XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy52aWV3WzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGRpbXMgPSB0aGlzLmdldENvbnRhaW5lckRpbXMoKTtcclxuICAgICAgICAgICAgaWYgKGRpbXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBkaW1zLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBkaW1zLmhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlcyBpZiB3aWR0aCBvciBoZWlnaHQgYXJlIDAgb3IgdW5kZWZpbmVkXHJcbiAgICAgICAgaWYgKCF0aGlzLndpZHRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSA2MDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSA0MDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud2lkdGggPSBNYXRoLmZsb29yKHRoaXMud2lkdGgpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRDb250YWluZXJEaW1zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB3aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0O1xyXG4gICAgICAgIHZhciBob3N0RWxlbSA9IHRoaXMuY2hhcnRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGhvc3RFbGVtLnBhcmVudE5vZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjb250YWluZXIgZGltZW5zaW9uc1xyXG4gICAgICAgICAgICB2YXIgZGltcyA9IGhvc3RFbGVtLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIHdpZHRoID0gZGltcy53aWR0aDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gZGltcy5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGFsbCBkYXRlIG9iamVjdHMgdGhhdCBhcHBlYXIgYXMgbmFtZVxyXG4gICAgICogaW50byBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmdzXHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZm9ybWF0RGF0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlc3VsdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGcgPSB0aGlzLnJlc3VsdHNbaV07XHJcbiAgICAgICAgICAgIGcubGFiZWwgPSBnLm5hbWU7XHJcbiAgICAgICAgICAgIGlmIChnLmxhYmVsIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgZy5sYWJlbCA9IGcubGFiZWwudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGcuc2VyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGcuc2VyaWVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBnLnNlcmllc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBkLmxhYmVsID0gZC5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkLmxhYmVsIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkLmxhYmVsID0gZC5sYWJlbC50b0xvY2FsZURhdGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51bmJpbmRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVzaXplU3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUuYmluZFdpbmRvd1Jlc2l6ZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IGZyb21FdmVudCh3aW5kb3csICdyZXNpemUnKTtcclxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnBpcGUoZGVib3VuY2VUaW1lKDIwMCkpLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBfdGhpcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmNkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVzaXplU3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xvbmVzIHRoZSBkYXRhIGludG8gYSBuZXcgb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7YW55fSBkYXRhXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgQmFzZUNoYXJ0XHJcbiAgICAgKi9cclxuICAgIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUuY2xvbmVEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZGF0YV8xID0gZGF0YTsgX2kgPCBkYXRhXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gZGF0YV8xW19pXTtcclxuICAgICAgICAgICAgdmFyIGNvcHkgPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBpdGVtWyduYW1lJ11cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGl0ZW1bJ3ZhbHVlJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29weVsndmFsdWUnXSA9IGl0ZW1bJ3ZhbHVlJ107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGl0ZW1bJ3NlcmllcyddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvcHlbJ3NlcmllcyddID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gaXRlbVsnc2VyaWVzJ107IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllc0l0ZW0gPSBfYltfYV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllc0l0ZW1Db3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgc2VyaWVzSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29weVsnc2VyaWVzJ10ucHVzaChzZXJpZXNJdGVtQ29weSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGl0ZW1bJ2V4dHJhJ10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY29weVsnZXh0cmEnXSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaXRlbVsnZXh0cmEnXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChjb3B5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJlc3VsdHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aWV3XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFzZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXNlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImN1c3RvbUNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhc2VDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBCYXNlQ2hhcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2Jhc2UtY2hhcnQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdj48L2Rpdj5cXG4gIFwiXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0LCB0eXBlb2YgKF9iID0gdHlwZW9mIE5nWm9uZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBOZ1pvbmUpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdCwgdHlwZW9mIChfYyA9IHR5cGVvZiBDaGFuZ2VEZXRlY3RvclJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBDaGFuZ2VEZXRlY3RvclJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0XSlcclxuICAgIF0sIEJhc2VDaGFydENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQmFzZUNoYXJ0Q29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIEF4aXNMYWJlbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF4aXNMYWJlbENvbXBvbmVudChlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gMjU7XHJcbiAgICAgICAgdGhpcy5tYXJnaW4gPSA1O1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcclxuICAgIH1cclxuICAgIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQXhpc0xhYmVsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9ICcwLjAxJztcclxuICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnbWlkZGxlJztcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9ICcnO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5vcmllbnQpIHtcclxuICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSAtKHRoaXMub2Zmc2V0ICsgdGhpcy50ZXh0SGVpZ2h0ICsgdGhpcy5tYXJnaW4pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gLXRoaXMuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gJ3JvdGF0ZSgyNzApJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB0aGlzLm9mZnNldCArIHRoaXMubWFyZ2luO1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ID0gLXRoaXMuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gJ3JvdGF0ZSgyNzApJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBeGlzTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXhpc0xhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXhpc0xhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEF4aXNMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XHJcbiAgICBBeGlzTGFiZWxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1heGlzLWxhYmVsXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOnRleHRcXG4gICAgICBbYXR0ci5zdHJva2Utd2lkdGhdPVxcXCJzdHJva2VXaWR0aFxcXCJcXG4gICAgICBbYXR0ci54XT1cXFwieFxcXCJcXG4gICAgICBbYXR0ci55XT1cXFwieVxcXCJcXG4gICAgICBbYXR0ci50ZXh0LWFuY2hvcl09XFxcInRleHRBbmNob3JcXFwiXFxuICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIj5cXG4gICAgICB7e2xhYmVsfX1cXG4gICAgPC9zdmc6dGV4dD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXHJcbiAgICBdLCBBeGlzTGFiZWxDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEF4aXNMYWJlbENvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbmZ1bmN0aW9uIHJlZHVjZVRpY2tzKHRpY2tzLCBtYXhUaWNrcykge1xyXG4gICAgaWYgKHRpY2tzLmxlbmd0aCA+IG1heFRpY2tzKSB7XHJcbiAgICAgICAgdmFyIHJlZHVjZWQgPSBbXTtcclxuICAgICAgICB2YXIgbW9kdWx1cyA9IE1hdGguZmxvb3IodGlja3MubGVuZ3RoIC8gbWF4VGlja3MpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgJSBtb2R1bHVzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZWR1Y2VkLnB1c2godGlja3NbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpY2tzID0gcmVkdWNlZDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aWNrcztcclxufVxyXG5cclxudmFyIFhBeGlzVGlja3NDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBYQXhpc1RpY2tzQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMudGlja0FyZ3VtZW50cyA9IFs1XTtcclxuICAgICAgICB0aGlzLnRpY2tTdHJva2UgPSAnI2NjYyc7XHJcbiAgICAgICAgdGhpcy50cmltVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubWF4VGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIHRoaXMuc2hvd0dyaWRMaW5lcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucm90YXRlVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGltZW5zaW9uc0NoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNhbFNwYWNpbmcgPSAyMDtcclxuICAgICAgICB0aGlzLnJvdGF0ZUxhYmVscyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW5uZXJUaWNrU2l6ZSA9IDY7XHJcbiAgICAgICAgdGhpcy5vdXRlclRpY2tTaXplID0gNjtcclxuICAgICAgICB0aGlzLnRpY2tQYWRkaW5nID0gMztcclxuICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnbWlkZGxlJztcclxuICAgICAgICB0aGlzLm1heFRpY2tzTGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLm1heEFsbG93ZWRMZW5ndGggPSAxNjtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICB9XHJcbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZURpbXMoKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlRGltcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUludCh0aGlzLnRpY2tzRWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCwgMTApO1xyXG4gICAgICAgIGlmIChoZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkLmVtaXQoeyBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGVEaW1zKCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgIHRoaXMudGlja3MgPSB0aGlzLmdldFRpY2tzKCk7XHJcbiAgICAgICAgaWYgKHRoaXMudGlja0Zvcm1hdHRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy50aWNrRm9ybWF0ID0gdGhpcy50aWNrRm9ybWF0dGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2NhbGUudGlja0Zvcm1hdCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpY2tGb3JtYXQgPSBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aGlzLnRpY2tBcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdEYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5yb3RhdGVUaWNrcyA/IHRoaXMuZ2V0Um90YXRpb25BbmdsZSh0aGlzLnRpY2tzKSA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5hZGp1c3RlZFNjYWxlID0gdGhpcy5zY2FsZS5iYW5kd2lkdGhcclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUoZCkgKyB0aGlzLnNjYWxlLmJhbmR3aWR0aCgpICogMC41O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogdGhpcy5zY2FsZTtcclxuICAgICAgICB0aGlzLnRleHRUcmFuc2Zvcm0gPSAnJztcclxuICAgICAgICBpZiAoYW5nbGUgJiYgYW5nbGUgIT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy50ZXh0VHJhbnNmb3JtID0gXCJyb3RhdGUoXCIgKyBhbmdsZSArIFwiKVwiO1xyXG4gICAgICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnZW5kJztcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbFNwYWNpbmcgPSAxMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdtaWRkbGUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZURpbXMoKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0Um90YXRpb25BbmdsZSA9IGZ1bmN0aW9uICh0aWNrcykge1xyXG4gICAgICAgIHZhciBhbmdsZSA9IDA7XHJcbiAgICAgICAgdGhpcy5tYXhUaWNrc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdGljayA9IHRoaXMudGlja0Zvcm1hdCh0aWNrc1tpXSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdmFyIHRpY2tMZW5ndGggPSB0aWNrLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHJpbVRpY2tzKSB7XHJcbiAgICAgICAgICAgICAgICB0aWNrTGVuZ3RoID0gdGhpcy50aWNrVHJpbSh0aWNrKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRpY2tMZW5ndGggPiB0aGlzLm1heFRpY2tzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heFRpY2tzTGVuZ3RoID0gdGlja0xlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4odGhpcy5tYXhUaWNrc0xlbmd0aCwgdGhpcy5tYXhBbGxvd2VkTGVuZ3RoKTtcclxuICAgICAgICB2YXIgY2hhcldpZHRoID0gODsgLy8gbmVlZCB0byBtZWFzdXJlIHRoaXNcclxuICAgICAgICB2YXIgd29yZFdpZHRoID0gbGVuICogY2hhcldpZHRoO1xyXG4gICAgICAgIHZhciBiYXNlV2lkdGggPSB3b3JkV2lkdGg7XHJcbiAgICAgICAgdmFyIG1heEJhc2VXaWR0aCA9IE1hdGguZmxvb3IodGhpcy53aWR0aCAvIHRpY2tzLmxlbmd0aCk7XHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIG9wdGltYWwgYW5nbGVcclxuICAgICAgICB3aGlsZSAoYmFzZVdpZHRoID4gbWF4QmFzZVdpZHRoICYmIGFuZ2xlID4gLTkwKSB7XHJcbiAgICAgICAgICAgIGFuZ2xlIC09IDMwO1xyXG4gICAgICAgICAgICBiYXNlV2lkdGggPSBNYXRoLmNvcyhhbmdsZSAqIChNYXRoLlBJIC8gMTgwKSkgKiB3b3JkV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbmdsZTtcclxuICAgIH07XHJcbiAgICBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUaWNrcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGlja3M7XHJcbiAgICAgICAgdmFyIG1heFRpY2tzID0gdGhpcy5nZXRNYXhUaWNrcygyMCk7XHJcbiAgICAgICAgdmFyIG1heFNjYWxlVGlja3MgPSB0aGlzLmdldE1heFRpY2tzKDEwMCk7XHJcbiAgICAgICAgaWYgKHRoaXMudGlja1ZhbHVlcykge1xyXG4gICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja1ZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZS50aWNrcykge1xyXG4gICAgICAgICAgICB0aWNrcyA9IHRoaXMuc2NhbGUudGlja3MuYXBwbHkodGhpcy5zY2FsZSwgW21heFNjYWxlVGlja3NdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRpY2tzID0gdGhpcy5zY2FsZS5kb21haW4oKTtcclxuICAgICAgICAgICAgdGlja3MgPSByZWR1Y2VUaWNrcyh0aWNrcywgbWF4VGlja3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGlja3M7XHJcbiAgICB9O1xyXG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0TWF4VGlja3MgPSBmdW5jdGlvbiAodGlja1dpZHRoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy53aWR0aCAvIHRpY2tXaWR0aCk7XHJcbiAgICB9O1xyXG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUudGlja1RyYW5zZm9ybSA9IGZ1bmN0aW9uICh0aWNrKSB7XHJcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHRoaXMuYWRqdXN0ZWRTY2FsZSh0aWNrKSArICcsJyArIHRoaXMudmVydGljYWxTcGFjaW5nICsgJyknO1xyXG4gICAgfTtcclxuICAgIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLmdyaWRMaW5lVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgKC10aGlzLnZlcnRpY2FsU3BhY2luZyAtIDUpICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUudGlja1RyaW0gPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmltVGlja3MgPyB0cmltTGFiZWwobGFiZWwsIHRoaXMubWF4VGlja0xlbmd0aCkgOiBsYWJlbDtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwib3JpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrQXJndW1lbnRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tWYWx1ZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tTdHJva2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFRpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmlkTGluZUhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFhBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcImRpbWVuc2lvbnNDaGFuZ2VkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBWaWV3Q2hpbGQoJ3RpY2tzZWwnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrc0VsZW1lbnRcIiwgdm9pZCAwKTtcclxuICAgIFhBeGlzVGlja3NDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy14LWF4aXMtdGlja3NdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyAjdGlja3NlbD5cXG4gICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aWNrc1xcXCIgY2xhc3M9XFxcInRpY2tcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRpY2tUcmFuc2Zvcm0odGljaylcXFwiPlxcbiAgICAgICAgPHRpdGxlPnt7IHRpY2tGb3JtYXQodGljaykgfX08L3RpdGxlPlxcbiAgICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICAgIHN0cm9rZS13aWR0aD1cXFwiMC4wMVxcXCJcXG4gICAgICAgICAgW2F0dHIudGV4dC1hbmNob3JdPVxcXCJ0ZXh0QW5jaG9yXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0ZXh0VHJhbnNmb3JtXFxcIlxcbiAgICAgICAgICBbc3R5bGUuZm9udC1zaXplXT1cXFwiJzEycHgnXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICB7eyB0aWNrVHJpbSh0aWNrRm9ybWF0KHRpY2spKSB9fVxcbiAgICAgICAgPC9zdmc6dGV4dD5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcblxcbiAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aWNrc1xcXCIgW2F0dHIudHJhbnNmb3JtXT1cXFwidGlja1RyYW5zZm9ybSh0aWNrKVxcXCI+XFxuICAgICAgPHN2ZzpnICpuZ0lmPVxcXCJzaG93R3JpZExpbmVzXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJncmlkTGluZVRyYW5zZm9ybSgpXFxcIj5cXG4gICAgICAgIDxzdmc6bGluZSBjbGFzcz1cXFwiZ3JpZGxpbmUtcGF0aCBncmlkbGluZS1wYXRoLXZlcnRpY2FsXFxcIiBbYXR0ci55MV09XFxcIi1ncmlkTGluZUhlaWdodFxcXCIgeTI9XFxcIjBcXFwiIC8+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBYQXhpc1RpY2tzQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBYQXhpc1RpY2tzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIFhBeGlzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gWEF4aXNDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy5yb3RhdGVUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zaG93R3JpZExpbmVzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy54T3JpZW50ID0gJ2JvdHRvbSc7XHJcbiAgICAgICAgdGhpcy54QXhpc09mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLnhBeGlzQ2xhc3NOYW1lID0gJ3ggYXhpcyc7XHJcbiAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5maWxsID0gJ25vbmUnO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlID0gJ3N0cm9rZSc7XHJcbiAgICAgICAgdGhpcy50aWNrU3Ryb2tlID0gJyNjY2MnO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAnbm9uZSc7XHJcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gNTtcclxuICAgIH1cclxuICAgIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoMCxcIiArICh0aGlzLnhBeGlzT2Zmc2V0ICsgdGhpcy5wYWRkaW5nICsgdGhpcy5kaW1zLmhlaWdodCkgKyBcIilcIjtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMueEF4aXNUaWNrQ291bnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlja0FyZ3VtZW50cyA9IFt0aGlzLnhBeGlzVGlja0NvdW50XTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLmVtaXRUaWNrc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICB2YXIgbmV3TGFiZWxPZmZzZXQgPSBoZWlnaHQgKyAyNSArIDU7XHJcbiAgICAgICAgaWYgKG5ld0xhYmVsT2Zmc2V0ICE9PSB0aGlzLmxhYmVsT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFiZWxPZmZzZXQgPSBuZXdMYWJlbE9mZnNldDtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kaW1lbnNpb25zQ2hhbmdlZC5lbWl0KHsgaGVpZ2h0OiBoZWlnaHQgfSk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWEF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0ludGVydmFsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrQ291bnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFhBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4T3JpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNPZmZzZXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltZW5zaW9uc0NoYW5nZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFZpZXdDaGlsZChYQXhpc1RpY2tzQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgWEF4aXNUaWNrc0NvbXBvbmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBYQXhpc1RpY2tzQ29tcG9uZW50KSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja3NDb21wb25lbnRcIiwgdm9pZCAwKTtcclxuICAgIFhBeGlzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMteC1heGlzXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgW2F0dHIuY2xhc3NdPVxcXCJ4QXhpc0NsYXNzTmFtZVxcXCIgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIj5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMteC1heGlzLXRpY2tzXFxuICAgICAgICAqbmdJZj1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1UaWNrc1xcXCJcXG4gICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVRpY2tzXFxcIlxcbiAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwidGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICBbdGlja0FyZ3VtZW50c109XFxcInRpY2tBcmd1bWVudHNcXFwiXFxuICAgICAgICBbdGlja1N0cm9rZV09XFxcInRpY2tTdHJva2VcXFwiXFxuICAgICAgICBbc2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICBbb3JpZW50XT1cXFwieE9yaWVudFxcXCJcXG4gICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgIFtncmlkTGluZUhlaWdodF09XFxcImRpbXMuaGVpZ2h0XFxcIlxcbiAgICAgICAgW3dpZHRoXT1cXFwiZGltcy53aWR0aFxcXCJcXG4gICAgICAgIFt0aWNrVmFsdWVzXT1cXFwidGlja3NcXFwiXFxuICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJlbWl0VGlja3NIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAvPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy1heGlzLWxhYmVsXFxuICAgICAgICAqbmdJZj1cXFwic2hvd0xhYmVsXFxcIlxcbiAgICAgICAgW2xhYmVsXT1cXFwibGFiZWxUZXh0XFxcIlxcbiAgICAgICAgW29mZnNldF09XFxcImxhYmVsT2Zmc2V0XFxcIlxcbiAgICAgICAgW29yaWVudF09XFxcIidib3R0b20nXFxcIlxcbiAgICAgICAgW2hlaWdodF09XFxcImRpbXMuaGVpZ2h0XFxcIlxcbiAgICAgICAgW3dpZHRoXT1cXFwiZGltcy53aWR0aFxcXCJcXG4gICAgICA+PC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBYQXhpc0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gWEF4aXNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgcm91bmRlZCByZWN0YW5nbGFyIHBhdGhcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0geyp9IHgsIHksIHcsIGgsIHIsIHRsLCB0ciwgYmwsIGJyXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiByb3VuZGVkUmVjdCh4LCB5LCB3LCBoLCByLCBfYSkge1xyXG4gICAgdmFyIHRsID0gX2FbMF0sIHRyID0gX2FbMV0sIGJsID0gX2FbMl0sIGJyID0gX2FbM107XHJcbiAgICB2YXIgcmV0dmFsID0gJyc7XHJcbiAgICB3ID0gTWF0aC5mbG9vcih3KTtcclxuICAgIGggPSBNYXRoLmZsb29yKGgpO1xyXG4gICAgdyA9IHcgPT09IDAgPyAxIDogdztcclxuICAgIGggPSBoID09PSAwID8gMSA6IGg7XHJcbiAgICByZXR2YWwgPSBcIk1cIiArIFt4ICsgciwgeV07XHJcbiAgICByZXR2YWwgKz0gXCJoXCIgKyAodyAtIDIgKiByKTtcclxuICAgIGlmICh0cikge1xyXG4gICAgICAgIHJldHZhbCArPSBcImFcIiArIFtyLCByXSArIFwiIDAgMCAxIFwiICsgW3IsIHJdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dmFsICs9IFwiaFwiICsgciArIFwidlwiICsgcjtcclxuICAgIH1cclxuICAgIHJldHZhbCArPSBcInZcIiArIChoIC0gMiAqIHIpO1xyXG4gICAgaWYgKGJyKSB7XHJcbiAgICAgICAgcmV0dmFsICs9IFwiYVwiICsgW3IsIHJdICsgXCIgMCAwIDEgXCIgKyBbLXIsIHJdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dmFsICs9IFwidlwiICsgciArIFwiaFwiICsgLXI7XHJcbiAgICB9XHJcbiAgICByZXR2YWwgKz0gXCJoXCIgKyAoMiAqIHIgLSB3KTtcclxuICAgIGlmIChibCkge1xyXG4gICAgICAgIHJldHZhbCArPSBcImFcIiArIFtyLCByXSArIFwiIDAgMCAxIFwiICsgWy1yLCAtcl07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR2YWwgKz0gXCJoXCIgKyAtciArIFwidlwiICsgLXI7XHJcbiAgICB9XHJcbiAgICByZXR2YWwgKz0gXCJ2XCIgKyAoMiAqIHIgLSBoKTtcclxuICAgIGlmICh0bCkge1xyXG4gICAgICAgIHJldHZhbCArPSBcImFcIiArIFtyLCByXSArIFwiIDAgMCAxIFwiICsgW3IsIC1yXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHZhbCArPSBcInZcIiArIC1yICsgXCJoXCIgKyByO1xyXG4gICAgfVxyXG4gICAgcmV0dmFsICs9IFwielwiO1xyXG4gICAgcmV0dXJuIHJldHZhbDtcclxufVxyXG5cclxudmFyIFlBeGlzVGlja3NDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBZQXhpc1RpY2tzQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMudGlja0FyZ3VtZW50cyA9IFs1XTtcclxuICAgICAgICB0aGlzLnRpY2tTdHJva2UgPSAnI2NjYyc7XHJcbiAgICAgICAgdGhpcy50cmltVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubWF4VGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIHRoaXMuc2hvd0dyaWRMaW5lcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2hvd1JlZkxhYmVscyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2hvd1JlZkxpbmVzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmlubmVyVGlja1NpemUgPSA2O1xyXG4gICAgICAgIHRoaXMudGlja1BhZGRpbmcgPSAzO1xyXG4gICAgICAgIHRoaXMudmVydGljYWxTcGFjaW5nID0gMjA7XHJcbiAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ21pZGRsZSc7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5vdXRlclRpY2tTaXplID0gNjtcclxuICAgICAgICB0aGlzLnJvdGF0ZUxhYmVscyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlTGluZUxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZURpbXMoKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlRGltcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHBhcnNlSW50KHRoaXMudGlja3NFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsIDEwKTtcclxuICAgICAgICBpZiAod2lkdGggIT09IHRoaXMud2lkdGgpIHtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkLmVtaXQoeyB3aWR0aDogd2lkdGggfSk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlRGltcygpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHNjYWxlO1xyXG4gICAgICAgIHZhciBzaWduID0gdGhpcy5vcmllbnQgPT09ICd0b3AnIHx8IHRoaXMub3JpZW50ID09PSAncmlnaHQnID8gLTEgOiAxO1xyXG4gICAgICAgIHRoaXMudGlja1NwYWNpbmcgPSBNYXRoLm1heCh0aGlzLmlubmVyVGlja1NpemUsIDApICsgdGhpcy50aWNrUGFkZGluZztcclxuICAgICAgICBzY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgdGhpcy50aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcclxuICAgICAgICBpZiAodGhpcy50aWNrRm9ybWF0dGluZykge1xyXG4gICAgICAgICAgICB0aGlzLnRpY2tGb3JtYXQgPSB0aGlzLnRpY2tGb3JtYXR0aW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzY2FsZS50aWNrRm9ybWF0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlja0Zvcm1hdCA9IHNjYWxlLnRpY2tGb3JtYXQuYXBwbHkoc2NhbGUsIHRoaXMudGlja0FyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRpY2tGb3JtYXQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQuY29uc3RydWN0b3IubmFtZSA9PT0gJ0RhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkanVzdGVkU2NhbGUgPSBzY2FsZS5iYW5kd2lkdGhcclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlKGQpICsgc2NhbGUuYmFuZHdpZHRoKCkgKiAwLjU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBzY2FsZTtcclxuICAgICAgICBpZiAodGhpcy5zaG93UmVmTGluZXMgJiYgdGhpcy5yZWZlcmVuY2VMaW5lcykge1xyXG4gICAgICAgICAgICB0aGlzLnNldFJlZmVyZW5jZWxpbmVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAodGhpcy5vcmllbnQpIHtcclxuICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gZnVuY3Rpb24gKHRpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgdGhpcy5hZGp1c3RlZFNjYWxlKHRpY2spICsgJywwKSc7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ21pZGRsZSc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkyID0gdGhpcy5pbm5lclRpY2tTaXplICogc2lnbjtcclxuICAgICAgICAgICAgICAgIHRoaXMueTEgPSB0aGlzLnRpY2tTcGFjaW5nICogc2lnbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHkgPSBzaWduIDwgMCA/ICcwZW0nIDogJy43MWVtJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB0aGlzLmFkanVzdGVkU2NhbGUodGljaykgKyAnLDApJztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnbWlkZGxlJztcclxuICAgICAgICAgICAgICAgIHRoaXMueTIgPSB0aGlzLmlubmVyVGlja1NpemUgKiBzaWduO1xyXG4gICAgICAgICAgICAgICAgdGhpcy55MSA9IHRoaXMudGlja1NwYWNpbmcgKiBzaWduO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5keSA9IHNpZ24gPCAwID8gJzBlbScgOiAnLjcxZW0nO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArIHRoaXMuYWRqdXN0ZWRTY2FsZSh0aWNrKSArICcpJztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnZW5kJztcclxuICAgICAgICAgICAgICAgIHRoaXMueDIgPSB0aGlzLmlubmVyVGlja1NpemUgKiAtc2lnbjtcclxuICAgICAgICAgICAgICAgIHRoaXMueDEgPSB0aGlzLnRpY2tTcGFjaW5nICogLXNpZ247XHJcbiAgICAgICAgICAgICAgICB0aGlzLmR5ID0gJy4zMmVtJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0aWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgdGhpcy5hZGp1c3RlZFNjYWxlKHRpY2spICsgJyknO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dEFuY2hvciA9ICdzdGFydCc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLngyID0gdGhpcy5pbm5lclRpY2tTaXplICogLXNpZ247XHJcbiAgICAgICAgICAgICAgICB0aGlzLngxID0gdGhpcy50aWNrU3BhY2luZyAqIC1zaWduO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5keSA9ICcuMzJlbSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGVEaW1zKCk7IH0pO1xyXG4gICAgfTtcclxuICAgIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLnNldFJlZmVyZW5jZWxpbmVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVmTWluID0gdGhpcy5hZGp1c3RlZFNjYWxlKE1hdGgubWluLmFwcGx5KG51bGwsIHRoaXMucmVmZXJlbmNlTGluZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnZhbHVlOyB9KSkpO1xyXG4gICAgICAgIHRoaXMucmVmTWF4ID0gdGhpcy5hZGp1c3RlZFNjYWxlKE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMucmVmZXJlbmNlTGluZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnZhbHVlOyB9KSkpO1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlTGluZUxlbmd0aCA9IHRoaXMucmVmZXJlbmNlTGluZXMubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlQXJlYVBhdGggPSByb3VuZGVkUmVjdCgwLCB0aGlzLnJlZk1heCwgdGhpcy5ncmlkTGluZVdpZHRoLCB0aGlzLnJlZk1pbiAtIHRoaXMucmVmTWF4LCAwLCBbXHJcbiAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgICAgIGZhbHNlXHJcbiAgICAgICAgXSk7XHJcbiAgICB9O1xyXG4gICAgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0VGlja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRpY2tzO1xyXG4gICAgICAgIHZhciBtYXhUaWNrcyA9IHRoaXMuZ2V0TWF4VGlja3MoMjApO1xyXG4gICAgICAgIHZhciBtYXhTY2FsZVRpY2tzID0gdGhpcy5nZXRNYXhUaWNrcyg1MCk7XHJcbiAgICAgICAgaWYgKHRoaXMudGlja1ZhbHVlcykge1xyXG4gICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja1ZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZS50aWNrcykge1xyXG4gICAgICAgICAgICB0aWNrcyA9IHRoaXMuc2NhbGUudGlja3MuYXBwbHkodGhpcy5zY2FsZSwgW21heFNjYWxlVGlja3NdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRpY2tzID0gdGhpcy5zY2FsZS5kb21haW4oKTtcclxuICAgICAgICAgICAgdGlja3MgPSByZWR1Y2VUaWNrcyh0aWNrcywgbWF4VGlja3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGlja3M7XHJcbiAgICB9O1xyXG4gICAgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0TWF4VGlja3MgPSBmdW5jdGlvbiAodGlja0hlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuaGVpZ2h0IC8gdGlja0hlaWdodCk7XHJcbiAgICB9O1xyXG4gICAgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUudGlja1RyYW5zZm9ybSA9IGZ1bmN0aW9uICh0aWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy5hZGp1c3RlZFNjYWxlKHRpY2spICsgXCIsXCIgKyB0aGlzLnZlcnRpY2FsU3BhY2luZyArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLmdyaWRMaW5lVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZSg1LDApXCI7XHJcbiAgICB9O1xyXG4gICAgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUudGlja1RyaW0gPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmltVGlja3MgPyB0cmltTGFiZWwobGFiZWwsIHRoaXMubWF4VGlja0xlbmd0aCkgOiBsYWJlbDtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwib3JpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrQXJndW1lbnRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tWYWx1ZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tTdHJva2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFRpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInRpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmlkTGluZVdpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInJlZmVyZW5jZUxpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1JlZkxhYmVsc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dSZWZMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzVGlja3NDb21wb25lbnQucHJvdG90eXBlLCBcImRpbWVuc2lvbnNDaGFuZ2VkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBWaWV3Q2hpbGQoJ3RpY2tzZWwnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBZQXhpc1RpY2tzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrc0VsZW1lbnRcIiwgdm9pZCAwKTtcclxuICAgIFlBeGlzVGlja3NDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy15LWF4aXMtdGlja3NdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyAjdGlja3NlbD5cXG4gICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aWNrc1xcXCIgY2xhc3M9XFxcInRpY2tcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybSh0aWNrKVxcXCI+XFxuICAgICAgICA8dGl0bGU+e3sgdGlja0Zvcm1hdCh0aWNrKSB9fTwvdGl0bGU+XFxuICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgc3Ryb2tlLXdpZHRoPVxcXCIwLjAxXFxcIlxcbiAgICAgICAgICBbYXR0ci5keV09XFxcImR5XFxcIlxcbiAgICAgICAgICBbYXR0ci54XT1cXFwieDFcXFwiXFxuICAgICAgICAgIFthdHRyLnldPVxcXCJ5MVxcXCJcXG4gICAgICAgICAgW2F0dHIudGV4dC1hbmNob3JdPVxcXCJ0ZXh0QW5jaG9yXFxcIlxcbiAgICAgICAgICBbc3R5bGUuZm9udC1zaXplXT1cXFwiJzEycHgnXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICB7eyB0aWNrVHJpbSh0aWNrRm9ybWF0KHRpY2spKSB9fVxcbiAgICAgICAgPC9zdmc6dGV4dD5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcblxcbiAgICA8c3ZnOnBhdGhcXG4gICAgICAqbmdJZj1cXFwicmVmZXJlbmNlTGluZUxlbmd0aCA+IDEgJiYgcmVmTWF4ICYmIHJlZk1pbiAmJiBzaG93UmVmTGluZXNcXFwiXFxuICAgICAgY2xhc3M9XFxcInJlZmVyZW5jZS1hcmVhXFxcIlxcbiAgICAgIFthdHRyLmRdPVxcXCJyZWZlcmVuY2VBcmVhUGF0aFxcXCJcXG4gICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJncmlkTGluZVRyYW5zZm9ybSgpXFxcIlxcbiAgICAvPlxcbiAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aWNrc1xcXCIgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtKHRpY2spXFxcIj5cXG4gICAgICA8c3ZnOmcgKm5nSWY9XFxcInNob3dHcmlkTGluZXNcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcImdyaWRMaW5lVHJhbnNmb3JtKClcXFwiPlxcbiAgICAgICAgPHN2ZzpsaW5lXFxuICAgICAgICAgICpuZ0lmPVxcXCJvcmllbnQgPT09ICdsZWZ0J1xcXCJcXG4gICAgICAgICAgY2xhc3M9XFxcImdyaWRsaW5lLXBhdGggZ3JpZGxpbmUtcGF0aC1ob3Jpem9udGFsXFxcIlxcbiAgICAgICAgICB4MT1cXFwiMFxcXCJcXG4gICAgICAgICAgW2F0dHIueDJdPVxcXCJncmlkTGluZVdpZHRoXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxzdmc6bGluZVxcbiAgICAgICAgICAqbmdJZj1cXFwib3JpZW50ID09PSAncmlnaHQnXFxcIlxcbiAgICAgICAgICBjbGFzcz1cXFwiZ3JpZGxpbmUtcGF0aCBncmlkbGluZS1wYXRoLWhvcml6b250YWxcXFwiXFxuICAgICAgICAgIHgxPVxcXCIwXFxcIlxcbiAgICAgICAgICBbYXR0ci54Ml09XFxcIi1ncmlkTGluZVdpZHRoXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcblxcbiAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgcmVmTGluZSBvZiByZWZlcmVuY2VMaW5lc1xcXCI+XFxuICAgICAgPHN2ZzpnICpuZ0lmPVxcXCJzaG93UmVmTGluZXNcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybShyZWZMaW5lLnZhbHVlKVxcXCI+XFxuICAgICAgICA8c3ZnOmxpbmVcXG4gICAgICAgICAgY2xhc3M9XFxcInJlZmxpbmUtcGF0aCBncmlkbGluZS1wYXRoLWhvcml6b250YWxcXFwiXFxuICAgICAgICAgIHgxPVxcXCIwXFxcIlxcbiAgICAgICAgICBbYXR0ci54Ml09XFxcImdyaWRMaW5lV2lkdGhcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcImdyaWRMaW5lVHJhbnNmb3JtKClcXFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPHN2ZzpnICpuZ0lmPVxcXCJzaG93UmVmTGFiZWxzXFxcIj5cXG4gICAgICAgICAgPHRpdGxlPnt7IHRpY2tUcmltKHRpY2tGb3JtYXQocmVmTGluZS52YWx1ZSkpIH19PC90aXRsZT5cXG4gICAgICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICAgICAgY2xhc3M9XFxcInJlZmxpbmUtbGFiZWxcXFwiXFxuICAgICAgICAgICAgW2F0dHIuZHldPVxcXCJkeVxcXCJcXG4gICAgICAgICAgICBbYXR0ci55XT1cXFwiLTZcXFwiXFxuICAgICAgICAgICAgW2F0dHIueF09XFxcImdyaWRMaW5lV2lkdGhcXFwiXFxuICAgICAgICAgICAgW2F0dHIudGV4dC1hbmNob3JdPVxcXCJ0ZXh0QW5jaG9yXFxcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAge3sgcmVmTGluZS5uYW1lIH19XFxuICAgICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgWUF4aXNUaWNrc0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gWUF4aXNUaWNrc0NvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBZQXhpc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFlBeGlzQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMuc2hvd0dyaWRMaW5lcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMueU9yaWVudCA9ICdsZWZ0JztcclxuICAgICAgICB0aGlzLnlBeGlzT2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMueUF4aXNDbGFzc05hbWUgPSAneSBheGlzJztcclxuICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gMTU7XHJcbiAgICAgICAgdGhpcy5maWxsID0gJ25vbmUnO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlID0gJyNDQ0MnO1xyXG4gICAgICAgIHRoaXMudGlja1N0cm9rZSA9ICcjQ0NDJztcclxuICAgICAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcclxuICAgICAgICB0aGlzLnBhZGRpbmcgPSA1O1xyXG4gICAgfVxyXG4gICAgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAtKHRoaXMueUF4aXNPZmZzZXQgKyB0aGlzLnBhZGRpbmcpO1xyXG4gICAgICAgIGlmICh0aGlzLnlPcmllbnQgPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgdGhpcy5sYWJlbE9mZnNldCA9IDY1O1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgKHRoaXMub2Zmc2V0ICsgdGhpcy5kaW1zLndpZHRoKSArIFwiICwgMClcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLm9mZnNldCArIFwiICwgMClcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMueUF4aXNUaWNrQ291bnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpY2tBcmd1bWVudHMgPSBbdGhpcy55QXhpc1RpY2tDb3VudF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5lbWl0VGlja3NXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgaWYgKHdpZHRoICE9PSB0aGlzLmxhYmVsT2Zmc2V0ICYmIHRoaXMueU9yaWVudCA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gd2lkdGggKyB0aGlzLmxhYmVsT2Zmc2V0O1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnNDaGFuZ2VkLmVtaXQoeyB3aWR0aDogd2lkdGggfSk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3aWR0aCAhPT0gdGhpcy5sYWJlbE9mZnNldCkge1xyXG4gICAgICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gd2lkdGg7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGltZW5zaW9uc0NoYW5nZWQuZW1pdCh7IHdpZHRoOiB3aWR0aCB9KTtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1UaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFRpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBZQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrSW50ZXJ2YWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tDb3VudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInlPcmllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWZlcmVuY2VMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dSZWZMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgWUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dSZWZMYWJlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc09mZnNldFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1lbnNpb25zQ2hhbmdlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVmlld0NoaWxkKFlBeGlzVGlja3NDb21wb25lbnQsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBZQXhpc1RpY2tzQ29tcG9uZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIFlBeGlzVGlja3NDb21wb25lbnQpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIFlBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrc0NvbXBvbmVudFwiLCB2b2lkIDApO1xyXG4gICAgWUF4aXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy15LWF4aXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBbYXR0ci5jbGFzc109XFxcInlBeGlzQ2xhc3NOYW1lXFxcIiBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXMtdGlja3NcXG4gICAgICAgICpuZ0lmPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVRpY2tzXFxcIlxcbiAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwidGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICBbdGlja0FyZ3VtZW50c109XFxcInRpY2tBcmd1bWVudHNcXFwiXFxuICAgICAgICBbdGlja1ZhbHVlc109XFxcInRpY2tzXFxcIlxcbiAgICAgICAgW3RpY2tTdHJva2VdPVxcXCJ0aWNrU3Ryb2tlXFxcIlxcbiAgICAgICAgW3NjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgW29yaWVudF09XFxcInlPcmllbnRcXFwiXFxuICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICBbZ3JpZExpbmVXaWR0aF09XFxcImRpbXMud2lkdGhcXFwiXFxuICAgICAgICBbcmVmZXJlbmNlTGluZXNdPVxcXCJyZWZlcmVuY2VMaW5lc1xcXCJcXG4gICAgICAgIFtzaG93UmVmTGluZXNdPVxcXCJzaG93UmVmTGluZXNcXFwiXFxuICAgICAgICBbc2hvd1JlZkxhYmVsc109XFxcInNob3dSZWZMYWJlbHNcXFwiXFxuICAgICAgICBbaGVpZ2h0XT1cXFwiZGltcy5oZWlnaHRcXFwiXFxuICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJlbWl0VGlja3NXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgIC8+XFxuXFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLWF4aXMtbGFiZWxcXG4gICAgICAgICpuZ0lmPVxcXCJzaG93TGFiZWxcXFwiXFxuICAgICAgICBbbGFiZWxdPVxcXCJsYWJlbFRleHRcXFwiXFxuICAgICAgICBbb2Zmc2V0XT1cXFwibGFiZWxPZmZzZXRcXFwiXFxuICAgICAgICBbb3JpZW50XT1cXFwieU9yaWVudFxcXCJcXG4gICAgICAgIFtoZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgIFt3aWR0aF09XFxcImRpbXMud2lkdGhcXFwiXFxuICAgICAgPjwvc3ZnOmc+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgWUF4aXNDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFlBeGlzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIEF4ZXNNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBeGVzTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgQXhlc01vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0F4aXNMYWJlbENvbXBvbmVudCwgWEF4aXNDb21wb25lbnQsIFhBeGlzVGlja3NDb21wb25lbnQsIFlBeGlzQ29tcG9uZW50LCBZQXhpc1RpY2tzQ29tcG9uZW50XSxcclxuICAgICAgICAgICAgZXhwb3J0czogW0F4aXNMYWJlbENvbXBvbmVudCwgWEF4aXNDb21wb25lbnQsIFhBeGlzVGlja3NDb21wb25lbnQsIFlBeGlzQ29tcG9uZW50LCBZQXhpc1RpY2tzQ29tcG9uZW50XVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBBeGVzTW9kdWxlKTtcclxuICAgIHJldHVybiBBeGVzTW9kdWxlO1xyXG59KCkpO1xyXG5cclxudmFyIENvbG9ySGVscGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29sb3JIZWxwZXIoc2NoZW1lLCB0eXBlLCBkb21haW4sIGN1c3RvbUNvbG9ycykge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBzY2hlbWUgPSBjb2xvclNldHMuZmluZChmdW5jdGlvbiAoY3MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcy5uYW1lID09PSBzY2hlbWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbG9yRG9tYWluID0gc2NoZW1lLmRvbWFpbjtcclxuICAgICAgICB0aGlzLnNjYWxlVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSBkb21haW47XHJcbiAgICAgICAgdGhpcy5jdXN0b21Db2xvcnMgPSBjdXN0b21Db2xvcnM7XHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMuZ2VuZXJhdGVDb2xvclNjaGVtZShzY2hlbWUsIHR5cGUsIHRoaXMuZG9tYWluKTtcclxuICAgIH1cclxuICAgIENvbG9ySGVscGVyLnByb3RvdHlwZS5nZW5lcmF0ZUNvbG9yU2NoZW1lID0gZnVuY3Rpb24gKHNjaGVtZSwgdHlwZSwgZG9tYWluKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHNjaGVtZSA9IGNvbG9yU2V0cy5maW5kKGZ1bmN0aW9uIChjcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNzLm5hbWUgPT09IHNjaGVtZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb2xvclNjYWxlO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAncXVhbnRpbGUnKSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2NhbGUgPSBzY2FsZVF1YW50aWxlKClcclxuICAgICAgICAgICAgICAgIC5yYW5nZShzY2hlbWUuZG9tYWluKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgY29sb3JTY2FsZSA9IHNjYWxlT3JkaW5hbCgpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2Uoc2NoZW1lLmRvbWFpbilcclxuICAgICAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgLy8gbGluZWFyIHNjaGVtZXMgbXVzdCBoYXZlIGF0IGxlYXN0IDIgY29sb3JzXHJcbiAgICAgICAgICAgIHZhciBjb2xvckRvbWFpbiA9IHNjaGVtZS5kb21haW4uc2xpY2UoKTtcclxuICAgICAgICAgICAgaWYgKGNvbG9yRG9tYWluLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29sb3JEb21haW4ucHVzaChjb2xvckRvbWFpblswXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yRG9tYWluID0gY29sb3JEb21haW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHJhbmdlKDAsIDEsIDEuMCAvIGNvbG9yRG9tYWluLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGNvbG9yU2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKHBvaW50cylcclxuICAgICAgICAgICAgICAgIC5yYW5nZShjb2xvckRvbWFpbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2xvclNjYWxlO1xyXG4gICAgfTtcclxuICAgIENvbG9ySGVscGVyLnByb3RvdHlwZS5nZXRDb2xvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgY2FuIG5vdCBiZSBudWxsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlU2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKHRoaXMuZG9tYWluKVxyXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCAxXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlU2NhbGUodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jdXN0b21Db2xvcnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1c3RvbUNvbG9ycyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlXzEgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB2YXIgZm91bmQgPSB2b2lkIDA7IC8vIHRvZG8gdHlwZSBjdXN0b21Db2xvcnNcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tQ29sb3JzICYmIHRoaXMuY3VzdG9tQ29sb3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdGhpcy5jdXN0b21Db2xvcnMuZmluZChmdW5jdGlvbiAobWFwcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBwaW5nLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZm9ybWF0dGVkVmFsdWVfMS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29sb3JIZWxwZXIucHJvdG90eXBlLmdldExpbmVhckdyYWRpZW50U3RvcHMgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0KSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmRvbWFpblswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlU2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy5kb21haW4pXHJcbiAgICAgICAgICAgIC5yYW5nZShbMCwgMV0pO1xyXG4gICAgICAgIHZhciBjb2xvclZhbHVlU2NhbGUgPSBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMuY29sb3JEb21haW4pXHJcbiAgICAgICAgICAgIC5yYW5nZShbMCwgMV0pO1xyXG4gICAgICAgIHZhciBlbmRDb2xvciA9IHRoaXMuZ2V0Q29sb3IodmFsdWUpO1xyXG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZSBzdG9wc1xyXG4gICAgICAgIHZhciBzdGFydFZhbCA9IHZhbHVlU2NhbGUoc3RhcnQpO1xyXG4gICAgICAgIHZhciBzdGFydENvbG9yID0gdGhpcy5nZXRDb2xvcihzdGFydCk7XHJcbiAgICAgICAgdmFyIGVuZFZhbCA9IHZhbHVlU2NhbGUodmFsdWUpO1xyXG4gICAgICAgIHZhciBpID0gMTtcclxuICAgICAgICB2YXIgY3VycmVudFZhbCA9IHN0YXJ0VmFsO1xyXG4gICAgICAgIHZhciBzdG9wcyA9IFtdO1xyXG4gICAgICAgIHN0b3BzLnB1c2goe1xyXG4gICAgICAgICAgICBjb2xvcjogc3RhcnRDb2xvcixcclxuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydFZhbCxcclxuICAgICAgICAgICAgb3JpZ2luYWxPZmZzZXQ6IHN0YXJ0VmFsLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRWYWwgPCBlbmRWYWwgJiYgaSA8IHRoaXMuY29sb3JEb21haW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3JEb21haW5baV07XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBjb2xvclZhbHVlU2NhbGUoY29sb3IpO1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDw9IHN0YXJ0VmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob2Zmc2V0LnRvRml4ZWQoNCkgPj0gKGVuZFZhbCAtIGNvbG9yVmFsdWVTY2FsZS5iYW5kd2lkdGgoKSkudG9GaXhlZCg0KSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RvcHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRWYWwgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdLm9mZnNldCA8IDEwMCkge1xyXG4gICAgICAgICAgICBzdG9wcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBlbmRDb2xvcixcclxuICAgICAgICAgICAgICAgIG9mZnNldDogZW5kVmFsLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZFZhbCA9PT0gc3RhcnRWYWwpIHtcclxuICAgICAgICAgICAgc3RvcHNbMF0ub2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgc3RvcHNbMV0ub2Zmc2V0ID0gMTAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIHRoZSBvZmZzZXRzIGludG8gcGVyY2VudGFnZXNcclxuICAgICAgICAgICAgaWYgKHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdLm9mZnNldCAhPT0gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHN0b3BzXzEgPSBzdG9wczsgX2kgPCBzdG9wc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gc3RvcHNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcy5vZmZzZXQgPSAoKHMub2Zmc2V0IC0gc3RhcnRWYWwpIC8gKGVuZFZhbCAtIHN0YXJ0VmFsKSkgKiAxMDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0b3BzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb2xvckhlbHBlcjtcclxufSgpKTtcclxuXHJcbnZhciBDaXJjbGVTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDaXJjbGVTZXJpZXNDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3N0YW5kYXJkJztcclxuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYmFyVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmdyYWRpZW50SWQgPSAnZ3JhZCcgKyBpZCgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudEZpbGwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2lyY2xlID0gdGhpcy5nZXRBY3RpdmVDaXJjbGUoKTtcclxuICAgIH07XHJcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldEFjdGl2ZUNpcmNsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBpbmRleEFjdGl2ZURhdGFQb2ludCA9IHRoaXMuZGF0YS5zZXJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQubmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsICYmIF90aGlzLnZpc2libGVWYWx1ZSAmJiBsYWJlbC50b1N0cmluZygpID09PSBfdGhpcy52aXNpYmxlVmFsdWUudG9TdHJpbmcoKSAmJiBkLnZhbHVlICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGluZGV4QWN0aXZlRGF0YVBvaW50ID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBObyB2YWxpZCBwb2ludCBpcyAnYWN0aXZlL2hvdmVyZWQgb3ZlcicgYXQgdGhpcyBtb21lbnQuXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcERhdGFQb2ludFRvQ2lyY2xlKHRoaXMuZGF0YS5zZXJpZXNbaW5kZXhBY3RpdmVEYXRhUG9pbnRdLCBpbmRleEFjdGl2ZURhdGFQb2ludCk7XHJcbiAgICB9O1xyXG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5tYXBEYXRhUG9pbnRUb0NpcmNsZSA9IGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgdmFyIHNlcmllc05hbWUgPSB0aGlzLmRhdGEubmFtZTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBkLnZhbHVlO1xyXG4gICAgICAgIHZhciBsYWJlbCA9IGQubmFtZTtcclxuICAgICAgICB2YXIgdG9vbHRpcExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwpO1xyXG4gICAgICAgIHZhciBjeDtcclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICBjeCA9IHRoaXMueFNjYWxlKGxhYmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIGN4ID0gdGhpcy54U2NhbGUoTnVtYmVyKGxhYmVsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjeCA9IHRoaXMueFNjYWxlKGxhYmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN5ID0gdGhpcy55U2NhbGUodGhpcy50eXBlID09PSAnc3RhbmRhcmQnID8gdmFsdWUgOiBkLmQxKTtcclxuICAgICAgICB2YXIgcmFkaXVzID0gNTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy55U2NhbGUucmFuZ2UoKVswXSAtIGN5O1xyXG4gICAgICAgIHZhciBvcGFjaXR5ID0gMTtcclxuICAgICAgICB2YXIgY29sb3I7XHJcbiAgICAgICAgaWYgKHRoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3N0YW5kYXJkJykge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IHRoaXMuY29sb3JzLmdldENvbG9yKGQuZDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xvciA9IHRoaXMuY29sb3JzLmdldENvbG9yKHNlcmllc05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGQsIHtcclxuICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNOYW1lLFxyXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgIG5hbWU6IGxhYmVsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lczogW1wiY2lyY2xlLWRhdGEtXCIgKyBpXSxcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICBsYWJlbDogbGFiZWwsXHJcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgIGN4OiBjeCxcclxuICAgICAgICAgICAgY3k6IGN5LFxyXG4gICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIHRvb2x0aXBMYWJlbDogdG9vbHRpcExhYmVsLFxyXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXHJcbiAgICAgICAgICAgIHNlcmllc05hbWU6IHNlcmllc05hbWUsXHJcbiAgICAgICAgICAgIGdyYWRpZW50U3RvcHM6IHRoaXMuZ2V0R3JhZGllbnRTdG9wcyhjb2xvciksXHJcbiAgICAgICAgICAgIG1pbjogZC5taW4sXHJcbiAgICAgICAgICAgIG1heDogZC5tYXhcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0VG9vbHRpcFRleHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgdG9vbHRpcExhYmVsID0gX2EudG9vbHRpcExhYmVsLCB2YWx1ZSA9IF9hLnZhbHVlLCBzZXJpZXNOYW1lID0gX2Euc2VyaWVzTmFtZSwgbWluJCQxID0gX2EubWluLCBtYXgkJDEgPSBfYS5tYXg7XHJcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtbGFiZWxcXFwiPlwiICsgc2VyaWVzTmFtZSArIFwiIFxcdTIwMjIgXCIgKyB0b29sdGlwTGFiZWwgKyBcIjwvc3Bhbj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC12YWxcXFwiPlwiICsgdmFsdWUudG9Mb2NhbGVTdHJpbmcoKSArIHRoaXMuZ2V0VG9vbHRpcE1pbk1heFRleHQobWluJCQxLCBtYXgkJDEpICsgXCI8L3NwYW4+XFxuICAgIFwiO1xyXG4gICAgfTtcclxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0VG9vbHRpcE1pbk1heFRleHQgPSBmdW5jdGlvbiAobWluJCQxLCBtYXgkJDEpIHtcclxuICAgICAgICBpZiAobWluJCQxICE9PSB1bmRlZmluZWQgfHwgbWF4JCQxICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcgKCc7XHJcbiAgICAgICAgICAgIGlmIChtaW4kJDEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCQkMSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICfiiaUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG1pbiQkMS50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCQkMSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgLSAnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1heCQkMSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ+KJpCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1heCQkMSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbWF4JCQxLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ICs9ICcpJztcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRHcmFkaWVudFN0b3BzID0gZnVuY3Rpb24gKGNvbG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC4yXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMTAwLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcbiAgICBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5hY3RpdmF0ZUNpcmNsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJhclZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IG5hbWU6IHRoaXMuZGF0YS5uYW1lIH0pO1xyXG4gICAgfTtcclxuICAgIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZGVhY3RpdmF0ZUNpcmNsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmJhclZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNpcmNsZS5vcGFjaXR5ID0gMDtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IG5hbWU6IHRoaXMuZGF0YS5uYW1lIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIENvbG9ySGVscGVyICE9PSBcInVuZGVmaW5lZFwiICYmIENvbG9ySGVscGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2FsZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzaWJsZVZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtY2lyY2xlLXNlcmllc10nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnICpuZ0lmPVxcXCJjaXJjbGVcXFwiPlxcbiAgICAgIDxkZWZzPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtc3ZnLWxpbmVhci1ncmFkaWVudFxcbiAgICAgICAgICBvcmllbnRhdGlvbj1cXFwidmVydGljYWxcXFwiXFxuICAgICAgICAgIFtuYW1lXT1cXFwiZ3JhZGllbnRJZFxcXCJcXG4gICAgICAgICAgW3N0b3BzXT1cXFwiY2lyY2xlLmdyYWRpZW50U3RvcHNcXFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvZGVmcz5cXG4gICAgICA8c3ZnOnJlY3RcXG4gICAgICAgICpuZ0lmPVxcXCJiYXJWaXNpYmxlICYmIHR5cGUgPT09ICdzdGFuZGFyZCdcXFwiXFxuICAgICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgICBbYXR0ci54XT1cXFwiY2lyY2xlLmN4IC0gY2lyY2xlLnJhZGl1c1xcXCJcXG4gICAgICAgIFthdHRyLnldPVxcXCJjaXJjbGUuY3lcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcImNpcmNsZS5yYWRpdXMgKiAyXFxcIlxcbiAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiY2lyY2xlLmhlaWdodFxcXCJcXG4gICAgICAgIFthdHRyLmZpbGxdPVxcXCJncmFkaWVudEZpbGxcXFwiXFxuICAgICAgICBjbGFzcz1cXFwidG9vbHRpcC1iYXJcXFwiXFxuICAgICAgLz5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtY2lyY2xlXFxuICAgICAgICBjbGFzcz1cXFwiY2lyY2xlXFxcIlxcbiAgICAgICAgW2N4XT1cXFwiY2lyY2xlLmN4XFxcIlxcbiAgICAgICAgW2N5XT1cXFwiY2lyY2xlLmN5XFxcIlxcbiAgICAgICAgW3JdPVxcXCJjaXJjbGUucmFkaXVzXFxcIlxcbiAgICAgICAgW2ZpbGxdPVxcXCJjaXJjbGUuY29sb3JcXFwiXFxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiaXNBY3RpdmUoeyBuYW1lOiBjaXJjbGUuc2VyaWVzTmFtZSB9KVxcXCJcXG4gICAgICAgIFtwb2ludGVyRXZlbnRzXT1cXFwiY2lyY2xlLnZhbHVlID09PSAwID8gJ25vbmUnIDogJ2FsbCdcXFwiXFxuICAgICAgICBbZGF0YV09XFxcImNpcmNsZS52YWx1ZVxcXCJcXG4gICAgICAgIFtjbGFzc05hbWVzXT1cXFwiY2lyY2xlLmNsYXNzTmFtZXNcXFwiXFxuICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljayhjaXJjbGUuZGF0YSlcXFwiXFxuICAgICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZUNpcmNsZSgpXFxcIlxcbiAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJkZWFjdGl2YXRlQ2lyY2xlKClcXFwiXFxuICAgICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cXFwiJ3RvcCdcXFwiXFxuICAgICAgICBbdG9vbHRpcFR5cGVdPVxcXCIndG9vbHRpcCdcXFwiXFxuICAgICAgICBbdG9vbHRpcFRpdGxlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogZ2V0VG9vbHRpcFRleHQoY2lyY2xlKVxcXCJcXG4gICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJjaXJjbGUuZGF0YVxcXCJcXG4gICAgICAvPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoMjUwLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQ2lyY2xlU2VyaWVzQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBDaXJjbGVTZXJpZXNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgQ2lyY2xlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2lyY2xlQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQodGhpcy5kYXRhKTtcclxuICAgIH07XHJcbiAgICBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLm9uTW91c2VFbnRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQodGhpcy5kYXRhKTtcclxuICAgIH07XHJcbiAgICBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLm9uTW91c2VMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh0aGlzLmRhdGEpO1xyXG4gICAgfTtcclxuICAgIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lcyA9IEFycmF5LmlzQXJyYXkodGhpcy5jbGFzc05hbWVzKSA/XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lcy5qb2luKCcgJykgOlxyXG4gICAgICAgICAgICAnJztcclxuICAgICAgICB0aGlzLmNsYXNzTmFtZXMgKz0gJ2NpcmNsZSc7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjeFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjeVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcImZpbGxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xhc3NOYW1lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjaXJjbGVPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcInBvaW50ZXJFdmVudHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDaXJjbGVDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignY2xpY2snKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25DbGlja1wiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgQ2lyY2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbk1vdXNlRW50ZXJcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIENpcmNsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUxlYXZlXCIsIG51bGwpO1xyXG4gICAgQ2lyY2xlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtY2lyY2xlXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmNpcmNsZVxcbiAgICAgIFthdHRyLmN4XT1cXFwiY3hcXFwiXFxuICAgICAgW2F0dHIuY3ldPVxcXCJjeVxcXCJcXG4gICAgICBbYXR0ci5yXT1cXFwiclxcXCJcXG4gICAgICBbYXR0ci5maWxsXT1cXFwiZmlsbFxcXCJcXG4gICAgICBbYXR0ci5zdHJva2VdPVxcXCJzdHJva2VcXFwiXFxuICAgICAgW2F0dHIub3BhY2l0eV09XFxcImNpcmNsZU9wYWNpdHlcXFwiXFxuICAgICAgW2F0dHIuY2xhc3NdPVxcXCJjbGFzc05hbWVzXFxcIlxcbiAgICAgIFthdHRyLnBvaW50ZXItZXZlbnRzXT1cXFwicG9pbnRlckV2ZW50c1xcXCJcXG4gICAgLz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBDaXJjbGVDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIENpcmNsZUNvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBHcmlkUGFuZWxDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHcmlkUGFuZWxDb21wb25lbnQoKSB7XHJcbiAgICB9XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHcmlkUGFuZWxDb21wb25lbnQucHJvdG90eXBlLCBcInBhdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdyaWRQYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdyaWRQYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHcmlkUGFuZWxDb21wb25lbnQucHJvdG90eXBlLCBcInhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdyaWRQYW5lbENvbXBvbmVudC5wcm90b3R5cGUsIFwieVwiLCB2b2lkIDApO1xyXG4gICAgR3JpZFBhbmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtZ3JpZC1wYW5lbF0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpyZWN0XFxuICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiaGVpZ2h0XFxcIlxcbiAgICAgIFthdHRyLndpZHRoXT1cXFwid2lkdGhcXFwiXFxuICAgICAgW2F0dHIueF09XFxcInhcXFwiXFxuICAgICAgW2F0dHIueV09XFxcInlcXFwiXFxuICAgICAgc3Ryb2tlPVxcXCJub25lXFxcIlxcbiAgICAgIGNsYXNzPVxcXCJncmlkcGFuZWxcXFwiXFxuICAgIC8+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgR3JpZFBhbmVsQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBHcmlkUGFuZWxDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50KCkge1xyXG4gICAgfVxyXG4gICAgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmdyaWRQYW5lbHMgPSB0aGlzLmdldEdyaWRQYW5lbHMoKTtcclxuICAgIH07XHJcbiAgICBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldEdyaWRQYW5lbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciB4O1xyXG4gICAgICAgICAgICB2YXIgeTtcclxuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdvZGQnO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMub3JpZW50ID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBfdGhpcy54U2NhbGUoZC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbkluZGV4ID0gTnVtYmVyLnBhcnNlSW50KChwb3NpdGlvbiAvIF90aGlzLnhTY2FsZS5zdGVwKCkpLnRvU3RyaW5nKCksIDEwKTtcclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbkluZGV4ICUgMiA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9ICdldmVuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IF90aGlzLnhTY2FsZS5iYW5kd2lkdGgoKSAqIF90aGlzLnhTY2FsZS5wYWRkaW5nSW5uZXIoKTtcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gX3RoaXMueFNjYWxlLmJhbmR3aWR0aCgpICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gX3RoaXMuZGltcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB4ID0gX3RoaXMueFNjYWxlKGQubmFtZSkgLSBvZmZzZXQgLyAyO1xyXG4gICAgICAgICAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMub3JpZW50ID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IF90aGlzLnlTY2FsZShkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uSW5kZXggPSBOdW1iZXIucGFyc2VJbnQoKHBvc2l0aW9uIC8gX3RoaXMueVNjYWxlLnN0ZXAoKSkudG9TdHJpbmcoKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uSW5kZXggJSAyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gJ2V2ZW4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3RoaXMueVNjYWxlLmJhbmR3aWR0aCgpICogX3RoaXMueVNjYWxlLnBhZGRpbmdJbm5lcigpO1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSBfdGhpcy5kaW1zLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gX3RoaXMueVNjYWxlLmJhbmR3aWR0aCgpICsgb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB5ID0gX3RoaXMueVNjYWxlKGQubmFtZSkgLSBvZmZzZXQgLyAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBkLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBjbGFzczogY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgeTogeVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwib3JpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1ncmlkLXBhbmVsLXNlcmllc10nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIG5neC1jaGFydHMtZ3JpZC1wYW5lbCAqbmdGb3I9XFxcImxldCBncmlkUGFuZWwgb2YgZ3JpZFBhbmVsc1xcXCJcXG4gICAgICBbaGVpZ2h0XT1cXFwiZ3JpZFBhbmVsLmhlaWdodFxcXCJcXG4gICAgICBbd2lkdGhdPVxcXCJncmlkUGFuZWwud2lkdGhcXFwiXFxuICAgICAgW3hdPVxcXCJncmlkUGFuZWwueFxcXCJcXG4gICAgICBbeV09XFxcImdyaWRQYW5lbC55XFxcIlxcbiAgICAgIFtjbGFzcy5ncmlkLXBhbmVsXT1cXFwidHJ1ZVxcXCJcXG4gICAgICBbY2xhc3Mub2RkXT1cXFwiZ3JpZFBhbmVsLmNsYXNzID09PSAnb2RkJ1xcXCJcXG4gICAgICBbY2xhc3MuZXZlbl09XFxcImdyaWRQYW5lbC5jbGFzcyA9PT0gJ2V2ZW4nXFxcIj5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBHcmlkUGFuZWxTZXJpZXNDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBTdmdMaW5lYXJHcmFkaWVudENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSAndmVydGljYWwnO1xyXG4gICAgfVxyXG4gICAgU3ZnTGluZWFyR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLngxID0gJzAlJztcclxuICAgICAgICB0aGlzLngyID0gJzAlJztcclxuICAgICAgICB0aGlzLnkxID0gJzAlJztcclxuICAgICAgICB0aGlzLnkyID0gJzAlJztcclxuICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgIHRoaXMueDIgPSAnMTAwJSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICAgICAgdGhpcy55MSA9ICcxMDAlJztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU3ZnTGluZWFyR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTdmdMaW5lYXJHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBTdmdMaW5lYXJHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwic3RvcHNcIiwgdm9pZCAwKTtcclxuICAgIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtc3ZnLWxpbmVhci1ncmFkaWVudF0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpsaW5lYXJHcmFkaWVudFxcbiAgICAgIFtpZF09XFxcIm5hbWVcXFwiXFxuICAgICAgW2F0dHIueDFdPVxcXCJ4MVxcXCJcXG4gICAgICBbYXR0ci55MV09XFxcInkxXFxcIlxcbiAgICAgIFthdHRyLngyXT1cXFwieDJcXFwiXFxuICAgICAgW2F0dHIueTJdPVxcXCJ5MlxcXCI+XFxuICAgICAgPHN2ZzpzdG9wICpuZ0Zvcj1cXFwibGV0IHN0b3Agb2Ygc3RvcHNcXFwiXFxuICAgICAgICBbYXR0ci5vZmZzZXRdPVxcXCJzdG9wLm9mZnNldCArICclJ1xcXCJcXG4gICAgICAgIFtzdHlsZS5zdG9wLWNvbG9yXT1cXFwic3RvcC5jb2xvclxcXCJcXG4gICAgICAgIFtzdHlsZS5zdG9wLW9wYWNpdHldPVxcXCJzdG9wLm9wYWNpdHlcXFwiXFxuICAgICAgLz5cXG4gICAgPC9zdmc6bGluZWFyR3JhZGllbnQ+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgU3ZnTGluZWFyR3JhZGllbnRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFN2Z0xpbmVhckdyYWRpZW50Q29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy5lbmRPcGFjaXR5ID0gMTtcclxuICAgICAgICB0aGlzLmN4ID0gMDtcclxuICAgICAgICB0aGlzLmN5ID0gMDtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwic3RvcHNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9wc0lucHV0IHx8IHRoaXMuc3RvcHNEZWZhdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wc0lucHV0ID0gdmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMuciA9ICczMCUnO1xyXG4gICAgICAgIGlmICgoJ2NvbG9yJyBpbiBjaGFuZ2VzKSB8fFxyXG4gICAgICAgICAgICAoJ3N0YXJ0T3BhY2l0eScgaW4gY2hhbmdlcykgfHxcclxuICAgICAgICAgICAgKCdlbmRPcGFjaXR5JyBpbiBjaGFuZ2VzKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BzRGVmYXVsdCA9IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMuc3RhcnRPcGFjaXR5XHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAxMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5lbmRPcGFjaXR5XHJcbiAgICAgICAgICAgICAgICB9XTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXJ0T3BhY2l0eVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcImVuZE9wYWNpdHlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjeFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQucHJvdG90eXBlLCBcImN5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXHJcbiAgICBdLCBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwic3RvcHNcIiwgbnVsbCk7XHJcbiAgICBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXN2Zy1yYWRpYWwtZ3JhZGllbnRdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6cmFkaWFsR3JhZGllbnRcXG4gICAgICBbaWRdPVxcXCJuYW1lXFxcIlxcbiAgICAgIFthdHRyLmN4XT1cXFwiY3hcXFwiXFxuICAgICAgW2F0dHIuY3ldPVxcXCJjeVxcXCJcXG4gICAgICBbYXR0ci5yXT1cXFwiclxcXCJcXG4gICAgICBncmFkaWVudFVuaXRzPVxcXCJ1c2VyU3BhY2VPblVzZVxcXCI+XFxuICAgICAgPHN2ZzpzdG9wICpuZ0Zvcj1cXFwibGV0IHN0b3Agb2Ygc3RvcHNcXFwiXFxuICAgICAgICBbYXR0ci5vZmZzZXRdPVxcXCJzdG9wLm9mZnNldCArICclJ1xcXCJcXG4gICAgICAgIFtzdHlsZS5zdG9wLWNvbG9yXT1cXFwic3RvcC5jb2xvclxcXCJcXG4gICAgICAgIFtzdHlsZS5zdG9wLW9wYWNpdHldPVxcXCJzdG9wLm9wYWNpdHlcXFwiXFxuICAgICAgLz5cXG4gICAgPC9zdmc6cmFkaWFsR3JhZGllbnQ+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIFRpbWVsaW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGltZWxpbmUoZWxlbWVudCwgY2QpIHtcclxuICAgICAgICB0aGlzLmNkID0gY2Q7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSA1MDtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLm9uRG9tYWluQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBUaW1lbGluZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQnJ1c2goKTtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRpbWVsaW5lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kaW1zID0gdGhpcy5nZXREaW1zKCk7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmRpbXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBvZmZzZXRZID0gdGhpcy52aWV3WzFdIC0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmJydXNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQnJ1c2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZSgwICwgXCIgKyBvZmZzZXRZICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJJZCA9ICdmaWx0ZXInICsgaWQoKS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gXCJ1cmwoI1wiICsgdGhpcy5maWx0ZXJJZCArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9O1xyXG4gICAgVGltZWxpbmUucHJvdG90eXBlLmdldFhEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gcmVzdWx0cy5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKGQubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IFttaW4kJDEsIG1heCQkMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBOdW1iZXIodik7IH0pO1xyXG4gICAgICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IFttaW4kJDEsIG1heCQkMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21haW4gPSB2YWx1ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgVGltZWxpbmUucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2NhbGU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVRpbWUoKVxyXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCB0aGlzLmRpbXMud2lkdGhdKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbih0aGlzLnhEb21haW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuZGltcy53aWR0aF0pXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKHRoaXMueERvbWFpbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVBvaW50KClcclxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcclxuICAgICAgICAgICAgICAgIC5wYWRkaW5nKDAuMSlcclxuICAgICAgICAgICAgICAgIC5kb21haW4odGhpcy54RG9tYWluKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlO1xyXG4gICAgfTtcclxuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5hZGRCcnVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmJydXNoKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMudmlld1swXTtcclxuICAgICAgICB0aGlzLmJydXNoID0gYnJ1c2hYKClcclxuICAgICAgICAgICAgLmV4dGVudChbWzAsIDBdLCBbd2lkdGgsIGhlaWdodF1dKVxyXG4gICAgICAgICAgICAub24oJ2JydXNoIGVuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGV2ZW50LnNlbGVjdGlvbiB8fCBfdGhpcy54U2NhbGUucmFuZ2UoKTtcclxuICAgICAgICAgICAgdmFyIG5ld0RvbWFpbiA9IHNlbGVjdGlvbi5tYXAoX3RoaXMueFNjYWxlLmludmVydCk7XHJcbiAgICAgICAgICAgIF90aGlzLm9uRG9tYWluQ2hhbmdlLmVtaXQobmV3RG9tYWluKTtcclxuICAgICAgICAgICAgX3RoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2VsZWN0KHRoaXMuZWxlbWVudClcclxuICAgICAgICAgICAgLnNlbGVjdCgnLmJydXNoJylcclxuICAgICAgICAgICAgLmNhbGwodGhpcy5icnVzaCk7XHJcbiAgICB9O1xyXG4gICAgVGltZWxpbmUucHJvdG90eXBlLnVwZGF0ZUJydXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5icnVzaClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnZpZXdbMF07XHJcbiAgICAgICAgdGhpcy5icnVzaC5leHRlbnQoW1swLCAwXSwgW3dpZHRoLCBoZWlnaHRdXSk7XHJcbiAgICAgICAgc2VsZWN0KHRoaXMuZWxlbWVudClcclxuICAgICAgICAgICAgLnNlbGVjdCgnLmJydXNoJylcclxuICAgICAgICAgICAgLmNhbGwodGhpcy5icnVzaCk7XHJcbiAgICAgICAgc2VsZWN0KHRoaXMuZWxlbWVudCkuc2VsZWN0KCcuc2VsZWN0aW9uJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9O1xyXG4gICAgVGltZWxpbmUucHJvdG90eXBlLmdldERpbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy52aWV3WzBdO1xyXG4gICAgICAgIHZhciBkaW1zID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBkaW1zO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUaW1lbGluZS5wcm90b3R5cGUsIFwidmlld1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcInN0YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUaW1lbGluZS5wcm90b3R5cGUsIFwicmVzdWx0c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcInNjaGVtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcImN1c3RvbUNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcIm1pbmlDaGFydFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcImF1dG9TY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcInNjYWxlVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgVGltZWxpbmUucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRpbWVsaW5lLnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUaW1lbGluZS5wcm90b3R5cGUsIFwib25Eb21haW5DaGFuZ2VcIiwgdm9pZCAwKTtcclxuICAgIFRpbWVsaW5lID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtdGltZWxpbmVdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6Z1xcbiAgICAgIGNsYXNzPVxcXCJ0aW1lbGluZVxcXCJcXG4gICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiPlxcbiAgICAgIDxzdmc6ZmlsdGVyIFthdHRyLmlkXT1cXFwiZmlsdGVySWRcXFwiPlxcbiAgICAgICAgPHN2ZzpmZUNvbG9yTWF0cml4IGluPVxcXCJTb3VyY2VHcmFwaGljXFxcIlxcbiAgICAgICAgICAgIHR5cGU9XFxcIm1hdHJpeFxcXCJcXG4gICAgICAgICAgICB2YWx1ZXM9XFxcIjAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAgMCAwIDEgMFxcXCIgLz5cXG4gICAgICA8L3N2ZzpmaWx0ZXI+XFxuICAgICAgPHN2ZzpnIGNsYXNzPVxcXCJlbWJlZGRlZC1jaGFydFxcXCI+XFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgICA8c3ZnOnJlY3QgeD1cXFwiMFxcXCJcXG4gICAgICAgIFthdHRyLndpZHRoXT1cXFwidmlld1swXVxcXCJcXG4gICAgICAgIHk9XFxcIjBcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJoZWlnaHRcXFwiXFxuICAgICAgICBjbGFzcz1cXFwiYnJ1c2gtYmFja2dyb3VuZFxcXCJcXG4gICAgICAvPlxcbiAgICAgIDxzdmc6ZyBjbGFzcz1cXFwiYnJ1c2hcXFwiPjwvc3ZnOmc+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIudGltZWxpbmUgLmJydXNoLWJhY2tncm91bmR7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9LnRpbWVsaW5lIC5icnVzaCAuc2VsZWN0aW9ue2ZpbGw6cmdiYSgwLDAsMCwuMSk7c3Ryb2tlLXdpZHRoOjFweDtzdHJva2U6Izg4OH0udGltZWxpbmUgLmJydXNoIC5oYW5kbGV7ZmlsbC1vcGFjaXR5OjB9LnRpbWVsaW5lIC5lbWJlZGRlZC1jaGFydHtvcGFjaXR5Oi42fVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QsIHR5cGVvZiAoX2IgPSB0eXBlb2YgQ2hhbmdlRGV0ZWN0b3JSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgQ2hhbmdlRGV0ZWN0b3JSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdF0pXHJcbiAgICBdLCBUaW1lbGluZSk7XHJcbiAgICByZXR1cm4gVGltZWxpbmU7XHJcbn0oKSk7XHJcblxyXG52YXIgQXJlYUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFyZWFDb21wb25lbnQoZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5zdGFydE9wYWNpdHkgPSAwLjU7XHJcbiAgICAgICAgdGhpcy5lbmRPcGFjaXR5ID0gMTtcclxuICAgICAgICB0aGlzLmdyYWRpZW50ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcclxuICAgIH1cclxuICAgIEFyZWFDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnRJZCA9ICdncmFkJyArIGlkKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmdyYWRpZW50RmlsbCA9IFwidXJsKCNcIiArIHRoaXMuZ3JhZGllbnRJZCArIFwiKVwiO1xyXG4gICAgICAgIGlmICh0aGlzLmdyYWRpZW50IHx8IHRoaXMuc3RvcHMpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdGhpcy5nZXRHcmFkaWVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzR3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVQYXRoRWwoKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ29tcG9uZW50LnByb3RvdHlwZS5sb2FkQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXJlYVBhdGggPSB0aGlzLnN0YXJ0aW5nUGF0aDtcclxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudXBkYXRlLmJpbmQodGhpcyksIDEwMCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlUGF0aEVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub2RlID0gc2VsZWN0KHRoaXMuZWxlbWVudCkuc2VsZWN0KCcuYXJlYScpO1xyXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbnMpIHtcclxuICAgICAgICAgICAgbm9kZS50cmFuc2l0aW9uKCkuZHVyYXRpb24oNzUwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5hdHRyKCdkJywgdGhpcy5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JhZGllbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmZpbGwsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLnN0YXJ0T3BhY2l0eVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwMCxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmZpbGwsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLmVuZE9wYWNpdHlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGF0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRpbmdQYXRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydE9wYWNpdHlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImVuZE9wYWNpdHlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RvcHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBBcmVhQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtYXJlYV0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpkZWZzICpuZ0lmPVxcXCJncmFkaWVudFxcXCI+XFxuICAgICAgPHN2ZzpnIG5neC1jaGFydHMtc3ZnLWxpbmVhci1ncmFkaWVudFxcbiAgICAgICAgb3JpZW50YXRpb249XFxcInZlcnRpY2FsXFxcIlxcbiAgICAgICAgW25hbWVdPVxcXCJncmFkaWVudElkXFxcIlxcbiAgICAgICAgW3N0b3BzXT1cXFwiZ3JhZGllbnRTdG9wc1xcXCJcXG4gICAgICAvPlxcbiAgICA8L3N2ZzpkZWZzPlxcbiAgICA8c3ZnOnBhdGhcXG4gICAgICBjbGFzcz1cXFwiYXJlYVxcXCJcXG4gICAgICBbYXR0ci5kXT1cXFwiYXJlYVBhdGhcXFwiXFxuICAgICAgW2F0dHIuZmlsbF09XFxcImdyYWRpZW50ID8gZ3JhZGllbnRGaWxsIDogZmlsbFxcXCJcXG4gICAgICBbc3R5bGUub3BhY2l0eV09XFxcIm9wYWNpdHlcXFwiXFxuICAgIC8+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxyXG4gICAgXSwgQXJlYUNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQXJlYUNvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbi8vIElmIHdlIGRvbid0IGNoZWNrIHdoZXRoZXIgJ3dpbmRvdycgYW5kICdnbG9iYWwnIHZhcmlhYmxlcyBhcmUgZGVmaW5lZCxcclxuLy8gY29kZSB3aWxsIGZhaWwgaW4gYnJvd3Nlci9ub2RlIHdpdGggJ3ZhcmlhYmxlIGlzIHVuZGVmaW5lZCcgZXJyb3IuXHJcbnZhciByb290O1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJvb3QgPSB3aW5kb3c7XHJcbn1cclxuZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJvb3QgPSBnbG9iYWw7XHJcbn1cclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcclxudmFyIE1vdXNlRXZlbnQgPSByb290Lk1vdXNlRXZlbnQ7XHJcbmZ1bmN0aW9uIGNyZWF0ZU1vdXNlRXZlbnQobmFtZSwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xyXG4gICAgaWYgKGJ1YmJsZXMgPT09IHZvaWQgMCkgeyBidWJibGVzID0gZmFsc2U7IH1cclxuICAgIGlmIChjYW5jZWxhYmxlID09PSB2b2lkIDApIHsgY2FuY2VsYWJsZSA9IHRydWU7IH1cclxuICAgIC8vIENhbGxpbmcgbmV3IG9mIGFuIGV2ZW50IGRvZXMgbm90IHdvcmsgY29ycmVjdGx5IG9uIElFLiBUaGUgZm9sbG93aW5nIGlzIGEgdGVzdGVkIHdvcmthcm91bmRcclxuICAgIC8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzE3Njk4My9kaXNwYXRjaGV2ZW50LW5vdC13b3JraW5nLWluLWllMTFcclxuICAgIGlmICh0eXBlb2YgKE1vdXNlRXZlbnQpID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gU2FuZSBicm93c2Vyc1xyXG4gICAgICAgIHJldHVybiBuZXcgTW91c2VFdmVudChuYW1lLCB7IGJ1YmJsZXM6IGJ1YmJsZXMsIGNhbmNlbGFibGU6IGNhbmNlbGFibGUgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBJRVxyXG4gICAgICAgIHZhciBldmVudCQkMSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XHJcbiAgICAgICAgZXZlbnQkJDEuaW5pdEV2ZW50KG5hbWUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xyXG4gICAgICAgIHJldHVybiBldmVudCQkMTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIFRvb2x0aXBBcmVhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVG9vbHRpcEFyZWEoKSB7XHJcbiAgICAgICAgdGhpcy5hbmNob3JPcGFjaXR5ID0gMDtcclxuICAgICAgICB0aGlzLmFuY2hvclBvcyA9IC0xO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yVmFsdWVzID0gW107XHJcbiAgICAgICAgdGhpcy5zaG93UGVyY2VudGFnZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ob3ZlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIFRvb2x0aXBBcmVhLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoeFZhbCkge1xyXG4gICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IGdyb3VwLnNlcmllcy5maW5kKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUudG9TdHJpbmcoKSA9PT0geFZhbC50b1N0cmluZygpOyB9KTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwTmFtZSA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgICAgIGlmIChncm91cE5hbWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cE5hbWUgPSBncm91cE5hbWUudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBpdGVtLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1BlcmNlbnRhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSAoaXRlbS5kMSAtIGl0ZW0uZDApLnRvRml4ZWQoMikgKyAnJSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcnMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmQxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBpdGVtLmQxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHRoaXMuY29sb3JzLmdldENvbG9yKHYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcihncm91cC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBncm91cE5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluOiBpdGVtLm1pbixcclxuICAgICAgICAgICAgICAgICAgICBtYXg6IGl0ZW0ubWF4LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9O1xyXG4gICAgVG9vbHRpcEFyZWEucHJvdG90eXBlLm1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCQkMSkge1xyXG4gICAgICAgIHZhciB4UG9zID0gZXZlbnQkJDEucGFnZVggLSBldmVudCQkMS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcclxuICAgICAgICB2YXIgY2xvc2VzdEluZGV4ID0gdGhpcy5maW5kQ2xvc2VzdFBvaW50SW5kZXgoeFBvcyk7XHJcbiAgICAgICAgdmFyIGNsb3Nlc3RQb2ludCA9IHRoaXMueFNldFtjbG9zZXN0SW5kZXhdO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yUG9zID0gdGhpcy54U2NhbGUoY2xvc2VzdFBvaW50KTtcclxuICAgICAgICB0aGlzLmFuY2hvclBvcyA9IE1hdGgubWF4KDAsIHRoaXMuYW5jaG9yUG9zKTtcclxuICAgICAgICB0aGlzLmFuY2hvclBvcyA9IE1hdGgubWluKHRoaXMuZGltcy53aWR0aCwgdGhpcy5hbmNob3JQb3MpO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yVmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoY2xvc2VzdFBvaW50KTtcclxuICAgICAgICBpZiAodGhpcy5hbmNob3JQb3MgIT09IHRoaXMubGFzdEFuY2hvclBvcykge1xyXG4gICAgICAgICAgICB2YXIgZXYgPSBjcmVhdGVNb3VzZUV2ZW50KCdtb3VzZWxlYXZlJyk7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcEFuY2hvci5uYXRpdmVFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLmFuY2hvck9wYWNpdHkgPSAwLjc7XHJcbiAgICAgICAgICAgIHRoaXMuaG92ZXIuZW1pdCh7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2xvc2VzdFBvaW50XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnNob3dUb29sdGlwKCk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEFuY2hvclBvcyA9IHRoaXMuYW5jaG9yUG9zO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sdGlwQXJlYS5wcm90b3R5cGUuZmluZENsb3Nlc3RQb2ludEluZGV4ID0gZnVuY3Rpb24gKHhQb3MpIHtcclxuICAgICAgICB2YXIgbWluSW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBtYXhJbmRleCA9IHRoaXMueFNldC5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBtaW5EaWZmID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICB2YXIgY2xvc2VzdEluZGV4ID0gMDtcclxuICAgICAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9ICgobWluSW5kZXggKyBtYXhJbmRleCkgLyAyKSB8IDA7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RWxlbWVudCA9IHRoaXMueFNjYWxlKHRoaXMueFNldFtjdXJyZW50SW5kZXhdKTtcclxuICAgICAgICAgICAgdmFyIGN1ckRpZmYgPSBNYXRoLmFicyhjdXJyZW50RWxlbWVudCAtIHhQb3MpO1xyXG4gICAgICAgICAgICBpZiAoY3VyRGlmZiA8IG1pbkRpZmYpIHtcclxuICAgICAgICAgICAgICAgIG1pbkRpZmYgPSBjdXJEaWZmO1xyXG4gICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gY3VycmVudEluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50RWxlbWVudCA8IHhQb3MpIHtcclxuICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50RWxlbWVudCA+IHhQb3MpIHtcclxuICAgICAgICAgICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1pbkRpZmYgPSAwO1xyXG4gICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gY3VycmVudEluZGV4O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RJbmRleDtcclxuICAgIH07XHJcbiAgICBUb29sdGlwQXJlYS5wcm90b3R5cGUuc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50JCQxID0gY3JlYXRlTW91c2VFdmVudCgnbW91c2VlbnRlcicpO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcEFuY2hvci5uYXRpdmVFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQkJDEpO1xyXG4gICAgfTtcclxuICAgIFRvb2x0aXBBcmVhLnByb3RvdHlwZS5oaWRlVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXZlbnQkJDEgPSBjcmVhdGVNb3VzZUV2ZW50KCdtb3VzZWxlYXZlJyk7XHJcbiAgICAgICAgdGhpcy50b29sdGlwQW5jaG9yLm5hdGl2ZUVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCQkMSk7XHJcbiAgICAgICAgdGhpcy5hbmNob3JPcGFjaXR5ID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RBbmNob3JQb3MgPSAtMTtcclxuICAgIH07XHJcbiAgICBUb29sdGlwQXJlYS5wcm90b3R5cGUuZ2V0VG9vbFRpcFRleHQgPSBmdW5jdGlvbiAodG9vbHRpcEl0ZW0pIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgaWYgKHRvb2x0aXBJdGVtLnNlcmllcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSB0b29sdGlwSXRlbS5zZXJpZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gJz8/Pyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCArPSAnOiAnO1xyXG4gICAgICAgIGlmICh0b29sdGlwSXRlbS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSB0b29sdGlwSXRlbS52YWx1ZS50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9vbHRpcEl0ZW0ubWluICE9PSB1bmRlZmluZWQgfHwgdG9vbHRpcEl0ZW0ubWF4ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICcgKCc7XHJcbiAgICAgICAgICAgIGlmICh0b29sdGlwSXRlbS5taW4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBJdGVtLm1heCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICfiiaUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRvb2x0aXBJdGVtLm1pbi50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBJdGVtLm1heCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgLSAnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvb2x0aXBJdGVtLm1heCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ+KJpCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRvb2x0aXBJdGVtLm1heCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdG9vbHRpcEl0ZW0ubWF4LnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ICs9ICcpJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcEFyZWEucHJvdG90eXBlLCBcInhTZXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBBcmVhLnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBBcmVhLnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBBcmVhLnByb3RvdHlwZSwgXCJyZXN1bHRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVG9vbHRpcEFyZWEucHJvdG90eXBlLCBcInNob3dQZXJjZW50YWdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVG9vbHRpcEFyZWEucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgVG9vbHRpcEFyZWEucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRvb2x0aXBBcmVhLnByb3RvdHlwZSwgXCJob3ZlclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVmlld0NoaWxkKCd0b29sdGlwQW5jaG9yJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUb29sdGlwQXJlYS5wcm90b3R5cGUsIFwidG9vbHRpcEFuY2hvclwiLCB2b2lkIDApO1xyXG4gICAgVG9vbHRpcEFyZWEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy10b29sdGlwLWFyZWFdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6Zz5cXG4gICAgICA8c3ZnOnJlY3RcXG4gICAgICAgIGNsYXNzPVxcXCJ0b29sdGlwLWFyZWFcXFwiXFxuICAgICAgICBbYXR0ci54XT1cXFwiMFxcXCJcXG4gICAgICAgIHk9XFxcIjBcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcImRpbXMud2lkdGhcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgIHN0eWxlPVxcXCJvcGFjaXR5OiAwOyBjdXJzb3I6ICdhdXRvJztcXFwiXFxuICAgICAgICAobW91c2Vtb3ZlKT1cXFwibW91c2VNb3ZlKCRldmVudClcXFwiXFxuICAgICAgICAobW91c2VsZWF2ZSk9XFxcImhpZGVUb29sdGlwKClcXFwiXFxuICAgICAgLz5cXG4gICAgICA8eGh0bWw6bmctdGVtcGxhdGUgI2RlZmF1bHRUb29sdGlwVGVtcGxhdGUgbGV0LW1vZGVsPVxcXCJtb2RlbFxcXCI+XFxuICAgICAgICA8eGh0bWw6ZGl2IGNsYXNzPVxcXCJhcmVhLXRvb2x0aXAtY29udGFpbmVyXFxcIj5cXG4gICAgICAgICAgPHhodG1sOmRpdiAqbmdGb3I9XFxcImxldCB0b29sdGlwSXRlbSBvZiBtb2RlbFxcXCIgY2xhc3M9XFxcInRvb2x0aXAtaXRlbVxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtaXRlbS1jb2xvclxcXCIgW3N0eWxlLmJhY2tncm91bmQtY29sb3JdPVxcXCJ0b29sdGlwSXRlbS5jb2xvclxcXCI+IDwvc3Bhbj5cXG4gICAgICAgICAgICB7eyBnZXRUb29sVGlwVGV4dCh0b29sdGlwSXRlbSkgfX1cXG4gICAgICAgICAgPC94aHRtbDpkaXY+XFxuICAgICAgICA8L3hodG1sOmRpdj5cXG4gICAgICA8L3hodG1sOm5nLXRlbXBsYXRlPlxcbiAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgI3Rvb2x0aXBBbmNob3JcXG4gICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCJhbmNob3JPcGFjaXR5ICE9PSAwID8gJ2FjdGl2ZScgOiAnaW5hY3RpdmUnXFxcIlxcbiAgICAgICAgY2xhc3M9XFxcInRvb2x0aXAtYW5jaG9yXFxcIlxcbiAgICAgICAgW2F0dHIueF09XFxcImFuY2hvclBvc1xcXCJcXG4gICAgICAgIHk9XFxcIjBcXFwiXFxuICAgICAgICBbYXR0ci53aWR0aF09XFxcIjFcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJkaW1zLmhlaWdodFxcXCJcXG4gICAgICAgIFtzdHlsZS5vcGFjaXR5XT1cXFwiYW5jaG9yT3BhY2l0eVxcXCJcXG4gICAgICAgIFtzdHlsZS5wb2ludGVyLWV2ZW50c109XFxcIidub25lJ1xcXCJcXG4gICAgICAgIG5neC10b29sdGlwXFxuICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBQbGFjZW1lbnRdPVxcXCIncmlnaHQnXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwiJ3Rvb2x0aXAnXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBTcGFjaW5nXT1cXFwiMTVcXFwiXFxuICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdG9vbHRpcFRlbXBsYXRlIDogZGVmYXVsdFRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImFuY2hvclZhbHVlc1xcXCJcXG4gICAgICAgIFt0b29sdGlwSW1tZWRpYXRlRXhpdF09XFxcInRydWVcXFwiXFxuICAgICAgLz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignaW5hY3RpdmUgPT4gYWN0aXZlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAwLjcgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSksXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignYWN0aXZlID0+IGluYWN0aXZlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoMjUwLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgVG9vbHRpcEFyZWEpO1xyXG4gICAgcmV0dXJuIFRvb2x0aXBBcmVhO1xyXG59KCkpO1xyXG5cclxuLy8gUm9iZXJ0IFBlbm5lcidzIGVhc2VPdXRFeHBvXHJcbmZ1bmN0aW9uIGVhc2VPdXRFeHBvKHQsIGIsIGMsIGQpIHtcclxuICAgIHJldHVybiAoYyAqICgtTWF0aC5wb3coMiwgKC0xMCAqIHQpIC8gZCkgKyAxKSAqIDEwMjQpIC8gMTAyMyArIGI7XHJcbn1cclxuLyoqXHJcbiAqIENvdW50cyBmcm9tIGEgbnVtYmVyIHRvIHRoZSBlbmQgaW5jcmVtZW50YWxseS5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge2FueX0gY291bnRGcm9tXHJcbiAqIEBwYXJhbSB7YW55fSBjb3VudFRvXHJcbiAqIEBwYXJhbSB7YW55fSBjb3VudERlY2ltYWxzXHJcbiAqIEBwYXJhbSB7YW55fSBjb3VudER1cmF0aW9uXHJcbiAqIEBwYXJhbSB7YW55fSBjYWxsYmFja1xyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZnVuY3Rpb24gY291bnQoY291bnRGcm9tLCBjb3VudFRvLCBjb3VudERlY2ltYWxzLCBjb3VudER1cmF0aW9uLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHN0YXJ0VmFsID0gTnVtYmVyKGNvdW50RnJvbSk7XHJcbiAgICB2YXIgZW5kVmFsID0gTnVtYmVyKGNvdW50VG8pO1xyXG4gICAgdmFyIGNvdW50RG93biA9IHN0YXJ0VmFsID4gZW5kVmFsO1xyXG4gICAgdmFyIGRlY2ltYWxzID0gTWF0aC5tYXgoMCwgY291bnREZWNpbWFscyk7XHJcbiAgICB2YXIgZGVjID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcclxuICAgIHZhciBkdXJhdGlvbiA9IE51bWJlcihjb3VudER1cmF0aW9uKSAqIDEwMDA7XHJcbiAgICB2YXIgc3RhcnRUaW1lO1xyXG4gICAgZnVuY3Rpb24gcnVuQ291bnQodGltZXN0YW1wKSB7XHJcbiAgICAgICAgdmFyIGZyYW1lVmFsO1xyXG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHRpbWVzdGFtcCAtIHN0YXJ0VGltZTtcclxuICAgICAgICBpZiAoY291bnREb3duKSB7XHJcbiAgICAgICAgICAgIGZyYW1lVmFsID0gc3RhcnRWYWwgLSBlYXNlT3V0RXhwbyhwcm9ncmVzcywgMCwgc3RhcnRWYWwgLSBlbmRWYWwsIGR1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZyYW1lVmFsID0gZWFzZU91dEV4cG8ocHJvZ3Jlc3MsIHN0YXJ0VmFsLCBlbmRWYWwgLSBzdGFydFZhbCwgZHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY291bnREb3duKSB7XHJcbiAgICAgICAgICAgIGZyYW1lVmFsID0gZnJhbWVWYWwgPCBlbmRWYWwgPyBlbmRWYWwgOiBmcmFtZVZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZyYW1lVmFsID0gZnJhbWVWYWwgPiBlbmRWYWwgPyBlbmRWYWwgOiBmcmFtZVZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnJhbWVWYWwgPSBNYXRoLnJvdW5kKGZyYW1lVmFsICogZGVjKSAvIGRlYztcclxuICAgICAgICB2YXIgdGljayA9IHByb2dyZXNzIDwgZHVyYXRpb247XHJcbiAgICAgICAgY2FsbGJhY2soe1xyXG4gICAgICAgICAgICB2YWx1ZTogZnJhbWVWYWwsXHJcbiAgICAgICAgICAgIHByb2dyZXNzOiBwcm9ncmVzcyxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXHJcbiAgICAgICAgICAgIGZpbmlzaGVkOiAhdGlja1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gcnVuQ291bnQodmFsKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAodGltZXN0YW1wKSB7XHJcbiAgICAgICAgc3RhcnRUaW1lID0gdGltZXN0YW1wO1xyXG4gICAgICAgIHJldHVybiBydW5Db3VudCh0aW1lc3RhbXApO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIERldGVybWluZSBkZWNpbWFscyBwbGFjZXNcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge2FueX0gY291bnRUb1xyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZnVuY3Rpb24gZGVjaW1hbENoZWNrZXIoY291bnRUbykge1xyXG4gICAgdmFyIGVuZFZhbCA9IE51bWJlcihjb3VudFRvKTtcclxuICAgIGlmIChlbmRWYWwgJSAxICE9PSAwICYmIE1hdGguYWJzKGVuZFZhbCkgPD0gMTApIHtcclxuICAgICAgICByZXR1cm4gMjtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcblxyXG4vKipcclxuICogQ291bnQgdXAgY29tcG9uZW50XHJcbiAqXHJcbiAqIExvb3NlbHkgaW5zcGlyZWQgYnk6XHJcbiAqICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9penVwZXQvYW5ndWxhcjItY291bnRvXHJcbiAqICAtIGh0dHBzOi8vaW5vcmdhbmlrLmdpdGh1Yi5pby9jb3VudFVwLmpzL1xyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBjbGFzcyBDb3VudFVwRGlyZWN0aXZlXHJcbiAqL1xyXG52YXIgQ291bnRVcERpcmVjdGl2ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvdW50VXBEaXJlY3RpdmUoY2QsIGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmNkID0gY2Q7XHJcbiAgICAgICAgdGhpcy5jb3VudER1cmF0aW9uID0gMTtcclxuICAgICAgICB0aGlzLmNvdW50UHJlZml4ID0gJyc7XHJcbiAgICAgICAgdGhpcy5jb3VudFN1ZmZpeCA9ICcnO1xyXG4gICAgICAgIHRoaXMuY291bnRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5jb3VudEZpbmlzaCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gJyc7XHJcbiAgICAgICAgdGhpcy5fY291bnREZWNpbWFscyA9IDA7XHJcbiAgICAgICAgdGhpcy5fY291bnRUbyA9IDA7XHJcbiAgICAgICAgdGhpcy5fY291bnRGcm9tID0gMDtcclxuICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnREZWNpbWFsc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudERlY2ltYWxzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50RGVjaW1hbHM7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsQ2hlY2tlcih0aGlzLmNvdW50VG8pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvdW50RGVjaW1hbHMgPSB2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnRUb1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb3VudFRvO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvdW50VG8gPSBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb3VudEZyb21cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY291bnRGcm9tO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvdW50RnJvbSA9IHBhcnNlRmxvYXQodmFsKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25SZXEpO1xyXG4gICAgfTtcclxuICAgIENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25SZXEpO1xyXG4gICAgICAgIHZhciB2YWx1ZUZvcm1hdHRpbmcgPSB0aGlzLnZhbHVlRm9ybWF0dGluZyB8fCAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBcIlwiICsgX3RoaXMuY291bnRQcmVmaXggKyB2YWx1ZS50b0xvY2FsZVN0cmluZygpICsgX3RoaXMuY291bnRTdWZmaXg7IH0pO1xyXG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgcHJvZ3Jlc3MgPSBfYS5wcm9ncmVzcywgZmluaXNoZWQgPSBfYS5maW5pc2hlZDtcclxuICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZUZvcm1hdHRpbmcodmFsdWUpO1xyXG4gICAgICAgICAgICBfdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcclxuICAgICAgICAgICAgaWYgKCFmaW5pc2hlZClcclxuICAgICAgICAgICAgICAgIF90aGlzLmNvdW50Q2hhbmdlLmVtaXQoeyB2YWx1ZTogX3RoaXMudmFsdWUsIHByb2dyZXNzOiBwcm9ncmVzcyB9KTtcclxuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuY291bnRGaW5pc2guZW1pdCh7IHZhbHVlOiBfdGhpcy52YWx1ZSwgcHJvZ3Jlc3M6IHByb2dyZXNzIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25SZXEgPSBjb3VudCh0aGlzLmNvdW50RnJvbSwgdGhpcy5jb3VudFRvLCB0aGlzLmNvdW50RGVjaW1hbHMsIHRoaXMuY291bnREdXJhdGlvbiwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb3VudER1cmF0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb3VudFByZWZpeFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnRTdWZmaXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENvdW50VXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbHVlRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXHJcbiAgICBdLCBDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb3VudERlY2ltYWxzXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb3VudFRvXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb3VudEZyb21cIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ291bnRVcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY291bnRDaGFuZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDb3VudFVwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb3VudEZpbmlzaFwiLCB2b2lkIDApO1xyXG4gICAgQ291bnRVcERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW25neC1jaGFydHMtY291bnQtdXBdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwie3t2YWx1ZX19XCJcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgQ2hhbmdlRGV0ZWN0b3JSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgQ2hhbmdlRGV0ZWN0b3JSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdCwgdHlwZW9mIChfYiA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdF0pXHJcbiAgICBdLCBDb3VudFVwRGlyZWN0aXZlKTtcclxuICAgIHJldHVybiBDb3VudFVwRGlyZWN0aXZlO1xyXG59KCkpO1xyXG5cclxudmFyIENPTVBPTkVOVFMgPSBbXHJcbiAgICBBcmVhQ29tcG9uZW50LFxyXG4gICAgQmFzZUNoYXJ0Q29tcG9uZW50LFxyXG4gICAgQ291bnRVcERpcmVjdGl2ZSxcclxuICAgIFRvb2x0aXBBcmVhLFxyXG4gICAgQ2hhcnRDb21wb25lbnQsXHJcbiAgICBMZWdlbmRDb21wb25lbnQsXHJcbiAgICBMZWdlbmRFbnRyeUNvbXBvbmVudCxcclxuICAgIFNjYWxlTGVnZW5kQ29tcG9uZW50LFxyXG4gICAgQ2lyY2xlQ29tcG9uZW50LFxyXG4gICAgQ2lyY2xlU2VyaWVzQ29tcG9uZW50LFxyXG4gICAgR3JpZFBhbmVsQ29tcG9uZW50LFxyXG4gICAgR3JpZFBhbmVsU2VyaWVzQ29tcG9uZW50LFxyXG4gICAgU3ZnTGluZWFyR3JhZGllbnRDb21wb25lbnQsXHJcbiAgICBTdmdSYWRpYWxHcmFkaWVudENvbXBvbmVudCxcclxuICAgIFRpbWVsaW5lLFxyXG4gICAgQWR2YW5jZWRMZWdlbmRDb21wb25lbnRcclxuXTtcclxudmFyIENoYXJ0Q29tbW9uTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2hhcnRDb21tb25Nb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBDaGFydENvbW1vbk1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW1xyXG4gICAgICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxyXG4gICAgICAgICAgICAgICAgQXhlc01vZHVsZSxcclxuICAgICAgICAgICAgICAgIFRvb2x0aXBNb2R1bGVcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBDT01QT05FTlRTLnNsaWNlKCksXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcclxuICAgICAgICAgICAgICAgIEF4ZXNNb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBUb29sdGlwTW9kdWxlXHJcbiAgICAgICAgICAgIF0uY29uY2F0KENPTVBPTkVOVFMpXHJcbiAgICAgICAgfSlcclxuICAgIF0sIENoYXJ0Q29tbW9uTW9kdWxlKTtcclxuICAgIHJldHVybiBDaGFydENvbW1vbk1vZHVsZTtcclxufSgpKTtcclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKF9hKSB7XHJcbiAgICB2YXIgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0LCBtYXJnaW5zID0gX2EubWFyZ2lucywgX2IgPSBfYS5zaG93WEF4aXMsIHNob3dYQXhpcyA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBfYyA9IF9hLnNob3dZQXhpcywgc2hvd1lBeGlzID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2EueEF4aXNIZWlnaHQsIHhBeGlzSGVpZ2h0ID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCwgX2UgPSBfYS55QXhpc1dpZHRoLCB5QXhpc1dpZHRoID0gX2UgPT09IHZvaWQgMCA/IDAgOiBfZSwgX2YgPSBfYS5zaG93WExhYmVsLCBzaG93WExhYmVsID0gX2YgPT09IHZvaWQgMCA/IGZhbHNlIDogX2YsIF9nID0gX2Euc2hvd1lMYWJlbCwgc2hvd1lMYWJlbCA9IF9nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9nLCBfaCA9IF9hLnNob3dMZWdlbmQsIHNob3dMZWdlbmQgPSBfaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaCwgX2ogPSBfYS5sZWdlbmRUeXBlLCBsZWdlbmRUeXBlID0gX2ogPT09IHZvaWQgMCA/ICdvcmRpbmFsJyA6IF9qLCBfayA9IF9hLmxlZ2VuZFBvc2l0aW9uLCBsZWdlbmRQb3NpdGlvbiA9IF9rID09PSB2b2lkIDAgPyAncmlnaHQnIDogX2ssIF9sID0gX2EuY29sdW1ucywgY29sdW1ucyA9IF9sID09PSB2b2lkIDAgPyAxMiA6IF9sO1xyXG4gICAgdmFyIHhPZmZzZXQgPSBtYXJnaW5zWzNdO1xyXG4gICAgdmFyIGNoYXJ0V2lkdGggPSB3aWR0aDtcclxuICAgIHZhciBjaGFydEhlaWdodCA9IGhlaWdodCAtIG1hcmdpbnNbMF0gLSBtYXJnaW5zWzJdO1xyXG4gICAgaWYgKHNob3dMZWdlbmQgJiYgbGVnZW5kUG9zaXRpb24gPT09ICdyaWdodCcpIHtcclxuICAgICAgICBpZiAobGVnZW5kVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIGNvbHVtbnMgLT0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbHVtbnMgLT0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjaGFydFdpZHRoID0gY2hhcnRXaWR0aCAqIGNvbHVtbnMgLyAxMjtcclxuICAgIGNoYXJ0V2lkdGggPSBjaGFydFdpZHRoIC0gbWFyZ2luc1sxXSAtIG1hcmdpbnNbM107XHJcbiAgICBpZiAoc2hvd1hBeGlzKSB7XHJcbiAgICAgICAgY2hhcnRIZWlnaHQgLT0gNTtcclxuICAgICAgICBjaGFydEhlaWdodCAtPSB4QXhpc0hlaWdodDtcclxuICAgICAgICBpZiAoc2hvd1hMYWJlbCkge1xyXG4gICAgICAgICAgICAvLyB0ZXh0IGhlaWdodCArIHNwYWNpbmcgYmV0d2VlbiBheGlzIGxhYmVsIGFuZCB0aWNrIGxhYmVsc1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMjUgKyA1O1xyXG4gICAgICAgICAgICBjaGFydEhlaWdodCAtPSBvZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNob3dZQXhpcykge1xyXG4gICAgICAgIGNoYXJ0V2lkdGggLT0gNTtcclxuICAgICAgICBjaGFydFdpZHRoIC09IHlBeGlzV2lkdGg7XHJcbiAgICAgICAgeE9mZnNldCArPSB5QXhpc1dpZHRoO1xyXG4gICAgICAgIHhPZmZzZXQgKz0gMTA7XHJcbiAgICAgICAgaWYgKHNob3dZTGFiZWwpIHtcclxuICAgICAgICAgICAgLy8gdGV4dCBoZWlnaHQgKyBzcGFjaW5nIGJldHdlZW4gYXhpcyBsYWJlbCBhbmQgdGljayBsYWJlbHNcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDI1ICsgNTtcclxuICAgICAgICAgICAgY2hhcnRXaWR0aCAtPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHhPZmZzZXQgKz0gb2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNoYXJ0V2lkdGggPSBNYXRoLm1heCgwLCBjaGFydFdpZHRoKTtcclxuICAgIGNoYXJ0SGVpZ2h0ID0gTWF0aC5tYXgoMCwgY2hhcnRIZWlnaHQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3aWR0aDogTWF0aC5mbG9vcihjaGFydFdpZHRoKSxcclxuICAgICAgICBoZWlnaHQ6IE1hdGguZmxvb3IoY2hhcnRIZWlnaHQpLFxyXG4gICAgICAgIHhPZmZzZXQ6IE1hdGguZmxvb3IoeE9mZnNldClcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCYXNlZCBvbiB0aGUgZGF0YSwgcmV0dXJuIGFuIGFycmF5IHdpdGggdW5pcXVlIHZhbHVlcy5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcmV0dXJucyBhcnJheVxyXG4gKiBAcGFyYW0gcmVzdWx0c1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VW5pcXVlWERvbWFpblZhbHVlcyhyZXN1bHRzKSB7XHJcbiAgICB2YXIgdmFsdWVTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIHJlc3VsdHNfMSA9IHJlc3VsdHM7IF9pIDwgcmVzdWx0c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzXzFbX2ldO1xyXG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSByZXN1bHQuc2VyaWVzOyBfYSA8IF9iLmxlbmd0aDsgX2ErKykge1xyXG4gICAgICAgICAgICB2YXIgZCA9IF9iW19hXTtcclxuICAgICAgICAgICAgdmFsdWVTZXQuYWRkKGQubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWVTZXQpO1xyXG59XHJcbi8qKlxyXG4gKiBHZXQgdGhlIHNjYWxlVHlwZSBvZiBlbnVtZXJhYmxlIG9mIHZhbHVlcy5cclxuICogQHBhcmFtIHZhbHVlc1xyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAndGltZScsICdsaW5lYXInIG9yICdvcmRpbmFsJ1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U2NhbGVUeXBlKHZhbHVlcywgY2hlY2tEYXRlVHlwZSkge1xyXG4gICAgaWYgKGNoZWNrRGF0ZVR5cGUgPT09IHZvaWQgMCkgeyBjaGVja0RhdGVUeXBlID0gdHJ1ZTsgfVxyXG4gICAgaWYgKGNoZWNrRGF0ZVR5cGUpIHtcclxuICAgICAgICB2YXIgYWxsRGF0ZXMgPSB2YWx1ZXMuZXZlcnkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7IH0pO1xyXG4gICAgICAgIGlmIChhbGxEYXRlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RpbWUnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBhbGxOdW1iZXJzID0gdmFsdWVzLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJzsgfSk7XHJcbiAgICBpZiAoYWxsTnVtYmVycykge1xyXG4gICAgICAgIHJldHVybiAnbGluZWFyJztcclxuICAgIH1cclxuICAgIHJldHVybiAnb3JkaW5hbCc7XHJcbn1cclxuXHJcbnZhciBBcmVhQ2hhcnRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXJlYUNoYXJ0Q29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXJlYUNoYXJ0Q29tcG9uZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xyXG4gICAgICAgIF90aGlzLmJhc2VWYWx1ZSA9ICdhdXRvJztcclxuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5jdXJ2ZSA9IGN1cnZlTGluZWFyO1xyXG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy50cmltWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLm1heFhBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcclxuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XHJcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XHJcbiAgICAgICAgX3RoaXMudGltZWxpbmVIZWlnaHQgPSA1MDtcclxuICAgICAgICBfdGhpcy50aW1lbGluZVBhZGRpbmcgPSAxMDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxyXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXHJcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcclxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXHJcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcclxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy50aW1lbGluZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpbXMuaGVpZ2h0IC09IHRoaXMudGltZWxpbmVIZWlnaHQgKyB0aGlzLm1hcmdpblsyXSArIHRoaXMudGltZWxpbmVQYWRkaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmdldFhEb21haW4oKTtcclxuICAgICAgICBpZiAodGhpcy5maWx0ZXJlZERvbWFpbikge1xyXG4gICAgICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmZpbHRlcmVkRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnlEb21haW4gPSB0aGlzLmdldFlEb21haW4oKTtcclxuICAgICAgICB0aGlzLnNlcmllc0RvbWFpbiA9IHRoaXMuZ2V0U2VyaWVzRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHRoaXMuZGltcy53aWR0aCk7XHJcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSh0aGlzLnlEb21haW4sIHRoaXMuZGltcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGltZWxpbmUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy5jbGlwUGF0aElkID0gJ2NsaXAnICsgaWQoKS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuY2xpcFBhdGggPSBcInVybCgjXCIgKyB0aGlzLmNsaXBQYXRoSWQgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVRpbWVsaW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVXaWR0aCA9IHRoaXMuZGltcy53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVhEb21haW4gPSB0aGlzLmdldFhEb21haW4oKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMudGltZWxpbmVYRG9tYWluLCB0aGlzLnRpbWVsaW5lV2lkdGgpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lWVNjYWxlID0gdGhpcy5nZXRZU2NhbGUodGhpcy55RG9tYWluLCB0aGlzLnRpbWVsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiwgXCIgKyAtdGhpcy5tYXJnaW5bMl0gKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRVbmlxdWVYRG9tYWluVmFsdWVzKHRoaXMucmVzdWx0cyk7XHJcbiAgICAgICAgdGhpcy5zY2FsZVR5cGUgPSBnZXRTY2FsZVR5cGUodmFsdWVzKTtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBOdW1iZXIodik7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWluJCQxO1xyXG4gICAgICAgIHZhciBtYXgkJDE7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScgfHwgdGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIG1pbiQkMSA9IHRoaXMueFNjYWxlTWluID8gdGhpcy54U2NhbGVNaW4gOiBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICBtYXgkJDEgPSB0aGlzLnhTY2FsZU1heCA/IHRoaXMueFNjYWxlTWF4IDogTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gW25ldyBEYXRlKG1pbiQkMSksIG5ldyBEYXRlKG1heCQkMSldO1xyXG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYURhdGUgPSBhLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBiRGF0ZSA9IGIuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFEYXRlID4gYkRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYkRhdGUgPiBhRGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21haW4gPSB2YWx1ZXM7XHJcbiAgICAgICAgICAgIHRoaXMueFNldCA9IHZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gcmVzdWx0cy5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IGRvbWFpbi5zbGljZSgpO1xyXG4gICAgICAgIGlmICghdGhpcy5hdXRvU2NhbGUpIHtcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2goMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmJhc2VWYWx1ZSAhPT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuYmFzZVZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pbiQkMSA9IHRoaXMueVNjYWxlTWluID8gdGhpcy55U2NhbGVNaW4gOiBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgIHZhciBtYXgkJDEgPSB0aGlzLnlTY2FsZU1heCA/IHRoaXMueVNjYWxlTWF4IDogTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICByZXR1cm4gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFNlcmllc0RvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lOyB9KTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIHdpZHRoKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVUaW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlTGluZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVBvaW50KCkucGFkZGluZygwLjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzY2FsZS5yYW5nZShbMCwgd2lkdGhdKS5kb21haW4oZG9tYWluKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIGhlaWdodCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxyXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRTY2FsZVR5cGUgPSBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICAgICAgdmFyIGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIHZhciBudW0gPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgdmFsdWVzXzEgPSB2YWx1ZXM7IF9pIDwgdmFsdWVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc18xW19pXTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGF0ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgbnVtID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd0aW1lJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG51bSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2xpbmVhcic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnb3JkaW5hbCc7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5pc0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVEb21haW4gPSBmdW5jdGlvbiAoZG9tYWluKSB7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJlZERvbWFpbiA9IGRvbWFpbjtcclxuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmZpbHRlcmVkRG9tYWluO1xyXG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUodGhpcy54RG9tYWluLCB0aGlzLmRpbXMud2lkdGgpO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlSG92ZXJlZFZlcnRpY2FsID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLmhvdmVyZWRWZXJ0aWNhbCA9IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5oaWRlQ2lyY2xlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhvdmVyZWRWZXJ0aWNhbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIHNlcmllcykge1xyXG4gICAgICAgIGlmIChzZXJpZXMpIHtcclxuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBzZXJpZXMubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gaXRlbS5uYW1lO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW47XHJcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuc2VyaWVzRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy55RG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB7XHJcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZG9tYWluOiBbXSxcclxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy5zZXJpZXNEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnM7XHJcbiAgICAgICAgICAgIG9wdHMudGl0bGUgPSB0aGlzLmxlZ2VuZFRpdGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnlEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRzO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW2l0ZW1dLmNvbmNhdCh0aGlzLmFjdGl2ZUVudHJpZXMpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5kZWFjdGl2YXRlQWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmFjdGl2ZUVudHJpZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogZW50cnksIGVudHJpZXM6IFtdIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXNlVmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYXV0b1NjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aW1lbGluZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VydmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZERvbWFpbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBBcmVhQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZU1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Nlcmllc1Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfZCA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9kIDogT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXJpZXNUb29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgQXJlYUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJoaWRlQ2lyY2xlc1wiLCBudWxsKTtcclxuICAgIEFyZWFDaGFydENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1hcmVhLWNoYXJ0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpkZWZzPlxcbiAgICAgICAgPHN2ZzpjbGlwUGF0aCBbYXR0ci5pZF09XFxcImNsaXBQYXRoSWRcXFwiPlxcbiAgICAgICAgICA8c3ZnOnJlY3RcXG4gICAgICAgICAgICBbYXR0ci53aWR0aF09XFxcImRpbXMud2lkdGggKyAxMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJkaW1zLmhlaWdodCArIDEwXFxcIlxcbiAgICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcIid0cmFuc2xhdGUoLTUsIC01KSdcXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpjbGlwUGF0aD5cXG4gICAgICA8L3N2ZzpkZWZzPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJhcmVhLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmcgW2F0dHIuY2xpcC1wYXRoXT1cXFwiY2xpcFBhdGhcXFwiPlxcbiAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1hcmVhLXNlcmllc1xcbiAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbYmFzZVZhbHVlXT1cXFwiYmFzZVZhbHVlXFxcIlxcbiAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgICAgW2N1cnZlXT1cXFwiY3VydmVcXFwiXFxuICAgICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0lmPVxcXCIhdG9vbHRpcERpc2FibGVkXFxcIiAobW91c2VsZWF2ZSk9XFxcImhpZGVDaXJjbGVzKClcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy10b29sdGlwLWFyZWFcXG4gICAgICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgICAgIFt4U2V0XT1cXFwieFNldFxcXCJcXG4gICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3Jlc3VsdHNdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwic2VyaWVzVG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgKGhvdmVyKT1cXFwidXBkYXRlSG92ZXJlZFZlcnRpY2FsKCRldmVudClcXFwiXFxuICAgICAgICAgICAgLz5cXG5cXG4gICAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHNcXFwiPlxcbiAgICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICAgIG5neC1jaGFydHMtY2lyY2xlLXNlcmllc1xcbiAgICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgICAgICBbdmlzaWJsZVZhbHVlXT1cXFwiaG92ZXJlZFZlcnRpY2FsXFxcIlxcbiAgICAgICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQsIHNlcmllcylcXFwiXFxuICAgICAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtdGltZWxpbmVcXG4gICAgICAgICpuZ0lmPVxcXCJ0aW1lbGluZSAmJiBzY2FsZVR5cGUgIT0gJ29yZGluYWwnXFxcIlxcbiAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidGltZWxpbmVUcmFuc2Zvcm1cXFwiXFxuICAgICAgICBbcmVzdWx0c109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICBbdmlld109XFxcIlt0aW1lbGluZVdpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgICAgW2hlaWdodF09XFxcInRpbWVsaW5lSGVpZ2h0XFxcIlxcbiAgICAgICAgW3NjaGVtZV09XFxcInNjaGVtZVxcXCJcXG4gICAgICAgIFtjdXN0b21Db2xvcnNdPVxcXCJjdXN0b21Db2xvcnNcXFwiXFxuICAgICAgICBbbGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgIChvbkRvbWFpbkNoYW5nZSk9XFxcInVwZGF0ZURvbWFpbigkZXZlbnQpXFxcIlxcbiAgICAgID5cXG4gICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0czsgdHJhY2tCeTogdHJhY2tCeVxcXCI+XFxuICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgIG5neC1jaGFydHMtYXJlYS1zZXJpZXNcXG4gICAgICAgICAgICBbeFNjYWxlXT1cXFwidGltZWxpbmVYU2NhbGVcXFwiXFxuICAgICAgICAgICAgW3lTY2FsZV09XFxcInRpbWVsaW5lWVNjYWxlXFxcIlxcbiAgICAgICAgICAgIFtiYXNlVmFsdWVdPVxcXCJiYXNlVmFsdWVcXFwiXFxuICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgIFtjdXJ2ZV09XFxcImN1cnZlXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEFyZWFDaGFydENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQXJlYUNoYXJ0Q29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuY3VydmUgPSBjdXJ2ZUxpbmVhcjtcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xyXG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xyXG4gICAgICAgIF90aGlzLnRpbWVsaW5lSGVpZ2h0ID0gNTA7XHJcbiAgICAgICAgX3RoaXMudGltZWxpbmVQYWRkaW5nID0gMTA7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5kaW1zLmhlaWdodCAtPSB0aGlzLnRpbWVsaW5lSGVpZ2h0ICsgdGhpcy5tYXJnaW5bMl0gKyB0aGlzLnRpbWVsaW5lUGFkZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWREb21haW4pIHtcclxuICAgICAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5maWx0ZXJlZERvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy55RG9tYWluID0gdGhpcy5nZXRZRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5zZXJpZXNEb21haW4gPSB0aGlzLmdldFNlcmllc0RvbWFpbigpO1xyXG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUodGhpcy54RG9tYWluLCB0aGlzLmRpbXMud2lkdGgpO1xyXG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUodGhpcy55RG9tYWluLCB0aGlzLmRpbXMuaGVpZ2h0KTtcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzXzEueFNldFtpXTtcclxuICAgICAgICAgICAgdmFyIGQwID0gMDtcclxuICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXNfMS5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBncm91cC5zZXJpZXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gYS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gZC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpc18xLnJlc3VsdHM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGdyb3VwLnNlcmllcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBhLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGIudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkLmQwID0gZDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5kMSA9IGQwICsgZC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBkMCArPSBkLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZDA6IGQwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkMTogZDBcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnNlcmllcy5wdXNoKGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGQuZDAgPSAoZC5kMCAqIDEwMCkgLyB0b3RhbDtcclxuICAgICAgICAgICAgICAgICAgICBkLmQxID0gKGQuZDEgKiAxMDApIC8gdG90YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkLmQwID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBkLmQxID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnhTZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgX2xvb3BfMShpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lbGluZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy5jbGlwUGF0aElkID0gJ2NsaXAnICsgaWQoKS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuY2xpcFBhdGggPSBcInVybCgjXCIgKyB0aGlzLmNsaXBQYXRoSWQgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVUaW1lbGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lbGluZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lV2lkdGggPSB0aGlzLmRpbXMud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVYRG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVYU2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnRpbWVsaW5lWERvbWFpbiwgdGhpcy50aW1lbGluZVdpZHRoKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy50aW1lbGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIsIFwiICsgLXRoaXMubWFyZ2luWzJdICsgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFhEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldFVuaXF1ZVhEb21haW5WYWx1ZXModGhpcy5yZXN1bHRzKTtcclxuICAgICAgICB0aGlzLnNjYWxlVHlwZSA9IGdldFNjYWxlVHlwZSh2YWx1ZXMpO1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IFtuZXcgRGF0ZShtaW4kJDEpLCBuZXcgRGF0ZShtYXgkJDEpXTtcclxuICAgICAgICAgICAgdGhpcy54U2V0ID0gdmFsdWVzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFEYXRlID0gYS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYkRhdGUgPSBiLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChhRGF0ZSA+IGJEYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJEYXRlID4gYURhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gTnVtYmVyKHYpOyB9KTtcclxuICAgICAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIHZhciBtYXgkJDEgPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICBkb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21haW4gPSB2YWx1ZXM7XHJcbiAgICAgICAgICAgIHRoaXMueFNldCA9IHZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbMCwgMTAwXTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRTZXJpZXNEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZTsgfSk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WFNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgd2lkdGgpIHtcclxuICAgICAgICB2YXIgc2NhbGU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVRpbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVMaW5lYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlUG9pbnQoKS5wYWRkaW5nKDAuMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjYWxlLnJhbmdlKFswLCB3aWR0aF0pLmRvbWFpbihkb21haW4pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIGhlaWdodCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxyXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlRG9tYWluID0gZnVuY3Rpb24gKGRvbWFpbikge1xyXG4gICAgICAgIHRoaXMuZmlsdGVyZWREb21haW4gPSBkb21haW47XHJcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5maWx0ZXJlZERvbWFpbjtcclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMueERvbWFpbiwgdGhpcy5kaW1zLndpZHRoKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVIb3ZlcmVkVmVydGljYWwgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHRoaXMuaG92ZXJlZFZlcnRpY2FsID0gaXRlbS52YWx1ZTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlQ2lyY2xlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhvdmVyZWRWZXJ0aWNhbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXMpIHtcclxuICAgICAgICBpZiAoc2VyaWVzKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc2VyaWVzID0gc2VyaWVzLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW47XHJcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuc2VyaWVzRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy55RG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGRvbWFpbjogW10sXHJcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuc2VyaWVzRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy55RG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5kZWFjdGl2YXRlQWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmFjdGl2ZUVudHJpZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogZW50cnksIGVudHJpZXM6IFtdIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRpbWVsaW5lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCdzZXJpZXNUb29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2QgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc1Rvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoaWRlQ2lyY2xlc1wiLCBudWxsKTtcclxuICAgIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYXJlYS1jaGFydC1ub3JtYWxpemVkJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpkZWZzPlxcbiAgICAgICAgPHN2ZzpjbGlwUGF0aCBbYXR0ci5pZF09XFxcImNsaXBQYXRoSWRcXFwiPlxcbiAgICAgICAgICA8c3ZnOnJlY3RcXG4gICAgICAgICAgICBbYXR0ci53aWR0aF09XFxcImRpbXMud2lkdGggKyAxMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJkaW1zLmhlaWdodCArIDEwXFxcIlxcbiAgICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcIid0cmFuc2xhdGUoLTUsIC01KSdcXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpjbGlwUGF0aD5cXG4gICAgICA8L3N2ZzpkZWZzPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJhcmVhLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmcgW2F0dHIuY2xpcC1wYXRoXT1cXFwiY2xpcFBhdGhcXFwiPlxcbiAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1hcmVhLXNlcmllc1xcbiAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgICBub3JtYWxpemVkPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgICAgICAgW2N1cnZlXT1cXFwiY3VydmVcXFwiXFxuICAgICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0lmPVxcXCIhdG9vbHRpcERpc2FibGVkXFxcIiAobW91c2VsZWF2ZSk9XFxcImhpZGVDaXJjbGVzKClcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy10b29sdGlwLWFyZWFcXG4gICAgICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgICAgIFt4U2V0XT1cXFwieFNldFxcXCJcXG4gICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3Jlc3VsdHNdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgIFtzaG93UGVyY2VudGFnZV09XFxcInRydWVcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInNlcmllc1Rvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgIChob3Zlcik9XFxcInVwZGF0ZUhvdmVyZWRWZXJ0aWNhbCgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIC8+XFxuXFxuICAgICAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzXFxcIj5cXG4gICAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgICBuZ3gtY2hhcnRzLWNpcmNsZS1zZXJpZXNcXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwic3RhY2tlZFxcXCJcXG4gICAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICAgICAgW3Zpc2libGVWYWx1ZV09XFxcImhvdmVyZWRWZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50LCBzZXJpZXMpXFxcIlxcbiAgICAgICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLXRpbWVsaW5lXFxuICAgICAgICAqbmdJZj1cXFwidGltZWxpbmUgJiYgc2NhbGVUeXBlICE9ICdvcmRpbmFsJ1xcXCJcXG4gICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRpbWVsaW5lVHJhbnNmb3JtXFxcIlxcbiAgICAgICAgW3Jlc3VsdHNdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgW3ZpZXddPVxcXCJbdGltZWxpbmVXaWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICAgIFtoZWlnaHRdPVxcXCJ0aW1lbGluZUhlaWdodFxcXCJcXG4gICAgICAgIFtzY2hlbWVdPVxcXCJzY2hlbWVcXFwiXFxuICAgICAgICBbY3VzdG9tQ29sb3JzXT1cXFwiY3VzdG9tQ29sb3JzXFxcIlxcbiAgICAgICAgW2xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAob25Eb21haW5DaGFuZ2UpPVxcXCJ1cGRhdGVEb21haW4oJGV2ZW50KVxcXCJcXG4gICAgICA+XFxuICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLWFyZWEtc2VyaWVzXFxuICAgICAgICAgICAgW3hTY2FsZV09XFxcInRpbWVsaW5lWFNjYWxlXFxcIlxcbiAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ0aW1lbGluZVlTY2FsZVxcXCJcXG4gICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgbm9ybWFsaXplZD1cXFwidHJ1ZVxcXCJcXG4gICAgICAgICAgICBbY3VydmVdPVxcXCJjdXJ2ZVxcXCJcXG4gICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuY3VydmUgPSBjdXJ2ZUxpbmVhcjtcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xyXG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xyXG4gICAgICAgIF90aGlzLnRpbWVsaW5lSGVpZ2h0ID0gNTA7XHJcbiAgICAgICAgX3RoaXMudGltZWxpbmVQYWRkaW5nID0gMTA7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5kaW1zLmhlaWdodCAtPSB0aGlzLnRpbWVsaW5lSGVpZ2h0ICsgdGhpcy5tYXJnaW5bMl0gKyB0aGlzLnRpbWVsaW5lUGFkZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWREb21haW4pIHtcclxuICAgICAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5maWx0ZXJlZERvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy55RG9tYWluID0gdGhpcy5nZXRZRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5zZXJpZXNEb21haW4gPSB0aGlzLmdldFNlcmllc0RvbWFpbigpO1xyXG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUodGhpcy54RG9tYWluLCB0aGlzLmRpbXMud2lkdGgpO1xyXG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUodGhpcy55RG9tYWluLCB0aGlzLmRpbXMuaGVpZ2h0KTtcclxuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzXzEueFNldFtpXTtcclxuICAgICAgICAgICAgdmFyIGQwID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXNfMS5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBncm91cC5zZXJpZXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gYS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5kMCA9IGQwO1xyXG4gICAgICAgICAgICAgICAgICAgIGQuZDEgPSBkMCArIGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZDAgKz0gZC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQwOiBkMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZDE6IGQwXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBncm91cC5zZXJpZXMucHVzaChkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnhTZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgX2xvb3BfMShpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lbGluZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy5jbGlwUGF0aElkID0gJ2NsaXAnICsgaWQoKS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuY2xpcFBhdGggPSBcInVybCgjXCIgKyB0aGlzLmNsaXBQYXRoSWQgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVUaW1lbGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lbGluZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lV2lkdGggPSB0aGlzLmRpbXMud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVYRG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVYU2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnRpbWVsaW5lWERvbWFpbiwgdGhpcy50aW1lbGluZVdpZHRoKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy50aW1lbGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIsIFwiICsgLXRoaXMubWFyZ2luWzJdICsgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFhEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldFVuaXF1ZVhEb21haW5WYWx1ZXModGhpcy5yZXN1bHRzKTtcclxuICAgICAgICB0aGlzLnNjYWxlVHlwZSA9IGdldFNjYWxlVHlwZSh2YWx1ZXMpO1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIE51bWJlcih2KTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaW4kJDE7XHJcbiAgICAgICAgdmFyIG1heCQkMTtcclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJyB8fCB0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgbWluJCQxID0gdGhpcy54U2NhbGVNaW4gPyB0aGlzLnhTY2FsZU1pbiA6IE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIG1heCQkMSA9IHRoaXMueFNjYWxlTWF4ID8gdGhpcy54U2NhbGVNYXggOiBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSBbbmV3IERhdGUobWluJCQxKSwgbmV3IERhdGUobWF4JCQxKV07XHJcbiAgICAgICAgICAgIHRoaXMueFNldCA9IHZhbHVlcy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhRGF0ZSA9IGEuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJEYXRlID0gYi5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYURhdGUgPiBiRGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIGlmIChiRGF0ZSA+IGFEYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IFttaW4kJDEsIG1heCQkMV07XHJcbiAgICAgICAgICAgIHRoaXMueFNldCA9IHZhbHVlcy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHZhbHVlcztcclxuICAgICAgICAgICAgdGhpcy54U2V0ID0gdmFsdWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpc18yLnhTZXRbaV07XHJcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpc18yLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGdyb3VwLnNlcmllcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBhLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGIudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gZC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkb21haW4ucHVzaChzdW0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRoaXNfMiA9IHRoaXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnhTZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgX2xvb3BfMihpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pbiQkMSA9IHRoaXMueVNjYWxlTWluID8gdGhpcy55U2NhbGVNaW4gOiBNYXRoLm1pbi5hcHBseShNYXRoLCBbMF0uY29uY2F0KGRvbWFpbikpO1xyXG4gICAgICAgIHZhciBtYXgkJDEgPSB0aGlzLnlTY2FsZU1heCA/IHRoaXMueVNjYWxlTWF4IDogTWF0aC5tYXguYXBwbHkoTWF0aCwgZG9tYWluKTtcclxuICAgICAgICByZXR1cm4gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRTZXJpZXNEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZTsgfSk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WFNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgd2lkdGgpIHtcclxuICAgICAgICB2YXIgc2NhbGU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZVRpbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVMaW5lYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlUG9pbnQoKS5wYWRkaW5nKDAuMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjYWxlLnJhbmdlKFswLCB3aWR0aF0pLmRvbWFpbihkb21haW4pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIGhlaWdodCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxyXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlRG9tYWluID0gZnVuY3Rpb24gKGRvbWFpbikge1xyXG4gICAgICAgIHRoaXMuZmlsdGVyZWREb21haW4gPSBkb21haW47XHJcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5maWx0ZXJlZERvbWFpbjtcclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMueERvbWFpbiwgdGhpcy5kaW1zLndpZHRoKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVIb3ZlcmVkVmVydGljYWwgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHRoaXMuaG92ZXJlZFZlcnRpY2FsID0gaXRlbS52YWx1ZTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlQ2lyY2xlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhvdmVyZWRWZXJ0aWNhbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlQWxsKCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhLCBzZXJpZXMpIHtcclxuICAgICAgICBpZiAoc2VyaWVzKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc2VyaWVzID0gc2VyaWVzLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW47XHJcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuc2VyaWVzRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy55RG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGRvbWFpbjogW10sXHJcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuc2VyaWVzRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy55RG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5kZWFjdGl2YXRlQWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmFjdGl2ZUVudHJpZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogZW50cnksIGVudHJpZXM6IFtdIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRpbWVsaW5lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZU1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBBcmVhQ2hhcnRTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Nlcmllc1Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfZCA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9kIDogT2JqZWN0KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VyaWVzVG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImhpZGVDaXJjbGVzXCIsIG51bGwpO1xyXG4gICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1hcmVhLWNoYXJ0LXN0YWNrZWQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmRlZnM+XFxuICAgICAgICA8c3ZnOmNsaXBQYXRoIFthdHRyLmlkXT1cXFwiY2xpcFBhdGhJZFxcXCI+XFxuICAgICAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgICAgIFthdHRyLndpZHRoXT1cXFwiZGltcy53aWR0aCArIDEwXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmhlaWdodF09XFxcImRpbXMuaGVpZ2h0ICsgMTBcXFwiXFxuICAgICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiJ3RyYW5zbGF0ZSgtNSwgLTUpJ1xcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmNsaXBQYXRoPlxcbiAgICAgIDwvc3ZnOmRlZnM+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImFyZWEtY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6ZyBbYXR0ci5jbGlwLXBhdGhdPVxcXCJjbGlwUGF0aFxcXCI+XFxuICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0czsgdHJhY2tCeTogdHJhY2tCeVxcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLWFyZWEtc2VyaWVzXFxuICAgICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgIHN0YWNrZWQ9XFxcInRydWVcXFwiXFxuICAgICAgICAgICAgICBbY3VydmVdPVxcXCJjdXJ2ZVxcXCJcXG4gICAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcblxcbiAgICAgICAgICA8c3ZnOmcgKm5nSWY9XFxcIiF0b29sdGlwRGlzYWJsZWRcXFwiIChtb3VzZWxlYXZlKT1cXFwiaGlkZUNpcmNsZXMoKVxcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLXRvb2x0aXAtYXJlYVxcbiAgICAgICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICAgICAgW3hTZXRdPVxcXCJ4U2V0XFxcIlxcbiAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbcmVzdWx0c109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJzZXJpZXNUb29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICAoaG92ZXIpPVxcXCJ1cGRhdGVIb3ZlcmVkVmVydGljYWwoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAvPlxcblxcbiAgICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0czsgdHJhY2tCeTogdHJhY2tCeVxcXCI+XFxuICAgICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1jaXJjbGUtc2VyaWVzXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcInN0YWNrZWRcXFwiXFxuICAgICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgICAgIFtzY2FsZVR5cGVdPVxcXCJzY2FsZVR5cGVcXFwiXFxuICAgICAgICAgICAgICAgIFt2aXNpYmxlVmFsdWVdPVxcXCJob3ZlcmVkVmVydGljYWxcXFwiXFxuICAgICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudCwgc2VyaWVzKVxcXCJcXG4gICAgICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgLz5cXG4gICAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICAgIDxzdmc6Z1xcbiAgICAgICAgbmd4LWNoYXJ0cy10aW1lbGluZVxcbiAgICAgICAgKm5nSWY9XFxcInRpbWVsaW5lICYmIHNjYWxlVHlwZSAhPSAnb3JkaW5hbCdcXFwiXFxuICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0aW1lbGluZVRyYW5zZm9ybVxcXCJcXG4gICAgICAgIFtyZXN1bHRzXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgIFt2aWV3XT1cXFwiW3RpbWVsaW5lV2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgICBbaGVpZ2h0XT1cXFwidGltZWxpbmVIZWlnaHRcXFwiXFxuICAgICAgICBbc2NoZW1lXT1cXFwic2NoZW1lXFxcIlxcbiAgICAgICAgW2N1c3RvbUNvbG9yc109XFxcImN1c3RvbUNvbG9yc1xcXCJcXG4gICAgICAgIFtsZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgKG9uRG9tYWluQ2hhbmdlKT1cXFwidXBkYXRlRG9tYWluKCRldmVudClcXFwiXFxuICAgICAgPlxcbiAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIj5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1hcmVhLXNlcmllc1xcbiAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ0aW1lbGluZVhTY2FsZVxcXCJcXG4gICAgICAgICAgICBbeVNjYWxlXT1cXFwidGltZWxpbmVZU2NhbGVcXFwiXFxuICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgIHN0YWNrZWQ9XFxcInRydWVcXFwiXFxuICAgICAgICAgICAgW2N1cnZlXT1cXFwiY3VydmVcXFwiXFxuICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcclxuICAgICAgICB9KVxyXG4gICAgXSwgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBBcmVhU2VyaWVzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXJlYVNlcmllc0NvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLmJhc2VWYWx1ZSA9ICdhdXRvJztcclxuICAgICAgICB0aGlzLnN0YWNrZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm5vcm1hbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy51cGRhdGVHcmFkaWVudCgpO1xyXG4gICAgICAgIHZhciBjdXJyZW50QXJlYTtcclxuICAgICAgICB2YXIgc3RhcnRpbmdBcmVhO1xyXG4gICAgICAgIHZhciB4UHJvcGVydHkgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkLm5hbWU7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy54U2NhbGUobGFiZWwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhY2tlZCB8fCB0aGlzLm5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgY3VycmVudEFyZWEgPSBhcmVhKClcclxuICAgICAgICAgICAgICAgIC54KHhQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgIC55MChmdW5jdGlvbiAoZCwgaSkgeyByZXR1cm4gX3RoaXMueVNjYWxlKGQuZDApOyB9KVxyXG4gICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiBfdGhpcy55U2NhbGUoZC5kMSk7IH0pO1xyXG4gICAgICAgICAgICBzdGFydGluZ0FyZWEgPSBhcmVhKClcclxuICAgICAgICAgICAgICAgIC54KHhQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgIC55MChmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMueVNjYWxlLnJhbmdlKClbMF07IH0pXHJcbiAgICAgICAgICAgICAgICAueTEoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLnlTY2FsZS5yYW5nZSgpWzBdOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcmVhID0gYXJlYSgpXHJcbiAgICAgICAgICAgICAgICAueCh4UHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYmFzZVZhbHVlID09PSAnYXV0bycgPyBfdGhpcy55U2NhbGUucmFuZ2UoKVswXSA6IF90aGlzLnlTY2FsZShfdGhpcy5iYXNlVmFsdWUpOyB9KVxyXG4gICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy55U2NhbGUoZC52YWx1ZSk7IH0pO1xyXG4gICAgICAgICAgICBzdGFydGluZ0FyZWEgPSBhcmVhKClcclxuICAgICAgICAgICAgICAgIC54KHhQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgIC55MChmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMuYmFzZVZhbHVlID09PSAnYXV0bycgPyBfdGhpcy55U2NhbGUucmFuZ2UoKVswXSA6IF90aGlzLnlTY2FsZShfdGhpcy5iYXNlVmFsdWUpOyB9KVxyXG4gICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy5iYXNlVmFsdWUgPT09ICdhdXRvJyA/IF90aGlzLnlTY2FsZS5yYW5nZSgpWzBdIDogX3RoaXMueVNjYWxlKF90aGlzLmJhc2VWYWx1ZSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50QXJlYS5jdXJ2ZSh0aGlzLmN1cnZlKTtcclxuICAgICAgICBzdGFydGluZ0FyZWEuY3VydmUodGhpcy5jdXJ2ZSk7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gLjg7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEuc2VyaWVzO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgZGF0YSA9IHNvcnRMaW5lYXIoZGF0YSwgJ25hbWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICBkYXRhID0gc29ydEJ5VGltZShkYXRhLCAnbmFtZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGF0YSA9IHNvcnRCeURvbWFpbihkYXRhLCAnbmFtZScsICdhc2MnLCB0aGlzLnhTY2FsZS5kb21haW4oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGF0aCA9IGN1cnJlbnRBcmVhKGRhdGEpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRpbmdQYXRoID0gc3RhcnRpbmdBcmVhKGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZUdyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzR3JhZGllbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFja2VkIHx8IHRoaXMubm9ybWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQwdmFsdWVzID0gdGhpcy5kYXRhLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZDA7IH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGQxdmFsdWVzID0gdGhpcy5kYXRhLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuZDE7IH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGQxdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBkMHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB0aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKG1heCQkMSwgbWluJCQxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmRhdGEuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4JCQxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IHRoaXMuY29sb3JzLmdldExpbmVhckdyYWRpZW50U3RvcHMobWF4JCQxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0luYWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMgfHwgdGhpcy5hY3RpdmVFbnRyaWVzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWUgPT09IGQubmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXNlVmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhY2tlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm5vcm1hbGl6ZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXJ2ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQXJlYVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEFyZWFTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgQXJlYVNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWFyZWEtc2VyaWVzXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmcgbmd4LWNoYXJ0cy1hcmVhXFxuICAgICAgY2xhc3M9XFxcImFyZWEtc2VyaWVzXFxcIlxcbiAgICAgIFtkYXRhXT1cXFwiZGF0YVxcXCJcXG4gICAgICBbcGF0aF09XFxcInBhdGhcXFwiXFxuICAgICAgW2ZpbGxdPVxcXCJjb2xvcnMuZ2V0Q29sb3IoZGF0YS5uYW1lKVxcXCJcXG4gICAgICBbc3RvcHNdPVxcXCJncmFkaWVudFN0b3BzXFxcIlxcbiAgICAgIFtzdGFydGluZ1BhdGhdPVxcXCJzdGFydGluZ1BhdGhcXFwiXFxuICAgICAgW29wYWNpdHldPVxcXCJvcGFjaXR5XFxcIlxcbiAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50IHx8IGhhc0dyYWRpZW50XFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiaXNBY3RpdmUoZGF0YSlcXFwiXFxuICAgICAgW2NsYXNzLmluYWN0aXZlXT1cXFwiaXNJbmFjdGl2ZShkYXRhKVxcXCJcXG4gICAgLz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBBcmVhU2VyaWVzQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBBcmVhU2VyaWVzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIEFyZWFDaGFydE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFyZWFDaGFydE1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIEFyZWFDaGFydE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NoYXJ0Q29tbW9uTW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICBBcmVhQ2hhcnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBBcmVhQ2hhcnROb3JtYWxpemVkQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQXJlYUNoYXJ0U3RhY2tlZENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEFyZWFTZXJpZXNDb21wb25lbnRcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZXhwb3J0czogW1xyXG4gICAgICAgICAgICAgICAgQXJlYUNoYXJ0Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQXJlYUNoYXJ0Tm9ybWFsaXplZENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBBcmVhU2VyaWVzQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQXJlYUNoYXJ0TW9kdWxlKTtcclxuICAgIHJldHVybiBBcmVhQ2hhcnRNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG52YXIgQmFyQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmFyQ29tcG9uZW50KGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLnJvdW5kRWRnZXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ub0JhcldoZW5aZXJvID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaGlkZUJhciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcclxuICAgIH1cclxuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRBbmltYXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmdyYWRpZW50SWQgPSAnZ3JhZCcgKyBpZCgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudEZpbGwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcclxuICAgICAgICBpZiAodGhpcy5ncmFkaWVudCB8fCB0aGlzLnN0b3BzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IHRoaXMuZ2V0R3JhZGllbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5oYXNHcmFkaWVudCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlUGF0aEVsKCk7XHJcbiAgICAgICAgdGhpcy5jaGVja1RvSGlkZUJhcigpO1xyXG4gICAgfTtcclxuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUubG9hZEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSB0aGlzLmdldFN0YXJ0aW5nUGF0aCgpO1xyXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy51cGRhdGUuYmluZCh0aGlzKSwgMTAwKTtcclxuICAgIH07XHJcbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVBhdGhFbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpLnNlbGVjdCgnLmJhcicpO1xyXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9ucykge1xyXG4gICAgICAgICAgICBub2RlXHJcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUuYXR0cignZCcsIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLmdldEdyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0b3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3BzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5maWxsLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5nZXRTdGFydE9wYWNpdHkoKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwMCxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmZpbGwsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUuZ2V0U3RhcnRpbmdQYXRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5hbmltYXRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuZ2V0UmFkaXVzKCk7XHJcbiAgICAgICAgdmFyIHBhdGg7XHJcbiAgICAgICAgaWYgKHRoaXMucm91bmRFZGdlcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gTWF0aC5taW4odGhpcy5oZWlnaHQsIHJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcm91bmRlZFJlY3QodGhpcy54LCB0aGlzLnkgKyB0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgMSwgMCwgdGhpcy5lZGdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBNYXRoLm1pbih0aGlzLndpZHRoLCByYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHJvdW5kZWRSZWN0KHRoaXMueCwgdGhpcy55LCAxLCB0aGlzLmhlaWdodCwgMCwgdGhpcy5lZGdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcm91bmRlZFJlY3QodGhpcy54LCB0aGlzLnkgKyB0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgMSwgMCwgdGhpcy5lZGdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcm91bmRlZFJlY3QodGhpcy54LCB0aGlzLnksIDEsIHRoaXMuaGVpZ2h0LCAwLCB0aGlzLmVkZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aDtcclxuICAgIH07XHJcbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuZ2V0UmFkaXVzKCk7XHJcbiAgICAgICAgdmFyIHBhdGg7XHJcbiAgICAgICAgaWYgKHRoaXMucm91bmRFZGdlcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gTWF0aC5taW4odGhpcy5oZWlnaHQsIHJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gcm91bmRlZFJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCByYWRpdXMsIHRoaXMuZWRnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgICAgICAgICAgcmFkaXVzID0gTWF0aC5taW4odGhpcy53aWR0aCwgcmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIHBhdGggPSByb3VuZGVkUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHJhZGl1cywgdGhpcy5lZGdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGggPSByb3VuZGVkUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHJhZGl1cywgdGhpcy5lZGdlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfTtcclxuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUuZ2V0UmFkaXVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByYWRpdXMgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLnJvdW5kRWRnZXMgJiYgdGhpcy5oZWlnaHQgPiA1ICYmIHRoaXMud2lkdGggPiA1KSB7XHJcbiAgICAgICAgICAgIHJhZGl1cyA9IE1hdGguZmxvb3IoTWF0aC5taW4oNSwgdGhpcy5oZWlnaHQgLyAyLCB0aGlzLndpZHRoIC8gMikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFkaXVzO1xyXG4gICAgfTtcclxuICAgIEJhckNvbXBvbmVudC5wcm90b3R5cGUuZ2V0U3RhcnRPcGFjaXR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJvdW5kRWRnZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDAuMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwLjU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImVkZ2VzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVkZ2VzID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucm91bmRFZGdlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhLnZhbHVlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlcyA9IFt0cnVlLCB0cnVlLCBmYWxzZSwgZmFsc2VdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXMgPSBbZmFsc2UsIGZhbHNlLCB0cnVlLCB0cnVlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhLnZhbHVlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlcyA9IFtmYWxzZSwgdHJ1ZSwgZmFsc2UsIHRydWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXMgPSBbdHJ1ZSwgZmFsc2UsIHRydWUsIGZhbHNlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGVkZ2VzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS5vbk1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHRoaXMuZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQmFyQ29tcG9uZW50LnByb3RvdHlwZS5vbk1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQodGhpcy5kYXRhKTtcclxuICAgIH07XHJcbiAgICBCYXJDb21wb25lbnQucHJvdG90eXBlLmNoZWNrVG9IaWRlQmFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGlkZUJhciA9XHJcbiAgICAgICAgICAgIHRoaXMubm9CYXJXaGVuWmVybyAmJlxyXG4gICAgICAgICAgICAgICAgKCh0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmIHRoaXMuaGVpZ2h0ID09PSAwKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgdGhpcy53aWR0aCA9PT0gMCkpO1xyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwib3JpZW50YXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRWRnZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm9mZnNldFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNBY3RpdmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdG9wc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcmlhTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm5vQmFyV2hlblplcm9cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbk1vdXNlRW50ZXJcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIEJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Nb3VzZUxlYXZlXCIsIG51bGwpO1xyXG4gICAgQmFyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtYmFyXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmRlZnMgKm5nSWY9XFxcImhhc0dyYWRpZW50XFxcIj5cXG4gICAgICA8c3ZnOmcgbmd4LWNoYXJ0cy1zdmctbGluZWFyLWdyYWRpZW50IFtvcmllbnRhdGlvbl09XFxcIm9yaWVudGF0aW9uXFxcIiBbbmFtZV09XFxcImdyYWRpZW50SWRcXFwiIFtzdG9wc109XFxcImdyYWRpZW50U3RvcHNcXFwiIC8+XFxuICAgIDwvc3ZnOmRlZnM+XFxuICAgIDxzdmc6cGF0aFxcbiAgICAgIGNsYXNzPVxcXCJiYXJcXFwiXFxuICAgICAgc3Ryb2tlPVxcXCJub25lXFxcIlxcbiAgICAgIHJvbGU9XFxcImltZ1xcXCJcXG4gICAgICB0YWJJbmRleD1cXFwiLTFcXFwiXFxuICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImlzQWN0aXZlXFxcIlxcbiAgICAgIFtjbGFzcy5oaWRkZW5dPVxcXCJoaWRlQmFyXFxcIlxcbiAgICAgIFthdHRyLmRdPVxcXCJwYXRoXFxcIlxcbiAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVxcXCJhcmlhTGFiZWxcXFwiXFxuICAgICAgW2F0dHIuZmlsbF09XFxcImhhc0dyYWRpZW50ID8gZ3JhZGllbnRGaWxsIDogZmlsbFxcXCJcXG4gICAgICAoY2xpY2spPVxcXCJzZWxlY3QuZW1pdChkYXRhKVxcXCJcXG4gICAgLz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXHJcbiAgICBdLCBCYXJDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEJhckNvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBCYXJIb3Jpem9udGFsQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJhckhvcml6b250YWxDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXJIb3Jpem9udGFsQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy50cmltWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLm1heFhBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLmJhclBhZGRpbmcgPSA4O1xyXG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnJvdW5kRWRnZXMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnNob3dEYXRhTGFiZWwgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5ub0JhcldoZW5aZXJvID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xyXG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xyXG4gICAgICAgIF90aGlzLmRhdGFMYWJlbE1heFdpZHRoID0geyBuZWdhdGl2ZTogMCwgcG9zaXRpdmU6IDAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvd0RhdGFMYWJlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heFdpZHRoID0geyBuZWdhdGl2ZTogMCwgcG9zaXRpdmU6IDAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXJnaW4gPSBbMTAsIDIwICsgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5wb3NpdGl2ZSwgMTAsIDIwICsgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZV07XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXHJcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcclxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxyXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcclxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxyXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcclxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WFNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFswLCB0aGlzLmRpbXMud2lkdGhdKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMueERvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMueURvbWFpbiA9IHRoaXMuZ2V0WURvbWFpbigpO1xyXG4gICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy55RG9tYWluLmxlbmd0aCAvICh0aGlzLmRpbXMuaGVpZ2h0IC8gdGhpcy5iYXJQYWRkaW5nICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB0aGlzLmRpbXMuaGVpZ2h0XSlcclxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcihzcGFjaW5nKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMueURvbWFpbik7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XHJcbiAgICAgICAgdmFyIG1pbiQkMSA9IHRoaXMueFNjYWxlTWluID8gTWF0aC5taW4uYXBwbHkoTWF0aCwgW3RoaXMueFNjYWxlTWluXS5jb25jYXQodmFsdWVzKSkgOiBNYXRoLm1pbi5hcHBseShNYXRoLCBbMF0uY29uY2F0KHZhbHVlcykpO1xyXG4gICAgICAgIHZhciBtYXgkJDEgPSB0aGlzLnhTY2FsZU1heCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIFt0aGlzLnhTY2FsZU1heF0uY29uY2F0KHZhbHVlcykpIDogTWF0aC5tYXguYXBwbHkoTWF0aCwgWzBdLmNvbmNhdCh2YWx1ZXMpKTtcclxuICAgICAgICByZXR1cm4gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRZRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmxhYmVsOyB9KTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnlEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnhEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB7XHJcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZG9tYWluOiBbXSxcclxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy55RG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy54RG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLm9uRGF0YUxhYmVsTWF4V2lkdGhDaGFuZ2VkID0gZnVuY3Rpb24gKGV2ZW50JCQxKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZXZlbnQkJDEuc2l6ZS5uZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLm5lZ2F0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZSwgZXZlbnQkJDEuc2l6ZS53aWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heFdpZHRoLnBvc2l0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5wb3NpdGl2ZSwgZXZlbnQkJDEuc2l6ZS53aWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudCQkMS5pbmRleCA9PT0gdGhpcy5yZXN1bHRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGUoKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0cy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWUgJiYgZC5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICBpdGVtID0gdGhpcy5yZXN1bHRzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZSAmJiBkLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFyUGFkZGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRWRnZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZU1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0RhdGFMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YUxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcIm5vQmFyV2hlblplcm9cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWJhci1ob3Jpem9udGFsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIHRydWUpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImJhci1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbeUF4aXNPZmZzZXRdPVxcXCJkYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZVxcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1zZXJpZXMtaG9yaXpvbnRhbFxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICBbc2VyaWVzXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICBbcm91bmRFZGdlc109XFxcInJvdW5kRWRnZXNcXFwiXFxuICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgW3Nob3dEYXRhTGFiZWxdPVxcXCJzaG93RGF0YUxhYmVsXFxcIlxcbiAgICAgICAgICBbZGF0YUxhYmVsRm9ybWF0dGluZ109XFxcImRhdGFMYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFtub0JhcldoZW5aZXJvXT1cXFwibm9CYXJXaGVuWmVyb1xcXCJcXG4gICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAoZGF0YUxhYmVsV2lkdGhDaGFuZ2VkKT1cXFwib25EYXRhTGFiZWxNYXhXaWR0aENoYW5nZWQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBCYXJIb3Jpem9udGFsQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEJhckhvcml6b250YWwyRENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCYXJIb3Jpem9udGFsMkRDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMuZ3JvdXBQYWRkaW5nID0gMTY7XHJcbiAgICAgICAgX3RoaXMuYmFyUGFkZGluZyA9IDg7XHJcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMucm91bmRFZGdlcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuc2hvd0RhdGFMYWJlbCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLm5vQmFyV2hlblplcm8gPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcclxuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XHJcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XHJcbiAgICAgICAgX3RoaXMuZGF0YUxhYmVsTWF4V2lkdGggPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3dEYXRhTGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aCA9IHsgbmVnYXRpdmU6IDAsIHBvc2l0aXZlOiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFyZ2luID0gWzEwLCAyMCArIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgucG9zaXRpdmUsIDEwLCAyMCArIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmVdO1xyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxyXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXHJcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcclxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXHJcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcclxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cERvbWFpbiA9IHRoaXMuZ2V0R3JvdXBEb21haW4oKTtcclxuICAgICAgICB0aGlzLmlubmVyRG9tYWluID0gdGhpcy5nZXRJbm5lckRvbWFpbigpO1xyXG4gICAgICAgIHRoaXMudmFsdWVzRG9tYWluID0gdGhpcy5nZXRWYWx1ZURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBTY2FsZSA9IHRoaXMuZ2V0R3JvdXBTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuaW5uZXJTY2FsZSA9IHRoaXMuZ2V0SW5uZXJTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMudmFsdWVTY2FsZSA9IHRoaXMuZ2V0VmFsdWVTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRHcm91cFNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5ncm91cERvbWFpbi5sZW5ndGggLyAodGhpcy5kaW1zLmhlaWdodCAvIHRoaXMuZ3JvdXBQYWRkaW5nICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB0aGlzLmRpbXMuaGVpZ2h0XSlcclxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcihzcGFjaW5nKVxyXG4gICAgICAgICAgICAucGFkZGluZ091dGVyKHNwYWNpbmcgLyAyKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMuZ3JvdXBEb21haW4pO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5uZXJTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5ncm91cFNjYWxlLmJhbmR3aWR0aCgpO1xyXG4gICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5pbm5lckRvbWFpbi5sZW5ndGggLyAoaGVpZ2h0IC8gdGhpcy5iYXJQYWRkaW5nICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCBoZWlnaHRdKVxyXG4gICAgICAgICAgICAucGFkZGluZ0lubmVyKHNwYWNpbmcpXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy5pbm5lckRvbWFpbik7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZVNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFswLCB0aGlzLmRpbXMud2lkdGhdKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMudmFsdWVzRG9tYWluKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLmdldEdyb3VwRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGdyb3VwLmxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZ3JvdXAubGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRJbm5lckRvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZ3JvdXAuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLmxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZ3JvdXAuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBbMF0uY29uY2F0KGRvbWFpbikpO1xyXG4gICAgICAgIHZhciBtYXgkJDEgPSB0aGlzLnhTY2FsZU1heCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIFt0aGlzLnhTY2FsZU1heF0uY29uY2F0KGRvbWFpbikpIDogTWF0aC5tYXguYXBwbHkoTWF0aCwgWzBdLmNvbmNhdChkb21haW4pKTtcclxuICAgICAgICByZXR1cm4gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLmdyb3VwVHJhbnNmb3JtID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsIFwiICsgdGhpcy5ncm91cFNjYWxlKGdyb3VwLmxhYmVsKSArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhLCBncm91cCkge1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgICBkYXRhLnNlcmllcyA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy52YWx1ZXNEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkb21haW46IFtdLFxyXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy52YWx1ZXNEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRzO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWUF4aXNXaWR0aCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgICAgIHRoaXMueUF4aXNXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUub25EYXRhTGFiZWxNYXhXaWR0aENoYW5nZWQgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwSW5kZXgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChldmVudCQkMS5zaXplLm5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heFdpZHRoLm5lZ2F0aXZlLCBldmVudCQkMS5zaXplLndpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgucG9zaXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heFdpZHRoLnBvc2l0aXZlLCBldmVudCQkMS5zaXplLndpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPT09IHRoaXMucmVzdWx0cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudXBkYXRlKCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnJlc3VsdHNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZykgeyByZXR1cm4gZy5zZXJpZXM7IH0pXHJcbiAgICAgICAgICAgIC5mbGF0KClcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBpdGVtcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCAhPT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEoaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JvdXBQYWRkaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImJhclBhZGRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmRFZGdlc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dEYXRhTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YUxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1iYXItaG9yaXpvbnRhbC0yZCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYmFyLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWdyaWQtcGFuZWwtc2VyaWVzXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ2YWx1ZVNjYWxlXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwiZ3JvdXBTY2FsZVxcXCJcXG4gICAgICAgICAgW2RhdGFdPVxcXCJyZXN1bHRzXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIG9yaWVudD1cXFwiaG9yaXpvbnRhbFxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInZhbHVlU2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwiZ3JvdXBTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbeUF4aXNPZmZzZXRdPVxcXCJkYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZVxcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgKm5nRm9yPVxcXCJsZXQgZ3JvdXAgb2YgcmVzdWx0czsgbGV0IGluZGV4ID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiZ3JvdXBUcmFuc2Zvcm0oZ3JvdXApXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLXNlcmllcy1ob3Jpem9udGFsXFxuICAgICAgICAgICAgW3hTY2FsZV09XFxcInZhbHVlU2NhbGVcXFwiXFxuICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJpbm5lclNjYWxlXFxcIlxcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgW3Nlcmllc109XFxcImdyb3VwLnNlcmllc1xcXCJcXG4gICAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgIFtzZXJpZXNOYW1lXT1cXFwiZ3JvdXAubmFtZVxcXCJcXG4gICAgICAgICAgICBbcm91bmRFZGdlc109XFxcInJvdW5kRWRnZXNcXFwiXFxuICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIFtzaG93RGF0YUxhYmVsXT1cXFwic2hvd0RhdGFMYWJlbFxcXCJcXG4gICAgICAgICAgICBbZGF0YUxhYmVsRm9ybWF0dGluZ109XFxcImRhdGFMYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgICAgW25vQmFyV2hlblplcm9dPVxcXCJub0JhcldoZW5aZXJvXFxcIlxcbiAgICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGRhdGFMYWJlbFdpZHRoQ2hhbmdlZCk9XFxcIm9uRGF0YUxhYmVsTWF4V2lkdGhDaGFuZ2VkKCRldmVudCwgaW5kZXgpXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJyonXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBCYXJIb3Jpem9udGFsMkRDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5iYXJQYWRkaW5nID0gODtcclxuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5ub0JhcldoZW5aZXJvID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xyXG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5mb3JtYXREYXRlcygpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBEb21haW4gPSB0aGlzLmdldEdyb3VwRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5pbm5lckRvbWFpbiA9IHRoaXMuZ2V0SW5uZXJEb21haW4oKTtcclxuICAgICAgICB0aGlzLnZhbHVlRG9tYWluID0gdGhpcy5nZXRWYWx1ZURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiAsIFwiICsgdGhpcy5tYXJnaW5bMF0gKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZ3JvdXAubGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBkb21haW4ucHVzaChncm91cC5sYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5uZXJEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC5sYWJlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLmxhYmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gWzAsIDEwMF07XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMuZ3JvdXBEb21haW4ubGVuZ3RoIC8gKHRoaXMuZGltcy5oZWlnaHQgLyB0aGlzLmJhclBhZGRpbmcgKyAxKTtcclxuICAgICAgICByZXR1cm4gc2NhbGVCYW5kKClcclxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHRoaXMuZGltcy5oZWlnaHRdKVxyXG4gICAgICAgICAgICAucGFkZGluZ0lubmVyKHNwYWNpbmcpXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy5ncm91cERvbWFpbik7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnZhbHVlRG9tYWluKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ3JvdXBUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCwgXCIgKyB0aGlzLnlTY2FsZShncm91cC5uYW1lKSArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIGdyb3VwKSB7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy52YWx1ZURvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB7XHJcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZG9tYWluOiBbXSxcclxuICAgICAgICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcclxuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMudmFsdWVEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRzO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXAsIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQkJDEpO1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMucmVzdWx0c1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChnKSB7IHJldHVybiBnLnNlcmllczsgfSlcclxuICAgICAgICAgICAgLmZsYXQoKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IGl0ZW1zLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgIT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhKGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImJhclBhZGRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm5vQmFyV2hlblplcm9cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1iYXItaG9yaXpvbnRhbC1ub3JtYWxpemVkJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgdW5kZWZpbmVkLCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgdW5kZWZpbmVkLCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJiYXItY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgKm5nRm9yPVxcXCJsZXQgZ3JvdXAgb2YgcmVzdWx0czsgdHJhY2tCeTogdHJhY2tCeVxcXCJcXG4gICAgICAgICAgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJncm91cFRyYW5zZm9ybShncm91cClcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgIG5neC1jaGFydHMtc2VyaWVzLWhvcml6b250YWxcXG4gICAgICAgICAgICB0eXBlPVxcXCJub3JtYWxpemVkXFxcIlxcbiAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICBbc2VyaWVzXT1cXFwiZ3JvdXAuc2VyaWVzXFxcIlxcbiAgICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgW3Nlcmllc05hbWVdPVxcXCJncm91cC5uYW1lXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIFtub0JhcldoZW5aZXJvXT1cXFwibm9CYXJXaGVuWmVyb1xcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICcqJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiAnc2NhbGUoMCknIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBCYXJIb3Jpem9udGFsTm9ybWFsaXplZENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2ZUVudHJpZXMgPSBbXTtcclxuICAgICAgICBfdGhpcy50cmltWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMudHJpbVlBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnJvdGF0ZVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLm1heFhBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLm1heFlBeGlzVGlja0xlbmd0aCA9IDE2O1xyXG4gICAgICAgIF90aGlzLmJhclBhZGRpbmcgPSA4O1xyXG4gICAgICAgIF90aGlzLnJvdW5kRG9tYWlucyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnNob3dEYXRhTGFiZWwgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5ub0JhcldoZW5aZXJvID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xyXG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xyXG4gICAgICAgIF90aGlzLmRhdGFMYWJlbE1heFdpZHRoID0geyBuZWdhdGl2ZTogMCwgcG9zaXRpdmU6IDAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3dEYXRhTGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aCA9IHsgbmVnYXRpdmU6IDAsIHBvc2l0aXZlOiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFyZ2luID0gWzEwLCAyMCArIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgucG9zaXRpdmUsIDEwLCAyMCArIHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmVdO1xyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxyXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXHJcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcclxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXHJcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcclxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cERvbWFpbiA9IHRoaXMuZ2V0R3JvdXBEb21haW4oKTtcclxuICAgICAgICB0aGlzLmlubmVyRG9tYWluID0gdGhpcy5nZXRJbm5lckRvbWFpbigpO1xyXG4gICAgICAgIHRoaXMudmFsdWVEb21haW4gPSB0aGlzLmdldFZhbHVlRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiICwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRHcm91cERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhncm91cC5sYWJlbCkpIHtcclxuICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGdyb3VwLmxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRJbm5lckRvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZ3JvdXAuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLmxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICB2YXIgc21hbGxlc3QgPSAwO1xyXG4gICAgICAgIHZhciBiaWdnZXN0ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHZhciBzbWFsbGVzdFN1bSA9IDA7XHJcbiAgICAgICAgICAgIHZhciBiaWdnZXN0U3VtID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQudmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3RTdW0gKz0gZC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpZ2dlc3RTdW0gKz0gZC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNtYWxsZXN0ID0gZC52YWx1ZSA8IHNtYWxsZXN0ID8gZC52YWx1ZSA6IHNtYWxsZXN0O1xyXG4gICAgICAgICAgICAgICAgYmlnZ2VzdCA9IGQudmFsdWUgPiBiaWdnZXN0ID8gZC52YWx1ZSA6IGJpZ2dlc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG9tYWluLnB1c2goc21hbGxlc3RTdW0pO1xyXG4gICAgICAgICAgICBkb21haW4ucHVzaChiaWdnZXN0U3VtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9tYWluLnB1c2goc21hbGxlc3QpO1xyXG4gICAgICAgIGRvbWFpbi5wdXNoKGJpZ2dlc3QpO1xyXG4gICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBbMF0uY29uY2F0KGRvbWFpbikpO1xyXG4gICAgICAgIHZhciBtYXgkJDEgPSB0aGlzLnhTY2FsZU1heCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIFt0aGlzLnhTY2FsZU1heF0uY29uY2F0KGRvbWFpbikpIDogTWF0aC5tYXguYXBwbHkoTWF0aCwgZG9tYWluKTtcclxuICAgICAgICByZXR1cm4gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5ncm91cERvbWFpbi5sZW5ndGggLyAodGhpcy5kaW1zLmhlaWdodCAvIHRoaXMuYmFyUGFkZGluZyArIDEpO1xyXG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5kaW1zLmhlaWdodF0pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLmdyb3VwRG9tYWluKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WFNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFswLCB0aGlzLmRpbXMud2lkdGhdKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMudmFsdWVEb21haW4pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kRG9tYWlucyA/IHNjYWxlLm5pY2UoKSA6IHNjYWxlO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5ncm91cFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZSgwLCBcIiArIHRoaXMueVNjYWxlKGdyb3VwLm5hbWUpICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSwgZ3JvdXApIHtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW47XHJcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuaW5uZXJEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnZhbHVlRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2hlbWVUeXBlLCBkb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkb21haW46IFtdLFxyXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy52YWx1ZURvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdHM7XHJcbiAgICB9O1xyXG4gICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVlBeGlzV2lkdGggPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkRhdGFMYWJlbE1heFdpZHRoQ2hhbmdlZCA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXBJbmRleCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGV2ZW50JCQxLnNpemUubmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZSA9IE1hdGgubWF4KHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgubmVnYXRpdmUsIGV2ZW50JCQxLnNpemUud2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhXaWR0aC5wb3NpdGl2ZSA9IE1hdGgubWF4KHRoaXMuZGF0YUxhYmVsTWF4V2lkdGgucG9zaXRpdmUsIGV2ZW50JCQxLnNpemUud2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ3JvdXBJbmRleCA9PT0gdGhpcy5yZXN1bHRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGUoKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5yZXN1bHRzXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGcpIHsgcmV0dXJuIGcuc2VyaWVzOyB9KVxyXG4gICAgICAgICAgICAuZmxhdCgpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gaXRlbXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCAhPT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEoaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFlBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFyUGFkZGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZERvbWFpbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVNYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0RhdGFMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFMYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWJhci1ob3Jpem9udGFsLXN0YWNrZWQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImJhci1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbeUF4aXNPZmZzZXRdPVxcXCJkYXRhTGFiZWxNYXhXaWR0aC5uZWdhdGl2ZVxcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgKm5nRm9yPVxcXCJsZXQgZ3JvdXAgb2YgcmVzdWx0czsgbGV0IGluZGV4ID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiZ3JvdXBUcmFuc2Zvcm0oZ3JvdXApXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLXNlcmllcy1ob3Jpem9udGFsXFxuICAgICAgICAgICAgdHlwZT1cXFwic3RhY2tlZFxcXCJcXG4gICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICBbc2VyaWVzXT1cXFwiZ3JvdXAuc2VyaWVzXFxcIlxcbiAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgIFtzZXJpZXNOYW1lXT1cXFwiZ3JvdXAubmFtZVxcXCJcXG4gICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgW3Nob3dEYXRhTGFiZWxdPVxcXCJzaG93RGF0YUxhYmVsXFxcIlxcbiAgICAgICAgICAgIFtkYXRhTGFiZWxGb3JtYXR0aW5nXT1cXFwiZGF0YUxhYmVsRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoZGF0YUxhYmVsV2lkdGhDaGFuZ2VkKT1cXFwib25EYXRhTGFiZWxNYXhXaWR0aENoYW5nZWQoJGV2ZW50LCBpbmRleClcXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAnKidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3NjYWxlKDApJyB9KSlcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgQmFyVmVydGljYWxDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQmFyVmVydGljYWxDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXJWZXJ0aWNhbENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5iYXJQYWRkaW5nID0gODtcclxuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5yb3VuZEVkZ2VzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5zaG93RGF0YUxhYmVsID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICBfdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQgPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvd0RhdGFMYWJlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFMYWJlbE1heEhlaWdodCA9IHsgbmVnYXRpdmU6IDAsIHBvc2l0aXZlOiAwIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFyZ2luID0gWzEwICsgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQucG9zaXRpdmUsIDIwLCAxMCArIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlLCAyMF07XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXHJcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcclxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxyXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcclxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxyXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcclxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcclxuICAgICAgICBpZiAodGhpcy5zaG93RGF0YUxhYmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGltcy5oZWlnaHQgLT0gdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiAsIFwiICsgKHRoaXMubWFyZ2luWzBdICsgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUpICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnhEb21haW4gPSB0aGlzLmdldFhEb21haW4oKTtcclxuICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMueERvbWFpbi5sZW5ndGggLyAodGhpcy5kaW1zLndpZHRoIC8gdGhpcy5iYXJQYWRkaW5nICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgIC5yYW5nZShbMCwgdGhpcy5kaW1zLndpZHRoXSlcclxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcihzcGFjaW5nKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMueERvbWFpbik7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLmdldFlTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnlEb21haW4gPSB0aGlzLmdldFlEb21haW4oKTtcclxuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbdGhpcy5kaW1zLmhlaWdodCwgMF0pXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy55RG9tYWluKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5sYWJlbDsgfSk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pO1xyXG4gICAgICAgIHZhciBtaW4kJDEgPSB0aGlzLnlTY2FsZU1pbiA/IE1hdGgubWluLmFwcGx5KE1hdGgsIFt0aGlzLnlTY2FsZU1pbl0uY29uY2F0KHZhbHVlcykpIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgWzBdLmNvbmNhdCh2YWx1ZXMpKTtcclxuICAgICAgICBpZiAodGhpcy55QXhpc1RpY2tzICYmICF0aGlzLnlBeGlzVGlja3Muc29tZShpc05hTikpIHtcclxuICAgICAgICAgICAgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgW21pbiQkMV0uY29uY2F0KHRoaXMueUF4aXNUaWNrcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy55U2NhbGVNYXggPyBNYXRoLm1heC5hcHBseShNYXRoLCBbdGhpcy55U2NhbGVNYXhdLmNvbmNhdCh2YWx1ZXMpKSA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIFswXS5jb25jYXQodmFsdWVzKSk7XHJcbiAgICAgICAgaWYgKHRoaXMueUF4aXNUaWNrcyAmJiAhdGhpcy55QXhpc1RpY2tzLnNvbWUoaXNOYU4pKSB7XHJcbiAgICAgICAgICAgIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIFttYXgkJDFdLmNvbmNhdCh0aGlzLnlBeGlzVGlja3MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnhEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnlEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGRvbWFpbjogW10sXHJcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMueERvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycztcclxuICAgICAgICAgICAgb3B0cy50aXRsZSA9IHRoaXMubGVnZW5kVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMueURvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdHM7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVlBeGlzV2lkdGggPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5vbkRhdGFMYWJlbE1heEhlaWdodENoYW5nZWQgPSBmdW5jdGlvbiAoZXZlbnQkJDEpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChldmVudCQkMS5zaXplLm5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUsIGV2ZW50JCQxLnNpemUuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0LnBvc2l0aXZlID0gTWF0aC5tYXgodGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQucG9zaXRpdmUsIGV2ZW50JCQxLnNpemUuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50JCQxLmluZGV4ID09PSB0aGlzLnJlc3VsdHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVwZGF0ZSgpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0cy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWUgJiYgZC5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0cy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWUgJiYgZC5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2hlbWVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImJhclBhZGRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRWRnZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0RhdGFMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFMYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYyA6IE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIEJhclZlcnRpY2FsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWJhci12ZXJ0aWNhbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHRydWUpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB0cnVlKVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJiYXItY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbeEF4aXNPZmZzZXRdPVxcXCJkYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmVcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXNlcmllcy12ZXJ0aWNhbFxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICBbc2VyaWVzXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgW3Nob3dEYXRhTGFiZWxdPVxcXCJzaG93RGF0YUxhYmVsXFxcIlxcbiAgICAgICAgICBbZGF0YUxhYmVsRm9ybWF0dGluZ109XFxcImRhdGFMYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgW3JvdW5kRWRnZXNdPVxcXCJyb3VuZEVkZ2VzXFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIFtub0JhcldoZW5aZXJvXT1cXFwibm9CYXJXaGVuWmVyb1xcXCJcXG4gICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAoZGF0YUxhYmVsSGVpZ2h0Q2hhbmdlZCk9XFxcIm9uRGF0YUxhYmVsTWF4SGVpZ2h0Q2hhbmdlZCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEJhclZlcnRpY2FsQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBCYXJWZXJ0aWNhbENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJhclZlcnRpY2FsMkRDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnNjYWxlVHlwZSA9ICdvcmRpbmFsJztcclxuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5ncm91cFBhZGRpbmcgPSAxNjtcclxuICAgICAgICBfdGhpcy5iYXJQYWRkaW5nID0gODtcclxuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5yb3VuZEVkZ2VzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5zaG93RGF0YUxhYmVsID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICBfdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQgPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICghdGhpcy5zaG93RGF0YUxhYmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0ID0geyBuZWdhdGl2ZTogMCwgcG9zaXRpdmU6IDAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXJnaW4gPSBbMTAgKyB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5wb3NpdGl2ZSwgMjAsIDEwICsgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUsIDIwXTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0RhdGFMYWJlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpbXMuaGVpZ2h0IC09IHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cERvbWFpbiA9IHRoaXMuZ2V0R3JvdXBEb21haW4oKTtcclxuICAgICAgICB0aGlzLmlubmVyRG9tYWluID0gdGhpcy5nZXRJbm5lckRvbWFpbigpO1xyXG4gICAgICAgIHRoaXMudmFsdWVzRG9tYWluID0gdGhpcy5nZXRWYWx1ZURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBTY2FsZSA9IHRoaXMuZ2V0R3JvdXBTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuaW5uZXJTY2FsZSA9IHRoaXMuZ2V0SW5uZXJTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMudmFsdWVTY2FsZSA9IHRoaXMuZ2V0VmFsdWVTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArICh0aGlzLm1hcmdpblswXSArIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlKSArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLm9uRGF0YUxhYmVsTWF4SGVpZ2h0Q2hhbmdlZCA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXBJbmRleCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGV2ZW50JCQxLnNpemUubmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZSwgZXZlbnQkJDEuc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQucG9zaXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5wb3NpdGl2ZSwgZXZlbnQkJDEuc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ3JvdXBJbmRleCA9PT0gdGhpcy5yZXN1bHRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGUoKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLmdldEdyb3VwU2NhbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLmdyb3VwRG9tYWluLmxlbmd0aCAvICh0aGlzLmRpbXMuaGVpZ2h0IC8gdGhpcy5ncm91cFBhZGRpbmcgKyAxKTtcclxuICAgICAgICByZXR1cm4gc2NhbGVCYW5kKClcclxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHRoaXMuZGltcy53aWR0aF0pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcclxuICAgICAgICAgICAgLnBhZGRpbmdPdXRlcihzcGFjaW5nIC8gMilcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLmdyb3VwRG9tYWluKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRJbm5lclNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ3JvdXBTY2FsZS5iYW5kd2lkdGgoKTtcclxuICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMuaW5uZXJEb21haW4ubGVuZ3RoIC8gKHdpZHRoIC8gdGhpcy5iYXJQYWRkaW5nICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB3aWR0aF0pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoc3BhY2luZylcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLmlubmVyRG9tYWluKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZVNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFt0aGlzLmRpbXMuaGVpZ2h0LCAwXSlcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnZhbHVlc0RvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZ3JvdXAubGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBkb21haW4ucHVzaChncm91cC5sYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5nZXRJbm5lckRvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZ3JvdXAuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLmxhYmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgWzBdLmNvbmNhdChkb21haW4pKTtcclxuICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy55U2NhbGVNYXggPyBNYXRoLm1heC5hcHBseShNYXRoLCBbdGhpcy55U2NhbGVNYXhdLmNvbmNhdChkb21haW4pKSA6IE1hdGgubWF4LmFwcGx5KE1hdGgsIFswXS5jb25jYXQoZG9tYWluKSk7XHJcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ3JvdXBUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmdyb3VwU2NhbGUoZ3JvdXAubGFiZWwpICsgXCIsIDApXCI7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhLCBncm91cCkge1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgICBkYXRhLnNlcmllcyA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW47XHJcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMuaW5uZXJEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnZhbHVlc0RvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkb21haW46IFtdLFxyXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy52YWx1ZXNEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRzO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVlBeGlzV2lkdGggPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVhBeGlzSGVpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXAsIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQkJDEpO1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgICBpdGVtLnNlcmllcyA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMucmVzdWx0c1xyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChnKSB7IHJldHVybiBnLnNlcmllczsgfSlcclxuICAgICAgICAgICAgLmZsYXQoKVxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IGl0ZW1zLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCAhPT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEoaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93R3JpZExpbmVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cFBhZGRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImJhclBhZGRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZERvbWFpbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZEVkZ2VzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93RGF0YUxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhTGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWwyRENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsMkRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtYmFyLXZlcnRpY2FsLTJkJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgdW5kZWZpbmVkLCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgdW5kZWZpbmVkLCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJiYXItY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtZ3JpZC1wYW5lbC1zZXJpZXNcXG4gICAgICAgICAgW3hTY2FsZV09XFxcImdyb3VwU2NhbGVcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ2YWx1ZVNjYWxlXFxcIlxcbiAgICAgICAgICBbZGF0YV09XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgb3JpZW50PVxcXCJ2ZXJ0aWNhbFxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcImdyb3VwU2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3hBeGlzT2Zmc2V0XT1cXFwiZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVYQXhpc0hlaWdodCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbeVNjYWxlXT1cXFwidmFsdWVTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhZQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInlBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtc2VyaWVzLXZlcnRpY2FsXFxuICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGdyb3VwIG9mIHJlc3VsdHM7IGxldCBpbmRleCA9IGluZGV4OyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcImdyb3VwVHJhbnNmb3JtKGdyb3VwKVxcXCJcXG4gICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwiaW5uZXJTY2FsZVxcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInZhbHVlU2NhbGVcXFwiXFxuICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgIFtzZXJpZXNdPVxcXCJncm91cC5zZXJpZXNcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgIFtzaG93RGF0YUxhYmVsXT1cXFwic2hvd0RhdGFMYWJlbFxcXCJcXG4gICAgICAgICAgW2RhdGFMYWJlbEZvcm1hdHRpbmddPVxcXCJkYXRhTGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbc2VyaWVzTmFtZV09XFxcImdyb3VwLm5hbWVcXFwiXFxuICAgICAgICAgIFtyb3VuZEVkZ2VzXT1cXFwicm91bmRFZGdlc1xcXCJcXG4gICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgKGRhdGFMYWJlbEhlaWdodENoYW5nZWQpPVxcXCJvbkRhdGFMYWJlbE1heEhlaWdodENoYW5nZWQoJGV2ZW50LCBpbmRleClcXFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAnKidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3NjYWxlKDApJyB9KSlcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBCYXJWZXJ0aWNhbDJEQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kVGl0bGUgPSAnTGVnZW5kJztcclxuICAgICAgICBfdGhpcy5sZWdlbmRQb3NpdGlvbiA9ICdyaWdodCc7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuc2hvd0dyaWRMaW5lcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMuYmFyUGFkZGluZyA9IDg7XHJcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxyXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXHJcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcclxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXHJcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcclxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cERvbWFpbiA9IHRoaXMuZ2V0R3JvdXBEb21haW4oKTtcclxuICAgICAgICB0aGlzLmlubmVyRG9tYWluID0gdGhpcy5nZXRJbm5lckRvbWFpbigpO1xyXG4gICAgICAgIHRoaXMudmFsdWVEb21haW4gPSB0aGlzLmdldFZhbHVlRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLmRpbXMueE9mZnNldCArIFwiICwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZ3JvdXAubGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBkb21haW4ucHVzaChncm91cC5sYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldElubmVyRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGQubGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5sYWJlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbMCwgMTAwXTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMuZ3JvdXBEb21haW4ubGVuZ3RoIC8gKHRoaXMuZGltcy53aWR0aCAvIHRoaXMuYmFyUGFkZGluZyArIDEpO1xyXG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5kaW1zLndpZHRoXSlcclxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcihzcGFjaW5nKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMuZ3JvdXBEb21haW4pO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFt0aGlzLmRpbXMuaGVpZ2h0LCAwXSlcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnZhbHVlRG9tYWluKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLmdyb3VwVHJhbnNmb3JtID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy54U2NhbGUoZ3JvdXAubmFtZSkgKyBcIiwgMClcIjtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSwgZ3JvdXApIHtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbjtcclxuICAgICAgICBpZiAodGhpcy5zY2hlbWVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy5pbm5lckRvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMudmFsdWVEb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0cyA9IHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGNvbG9yczogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkb21haW46IFtdLFxyXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdHMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy52YWx1ZURvbWFpbjtcclxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSB0aGlzLmNvbG9ycy5zY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdHM7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVhBeGlzSGVpZ2h0ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICB0aGlzLnhBeGlzSGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5yZXN1bHRzXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGcpIHsgcmV0dXJuIGcuc2VyaWVzOyB9KVxyXG4gICAgICAgICAgICAuZmxhdCgpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLmxhYmVsID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gaXRlbXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgIT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhKGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1YQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRlWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhYQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcImJhclBhZGRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudC5wcm90b3R5cGUsIFwibm9CYXJXaGVuWmVyb1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1iYXItdmVydGljYWwtbm9ybWFsaXplZCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIHVuZGVmaW5lZCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiYmFyLWNoYXJ0IGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXgtYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieEF4aXNcXFwiXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhZQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInlBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGdyb3VwIG9mIHJlc3VsdHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiZ3JvdXBUcmFuc2Zvcm0oZ3JvdXApXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLXNlcmllcy12ZXJ0aWNhbFxcbiAgICAgICAgICAgIHR5cGU9XFxcIm5vcm1hbGl6ZWRcXFwiXFxuICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgIFtzZXJpZXNdPVxcXCJncm91cC5zZXJpZXNcXFwiXFxuICAgICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICBbc2VyaWVzTmFtZV09XFxcImdyb3VwLm5hbWVcXFwiXFxuICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIFtub0JhcldoZW5aZXJvXT1cXFwibm9CYXJXaGVuWmVyb1xcXCJcXG4gICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgZ3JvdXApXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJyonXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICdzY2FsZSgwKScgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQmFyVmVydGljYWxOb3JtYWxpemVkQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgX3RoaXMudHJpbVhBeGlzVGlja3MgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5yb3RhdGVYQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5tYXhYQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5iYXJQYWRkaW5nID0gODtcclxuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zaG93RGF0YUxhYmVsID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubm9CYXJXaGVuWmVybyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICBfdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQgPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3dEYXRhTGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQgPSB7IG5lZ2F0aXZlOiAwLCBwb3NpdGl2ZTogMCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hcmdpbiA9IFsxMCArIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0LnBvc2l0aXZlLCAyMCwgMTAgKyB0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZSwgMjBdO1xyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxyXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXHJcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcclxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXHJcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcclxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5zaG93RGF0YUxhYmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGltcy5oZWlnaHQgLT0gdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcclxuICAgICAgICB0aGlzLmdyb3VwRG9tYWluID0gdGhpcy5nZXRHcm91cERvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuaW5uZXJEb21haW4gPSB0aGlzLmdldElubmVyRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZURvbWFpbiA9IHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArICh0aGlzLm1hcmdpblswXSArIHRoaXMuZGF0YUxhYmVsTWF4SGVpZ2h0Lm5lZ2F0aXZlKSArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JvdXBEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZ3JvdXAubGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBkb21haW4ucHVzaChncm91cC5sYWJlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldElubmVyRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBncm91cC5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGQubGFiZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5sYWJlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICB2YXIgc21hbGxlc3QgPSAwO1xyXG4gICAgICAgIHZhciBiaWdnZXN0ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHZhciBzbWFsbGVzdFN1bSA9IDA7XHJcbiAgICAgICAgICAgIHZhciBiaWdnZXN0U3VtID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGQudmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3RTdW0gKz0gZC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpZ2dlc3RTdW0gKz0gZC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNtYWxsZXN0ID0gZC52YWx1ZSA8IHNtYWxsZXN0ID8gZC52YWx1ZSA6IHNtYWxsZXN0O1xyXG4gICAgICAgICAgICAgICAgYmlnZ2VzdCA9IGQudmFsdWUgPiBiaWdnZXN0ID8gZC52YWx1ZSA6IGJpZ2dlc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG9tYWluLnB1c2goc21hbGxlc3RTdW0pO1xyXG4gICAgICAgICAgICBkb21haW4ucHVzaChiaWdnZXN0U3VtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9tYWluLnB1c2goc21hbGxlc3QpO1xyXG4gICAgICAgIGRvbWFpbi5wdXNoKGJpZ2dlc3QpO1xyXG4gICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBbMF0uY29uY2F0KGRvbWFpbikpO1xyXG4gICAgICAgIHZhciBtYXgkJDEgPSB0aGlzLnlTY2FsZU1heCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIFt0aGlzLnlTY2FsZU1heF0uY29uY2F0KGRvbWFpbikpIDogTWF0aC5tYXguYXBwbHkoTWF0aCwgZG9tYWluKTtcclxuICAgICAgICByZXR1cm4gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMuZ3JvdXBEb21haW4ubGVuZ3RoIC8gKHRoaXMuZGltcy53aWR0aCAvIHRoaXMuYmFyUGFkZGluZyArIDEpO1xyXG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5kaW1zLndpZHRoXSlcclxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcihzcGFjaW5nKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMuZ3JvdXBEb21haW4pO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFt0aGlzLmRpbXMuaGVpZ2h0LCAwXSlcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnZhbHVlRG9tYWluKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLm9uRGF0YUxhYmVsTWF4SGVpZ2h0Q2hhbmdlZCA9IGZ1bmN0aW9uIChldmVudCQkMSwgZ3JvdXBJbmRleCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGV2ZW50JCQxLnNpemUubmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5uZWdhdGl2ZSwgZXZlbnQkJDEuc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhTGFiZWxNYXhIZWlnaHQucG9zaXRpdmUgPSBNYXRoLm1heCh0aGlzLmRhdGFMYWJlbE1heEhlaWdodC5wb3NpdGl2ZSwgZXZlbnQkJDEuc2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ3JvdXBJbmRleCA9PT0gdGhpcy5yZXN1bHRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGUoKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUuZ3JvdXBUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnhTY2FsZShncm91cC5uYW1lKSArIFwiLCAwKVwiO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhLCBncm91cCkge1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgICBkYXRhLnNlcmllcyA9IGdyb3VwLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLmlubmVyRG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9tYWluID0gdGhpcy52YWx1ZURvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGRvbWFpbjogW10sXHJcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuaW5uZXJEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnM7XHJcbiAgICAgICAgICAgIG9wdHMudGl0bGUgPSB0aGlzLmxlZ2VuZFRpdGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnZhbHVlRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVlBeGlzV2lkdGggPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnJlc3VsdHNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZykgeyByZXR1cm4gZy5zZXJpZXM7IH0pXHJcbiAgICAgICAgICAgIC5mbGF0KClcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBpdGVtcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5sYWJlbCAhPT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEoaS5uYW1lID09PSBpdGVtLm5hbWUgJiYgaS5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFBvc2l0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dYQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dZQXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2NoZW1lVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFyUGFkZGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZU1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0RhdGFMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhTGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub0JhcldoZW5aZXJvXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWJhci12ZXJ0aWNhbC1zdGFja2VkJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgdW5kZWZpbmVkLCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgdW5kZWZpbmVkLCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJiYXItY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteC1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ4QXhpc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1hBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyb3RhdGVUaWNrc109XFxcInJvdGF0ZVhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WEF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ4QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbeEF4aXNPZmZzZXRdPVxcXCJkYXRhTGFiZWxNYXhIZWlnaHQubmVnYXRpdmVcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbdGlja3NdPVxcXCJ5QXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAqbmdGb3I9XFxcImxldCBncm91cCBvZiByZXN1bHRzOyBsZXQgaW5kZXggPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeVxcXCJcXG4gICAgICAgICAgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIlxcbiAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJncm91cFRyYW5zZm9ybShncm91cClcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgIG5neC1jaGFydHMtc2VyaWVzLXZlcnRpY2FsXFxuICAgICAgICAgICAgdHlwZT1cXFwic3RhY2tlZFxcXCJcXG4gICAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgW3Nlcmllc109XFxcImdyb3VwLnNlcmllc1xcXCJcXG4gICAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgIFtzaG93RGF0YUxhYmVsXT1cXFwic2hvd0RhdGFMYWJlbFxcXCJcXG4gICAgICAgICAgICBbZGF0YUxhYmVsRm9ybWF0dGluZ109XFxcImRhdGFMYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgICAgW3Nlcmllc05hbWVdPVxcXCJncm91cC5uYW1lXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICBbbm9CYXJXaGVuWmVyb109XFxcIm5vQmFyV2hlblplcm9cXFwiXFxuICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50LCBncm91cClcXFwiXFxuICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQsIGdyb3VwKVxcXCJcXG4gICAgICAgICAgICAoZGF0YUxhYmVsSGVpZ2h0Q2hhbmdlZCk9XFxcIm9uRGF0YUxhYmVsTWF4SGVpZ2h0Q2hhbmdlZCgkZXZlbnQsIGluZGV4KVxcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIl0sXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICcqJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiAnc2NhbGUoMCknIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEQwVHlwZXM7XHJcbihmdW5jdGlvbiAoRDBUeXBlcykge1xyXG4gICAgRDBUeXBlc1tcInBvc2l0aXZlXCJdID0gXCJwb3NpdGl2ZVwiO1xyXG4gICAgRDBUeXBlc1tcIm5lZ2F0aXZlXCJdID0gXCJuZWdhdGl2ZVwiO1xyXG59KShEMFR5cGVzIHx8IChEMFR5cGVzID0ge30pKTtcclxudmFyIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2VyaWVzVmVydGljYWxDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3N0YW5kYXJkJztcclxuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zaG93RGF0YUxhYmVsID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ub0JhcldoZW5aZXJvID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRhdGFMYWJlbEhlaWdodENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5iYXJzRm9yRGF0YUxhYmVscyA9IFtdO1xyXG4gICAgfVxyXG4gICAgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwU2V0dGluZ3MoKTtcclxuICAgICAgICB2YXIgd2lkdGg7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VyaWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMueFNjYWxlLmJhbmR3aWR0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xyXG4gICAgICAgIHZhciB5U2NhbGVNaW4gPSBNYXRoLm1heCh0aGlzLnlTY2FsZS5kb21haW4oKVswXSwgMCk7XHJcbiAgICAgICAgdmFyIGQwID0gKF9hID0ge30sXHJcbiAgICAgICAgICAgIF9hW0QwVHlwZXMucG9zaXRpdmVdID0gMCxcclxuICAgICAgICAgICAgX2FbRDBUeXBlcy5uZWdhdGl2ZV0gPSAwLFxyXG4gICAgICAgICAgICBfYSk7XHJcbiAgICAgICAgdmFyIGQwVHlwZSA9IEQwVHlwZXMucG9zaXRpdmU7XHJcbiAgICAgICAgdmFyIHRvdGFsO1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdub3JtYWxpemVkJykge1xyXG4gICAgICAgICAgICB0b3RhbCA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIHN1bSArIGQ7IH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJhcnMgPSB0aGlzLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGQudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IF90aGlzLmdldExhYmVsKGQpO1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCk7XHJcbiAgICAgICAgICAgIHZhciByb3VuZEVkZ2VzID0gX3RoaXMucm91bmRFZGdlcztcclxuICAgICAgICAgICAgZDBUeXBlID0gdmFsdWUgPiAwID8gRDBUeXBlcy5wb3NpdGl2ZSA6IEQwVHlwZXMubmVnYXRpdmU7XHJcbiAgICAgICAgICAgIHZhciBiYXIgPSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXHJcbiAgICAgICAgICAgICAgICByb3VuZEVkZ2VzOiByb3VuZEVkZ2VzLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogZCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZExhYmVsOiBmb3JtYXR0ZWRMYWJlbCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcclxuICAgICAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgICAgICB5OiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy50eXBlID09PSAnc3RhbmRhcmQnKSB7XHJcbiAgICAgICAgICAgICAgICBiYXIuaGVpZ2h0ID0gTWF0aC5hYnMoX3RoaXMueVNjYWxlKHZhbHVlKSAtIF90aGlzLnlTY2FsZSh5U2NhbGVNaW4pKTtcclxuICAgICAgICAgICAgICAgIGJhci54ID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXIueSA9IF90aGlzLnlTY2FsZSgwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhci55ID0gX3RoaXMueVNjYWxlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy50eXBlID09PSAnc3RhY2tlZCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQwID0gZDBbZDBUeXBlXTtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQxID0gb2Zmc2V0MCArIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZDBbZDBUeXBlXSArPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJhci5oZWlnaHQgPSBfdGhpcy55U2NhbGUob2Zmc2V0MCkgLSBfdGhpcy55U2NhbGUob2Zmc2V0MSk7XHJcbiAgICAgICAgICAgICAgICBiYXIueCA9IDA7XHJcbiAgICAgICAgICAgICAgICBiYXIueSA9IF90aGlzLnlTY2FsZShvZmZzZXQxKTtcclxuICAgICAgICAgICAgICAgIGJhci5vZmZzZXQwID0gb2Zmc2V0MDtcclxuICAgICAgICAgICAgICAgIGJhci5vZmZzZXQxID0gb2Zmc2V0MTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy50eXBlID09PSAnbm9ybWFsaXplZCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQwID0gZDBbZDBUeXBlXTtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQxID0gb2Zmc2V0MCArIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZDBbZDBUeXBlXSArPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0b3RhbCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQwID0gKG9mZnNldDAgKiAxMDApIC8gdG90YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MSA9IChvZmZzZXQxICogMTAwKSAvIHRvdGFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0MSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBiYXIuaGVpZ2h0ID0gX3RoaXMueVNjYWxlKG9mZnNldDApIC0gX3RoaXMueVNjYWxlKG9mZnNldDEpO1xyXG4gICAgICAgICAgICAgICAgYmFyLnggPSAwO1xyXG4gICAgICAgICAgICAgICAgYmFyLnkgPSBfdGhpcy55U2NhbGUob2Zmc2V0MSk7XHJcbiAgICAgICAgICAgICAgICBiYXIub2Zmc2V0MCA9IG9mZnNldDA7XHJcbiAgICAgICAgICAgICAgICBiYXIub2Zmc2V0MSA9IG9mZnNldDE7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IChvZmZzZXQxIC0gb2Zmc2V0MCkudG9GaXhlZCgyKSArICclJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgICAgICBiYXIuY29sb3IgPSBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IobGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnR5cGUgPT09ICdzdGFuZGFyZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXIuY29sb3IgPSBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhci5ncmFkaWVudFN0b3BzID0gX3RoaXMuY29sb3JzLmdldExpbmVhckdyYWRpZW50U3RvcHModmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFyLmNvbG9yID0gX3RoaXMuY29sb3JzLmdldENvbG9yKGJhci5vZmZzZXQxKTtcclxuICAgICAgICAgICAgICAgICAgICBiYXIuZ3JhZGllbnRTdG9wcyA9IF90aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKGJhci5vZmZzZXQxLCBiYXIub2Zmc2V0MCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRvb2x0aXBMYWJlbCA9IGZvcm1hdHRlZExhYmVsO1xyXG4gICAgICAgICAgICBiYXIuYXJpYUxhYmVsID0gZm9ybWF0dGVkTGFiZWwgKyAnICcgKyB2YWx1ZS50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuc2VyaWVzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcExhYmVsID0gX3RoaXMuc2VyaWVzTmFtZSArIFwiIFxcdTIwMjIgXCIgKyBmb3JtYXR0ZWRMYWJlbDtcclxuICAgICAgICAgICAgICAgIGJhci5kYXRhLnNlcmllcyA9IF90aGlzLnNlcmllc05hbWU7XHJcbiAgICAgICAgICAgICAgICBiYXIuYXJpYUxhYmVsID0gX3RoaXMuc2VyaWVzTmFtZSArICcgJyArIGJhci5hcmlhTGFiZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmFyLnRvb2x0aXBUZXh0ID0gX3RoaXMudG9vbHRpcERpc2FibGVkXHJcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgOiBcIlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtbGFiZWxcXFwiPlwiICsgdG9vbHRpcExhYmVsICsgXCI8L3NwYW4+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC12YWxcXFwiPlwiICsgdmFsdWUudG9Mb2NhbGVTdHJpbmcoKSArIFwiPC9zcGFuPlxcbiAgICAgIFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gYmFyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRGF0YUxhYmVscygpO1xyXG4gICAgfTtcclxuICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVEYXRhTGFiZWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3N0YWNrZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFyc0ZvckRhdGFMYWJlbHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSB7fTtcclxuICAgICAgICAgICAgc2VjdGlvbi5zZXJpZXMgPSB0aGlzLnNlcmllc05hbWU7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbFBvc2l0aXZlID0gdGhpcy5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgZCkgeyByZXR1cm4gKGQgPiAwID8gc3VtICsgZCA6IHN1bSk7IH0sIDApO1xyXG4gICAgICAgICAgICB2YXIgdG90YWxOZWdhdGl2ZSA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIChkIDwgMCA/IHN1bSArIGQgOiBzdW0pOyB9LCAwKTtcclxuICAgICAgICAgICAgc2VjdGlvbi50b3RhbCA9IHRvdGFsUG9zaXRpdmUgKyB0b3RhbE5lZ2F0aXZlO1xyXG4gICAgICAgICAgICBzZWN0aW9uLnggPSAwO1xyXG4gICAgICAgICAgICBzZWN0aW9uLnkgPSAwO1xyXG4gICAgICAgICAgICBpZiAoc2VjdGlvbi50b3RhbCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb24uaGVpZ2h0ID0gdGhpcy55U2NhbGUodG90YWxQb3NpdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLmhlaWdodCA9IHRoaXMueVNjYWxlKHRvdGFsTmVnYXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlY3Rpb24ud2lkdGggPSB0aGlzLnhTY2FsZS5iYW5kd2lkdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5iYXJzRm9yRGF0YUxhYmVscy5wdXNoKHNlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5iYXJzRm9yRGF0YUxhYmVscyA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb24uc2VyaWVzID0gX3RoaXMuc2VyaWVzTmFtZSA/IF90aGlzLnNlcmllc05hbWUgOiBkLmxhYmVsO1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi50b3RhbCA9IGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnggPSBfdGhpcy54U2NhbGUoZC5sYWJlbCk7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnkgPSBfdGhpcy55U2NhbGUoMCk7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLmhlaWdodCA9IF90aGlzLnlTY2FsZShzZWN0aW9uLnRvdGFsKSAtIF90aGlzLnlTY2FsZSgwKTtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb24ud2lkdGggPSBfdGhpcy54U2NhbGUuYmFuZHdpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVUb29sdGlwU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50b29sdGlwUGxhY2VtZW50ID0gdGhpcy50b29sdGlwRGlzYWJsZWQgPyB1bmRlZmluZWQgOiAndG9wJztcclxuICAgICAgICB0aGlzLnRvb2x0aXBUeXBlID0gdGhpcy50b29sdGlwRGlzYWJsZWQgPyB1bmRlZmluZWQgOiAndG9vbHRpcCc7XHJcbiAgICB9O1xyXG4gICAgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWUgJiYgZW50cnkuc2VyaWVzID09PSBkLnNlcmllcztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMYWJlbCA9IGZ1bmN0aW9uIChkYXRhSXRlbSkge1xyXG4gICAgICAgIGlmIChkYXRhSXRlbS5sYWJlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW0ubGFiZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhSXRlbS5uYW1lO1xyXG4gICAgfTtcclxuICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBiYXIpIHtcclxuICAgICAgICByZXR1cm4gYmFyLmxhYmVsO1xyXG4gICAgfTtcclxuICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0RhdGFMYWJlbEJ5ID0gZnVuY3Rpb24gKGluZGV4LCBiYXJMYWJlbCkge1xyXG4gICAgICAgIHJldHVybiBpbmRleCArICcjJyArIGJhckxhYmVsLnNlcmllcyArICcjJyArIGJhckxhYmVsLnRvdGFsO1xyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc05hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRWRnZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93RGF0YUxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YUxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub0JhcldoZW5aZXJvXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzVmVydGljYWxDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFMYWJlbEhlaWdodENoYW5nZWRcIiwgdm9pZCAwKTtcclxuICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtc2VyaWVzLXZlcnRpY2FsXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOmdcXG4gICAgICBuZ3gtY2hhcnRzLWJhclxcbiAgICAgICpuZ0Zvcj1cXFwibGV0IGJhciBvZiBiYXJzOyB0cmFja0J5OiB0cmFja0J5XFxcIlxcbiAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICBbQC5kaXNhYmxlZF09XFxcIiFhbmltYXRpb25zXFxcIlxcbiAgICAgIFt3aWR0aF09XFxcImJhci53aWR0aFxcXCJcXG4gICAgICBbaGVpZ2h0XT1cXFwiYmFyLmhlaWdodFxcXCJcXG4gICAgICBbeF09XFxcImJhci54XFxcIlxcbiAgICAgIFt5XT1cXFwiYmFyLnlcXFwiXFxuICAgICAgW2ZpbGxdPVxcXCJiYXIuY29sb3JcXFwiXFxuICAgICAgW3N0b3BzXT1cXFwiYmFyLmdyYWRpZW50U3RvcHNcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJiYXIuZGF0YVxcXCJcXG4gICAgICBbb3JpZW50YXRpb25dPVxcXCIndmVydGljYWwnXFxcIlxcbiAgICAgIFtyb3VuZEVkZ2VzXT1cXFwiYmFyLnJvdW5kRWRnZXNcXFwiXFxuICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgW2FyaWFMYWJlbF09XFxcImJhci5hcmlhTGFiZWxcXFwiXFxuICAgICAgW2lzQWN0aXZlXT1cXFwiaXNBY3RpdmUoYmFyLmRhdGEpXFxcIlxcbiAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgKGFjdGl2YXRlKT1cXFwiYWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgIChkZWFjdGl2YXRlKT1cXFwiZGVhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgbmd4LXRvb2x0aXBcXG4gICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cXFwidG9vbHRpcFBsYWNlbWVudFxcXCJcXG4gICAgICBbdG9vbHRpcFR5cGVdPVxcXCJ0b29sdGlwVHlwZVxcXCJcXG4gICAgICBbdG9vbHRpcFRpdGxlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogYmFyLnRvb2x0aXBUZXh0XFxcIlxcbiAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgW3Rvb2x0aXBDb250ZXh0XT1cXFwiYmFyLmRhdGFcXFwiXFxuICAgICAgW25vQmFyV2hlblplcm9dPVxcXCJub0JhcldoZW5aZXJvXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgPjwvc3ZnOmc+XFxuICAgIDxzdmc6ZyAqbmdJZj1cXFwic2hvd0RhdGFMYWJlbFxcXCI+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLWJhci1sYWJlbFxcbiAgICAgICAgKm5nRm9yPVxcXCJsZXQgYiBvZiBiYXJzRm9yRGF0YUxhYmVsczsgbGV0IGkgPSBpbmRleDsgdHJhY2tCeTogdHJhY2tEYXRhTGFiZWxCeVxcXCJcXG4gICAgICAgIFtiYXJYXT1cXFwiYi54XFxcIlxcbiAgICAgICAgW2JhclldPVxcXCJiLnlcXFwiXFxuICAgICAgICBbYmFyV2lkdGhdPVxcXCJiLndpZHRoXFxcIlxcbiAgICAgICAgW2JhckhlaWdodF09XFxcImIuaGVpZ2h0XFxcIlxcbiAgICAgICAgW3ZhbHVlXT1cXFwiYi50b3RhbFxcXCJcXG4gICAgICAgIFt2YWx1ZUZvcm1hdHRpbmddPVxcXCJkYXRhTGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgW29yaWVudGF0aW9uXT1cXFwiJ3ZlcnRpY2FsJ1xcXCJcXG4gICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcImRhdGFMYWJlbEhlaWdodENoYW5nZWQuZW1pdCh7IHNpemU6ICRldmVudCwgaW5kZXg6IGkgfSlcXFwiXFxuICAgICAgLz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBTZXJpZXNIb3Jpem9udGFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2VyaWVzSG9yaXpvbnRhbCgpIHtcclxuICAgICAgICB0aGlzLmJhcnNGb3JEYXRhTGFiZWxzID0gW107XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3N0YW5kYXJkJztcclxuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zaG93RGF0YUxhYmVsID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ub0JhcldoZW5aZXJvID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRhdGFMYWJlbFdpZHRoQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBTZXR0aW5ncygpO1xyXG4gICAgICAgIHZhciBkMCA9IChfYSA9IHt9LFxyXG4gICAgICAgICAgICBfYVtEMFR5cGVzLnBvc2l0aXZlXSA9IDAsXHJcbiAgICAgICAgICAgIF9hW0QwVHlwZXMubmVnYXRpdmVdID0gMCxcclxuICAgICAgICAgICAgX2EpO1xyXG4gICAgICAgIHZhciBkMFR5cGU7XHJcbiAgICAgICAgZDBUeXBlID0gRDBUeXBlcy5wb3NpdGl2ZTtcclxuICAgICAgICB2YXIgdG90YWw7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ25vcm1hbGl6ZWQnKSB7XHJcbiAgICAgICAgICAgIHRvdGFsID0gdGhpcy5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgZCkgeyByZXR1cm4gc3VtICsgZDsgfSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB4U2NhbGVNaW4gPSBNYXRoLm1heCh0aGlzLnhTY2FsZS5kb21haW4oKVswXSwgMCk7XHJcbiAgICAgICAgdGhpcy5iYXJzID0gdGhpcy5zZXJpZXMubWFwKGZ1bmN0aW9uIChkLCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkLnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBfdGhpcy5nZXRMYWJlbChkKTtcclxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwpO1xyXG4gICAgICAgICAgICB2YXIgcm91bmRFZGdlcyA9IF90aGlzLnJvdW5kRWRnZXM7XHJcbiAgICAgICAgICAgIGQwVHlwZSA9IHZhbHVlID4gMCA/IEQwVHlwZXMucG9zaXRpdmUgOiBEMFR5cGVzLm5lZ2F0aXZlO1xyXG4gICAgICAgICAgICB2YXIgYmFyID0ge1xyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxyXG4gICAgICAgICAgICAgICAgcm91bmRFZGdlczogcm91bmRFZGdlcyxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGQsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRMYWJlbDogZm9ybWF0dGVkTGFiZWxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYmFyLmhlaWdodCA9IF90aGlzLnlTY2FsZS5iYW5kd2lkdGgoKTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnR5cGUgPT09ICdzdGFuZGFyZCcpIHtcclxuICAgICAgICAgICAgICAgIGJhci53aWR0aCA9IE1hdGguYWJzKF90aGlzLnhTY2FsZSh2YWx1ZSkgLSBfdGhpcy54U2NhbGUoeFNjYWxlTWluKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFyLnggPSBfdGhpcy54U2NhbGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFyLnggPSBfdGhpcy54U2NhbGUoeFNjYWxlTWluKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJhci55ID0gX3RoaXMueVNjYWxlKGxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy50eXBlID09PSAnc3RhY2tlZCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQwID0gZDBbZDBUeXBlXTtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQxID0gb2Zmc2V0MCArIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZDBbZDBUeXBlXSArPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJhci53aWR0aCA9IF90aGlzLnhTY2FsZShvZmZzZXQxKSAtIF90aGlzLnhTY2FsZShvZmZzZXQwKTtcclxuICAgICAgICAgICAgICAgIGJhci54ID0gX3RoaXMueFNjYWxlKG9mZnNldDApO1xyXG4gICAgICAgICAgICAgICAgYmFyLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgYmFyLm9mZnNldDAgPSBvZmZzZXQwO1xyXG4gICAgICAgICAgICAgICAgYmFyLm9mZnNldDEgPSBvZmZzZXQxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnR5cGUgPT09ICdub3JtYWxpemVkJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldDAgPSBkMFtkMFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldDEgPSBvZmZzZXQwICsgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBkMFtkMFR5cGVdICs9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDAgPSAob2Zmc2V0MCAqIDEwMCkgLyB0b3RhbDtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQxID0gKG9mZnNldDEgKiAxMDApIC8gdG90YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQwID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQxID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJhci53aWR0aCA9IF90aGlzLnhTY2FsZShvZmZzZXQxKSAtIF90aGlzLnhTY2FsZShvZmZzZXQwKTtcclxuICAgICAgICAgICAgICAgIGJhci54ID0gX3RoaXMueFNjYWxlKG9mZnNldDApO1xyXG4gICAgICAgICAgICAgICAgYmFyLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgYmFyLm9mZnNldDAgPSBvZmZzZXQwO1xyXG4gICAgICAgICAgICAgICAgYmFyLm9mZnNldDEgPSBvZmZzZXQxO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAob2Zmc2V0MSAtIG9mZnNldDApLnRvRml4ZWQoMikgKyAnJSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF90aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICAgICAgYmFyLmNvbG9yID0gX3RoaXMuY29sb3JzLmdldENvbG9yKGxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50eXBlID09PSAnc3RhbmRhcmQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFyLmNvbG9yID0gX3RoaXMuY29sb3JzLmdldENvbG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBiYXIuZ3JhZGllbnRTdG9wcyA9IF90aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhci5jb2xvciA9IF90aGlzLmNvbG9ycy5nZXRDb2xvcihiYXIub2Zmc2V0MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFyLmdyYWRpZW50U3RvcHMgPSBfdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyhiYXIub2Zmc2V0MSwgYmFyLm9mZnNldDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0b29sdGlwTGFiZWwgPSBmb3JtYXR0ZWRMYWJlbDtcclxuICAgICAgICAgICAgYmFyLmFyaWFMYWJlbCA9IGZvcm1hdHRlZExhYmVsICsgJyAnICsgdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnNlcmllc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBMYWJlbCA9IF90aGlzLnNlcmllc05hbWUgKyBcIiBcXHUyMDIyIFwiICsgZm9ybWF0dGVkTGFiZWw7XHJcbiAgICAgICAgICAgICAgICBiYXIuZGF0YS5zZXJpZXMgPSBfdGhpcy5zZXJpZXNOYW1lO1xyXG4gICAgICAgICAgICAgICAgYmFyLmFyaWFMYWJlbCA9IF90aGlzLnNlcmllc05hbWUgKyAnICcgKyBiYXIuYXJpYUxhYmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJhci50b29sdGlwVGV4dCA9IF90aGlzLnRvb2x0aXBEaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIDogXCJcXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIHRvb2x0aXBMYWJlbCArIFwiPC9zcGFuPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtdmFsXFxcIj5cIiArIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCkgKyBcIjwvc3Bhbj5cXG4gICAgICBcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGJhcjtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZURhdGFMYWJlbHMoKTtcclxuICAgIH07XHJcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS51cGRhdGVEYXRhTGFiZWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3N0YWNrZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFyc0ZvckRhdGFMYWJlbHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSB7fTtcclxuICAgICAgICAgICAgc2VjdGlvbi5zZXJpZXMgPSB0aGlzLnNlcmllc05hbWU7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbFBvc2l0aXZlID0gdGhpcy5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgZCkgeyByZXR1cm4gKGQgPiAwID8gc3VtICsgZCA6IHN1bSk7IH0sIDApO1xyXG4gICAgICAgICAgICB2YXIgdG90YWxOZWdhdGl2ZSA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGQpIHsgcmV0dXJuIChkIDwgMCA/IHN1bSArIGQgOiBzdW0pOyB9LCAwKTtcclxuICAgICAgICAgICAgc2VjdGlvbi50b3RhbCA9IHRvdGFsUG9zaXRpdmUgKyB0b3RhbE5lZ2F0aXZlO1xyXG4gICAgICAgICAgICBzZWN0aW9uLnggPSAwO1xyXG4gICAgICAgICAgICBzZWN0aW9uLnkgPSAwO1xyXG4gICAgICAgICAgICAvLyBpZiB0b3RhbCBpcyBwb3NpdGl2ZSB0aGVuIHdlIHNob3cgaXQgb24gdGhlIHJpZ2h0LCBvdGhlcndpc2Ugb24gdGhlIGxlZnRcclxuICAgICAgICAgICAgaWYgKHNlY3Rpb24udG90YWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLndpZHRoID0gdGhpcy54U2NhbGUodG90YWxQb3NpdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLndpZHRoID0gdGhpcy54U2NhbGUodG90YWxOZWdhdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VjdGlvbi5oZWlnaHQgPSB0aGlzLnlTY2FsZS5iYW5kd2lkdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5iYXJzRm9yRGF0YUxhYmVscy5wdXNoKHNlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5iYXJzRm9yRGF0YUxhYmVscyA9IHRoaXMuc2VyaWVzLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb24uc2VyaWVzID0gX3RoaXMuc2VyaWVzTmFtZSA/IF90aGlzLnNlcmllc05hbWUgOiBkLmxhYmVsO1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi50b3RhbCA9IGQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnggPSBfdGhpcy54U2NhbGUoMCk7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLnkgPSBfdGhpcy55U2NhbGUoZC5sYWJlbCk7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLndpZHRoID0gX3RoaXMueFNjYWxlKHNlY3Rpb24udG90YWwpIC0gX3RoaXMueFNjYWxlKDApO1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5oZWlnaHQgPSBfdGhpcy55U2NhbGUuYmFuZHdpZHRoKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLnVwZGF0ZVRvb2x0aXBTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRvb2x0aXBQbGFjZW1lbnQgPSB0aGlzLnRvb2x0aXBEaXNhYmxlZCA/IHVuZGVmaW5lZCA6ICd0b3AnO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFR5cGUgPSB0aGlzLnRvb2x0aXBEaXNhYmxlZCA/IHVuZGVmaW5lZCA6ICd0b29sdGlwJztcclxuICAgIH07XHJcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lICYmIGVudHJ5LnNlcmllcyA9PT0gZC5zZXJpZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS5nZXRMYWJlbCA9IGZ1bmN0aW9uIChkYXRhSXRlbSkge1xyXG4gICAgICAgIGlmIChkYXRhSXRlbS5sYWJlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW0ubGFiZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhSXRlbS5uYW1lO1xyXG4gICAgfTtcclxuICAgIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGJhcikge1xyXG4gICAgICAgIHJldHVybiBiYXIubGFiZWw7XHJcbiAgICB9O1xyXG4gICAgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUudHJhY2tEYXRhTGFiZWxCeSA9IGZ1bmN0aW9uIChpbmRleCwgYmFyTGFiZWwpIHtcclxuICAgICAgICByZXR1cm4gaW5kZXggKyAnIycgKyBiYXJMYWJlbC5zZXJpZXMgKyAnIycgKyBiYXJMYWJlbC50b3RhbDtcclxuICAgIH07XHJcbiAgICBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZS5jbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJzZXJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJzZXJpZXNOYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJyb3VuZEVkZ2VzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcInNob3dEYXRhTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNlcmllc0hvcml6b250YWwucHJvdG90eXBlLCBcImRhdGFMYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJub0JhcldoZW5aZXJvXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsLnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU2VyaWVzSG9yaXpvbnRhbC5wcm90b3R5cGUsIFwiZGF0YUxhYmVsV2lkdGhDaGFuZ2VkXCIsIHZvaWQgMCk7XHJcbiAgICBTZXJpZXNIb3Jpem9udGFsID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtc2VyaWVzLWhvcml6b250YWxdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6Z1xcbiAgICAgIG5neC1jaGFydHMtYmFyXFxuICAgICAgKm5nRm9yPVxcXCJsZXQgYmFyIG9mIGJhcnM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIlxcbiAgICAgIFt3aWR0aF09XFxcImJhci53aWR0aFxcXCJcXG4gICAgICBbaGVpZ2h0XT1cXFwiYmFyLmhlaWdodFxcXCJcXG4gICAgICBbeF09XFxcImJhci54XFxcIlxcbiAgICAgIFt5XT1cXFwiYmFyLnlcXFwiXFxuICAgICAgW2ZpbGxdPVxcXCJiYXIuY29sb3JcXFwiXFxuICAgICAgW3N0b3BzXT1cXFwiYmFyLmdyYWRpZW50U3RvcHNcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJiYXIuZGF0YVxcXCJcXG4gICAgICBbb3JpZW50YXRpb25dPVxcXCInaG9yaXpvbnRhbCdcXFwiXFxuICAgICAgW3JvdW5kRWRnZXNdPVxcXCJiYXIucm91bmRFZGdlc1xcXCJcXG4gICAgICAoc2VsZWN0KT1cXFwiY2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICBbaXNBY3RpdmVdPVxcXCJpc0FjdGl2ZShiYXIuZGF0YSlcXFwiXFxuICAgICAgW2FyaWFMYWJlbF09XFxcImJhci5hcmlhTGFiZWxcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgIG5neC10b29sdGlwXFxuICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcInRvb2x0aXBQbGFjZW1lbnRcXFwiXFxuICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwidG9vbHRpcFR5cGVcXFwiXFxuICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IGJhci50b29sdGlwVGV4dFxcXCJcXG4gICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImJhci5kYXRhXFxcIlxcbiAgICAgIFtub0JhcldoZW5aZXJvXT1cXFwibm9CYXJXaGVuWmVyb1xcXCJcXG4gICAgPjwvc3ZnOmc+XFxuICAgIDxzdmc6ZyAqbmdJZj1cXFwic2hvd0RhdGFMYWJlbFxcXCI+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLWJhci1sYWJlbFxcbiAgICAgICAgKm5nRm9yPVxcXCJsZXQgYiBvZiBiYXJzRm9yRGF0YUxhYmVsczsgbGV0IGkgPSBpbmRleDsgdHJhY2tCeTogdHJhY2tEYXRhTGFiZWxCeVxcXCJcXG4gICAgICAgIFtiYXJYXT1cXFwiYi54XFxcIlxcbiAgICAgICAgW2JhclldPVxcXCJiLnlcXFwiXFxuICAgICAgICBbYmFyV2lkdGhdPVxcXCJiLndpZHRoXFxcIlxcbiAgICAgICAgW2JhckhlaWdodF09XFxcImIuaGVpZ2h0XFxcIlxcbiAgICAgICAgW3ZhbHVlXT1cXFwiYi50b3RhbFxcXCJcXG4gICAgICAgIFt2YWx1ZUZvcm1hdHRpbmddPVxcXCJkYXRhTGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgW29yaWVudGF0aW9uXT1cXFwiJ2hvcml6b250YWwnXFxcIlxcbiAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwiZGF0YUxhYmVsV2lkdGhDaGFuZ2VkLmVtaXQoeyBzaXplOiAkZXZlbnQsIGluZGV4OiBpIH0pXFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSlcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBTZXJpZXNIb3Jpem9udGFsKTtcclxuICAgIHJldHVybiBTZXJpZXNIb3Jpem9udGFsO1xyXG59KCkpO1xyXG5cclxudmFyIEJhckxhYmVsQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmFyTGFiZWxDb21wb25lbnQoZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuZGltZW5zaW9uc0NoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsUGFkZGluZyA9IDI7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNhbFBhZGRpbmcgPSA1O1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcclxuICAgIH1cclxuICAgIEJhckxhYmVsQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHcgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XHJcbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0OiBoLCB3aWR0aDogdywgbmVnYXRpdmU6IHRoaXMudmFsdWUgPCAwIH07XHJcbiAgICB9O1xyXG4gICAgQmFyTGFiZWxDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRpbWVuc2lvbnNDaGFuZ2VkLmVtaXQodGhpcy5nZXRTaXplKCkpO1xyXG4gICAgfTtcclxuICAgIEJhckxhYmVsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0ZWRWYWx1ZSA9IHRoaXMudmFsdWVGb3JtYXR0aW5nKHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5mb3JtYXRlZFZhbHVlID0gZm9ybWF0TGFiZWwodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICAgdGhpcy54ID0gdGhpcy5iYXJYICsgdGhpcy5iYXJXaWR0aDtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLnggLSB0aGlzLmhvcml6b250YWxQYWRkaW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ2VuZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB0aGlzLnggKyB0aGlzLmhvcml6b250YWxQYWRkaW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ3N0YXJ0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLmJhclkgKyB0aGlzLmJhckhlaWdodCAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLmJhclggKyB0aGlzLmJhcldpZHRoIC8gMjtcclxuICAgICAgICAgICAgdGhpcy55ID0gdGhpcy5iYXJZICsgdGhpcy5iYXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy55ID0gdGhpcy55ICsgdGhpcy52ZXJ0aWNhbFBhZGRpbmc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRBbmNob3IgPSAnZW5kJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSAtIHRoaXMudmVydGljYWxQYWRkaW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0QW5jaG9yID0gJ3N0YXJ0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwicm90YXRlKC00NSwgXCIgKyB0aGlzLnggKyBcIiAsIFwiICsgdGhpcy55ICsgXCIpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJhckxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXJYXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFyWVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQmFyTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImJhcldpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFySGVpZ2h0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCYXJMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwib3JpZW50YXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEJhckxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1lbnNpb25zQ2hhbmdlZFwiLCB2b2lkIDApO1xyXG4gICAgQmFyTGFiZWxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1iYXItbGFiZWxdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiICBcXG4gICAgPHN2Zzp0ZXh0ICAgXFxuICAgICAgY2xhc3M9XFxcInRleHREYXRhTGFiZWxcXFwiIFxcbiAgICAgIGFsaWdubWVudC1iYXNlbGluZT1cXFwibWlkZGxlXFxcIiAgICAgXFxuICAgICAgW2F0dHIudGV4dC1hbmNob3JdPVxcXCJ0ZXh0QW5jaG9yXFxcIlxcbiAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCJcXG4gICAgICBbYXR0ci54XT1cXFwieFxcXCIgXFxuICAgICAgW2F0dHIueV09XFxcInlcXFwiPlxcbiAgICAgIHt7Zm9ybWF0ZWRWYWx1ZX19ICAgICBcXG4gICAgPC9zdmc6dGV4dD4gICAgICAgICAgXFxuXFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIudGV4dERhdGFMYWJlbHtmb250LXNpemU6MTFweH1cIl0sXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9iID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0XSlcclxuICAgIF0sIEJhckxhYmVsQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBCYXJMYWJlbENvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBCYXJDaGFydE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJhckNoYXJ0TW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgQmFyQ2hhcnRNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDaGFydENvbW1vbk1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgQmFyQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQmFySG9yaXpvbnRhbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhckhvcml6b250YWwyRENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhckhvcml6b250YWxOb3JtYWxpemVkQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQmFySG9yaXpvbnRhbFN0YWNrZWRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJWZXJ0aWNhbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhclZlcnRpY2FsMkRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJWZXJ0aWNhbE5vcm1hbGl6ZWRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJWZXJ0aWNhbFN0YWNrZWRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJMYWJlbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFNlcmllc0hvcml6b250YWwsXHJcbiAgICAgICAgICAgICAgICBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgICAgICAgICBCYXJDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJIb3Jpem9udGFsQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQmFySG9yaXpvbnRhbDJEQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCYXJIb3Jpem9udGFsU3RhY2tlZENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhclZlcnRpY2FsQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgQmFyVmVydGljYWwyRENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhclZlcnRpY2FsU3RhY2tlZENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEJhckxhYmVsQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgU2VyaWVzSG9yaXpvbnRhbCxcclxuICAgICAgICAgICAgICAgIFNlcmllc1ZlcnRpY2FsQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQmFyQ2hhcnRNb2R1bGUpO1xyXG4gICAgcmV0dXJuIEJhckNoYXJ0TW9kdWxlO1xyXG59KCkpO1xyXG5cclxuZnVuY3Rpb24gZ2V0RG9tYWluKHZhbHVlcywgc2NhbGVUeXBlLCBhdXRvU2NhbGUsIG1pblZhbCwgbWF4VmFsKSB7XHJcbiAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICBpZiAoc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIE51bWJlcih2KTsgfSk7XHJcbiAgICAgICAgaWYgKCFhdXRvU2NhbGUpIHtcclxuICAgICAgICAgICAgdmFsdWVzLnB1c2goMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNjYWxlVHlwZSA9PT0gJ3RpbWUnIHx8IHNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICB2YXIgbWluJCQxID0gbWluVmFsID8gbWluVmFsIDogTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICB2YXIgbWF4JCQxID0gbWF4VmFsID8gbWF4VmFsIDogTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICBkb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZG9tYWluID0gdmFsdWVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRvbWFpbjtcclxufVxyXG5mdW5jdGlvbiBnZXRTY2FsZShkb21haW4sIHJhbmdlJCQxLCBzY2FsZVR5cGUsIHJvdW5kRG9tYWlucykge1xyXG4gICAgdmFyIHNjYWxlO1xyXG4gICAgaWYgKHNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgc2NhbGUgPSBzY2FsZVRpbWUoKVxyXG4gICAgICAgICAgICAucmFuZ2UocmFuZ2UkJDEpXHJcbiAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKHJhbmdlJCQxKVxyXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgaWYgKHJvdW5kRG9tYWlucykge1xyXG4gICAgICAgICAgICBzY2FsZSA9IHNjYWxlLm5pY2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgIHNjYWxlID0gc2NhbGVQb2ludCgpXHJcbiAgICAgICAgICAgIC5yYW5nZShbcmFuZ2UkJDFbMF0sIHJhbmdlJCQxWzFdXSlcclxuICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNjYWxlO1xyXG59XHJcblxyXG52YXIgQnViYmxlQ2hhcnRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQnViYmxlQ2hhcnRDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCdWJibGVDaGFydENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy54QXhpcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMueUF4aXMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubWF4UmFkaXVzID0gMTA7XHJcbiAgICAgICAgX3RoaXMubWluUmFkaXVzID0gMztcclxuICAgICAgICBfdGhpcy5zY2hlbWVUeXBlID0gJ29yZGluYWwnO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuc2NhbGVUeXBlID0gJ2xpbmVhcic7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcclxuICAgICAgICBfdGhpcy5idWJibGVQYWRkaW5nID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxyXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXHJcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcclxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXHJcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcclxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNlcmllc0RvbWFpbiA9IHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZTsgfSk7XHJcbiAgICAgICAgdGhpcy5yRG9tYWluID0gdGhpcy5nZXRSRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy54RG9tYWluID0gdGhpcy5nZXRYRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy55RG9tYWluID0gdGhpcy5nZXRZRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIsXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgICAgIHZhciBjb2xvckRvbWFpbiA9IHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnID8gdGhpcy5zZXJpZXNEb21haW4gOiB0aGlzLnJEb21haW47XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgY29sb3JEb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnJlc3VsdHM7XHJcbiAgICAgICAgdGhpcy5taW5SYWRpdXMgPSBNYXRoLm1heCh0aGlzLm1pblJhZGl1cywgMSk7XHJcbiAgICAgICAgdGhpcy5tYXhSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm1heFJhZGl1cywgMSk7XHJcbiAgICAgICAgdGhpcy5yU2NhbGUgPSB0aGlzLmdldFJTY2FsZSh0aGlzLnJEb21haW4sIFt0aGlzLm1pblJhZGl1cywgdGhpcy5tYXhSYWRpdXNdKTtcclxuICAgICAgICB0aGlzLmJ1YmJsZVBhZGRpbmcgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgdGhpcy5zZXRTY2FsZXMoKTtcclxuICAgICAgICB0aGlzLmJ1YmJsZVBhZGRpbmcgPSB0aGlzLmdldEJ1YmJsZVBhZGRpbmcoKTtcclxuICAgICAgICB0aGlzLnNldFNjYWxlcygpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT3B0aW9ucyA9IHRoaXMuZ2V0TGVnZW5kT3B0aW9ucygpO1xyXG4gICAgICAgIHRoaXMuY2xpcFBhdGhJZCA9ICdjbGlwJyArIGlkKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmNsaXBQYXRoID0gXCJ1cmwoI1wiICsgdGhpcy5jbGlwUGF0aElkICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmhpZGVDaXJjbGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUFsbCgpO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIHNlcmllcykge1xyXG4gICAgICAgIGlmIChzZXJpZXMpIHtcclxuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBzZXJpZXMubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0QnViYmxlUGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgeU1pbiA9IDA7XHJcbiAgICAgICAgdmFyIHhNaW4gPSAwO1xyXG4gICAgICAgIHZhciB5TWF4ID0gdGhpcy5kaW1zLmhlaWdodDtcclxuICAgICAgICB2YXIgeE1heCA9IHRoaXMuZGltcy53aWR0aDtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5kYXRhOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcyA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHMuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuclNjYWxlKGQucik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSB0aGlzLnhTY2FsZVR5cGUgPT09ICdsaW5lYXInID8gdGhpcy54U2NhbGUoTnVtYmVyKGQueCkpIDogdGhpcy54U2NhbGUoZC54KTtcclxuICAgICAgICAgICAgICAgIHZhciBjeSA9IHRoaXMueVNjYWxlVHlwZSA9PT0gJ2xpbmVhcicgPyB0aGlzLnlTY2FsZShOdW1iZXIoZC55KSkgOiB0aGlzLnlTY2FsZShkLnkpO1xyXG4gICAgICAgICAgICAgICAgeE1pbiA9IE1hdGgubWF4KHIgLSBjeCwgeE1pbik7XHJcbiAgICAgICAgICAgICAgICB5TWluID0gTWF0aC5tYXgociAtIGN5LCB5TWluKTtcclxuICAgICAgICAgICAgICAgIHlNYXggPSBNYXRoLm1heChjeSArIHIsIHlNYXgpO1xyXG4gICAgICAgICAgICAgICAgeE1heCA9IE1hdGgubWF4KGN4ICsgciwgeE1heCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXggLSB0aGlzLmRpbXMud2lkdGgsIDApO1xyXG4gICAgICAgIHlNYXggPSBNYXRoLm1heCh5TWF4IC0gdGhpcy5kaW1zLmhlaWdodCwgMCk7XHJcbiAgICAgICAgcmV0dXJuIFt5TWluLCB4TWF4LCB5TWF4LCB4TWluXTtcclxuICAgIH07XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuc2V0U2NhbGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZGltcy53aWR0aDtcclxuICAgICAgICBpZiAodGhpcy54U2NhbGVNaW4gPT09IHVuZGVmaW5lZCAmJiB0aGlzLnhTY2FsZU1heCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gd2lkdGggLSB0aGlzLmJ1YmJsZVBhZGRpbmdbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmRpbXMuaGVpZ2h0O1xyXG4gICAgICAgIGlmICh0aGlzLnlTY2FsZU1pbiA9PT0gdW5kZWZpbmVkICYmIHRoaXMueVNjYWxlTWF4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IC0gdGhpcy5idWJibGVQYWRkaW5nWzJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMueERvbWFpbiwgd2lkdGgpO1xyXG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUodGhpcy55RG9tYWluLCBoZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRZU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gZ2V0U2NhbGUoZG9tYWluLCBbaGVpZ2h0LCB0aGlzLmJ1YmJsZVBhZGRpbmdbMF1dLCB0aGlzLnlTY2FsZVR5cGUsIHRoaXMucm91bmREb21haW5zKTtcclxuICAgIH07XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WFNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgd2lkdGgpIHtcclxuICAgICAgICByZXR1cm4gZ2V0U2NhbGUoZG9tYWluLCBbdGhpcy5idWJibGVQYWRkaW5nWzNdLCB3aWR0aF0sIHRoaXMueFNjYWxlVHlwZSwgdGhpcy5yb3VuZERvbWFpbnMpO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRSU2NhbGUgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSQkMSkge1xyXG4gICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKHJhbmdlJCQxKVxyXG4gICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmREb21haW5zID8gc2NhbGUubmljZSgpIDogc2NhbGU7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB7XHJcbiAgICAgICAgICAgIHNjYWxlVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBjb2xvcnM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgZG9tYWluOiBbXSxcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb24sXHJcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChvcHRzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy5zZXJpZXNEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnM7XHJcbiAgICAgICAgICAgIG9wdHMudGl0bGUgPSB0aGlzLmxlZ2VuZFRpdGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0cy5kb21haW4gPSB0aGlzLnJEb21haW47XHJcbiAgICAgICAgICAgIG9wdHMuY29sb3JzID0gdGhpcy5jb2xvcnMuc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRzO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHJlc3VsdHMuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyhkLngpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZC54KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnhTY2FsZVR5cGUgPSBnZXRTY2FsZVR5cGUodmFsdWVzKTtcclxuICAgICAgICByZXR1cm4gZ2V0RG9tYWluKHZhbHVlcywgdGhpcy54U2NhbGVUeXBlLCB0aGlzLmF1dG9TY2FsZSwgdGhpcy54U2NhbGVNaW4sIHRoaXMueFNjYWxlTWF4KTtcclxuICAgIH07XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSByZXN1bHRzLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZXMuaW5jbHVkZXMoZC55KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGQueSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy55U2NhbGVUeXBlID0gZ2V0U2NhbGVUeXBlKHZhbHVlcyk7XHJcbiAgICAgICAgcmV0dXJuIGdldERvbWFpbih2YWx1ZXMsIHRoaXMueVNjYWxlVHlwZSwgdGhpcy5hdXRvU2NhbGUsIHRoaXMueVNjYWxlTWluLCB0aGlzLnlTY2FsZU1heCk7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFJEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1pbiQkMSA9IEluZmluaXR5O1xyXG4gICAgICAgIHZhciBtYXgkJDEgPSAtSW5maW5pdHk7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSByZXN1bHRzLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKGQucikgfHwgMTtcclxuICAgICAgICAgICAgICAgIG1pbiQkMSA9IE1hdGgubWluKG1pbiQkMSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgbWF4JCQxID0gTWF0aC5tYXgobWF4JCQxLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICB9O1xyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVlBeGlzV2lkdGggPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW2l0ZW1dLmNvbmNhdCh0aGlzLmFjdGl2ZUVudHJpZXMpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmRlYWN0aXZhdGVBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuYWN0aXZlRW50cmllczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBlbnRyeSwgZW50cmllczogW10gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0dyaWRMaW5lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WEF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmREb21haW5zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4UmFkaXVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluUmFkaXVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImF1dG9TY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBCdWJibGVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGlkZUNpcmNsZXNcIiwgbnVsbCk7XHJcbiAgICBCdWJibGVDaGFydENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1idWJibGUtY2hhcnQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmRlZnM+XFxuICAgICAgICA8c3ZnOmNsaXBQYXRoIFthdHRyLmlkXT1cXFwiY2xpcFBhdGhJZFxcXCI+XFxuICAgICAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgICAgIFthdHRyLndpZHRoXT1cXFwiZGltcy53aWR0aCArIDEwXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmhlaWdodF09XFxcImRpbXMuaGVpZ2h0ICsgMTBcXFwiXFxuICAgICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiJ3RyYW5zbGF0ZSgtNSwgLTUpJ1xcXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvc3ZnOmNsaXBQYXRoPlxcbiAgICAgIDwvc3ZnOmRlZnM+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcImJ1YmJsZS1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy15LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInlBeGlzXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxzdmc6cmVjdFxcbiAgICAgICAgICBjbGFzcz1cXFwiYnViYmxlLWNoYXJ0LWFyZWFcXFwiXFxuICAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgIHk9XFxcIjBcXFwiXFxuICAgICAgICAgIFthdHRyLndpZHRoXT1cXFwiZGltcy53aWR0aFxcXCJcXG4gICAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiZGltcy5oZWlnaHRcXFwiXFxuICAgICAgICAgIHN0eWxlPVxcXCJmaWxsOiByZ2IoMjU1LCAwLCAwKTsgb3BhY2l0eTogMDsgY3Vyc29yOiAnYXV0byc7XFxcIlxcbiAgICAgICAgICAobW91c2VlbnRlcik9XFxcImRlYWN0aXZhdGVBbGwoKVxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8c3ZnOmcgW2F0dHIuY2xpcC1wYXRoXT1cXFwiY2xpcFBhdGhcXFwiPlxcbiAgICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgc2VyaWVzIG9mIGRhdGE7IHRyYWNrQnk6IHRyYWNrQnlcXFwiIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLWJ1YmJsZS1zZXJpZXNcXG4gICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW3JTY2FsZV09XFxcInJTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFt4U2NhbGVUeXBlXT1cXFwieFNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICAgIFt5U2NhbGVUeXBlXT1cXFwieVNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICAgIFt4QXhpc0xhYmVsXT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgICAgIFt5QXhpc0xhYmVsXT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICBbZGF0YV09XFxcInNlcmllc1xcXCJcXG4gICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50LCBzZXJpZXMpXFxcIlxcbiAgICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiXSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQnViYmxlQ2hhcnRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEJ1YmJsZUNoYXJ0Q29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEJ1YmJsZVNlcmllc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ1YmJsZVNlcmllc0NvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNpcmNsZXMgPSB0aGlzLmdldENpcmNsZXMoKTtcclxuICAgIH07XHJcbiAgICBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldENpcmNsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgc2VyaWVzTmFtZSA9IHRoaXMuZGF0YS5uYW1lO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc2VyaWVzXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkLnkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkLnggIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGQueTtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gZC54O1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBkLnI7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gX3RoaXMuclNjYWxlKHIgfHwgMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9vbHRpcExhYmVsID0gZm9ybWF0TGFiZWwoZC5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHZhciBjeCA9IF90aGlzLnhTY2FsZVR5cGUgPT09ICdsaW5lYXInID8gX3RoaXMueFNjYWxlKE51bWJlcih4KSkgOiBfdGhpcy54U2NhbGUoeCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSBfdGhpcy55U2NhbGVUeXBlID09PSAnbGluZWFyJyA/IF90aGlzLnlTY2FsZShOdW1iZXIoeSkpIDogX3RoaXMueVNjYWxlKHkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gX3RoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicgPyBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IocikgOiBfdGhpcy5jb2xvcnMuZ2V0Q29sb3Ioc2VyaWVzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNBY3RpdmUgPSAhX3RoaXMuYWN0aXZlRW50cmllcy5sZW5ndGggPyB0cnVlIDogX3RoaXMuaXNBY3RpdmUoeyBuYW1lOiBzZXJpZXNOYW1lIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBpc0FjdGl2ZSA/IDEgOiAwLjM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGQsIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHNlcmllc05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZC5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLnksXHJcbiAgICAgICAgICAgICAgICAgICAgeDogZC54LFxyXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogZC5yXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgcjogcixcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzOiBbXCJjaXJjbGUtZGF0YS1cIiArIGldLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB5LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB4LFxyXG4gICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcclxuICAgICAgICAgICAgICAgICAgICBjeTogY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcExhYmVsOiB0b29sdGlwTGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzTmFtZTogc2VyaWVzTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIGN4ICsgXCIsXCIgKyBjeSArIFwiKVwiXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoY2lyY2xlKSB7IHJldHVybiBjaXJjbGUgIT09IHVuZGVmaW5lZDsgfSk7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUb29sdGlwVGV4dCA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcclxuICAgICAgICB2YXIgaGFzUmFkaXVzID0gdHlwZW9mIGNpcmNsZS5yICE9PSAndW5kZWZpbmVkJztcclxuICAgICAgICB2YXIgaGFzVG9vbHRpcExhYmVsID0gY2lyY2xlLnRvb2x0aXBMYWJlbCAmJiBjaXJjbGUudG9vbHRpcExhYmVsLmxlbmd0aDtcclxuICAgICAgICB2YXIgaGFzU2VyaWVzTmFtZSA9IGNpcmNsZS5zZXJpZXNOYW1lICYmIGNpcmNsZS5zZXJpZXNOYW1lLmxlbmd0aDtcclxuICAgICAgICB2YXIgcmFkaXVzVmFsdWUgPSBoYXNSYWRpdXMgPyBmb3JtYXRMYWJlbChjaXJjbGUucikgOiAnJztcclxuICAgICAgICB2YXIgeEF4aXNMYWJlbCA9IHRoaXMueEF4aXNMYWJlbCAmJiB0aGlzLnhBeGlzTGFiZWwgIT09ICcnID8gdGhpcy54QXhpc0xhYmVsICsgXCI6XCIgOiAnJztcclxuICAgICAgICB2YXIgeUF4aXNMYWJlbCA9IHRoaXMueUF4aXNMYWJlbCAmJiB0aGlzLnlBeGlzTGFiZWwgIT09ICcnID8gdGhpcy55QXhpc0xhYmVsICsgXCI6XCIgOiAnJztcclxuICAgICAgICB2YXIgeCA9IGZvcm1hdExhYmVsKGNpcmNsZS54KTtcclxuICAgICAgICB2YXIgeSA9IGZvcm1hdExhYmVsKGNpcmNsZS55KTtcclxuICAgICAgICB2YXIgbmFtZSA9IGhhc1Nlcmllc05hbWUgJiYgaGFzVG9vbHRpcExhYmVsXHJcbiAgICAgICAgICAgID8gY2lyY2xlLnNlcmllc05hbWUgKyBcIiBcXHUyMDIyIFwiICsgY2lyY2xlLnRvb2x0aXBMYWJlbFxyXG4gICAgICAgICAgICA6IGNpcmNsZS5zZXJpZXNOYW1lICsgY2lyY2xlLnRvb2x0aXBMYWJlbDtcclxuICAgICAgICB2YXIgdG9vbHRpcFRpdGxlID0gaGFzU2VyaWVzTmFtZSB8fCBoYXNUb29sdGlwTGFiZWwgPyBcIjxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIG5hbWUgKyBcIjwvc3Bhbj5cIiA6ICcnO1xyXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIFwiICsgdG9vbHRpcFRpdGxlICsgXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC1sYWJlbFxcXCI+XFxuICAgICAgICA8bGFiZWw+XCIgKyB4QXhpc0xhYmVsICsgXCI8L2xhYmVsPiBcIiArIHggKyBcIjxiciAvPlxcbiAgICAgICAgPGxhYmVsPlwiICsgeUF4aXNMYWJlbCArIFwiPC9sYWJlbD4gXCIgKyB5ICsgXCJcXG4gICAgICA8L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtdmFsXFxcIj5cXG4gICAgICAgIFwiICsgcmFkaXVzVmFsdWUgKyBcIlxcbiAgICAgIDwvc3Bhbj5cXG4gICAgXCI7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWUgPT09IGQubmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKGNpcmNsZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUVudHJpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0FjdGl2ZSh7IG5hbWU6IGNpcmNsZS5zZXJpZXNOYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2lyY2xlLm9wYWNpdHkgIT09IDA7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5hY3RpdmF0ZUNpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcclxuICAgICAgICBjaXJjbGUuYmFyVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgbmFtZTogdGhpcy5kYXRhLm5hbWUgfSk7XHJcbiAgICB9O1xyXG4gICAgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5kZWFjdGl2YXRlQ2lyY2xlID0gZnVuY3Rpb24gKGNpcmNsZSkge1xyXG4gICAgICAgIGNpcmNsZS5iYXJWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyBuYW1lOiB0aGlzLmRhdGEubmFtZSB9KTtcclxuICAgIH07XHJcbiAgICBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnRyYWNrQnkgPSBmdW5jdGlvbiAoaW5kZXgsIGNpcmNsZSkge1xyXG4gICAgICAgIHJldHVybiBjaXJjbGUuZGF0YS5zZXJpZXMgKyBcIiBcIiArIGNpcmNsZS5kYXRhLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiclNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlVHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzaWJsZVZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgQnViYmxlU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEJ1YmJsZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIEJ1YmJsZVNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWJ1YmJsZS1zZXJpZXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBjaXJjbGUgb2YgY2lyY2xlczsgdHJhY2tCeTogdHJhY2tCeVxcXCI+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcImNpcmNsZS50cmFuc2Zvcm1cXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtY2lyY2xlXFxuICAgICAgICAgIFtAYW5pbWF0aW9uU3RhdGVdPVxcXCInYWN0aXZlJ1xcXCJcXG4gICAgICAgICAgY2xhc3M9XFxcImNpcmNsZVxcXCJcXG4gICAgICAgICAgW2N4XT1cXFwiMFxcXCJcXG4gICAgICAgICAgW2N5XT1cXFwiMFxcXCJcXG4gICAgICAgICAgW3JdPVxcXCJjaXJjbGUucmFkaXVzXFxcIlxcbiAgICAgICAgICBbZmlsbF09XFxcImNpcmNsZS5jb2xvclxcXCJcXG4gICAgICAgICAgW3N0eWxlLm9wYWNpdHldPVxcXCJjaXJjbGUub3BhY2l0eVxcXCJcXG4gICAgICAgICAgW2NsYXNzLmFjdGl2ZV09XFxcImNpcmNsZS5pc0FjdGl2ZVxcXCJcXG4gICAgICAgICAgW3BvaW50ZXJFdmVudHNdPVxcXCInYWxsJ1xcXCJcXG4gICAgICAgICAgW2RhdGFdPVxcXCJjaXJjbGUudmFsdWVcXFwiXFxuICAgICAgICAgIFtjbGFzc05hbWVzXT1cXFwiY2lyY2xlLmNsYXNzTmFtZXNcXFwiXFxuICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKGNpcmNsZS5kYXRhKVxcXCJcXG4gICAgICAgICAgKGFjdGl2YXRlKT1cXFwiYWN0aXZhdGVDaXJjbGUoY2lyY2xlKVxcXCJcXG4gICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJkZWFjdGl2YXRlQ2lyY2xlKGNpcmNsZSlcXFwiXFxuICAgICAgICAgIG5neC10b29sdGlwXFxuICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cXFwiJ3RvcCdcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVHlwZV09XFxcIid0b29sdGlwJ1xcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBUaXRsZV09XFxcInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IGdldFRvb2x0aXBUZXh0KGNpcmNsZSlcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImNpcmNsZS5kYXRhXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgwKSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoMjUwLCBzdHlsZSh7IG9wYWNpdHk6IDEsIHRyYW5zZm9ybTogJ3NjYWxlKDEpJyB9KSlcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBCdWJibGVTZXJpZXNDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEJ1YmJsZVNlcmllc0NvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBCdWJibGVDaGFydE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ1YmJsZUNoYXJ0TW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgQnViYmxlQ2hhcnRNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDaGFydENvbW1vbk1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgQnViYmxlQ2hhcnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCdWJibGVTZXJpZXNDb21wb25lbnRcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZXhwb3J0czogW1xyXG4gICAgICAgICAgICAgICAgQnViYmxlQ2hhcnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBCdWJibGVTZXJpZXNDb21wb25lbnRcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBCdWJibGVDaGFydE1vZHVsZSk7XHJcbiAgICByZXR1cm4gQnViYmxlQ2hhcnRNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG52YXIgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5mb3JjZSA9IGZvcmNlU2ltdWxhdGlvbigpXHJcbiAgICAgICAgICAgIC5mb3JjZSgnY2hhcmdlJywgZm9yY2VNYW55Qm9keSgpKVxyXG4gICAgICAgICAgICAuZm9yY2UoJ2NvbGxpZGUnLCBmb3JjZUNvbGxpZGUoNSkpXHJcbiAgICAgICAgICAgIC5mb3JjZSgneCcsIGZvcmNlWCgpKVxyXG4gICAgICAgICAgICAuZm9yY2UoJ3knLCBmb3JjZVkoKSk7XHJcbiAgICAgICAgX3RoaXMuZm9yY2VMaW5rID0gZm9yY2VMaW5rKCkuaWQoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmFsdWU7IH0pO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xyXG4gICAgICAgIF90aGlzLm5vZGVzID0gW107XHJcbiAgICAgICAgX3RoaXMubGlua3MgPSBbXTtcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgX3RoaXMucmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIF90aGlzLmdyb3VwUmVzdWx0c0J5ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmFsdWU7IH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zZXJpZXNEb21haW4gPSB0aGlzLmdldFNlcmllc0RvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcIlxcbiAgICAgIHRyYW5zbGF0ZShcIiArICh0aGlzLmRpbXMueE9mZnNldCArIHRoaXMuZGltcy53aWR0aCAvIDIpICsgXCIsIFwiICsgKHRoaXMubWFyZ2luWzBdICsgdGhpcy5kaW1zLmhlaWdodCAvIDIpICsgXCIpXFxuICAgIFwiO1xyXG4gICAgICAgIGlmICh0aGlzLmZvcmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VcclxuICAgICAgICAgICAgICAgIC5ub2Rlcyh0aGlzLm5vZGVzKVxyXG4gICAgICAgICAgICAgICAgLmZvcmNlKCdsaW5rJywgdGhpcy5mb3JjZUxpbmsubGlua3ModGhpcy5saW5rcykpXHJcbiAgICAgICAgICAgICAgICAuYWxwaGEoMC41KVxyXG4gICAgICAgICAgICAgICAgLnJlc3RhcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChldmVudCQkMSkge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUVudHJpZXMuaW5kZXhPZihldmVudCQkMSkgPiAtMSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtldmVudCQkMV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcyk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGV2ZW50JCQxLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEpIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmluZGV4T2YoZXZlbnQkJDEpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBldmVudCQkMSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2VyaWVzRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMuZ3JvdXBSZXN1bHRzQnkoZCk7IH0pXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG5vZGVzLCBub2RlKSB7IHJldHVybiAobm9kZXMuaW5jbHVkZXMobm9kZSkgPyBub2RlcyA6IG5vZGVzLmNvbmNhdChbbm9kZV0pKTsgfSwgW10pXHJcbiAgICAgICAgICAgIC5zb3J0KCk7XHJcbiAgICB9O1xyXG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0xpbmtCeSA9IGZ1bmN0aW9uIChpbmRleCwgbGluaykge1xyXG4gICAgICAgIHJldHVybiBsaW5rLmluZGV4O1xyXG4gICAgfTtcclxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tOb2RlQnkgPSBmdW5jdGlvbiAoaW5kZXgsIG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcclxuICAgIH07XHJcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgJ29yZGluYWwnLCB0aGlzLnNlcmllc0RvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGVnZW5kT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6ICdvcmRpbmFsJyxcclxuICAgICAgICAgICAgZG9tYWluOiB0aGlzLnNlcmllc0RvbWFpbixcclxuICAgICAgICAgICAgY29sb3JzOiB0aGlzLmNvbG9ycyxcclxuICAgICAgICAgICAgdGl0bGU6IHRoaXMubGVnZW5kVGl0bGUsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKG5vZGUsICRldmVudCkge1xyXG4gICAgICAgIHRoaXMuZm9yY2UuYWxwaGFUYXJnZXQoMC4zKS5yZXN0YXJ0KCk7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZ05vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdTdGFydCA9IHsgeDogJGV2ZW50LnggLSBub2RlLngsIHk6ICRldmVudC55IC0gbm9kZS55IH07XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZ05vZGUuZnggPSAkZXZlbnQueCAtIHRoaXMuZHJhZ2dpbmdTdGFydC54O1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdOb2RlLmZ5ID0gJGV2ZW50LnkgLSB0aGlzLmRyYWdnaW5nU3RhcnQueTtcclxuICAgIH07XHJcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLm9uRHJhZyA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmdOb2RlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZ05vZGUuZnggPSAkZXZlbnQueCAtIHRoaXMuZHJhZ2dpbmdTdGFydC54O1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmdOb2RlLmZ5ID0gJGV2ZW50LnkgLSB0aGlzLmRyYWdnaW5nU3RhcnQueTtcclxuICAgIH07XHJcbiAgICBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLm9uRHJhZ0VuZCA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmdOb2RlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5mb3JjZS5hbHBoYVRhcmdldCgwKTtcclxuICAgICAgICB0aGlzLmRyYWdnaW5nTm9kZS5meCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmRyYWdnaW5nTm9kZS5meSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmRyYWdnaW5nTm9kZSA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9yY2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9yY2VMaW5rXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJub2Rlc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBBcnJheSkgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsaW5rc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ2xpbmtUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfZCA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9kIDogT2JqZWN0KVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsaW5rVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgnbm9kZVRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9lID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2UgOiBPYmplY3QpXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcIm5vZGVUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCd0b29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2YgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZiA6IE9iamVjdClcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBWaWV3Q2hpbGQoQ2hhcnRDb21wb25lbnQsIHsgcmVhZDogRWxlbWVudFJlZiwgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfZyA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZyA6IE9iamVjdClcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hhcnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncm91cFJlc3VsdHNCeVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSG9zdExpc3RlbmVyKCdkb2N1bWVudDptb3VzZW1vdmUnLCBbJyRldmVudCddKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfaCA9IHR5cGVvZiBNb3VzZUV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIE1vdXNlRXZlbnQpID09PSBcImZ1bmN0aW9uXCIgPyBfaCA6IE9iamVjdF0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQucHJvdG90eXBlLCBcIm9uRHJhZ1wiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6bW91c2V1cCcsIFsnJGV2ZW50J10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9qID0gdHlwZW9mIE1vdXNlRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgTW91c2VFdmVudCkgPT09IFwiZnVuY3Rpb25cIiA/IF9qIDogT2JqZWN0XSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudC5wcm90b3R5cGUsIFwib25EcmFnRW5kXCIsIG51bGwpO1xyXG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWZvcmNlLWRpcmVjdGVkLWdyYXBoJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwiZm9yY2UtZGlyZWN0ZWQtZ3JhcGggY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnIGNsYXNzPVxcXCJsaW5rc1xcXCI+XFxuICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBsaW5rIG9mIGxpbmtzOyB0cmFja0J5OiB0cmFja0xpbmtCeVxcXCI+XFxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlXFxuICAgICAgICAgICAgICAqbmdJZj1cXFwibGlua1RlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVxcXCJsaW5rVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVxcXCJ7ICRpbXBsaWNpdDogbGluayB9XFxcIlxcbiAgICAgICAgICAgID48L25nLXRlbXBsYXRlPlxcbiAgICAgICAgICAgIDxzdmc6bGluZVxcbiAgICAgICAgICAgICAgKm5nSWY9XFxcIiFsaW5rVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD1cXFwiMVxcXCJcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJlZGdlXFxcIlxcbiAgICAgICAgICAgICAgW2F0dHIueDFdPVxcXCJsaW5rLnNvdXJjZS54XFxcIlxcbiAgICAgICAgICAgICAgW2F0dHIueTFdPVxcXCJsaW5rLnNvdXJjZS55XFxcIlxcbiAgICAgICAgICAgICAgW2F0dHIueDJdPVxcXCJsaW5rLnRhcmdldC54XFxcIlxcbiAgICAgICAgICAgICAgW2F0dHIueTJdPVxcXCJsaW5rLnRhcmdldC55XFxcIlxcbiAgICAgICAgICAgIC8+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnIGNsYXNzPVxcXCJub2Rlc1xcXCI+XFxuICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IG5vZGUgb2Ygbm9kZXM7IHRyYWNrQnk6IHRyYWNrTm9kZUJ5XFxcIlxcbiAgICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcIid0cmFuc2xhdGUoJyArIG5vZGUueCArICcsJyArIG5vZGUueSArICcpJ1xcXCJcXG4gICAgICAgICAgICBbYXR0ci5maWxsXT1cXFwiY29sb3JzLmdldENvbG9yKGdyb3VwUmVzdWx0c0J5KG5vZGUpKVxcXCJcXG4gICAgICAgICAgICBbYXR0ci5zdHJva2VdPVxcXCJjb2xvcnMuZ2V0Q29sb3IoZ3JvdXBSZXN1bHRzQnkobm9kZSkpXFxcIlxcbiAgICAgICAgICAgIChtb3VzZWRvd24pPVxcXCJvbkRyYWdTdGFydChub2RlLCAkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIChjbGljayk9XFxcIm9uQ2xpY2soeyBuYW1lOiBub2RlLnZhbHVlIH0pXFxcIlxcbiAgICAgICAgICAgIG5neC10b29sdGlwXFxuICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwVHlwZV09XFxcIid0b29sdGlwJ1xcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFRpdGxlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogbm9kZS52YWx1ZVxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcIm5vZGVcXFwiXFxuICAgICAgICAgID5cXG4gICAgICAgICAgICA8bmctdGVtcGxhdGVcXG4gICAgICAgICAgICAgICpuZ0lmPVxcXCJub2RlVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XFxcIm5vZGVUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XFxcInsgJGltcGxpY2l0OiBub2RlIH1cXFwiXFxuICAgICAgICAgICAgPjwvbmctdGVtcGxhdGU+XFxuICAgICAgICAgICAgPHN2ZzpjaXJjbGUgKm5nSWY9XFxcIiFub2RlVGVtcGxhdGVcXFwiIHI9XFxcIjVcXFwiIC8+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCIsIFwiLmZvcmNlLWRpcmVjdGVkLWdyYXBoIC5lZGdle3N0cm9rZTojMzMzfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBGb3JjZURpcmVjdGVkR3JhcGhDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgRm9yY2VEaXJlY3RlZEdyYXBoTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRm9yY2VEaXJlY3RlZEdyYXBoTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoTW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIEZvcmNlRGlyZWN0ZWRHcmFwaENvbXBvbmVudCxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZXhwb3J0czogW1xyXG4gICAgICAgICAgICAgICAgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEZvcmNlRGlyZWN0ZWRHcmFwaE1vZHVsZSk7XHJcbiAgICByZXR1cm4gRm9yY2VEaXJlY3RlZEdyYXBoTW9kdWxlO1xyXG59KCkpO1xyXG5cclxudmFyIEhlYXRNYXBDZWxsQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSGVhdE1hcENlbGxDb21wb25lbnQoZWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcclxuICAgIH1cclxuICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMueCArIFwiICwgXCIgKyB0aGlzLnkgKyBcIilcIjtcclxuICAgICAgICB0aGlzLnN0YXJ0T3BhY2l0eSA9IDAuMztcclxuICAgICAgICB0aGlzLmdyYWRpZW50SWQgPSAnZ3JhZCcgKyBpZCgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudFVybCA9IFwidXJsKCNcIiArIHRoaXMuZ3JhZGllbnRJZCArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IHRoaXMuZ2V0R3JhZGllbnRTdG9wcygpO1xyXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5nZXRHcmFkaWVudFN0b3BzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmZpbGwsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLnN0YXJ0T3BhY2l0eVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwMCxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmZpbGwsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5sb2FkQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub2RlID0gc2VsZWN0KHRoaXMuZWxlbWVudCkuc2VsZWN0KCcuY2VsbCcpO1xyXG4gICAgICAgIG5vZGUuYXR0cignb3BhY2l0eScsIDApO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0ZVRvQ3VycmVudEZvcm0oKTtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUuYW5pbWF0ZVRvQ3VycmVudEZvcm0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3QodGhpcy5lbGVtZW50KS5zZWxlY3QoJy5jZWxsJyk7XHJcbiAgICAgICAgbm9kZVxyXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgIC5kdXJhdGlvbig3NTApXHJcbiAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMSk7XHJcbiAgICB9O1xyXG4gICAgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdCh0aGlzLmRhdGEpO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5vbk1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHRoaXMuZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLm9uTW91c2VMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh0aGlzLmRhdGEpO1xyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwieFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbk1vdXNlRW50ZXJcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIEhlYXRNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbk1vdXNlTGVhdmVcIiwgbnVsbCk7XHJcbiAgICBIZWF0TWFwQ2VsbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWhlYXQtbWFwLWNlbGxdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJjZWxsXFxcIj5cXG4gICAgICA8ZGVmcyAqbmdJZj1cXFwiZ3JhZGllbnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnIG5neC1jaGFydHMtc3ZnLWxpbmVhci1ncmFkaWVudCBvcmllbnRhdGlvbj1cXFwidmVydGljYWxcXFwiIFtuYW1lXT1cXFwiZ3JhZGllbnRJZFxcXCIgW3N0b3BzXT1cXFwiZ3JhZGllbnRTdG9wc1xcXCIgLz5cXG4gICAgICA8L2RlZnM+XFxuICAgICAgPHN2ZzpyZWN0XFxuICAgICAgICBbYXR0ci5maWxsXT1cXFwiZ3JhZGllbnQgPyBncmFkaWVudFVybCA6IGZpbGxcXFwiXFxuICAgICAgICByeD1cXFwiM1xcXCJcXG4gICAgICAgIFthdHRyLndpZHRoXT1cXFwid2lkdGhcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJoZWlnaHRcXFwiXFxuICAgICAgICBjbGFzcz1cXFwiY2VsbFxcXCJcXG4gICAgICAgIHN0eWxlPVxcXCJjdXJzb3I6IHBvaW50ZXJcXFwiXFxuICAgICAgICAoY2xpY2spPVxcXCJvbkNsaWNrKClcXFwiXFxuICAgICAgLz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbdHlwZW9mIChfYSA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdF0pXHJcbiAgICBdLCBIZWF0TWFwQ2VsbENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gSGVhdE1hcENlbGxDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgSGVhdENlbGxTZXJpZXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXBUZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcFRleHQgPSB0aGlzLmdldFRvb2x0aXBUZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy5nZXRDZWxscygpO1xyXG4gICAgfTtcclxuICAgIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDZWxscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjZWxscyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZGF0YS5tYXAoZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgICAgICByb3cuc2VyaWVzLm1hcChmdW5jdGlvbiAoY2VsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2VsbC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGNlbGwuc2VyaWVzID0gcm93Lm5hbWU7XHJcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgICAgICAgICBjZWxsOiBjZWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IF90aGlzLnhTY2FsZShyb3cubmFtZSksXHJcbiAgICAgICAgICAgICAgICAgICAgeTogX3RoaXMueVNjYWxlKGNlbGwubmFtZSksXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IF90aGlzLnhTY2FsZS5iYW5kd2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IF90aGlzLnlTY2FsZS5iYW5kd2lkdGgoKSxcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IodmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBmb3JtYXRMYWJlbChjZWxsLm5hbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlcmllczogcm93Lm5hbWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2VsbHM7XHJcbiAgICB9O1xyXG4gICAgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFRvb2x0aXBUZXh0ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsID0gX2EubGFiZWwsIGRhdGEgPSBfYS5kYXRhLCBzZXJpZXMgPSBfYS5zZXJpZXM7XHJcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtbGFiZWxcXFwiPlwiICsgc2VyaWVzICsgXCIgXFx1MjAyMiBcIiArIGxhYmVsICsgXCI8L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtdmFsXFxcIj5cIiArIGRhdGEudG9Mb2NhbGVTdHJpbmcoKSArIFwiPC9zcGFuPlxcbiAgICBcIjtcclxuICAgIH07XHJcbiAgICBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLnRvb2x0aXBUZXh0O1xyXG4gICAgfTtcclxuICAgIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2MgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIEhlYXRDZWxsU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtaGVhdC1tYXAtY2VsbC1zZXJpZXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6Z1xcbiAgICAgIG5neC1jaGFydHMtaGVhdC1tYXAtY2VsbFxcbiAgICAgICpuZ0Zvcj1cXFwibGV0IGMgb2YgY2VsbHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgW3hdPVxcXCJjLnhcXFwiXFxuICAgICAgW3ldPVxcXCJjLnlcXFwiXFxuICAgICAgW3dpZHRoXT1cXFwiYy53aWR0aFxcXCJcXG4gICAgICBbaGVpZ2h0XT1cXFwiYy5oZWlnaHRcXFwiXFxuICAgICAgW2ZpbGxdPVxcXCJjLmZpbGxcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJjLmRhdGFcXFwiXFxuICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soYy5jZWxsKVxcXCJcXG4gICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZS5lbWl0KGMuY2VsbClcXFwiXFxuICAgICAgKGRlYWN0aXZhdGUpPVxcXCJkZWFjdGl2YXRlLmVtaXQoYy5jZWxsKVxcXCJcXG4gICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgbmd4LXRvb2x0aXBcXG4gICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cXFwiJ3RvcCdcXFwiXFxuICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwiJ3Rvb2x0aXAnXFxcIlxcbiAgICAgIFt0b29sdGlwVGl0bGVdPVxcXCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiB0b29sdGlwVGV4dChjKVxcXCJcXG4gICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcInsgc2VyaWVzOiBjLnNlcmllcywgbmFtZTogYy5sYWJlbCwgdmFsdWU6IGMuZGF0YSB9XFxcIlxcbiAgICA+PC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBIZWF0Q2VsbFNlcmllc0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gSGVhdENlbGxTZXJpZXNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgSGVhdE1hcENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhIZWF0TWFwQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSGVhdE1hcENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy5pbm5lclBhZGRpbmcgPSA4O1xyXG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcclxuICAgICAgICBfdGhpcy54QXhpc0hlaWdodCA9IDA7XHJcbiAgICAgICAgX3RoaXMueUF4aXNXaWR0aCA9IDA7XHJcbiAgICAgICAgX3RoaXMuc2NhbGVUeXBlID0gJ2xpbmVhcic7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5mb3JtYXREYXRlcygpO1xyXG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xyXG4gICAgICAgIHRoaXMueURvbWFpbiA9IHRoaXMuZ2V0WURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMudmFsdWVEb21haW4gPSB0aGlzLmdldFZhbHVlRG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5zY2FsZVR5cGUgPSBnZXRTY2FsZVR5cGUodGhpcy52YWx1ZURvbWFpbiwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxyXG4gICAgICAgICAgICBzaG93WEF4aXM6IHRoaXMueEF4aXMsXHJcbiAgICAgICAgICAgIHNob3dZQXhpczogdGhpcy55QXhpcyxcclxuICAgICAgICAgICAgeEF4aXNIZWlnaHQ6IHRoaXMueEF4aXNIZWlnaHQsXHJcbiAgICAgICAgICAgIHlBeGlzV2lkdGg6IHRoaXMueUF4aXNXaWR0aCxcclxuICAgICAgICAgICAgc2hvd1hMYWJlbDogdGhpcy5zaG93WEF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd1lMYWJlbDogdGhpcy5zaG93WUF4aXNMYWJlbCxcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFR5cGU6IHRoaXMuc2NhbGVUeXBlLFxyXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgdmFyIG1pbiQkMSA9IHRoaXMubWluO1xyXG4gICAgICAgICAgICB2YXIgbWF4JCQxID0gdGhpcy5tYXg7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5taW4pIHtcclxuICAgICAgICAgICAgICAgIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIFswXS5jb25jYXQodGhpcy52YWx1ZURvbWFpbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5tYXgpIHtcclxuICAgICAgICAgICAgICAgIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHRoaXMudmFsdWVEb21haW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVEb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKCk7XHJcbiAgICAgICAgdGhpcy55U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy5yZWN0cyA9IHRoaXMuZ2V0UmVjdHMoKTtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkb21haW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGlmICghZG9tYWluLmluY2x1ZGVzKGdyb3VwLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkb21haW4ucHVzaChncm91cC5uYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IF9hW19pXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGdyb3VwLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb21haW4uaW5jbHVkZXMoZC5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZ3JvdXAuc2VyaWVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbi5pbmNsdWRlcyhkLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5wdXNoKGQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW47XHJcbiAgICB9O1xyXG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgTiwgTCkge1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gMDsgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdbJywgJycpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnXScsICcnKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3B4JywgJycpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnXFwnJywgJycpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJywnKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbih2YWx1ZVtpbmRleF0sIG51bGwsIE4sIEwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5pbmNsdWRlcygnJScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiArdmFsdWUucmVwbGFjZSgnJScsICcnKSAvIDEwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE4gLyAoTCAvICt2YWx1ZSArIDEpO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZiA9IHRoaXMuZ2V0RGltZW5zaW9uKHRoaXMuaW5uZXJQYWRkaW5nLCAwLCB0aGlzLnhEb21haW4ubGVuZ3RoLCB0aGlzLmRpbXMud2lkdGgpO1xyXG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbMCwgdGhpcy5kaW1zLndpZHRoXSlcclxuICAgICAgICAgICAgLmRvbWFpbih0aGlzLnhEb21haW4pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoZik7XHJcbiAgICB9O1xyXG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmID0gdGhpcy5nZXREaW1lbnNpb24odGhpcy5pbm5lclBhZGRpbmcsIDEsIHRoaXMueURvbWFpbi5sZW5ndGgsIHRoaXMuZGltcy5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiBzY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAucmFuZ2VSb3VuZChbdGhpcy5kaW1zLmhlaWdodCwgMF0pXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy55RG9tYWluKVxyXG4gICAgICAgICAgICAucGFkZGluZ0lubmVyKGYpO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLmdldFJlY3RzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlY3RzID0gW107XHJcbiAgICAgICAgdGhpcy54RG9tYWluLm1hcChmdW5jdGlvbiAoeFZhbCkge1xyXG4gICAgICAgICAgICBfdGhpcy55RG9tYWluLm1hcChmdW5jdGlvbiAoeVZhbCkge1xyXG4gICAgICAgICAgICAgICAgcmVjdHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogX3RoaXMueFNjYWxlKHhWYWwpLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IF90aGlzLnlTY2FsZSh5VmFsKSxcclxuICAgICAgICAgICAgICAgICAgICByeDogMyxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogX3RoaXMueFNjYWxlLmJhbmR3aWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogX3RoaXMueVNjYWxlLmJhbmR3aWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICdyZ2JhKDIwMCwyMDAsMjAwLDAuMDMpJ1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZWN0cztcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgdGhpcy5zY2FsZVR5cGUsIHRoaXMudmFsdWVEb21haW4pO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiB0aGlzLnNjYWxlVHlwZSxcclxuICAgICAgICAgICAgZG9tYWluOiB0aGlzLnZhbHVlRG9tYWluLFxyXG4gICAgICAgICAgICBjb2xvcnM6IHRoaXMuc2NhbGVUeXBlID09PSAnb3JkaW5hbCcgPyB0aGlzLmNvbG9ycyA6IHRoaXMuY29sb3JzLnNjYWxlLFxyXG4gICAgICAgICAgICB0aXRsZTogdGhpcy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJyA/IHRoaXMubGVnZW5kVGl0bGUgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoZXZlbnQkJDEsIGdyb3VwLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50JCQxKTtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgaXRlbS5zZXJpZXMgPSBncm91cC5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnJlc3VsdHNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZykgeyByZXR1cm4gZy5zZXJpZXM7IH0pXHJcbiAgICAgICAgICAgIC5mbGF0KClcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBpLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBpdGVtcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGV2ZW50JCQxLCBncm91cCwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCQkMSk7XHJcbiAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc2VyaWVzID0gZ3JvdXAubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkubGFiZWwgIT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhKGkubmFtZSA9PT0gaXRlbS5uYW1lICYmIGkuc2VyaWVzID09PSBpdGVtLnNlcmllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZFRpdGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5uZXJQYWRkaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0ZVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBIZWF0TWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgSGVhdE1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBIZWF0TWFwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWhlYXQtbWFwJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxDbGljayk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJoZWF0LW1hcCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInhBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW3JvdGF0ZVRpY2tzXT1cXFwicm90YXRlWEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhYQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInhBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInhBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVhBeGlzSGVpZ2h0KCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLXktYXhpc1xcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dZQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1ZQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFlBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieUF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWUF4aXNXaWR0aCgkZXZlbnQpXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOnJlY3RcXG4gICAgICAgICAgKm5nRm9yPVxcXCJsZXQgcmVjdCBvZiByZWN0c1xcXCJcXG4gICAgICAgICAgW2F0dHIueF09XFxcInJlY3QueFxcXCJcXG4gICAgICAgICAgW2F0dHIueV09XFxcInJlY3QueVxcXCJcXG4gICAgICAgICAgW2F0dHIucnhdPVxcXCJyZWN0LnJ4XFxcIlxcbiAgICAgICAgICBbYXR0ci53aWR0aF09XFxcInJlY3Qud2lkdGhcXFwiXFxuICAgICAgICAgIFthdHRyLmhlaWdodF09XFxcInJlY3QuaGVpZ2h0XFxcIlxcbiAgICAgICAgICBbYXR0ci5maWxsXT1cXFwicmVjdC5maWxsXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWhlYXQtbWFwLWNlbGwtc2VyaWVzXFxuICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgIFtkYXRhXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBUZXh0XT1cXFwidG9vbHRpcFRleHRcXFwiXFxuICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEhlYXRNYXBDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEhlYXRNYXBDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgSGVhdE1hcE1vZHVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEhlYXRNYXBNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBIZWF0TWFwTW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgSGVhdENlbGxTZXJpZXNDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBIZWF0TWFwQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIEhlYXRNYXBDZWxsQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgSGVhdENlbGxTZXJpZXNDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBIZWF0TWFwQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgSGVhdE1hcE1vZHVsZSk7XHJcbiAgICByZXR1cm4gSGVhdE1hcE1vZHVsZTtcclxufSgpKTtcclxuXHJcbnZhciBMaW5lQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGluZUNvbXBvbmVudChlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLmZpbGwgPSAnbm9uZSc7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBMaW5lQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxQYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXRoRWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGluZUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlUGF0aEVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub2RlID0gc2VsZWN0KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KS5zZWxlY3QoJy5saW5lJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9ucykge1xyXG4gICAgICAgICAgICBub2RlXHJcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDc1MClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgdGhpcy5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUuYXR0cignZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDb21wb25lbnQucHJvdG90eXBlLCBcInBhdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDb21wb25lbnQucHJvdG90eXBlLCBcInN0cm9rZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTGluZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIExpbmVDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIExpbmVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1saW5lXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8c3ZnOnBhdGhcXG4gICAgICBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiXFxuICAgICAgY2xhc3M9XFxcImxpbmVcXFwiXFxuICAgICAgW2F0dHIuZF09XFxcImluaXRpYWxQYXRoXFxcIlxcbiAgICAgIFthdHRyLmZpbGxdPVxcXCJmaWxsXFxcIlxcbiAgICAgIFthdHRyLnN0cm9rZV09XFxcInN0cm9rZVxcXCJcXG4gICAgICBzdHJva2Utd2lkdGg9XFxcIjEuNXB4XFxcIlxcbiAgICAvPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgICAgICAgICBhbmltYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogMjAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IDIwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDEwMDAsIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxyXG4gICAgXSwgTGluZUNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTGluZUNvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBMaW5lQ2hhcnRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTGluZUNoYXJ0Q29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGluZUNoYXJ0Q29tcG9uZW50KCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFRpdGxlID0gJ0xlZ2VuZCc7XHJcbiAgICAgICAgX3RoaXMubGVnZW5kUG9zaXRpb24gPSAncmlnaHQnO1xyXG4gICAgICAgIF90aGlzLnNob3dHcmlkTGluZXMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmN1cnZlID0gY3VydmVMaW5lYXI7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRyaW1YQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy50cmltWUF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucm90YXRlWEF4aXNUaWNrcyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMubWF4WEF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMubWF4WUF4aXNUaWNrTGVuZ3RoID0gMTY7XHJcbiAgICAgICAgX3RoaXMucm91bmREb21haW5zID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuc2hvd1JlZkxpbmVzID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuc2hvd1JlZkxhYmVscyA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5tYXJnaW4gPSBbMTAsIDIwLCAxMCwgMjBdO1xyXG4gICAgICAgIF90aGlzLnhBeGlzSGVpZ2h0ID0gMDtcclxuICAgICAgICBfdGhpcy55QXhpc1dpZHRoID0gMDtcclxuICAgICAgICBfdGhpcy50aW1lbGluZUhlaWdodCA9IDUwO1xyXG4gICAgICAgIF90aGlzLnRpbWVsaW5lUGFkZGluZyA9IDEwO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW4sXHJcbiAgICAgICAgICAgIHNob3dYQXhpczogdGhpcy54QXhpcyxcclxuICAgICAgICAgICAgc2hvd1lBeGlzOiB0aGlzLnlBeGlzLFxyXG4gICAgICAgICAgICB4QXhpc0hlaWdodDogdGhpcy54QXhpc0hlaWdodCxcclxuICAgICAgICAgICAgeUF4aXNXaWR0aDogdGhpcy55QXhpc1dpZHRoLFxyXG4gICAgICAgICAgICBzaG93WExhYmVsOiB0aGlzLnNob3dYQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93WUxhYmVsOiB0aGlzLnNob3dZQXhpc0xhYmVsLFxyXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcclxuICAgICAgICAgICAgbGVnZW5kVHlwZTogdGhpcy5zY2hlbWVUeXBlLFxyXG4gICAgICAgICAgICBsZWdlbmRQb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGltcy5oZWlnaHQgLT0gdGhpcy50aW1lbGluZUhlaWdodCArIHRoaXMubWFyZ2luWzJdICsgdGhpcy50aW1lbGluZVBhZGRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZ2V0WERvbWFpbigpO1xyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmVkRG9tYWluKSB7XHJcbiAgICAgICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZmlsdGVyZWREb21haW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueURvbWFpbiA9IHRoaXMuZ2V0WURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzRG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oKTtcclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMueERvbWFpbiwgdGhpcy5kaW1zLndpZHRoKTtcclxuICAgICAgICB0aGlzLnlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKHRoaXMueURvbWFpbiwgdGhpcy5kaW1zLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lbGluZSgpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHRoaXMuZGltcy54T2Zmc2V0ICsgXCIgLCBcIiArIHRoaXMubWFyZ2luWzBdICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy5jbGlwUGF0aElkID0gJ2NsaXAnICsgaWQoKS50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuY2xpcFBhdGggPSBcInVybCgjXCIgKyB0aGlzLmNsaXBQYXRoSWQgKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVRpbWVsaW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVXaWR0aCA9IHRoaXMuZGltcy53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVhEb21haW4gPSB0aGlzLmdldFhEb21haW4oKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMudGltZWxpbmVYRG9tYWluLCB0aGlzLnRpbWVsaW5lV2lkdGgpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lWVNjYWxlID0gdGhpcy5nZXRZU2NhbGUodGhpcy55RG9tYWluLCB0aGlzLnRpbWVsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy50aW1lbGluZVRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiwgXCIgKyAtdGhpcy5tYXJnaW5bMl0gKyBcIilcIjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRVbmlxdWVYRG9tYWluVmFsdWVzKHRoaXMucmVzdWx0cyk7XHJcbiAgICAgICAgdGhpcy5zY2FsZVR5cGUgPSBnZXRTY2FsZVR5cGUodmFsdWVzKTtcclxuICAgICAgICB2YXIgZG9tYWluID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBOdW1iZXIodik7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWluJCQxO1xyXG4gICAgICAgIHZhciBtYXgkJDE7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScgfHwgdGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIG1pbiQkMSA9IHRoaXMueFNjYWxlTWluID8gdGhpcy54U2NhbGVNaW4gOiBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICBtYXgkJDEgPSB0aGlzLnhTY2FsZU1heCA/IHRoaXMueFNjYWxlTWF4IDogTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgZG9tYWluID0gW25ldyBEYXRlKG1pbiQkMSksIG5ldyBEYXRlKG1heCQkMSldO1xyXG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYURhdGUgPSBhLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBiRGF0ZSA9IGIuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFEYXRlID4gYkRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYkRhdGUgPiBhRGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgICAgICAgICB0aGlzLnhTZXQgPSB2YWx1ZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb21haW4gPSB2YWx1ZXM7XHJcbiAgICAgICAgICAgIHRoaXMueFNldCA9IHZhbHVlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gcmVzdWx0cy5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmIChkb21haW4uaW5kZXhPZihkLnZhbHVlKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkLm1pbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNSYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbi5pbmRleE9mKGQubWluKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5taW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkLm1heCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNSYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbi5pbmRleE9mKGQubWF4KSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5tYXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWVzID0gZG9tYWluLnNsaWNlKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dG9TY2FsZSkge1xyXG4gICAgICAgICAgICB2YWx1ZXMucHVzaCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pbiQkMSA9IHRoaXMueVNjYWxlTWluID8gdGhpcy55U2NhbGVNaW4gOiBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgIHZhciBtYXgkJDEgPSB0aGlzLnlTY2FsZU1heCA/IHRoaXMueVNjYWxlTWF4IDogTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICByZXR1cm4gW21pbiQkMSwgbWF4JCQxXTtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFNlcmllc0RvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lOyB9KTtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIHdpZHRoKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVUaW1lKClcclxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbihkb21haW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBzY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcclxuICAgICAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucm91bmREb21haW5zKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZSA9IHNjYWxlLm5pY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVQb2ludCgpXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcclxuICAgICAgICAgICAgICAgIC5wYWRkaW5nKDAuMSlcclxuICAgICAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjYWxlO1xyXG4gICAgfTtcclxuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pXHJcbiAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZURvbWFpbiA9IGZ1bmN0aW9uIChkb21haW4pIHtcclxuICAgICAgICB0aGlzLmZpbHRlcmVkRG9tYWluID0gZG9tYWluO1xyXG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZmlsdGVyZWREb21haW47XHJcbiAgICAgICAgdGhpcy54U2NhbGUgPSB0aGlzLmdldFhTY2FsZSh0aGlzLnhEb21haW4sIHRoaXMuZGltcy53aWR0aCk7XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVIb3ZlcmVkVmVydGljYWwgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHRoaXMuaG92ZXJlZFZlcnRpY2FsID0gaXRlbS52YWx1ZTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmhpZGVDaXJjbGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaG92ZXJlZFZlcnRpY2FsID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGVBbGwoKTtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZTtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZG9tYWluO1xyXG4gICAgICAgIGlmICh0aGlzLnNjaGVtZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBkb21haW4gPSB0aGlzLnNlcmllc0RvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9IHRoaXMueURvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsIHRoaXMuc2NoZW1lVHlwZSwgZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICB9O1xyXG4gICAgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRzID0ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgY29sb3JzOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGRvbWFpbjogW10sXHJcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0cy5zY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xyXG4gICAgICAgICAgICBvcHRzLmRvbWFpbiA9IHRoaXMuc2VyaWVzRG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgICAgICBvcHRzLnRpdGxlID0gdGhpcy5sZWdlbmRUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdHMuZG9tYWluID0gdGhpcy55RG9tYWluO1xyXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IHRoaXMuY29sb3JzLnNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0cztcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVlBeGlzV2lkdGggPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgICAgICB0aGlzLnlBeGlzV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlWEF4aXNIZWlnaHQgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueEF4aXNIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUFsbCgpO1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZGVhY3RpdmF0ZUFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5hY3RpdmVFbnRyaWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGVudHJ5LCBlbnRyaWVzOiBbXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1lBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc0xhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImF1dG9TY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aW1lbGluZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VydmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VGaWxsT3BhY2l0eVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbVhBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRyaW1ZQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVYQXhpc1RpY2tzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFhBeGlzVGlja0xlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhZQXhpc1RpY2tMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzVGlja3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93UmVmTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicmVmZXJlbmNlTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dSZWZMYWJlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlTWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhTY2FsZU1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTGluZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ5U2NhbGVNaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlTWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKCdzZXJpZXNUb29sdGlwVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2QgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfZCA6IE9iamVjdClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VyaWVzVG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIExpbmVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGlkZUNpcmNsZXNcIiwgbnVsbCk7XHJcbiAgICBMaW5lQ2hhcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtbGluZS1jaGFydCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZGVmcz5cXG4gICAgICAgIDxzdmc6Y2xpcFBhdGggW2F0dHIuaWRdPVxcXCJjbGlwUGF0aElkXFxcIj5cXG4gICAgICAgICAgPHN2ZzpyZWN0XFxuICAgICAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJkaW1zLndpZHRoICsgMTBcXFwiXFxuICAgICAgICAgICAgW2F0dHIuaGVpZ2h0XT1cXFwiZGltcy5oZWlnaHQgKyAxMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCIndHJhbnNsYXRlKC01LCAtNSknXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9zdmc6Y2xpcFBhdGg+XFxuICAgICAgPC9zdmc6ZGVmcz5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIiBjbGFzcz1cXFwibGluZS1jaGFydCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy14LWF4aXNcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzXFxcIlxcbiAgICAgICAgICBbeFNjYWxlXT1cXFwieFNjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtzaG93R3JpZExpbmVzXT1cXFwic2hvd0dyaWRMaW5lc1xcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbF09XFxcInNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxUZXh0XT1cXFwieEF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW3RyaW1UaWNrc109XFxcInRyaW1YQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbcm90YXRlVGlja3NdPVxcXCJyb3RhdGVYQXhpc1RpY2tzXFxcIlxcbiAgICAgICAgICBbbWF4VGlja0xlbmd0aF09XFxcIm1heFhBeGlzVGlja0xlbmd0aFxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwieEF4aXNUaWNrRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW3RpY2tzXT1cXFwieEF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgKGRpbWVuc2lvbnNDaGFuZ2VkKT1cXFwidXBkYXRlWEF4aXNIZWlnaHQoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJ5QXhpc1xcXCJcXG4gICAgICAgICAgW3lTY2FsZV09XFxcInlTY2FsZVxcXCJcXG4gICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICBbc2hvd0dyaWRMaW5lc109XFxcInNob3dHcmlkTGluZXNcXFwiXFxuICAgICAgICAgIFtzaG93TGFiZWxdPVxcXCJzaG93WUF4aXNMYWJlbFxcXCJcXG4gICAgICAgICAgW2xhYmVsVGV4dF09XFxcInlBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFt0cmltVGlja3NdPVxcXCJ0cmltWUF4aXNUaWNrc1xcXCJcXG4gICAgICAgICAgW21heFRpY2tMZW5ndGhdPVxcXCJtYXhZQXhpc1RpY2tMZW5ndGhcXFwiXFxuICAgICAgICAgIFt0aWNrRm9ybWF0dGluZ109XFxcInlBeGlzVGlja0Zvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0aWNrc109XFxcInlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFtyZWZlcmVuY2VMaW5lc109XFxcInJlZmVyZW5jZUxpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd1JlZkxpbmVzXT1cXFwic2hvd1JlZkxpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd1JlZkxhYmVsc109XFxcInNob3dSZWZMYWJlbHNcXFwiXFxuICAgICAgICAgIChkaW1lbnNpb25zQ2hhbmdlZCk9XFxcInVwZGF0ZVlBeGlzV2lkdGgoJGV2ZW50KVxcXCJcXG4gICAgICAgID48L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnIFthdHRyLmNsaXAtcGF0aF09XFxcImNsaXBQYXRoXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHNlcmllcyBvZiByZXN1bHRzOyB0cmFja0J5OiB0cmFja0J5XFxcIiBbQGFuaW1hdGlvblN0YXRlXT1cXFwiJ2FjdGl2ZSdcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1saW5lLXNlcmllc1xcbiAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgICAgW2N1cnZlXT1cXFwiY3VydmVcXFwiXFxuICAgICAgICAgICAgICBbcmFuZ2VGaWxsT3BhY2l0eV09XFxcInJhbmdlRmlsbE9wYWNpdHlcXFwiXFxuICAgICAgICAgICAgICBbaGFzUmFuZ2VdPVxcXCJoYXNSYW5nZVxcXCJcXG4gICAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcblxcbiAgICAgICAgICA8c3ZnOmcgKm5nSWY9XFxcIiF0b29sdGlwRGlzYWJsZWRcXFwiIChtb3VzZWxlYXZlKT1cXFwiaGlkZUNpcmNsZXMoKVxcXCI+XFxuICAgICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgICBuZ3gtY2hhcnRzLXRvb2x0aXAtYXJlYVxcbiAgICAgICAgICAgICAgW2RpbXNdPVxcXCJkaW1zXFxcIlxcbiAgICAgICAgICAgICAgW3hTZXRdPVxcXCJ4U2V0XFxcIlxcbiAgICAgICAgICAgICAgW3hTY2FsZV09XFxcInhTY2FsZVxcXCJcXG4gICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbcmVzdWx0c109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJzZXJpZXNUb29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICAoaG92ZXIpPVxcXCJ1cGRhdGVIb3ZlcmVkVmVydGljYWwoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAvPlxcblxcbiAgICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0c1xcXCI+XFxuICAgICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1jaXJjbGUtc2VyaWVzXFxuICAgICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5U2NhbGVcXFwiXFxuICAgICAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgICAgICAgICBbdmlzaWJsZVZhbHVlXT1cXFwiaG92ZXJlZFZlcnRpY2FsXFxcIlxcbiAgICAgICAgICAgICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtdGltZWxpbmVcXG4gICAgICAgICpuZ0lmPVxcXCJ0aW1lbGluZSAmJiBzY2FsZVR5cGUgIT0gJ29yZGluYWwnXFxcIlxcbiAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidGltZWxpbmVUcmFuc2Zvcm1cXFwiXFxuICAgICAgICBbcmVzdWx0c109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICBbdmlld109XFxcIlt0aW1lbGluZVdpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgICAgW2hlaWdodF09XFxcInRpbWVsaW5lSGVpZ2h0XFxcIlxcbiAgICAgICAgW3NjaGVtZV09XFxcInNjaGVtZVxcXCJcXG4gICAgICAgIFtjdXN0b21Db2xvcnNdPVxcXCJjdXN0b21Db2xvcnNcXFwiXFxuICAgICAgICBbc2NhbGVUeXBlXT1cXFwic2NhbGVUeXBlXFxcIlxcbiAgICAgICAgW2xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICAgIChvbkRvbWFpbkNoYW5nZSk9XFxcInVwZGF0ZURvbWFpbigkZXZlbnQpXFxcIlxcbiAgICAgID5cXG4gICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0czsgdHJhY2tCeTogdHJhY2tCeVxcXCI+XFxuICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgIG5neC1jaGFydHMtbGluZS1zZXJpZXNcXG4gICAgICAgICAgICBbeFNjYWxlXT1cXFwidGltZWxpbmVYU2NhbGVcXFwiXFxuICAgICAgICAgICAgW3lTY2FsZV09XFxcInRpbWVsaW5lWVNjYWxlXFxcIlxcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXNcXFwiXFxuICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICBbY3VydmVdPVxcXCJjdXJ2ZVxcXCJcXG4gICAgICAgICAgICBbaGFzUmFuZ2VdPVxcXCJoYXNSYW5nZVxcXCJcXG4gICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgICAgICAgICAgYW5pbWF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcignYW5pbWF0aW9uU3RhdGUnLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBMaW5lQ2hhcnRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIExpbmVDaGFydENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBMaW5lU2VyaWVzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTGluZVNlcmllc0NvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlR3JhZGllbnRzKCk7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnNvcnREYXRhKHRoaXMuZGF0YS5zZXJpZXMpO1xyXG4gICAgICAgIHZhciBsaW5lR2VuID0gdGhpcy5nZXRMaW5lR2VuZXJhdG9yKCk7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gbGluZUdlbihkYXRhKSB8fCAnJztcclxuICAgICAgICB2YXIgYXJlYUdlbiA9IHRoaXMuZ2V0QXJlYUdlbmVyYXRvcigpO1xyXG4gICAgICAgIHRoaXMuYXJlYVBhdGggPSBhcmVhR2VuKGRhdGEpIHx8ICcnO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1JhbmdlKSB7XHJcbiAgICAgICAgICAgIHZhciByYW5nZSQkMSA9IHRoaXMuZ2V0UmFuZ2VHZW5lcmF0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5vdXRlclBhdGggPSByYW5nZSQkMShkYXRhKSB8fCAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzR3JhZGllbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdHJva2UgPSB0aGlzLmdyYWRpZW50VXJsO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5kYXRhLnNlcmllcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pO1xyXG4gICAgICAgICAgICB2YXIgbWF4JCQxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIGlmIChtYXgkJDEgPT09IG1pbiQkMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJva2UgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcihtYXgkJDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0cm9rZSA9IHRoaXMuY29sb3JzLmdldENvbG9yKHRoaXMuZGF0YS5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGluZUdlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBsaW5lKClcclxuICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gZC5uYW1lO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5zY2FsZVR5cGUgPT09ICd0aW1lJykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy54U2NhbGUobGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKE51bWJlcihsYWJlbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy54U2NhbGUobGFiZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAueShmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMueVNjYWxlKGQudmFsdWUpOyB9KVxyXG4gICAgICAgICAgICAuY3VydmUodGhpcy5jdXJ2ZSk7XHJcbiAgICB9O1xyXG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0UmFuZ2VHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gYXJlYSgpXHJcbiAgICAgICAgICAgIC54KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQubmFtZTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnhTY2FsZShOdW1iZXIobGFiZWwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMueFNjYWxlKGxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnkwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy55U2NhbGUodHlwZW9mIGQubWluID09PSAnbnVtYmVyJyA/IGQubWluIDogZC52YWx1ZSk7IH0pXHJcbiAgICAgICAgICAgIC55MShmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMueVNjYWxlKHR5cGVvZiBkLm1heCA9PT0gJ251bWJlcicgPyBkLm1heCA6IGQudmFsdWUpOyB9KVxyXG4gICAgICAgICAgICAuY3VydmUodGhpcy5jdXJ2ZSk7XHJcbiAgICB9O1xyXG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0QXJlYUdlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB4UHJvcGVydHkgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkLm5hbWU7XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy54U2NhbGUobGFiZWwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGFyZWEoKVxyXG4gICAgICAgICAgICAueCh4UHJvcGVydHkpXHJcbiAgICAgICAgICAgIC55MChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy55U2NhbGUucmFuZ2UoKVswXTsgfSlcclxuICAgICAgICAgICAgLnkxKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy55U2NhbGUoZC52YWx1ZSk7IH0pXHJcbiAgICAgICAgICAgIC5jdXJ2ZSh0aGlzLmN1cnZlKTtcclxuICAgIH07XHJcbiAgICBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5zb3J0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICBkYXRhID0gc29ydExpbmVhcihkYXRhLCAnbmFtZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBzb3J0QnlUaW1lKGRhdGEsICduYW1lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhID0gc29ydEJ5RG9tYWluKGRhdGEsICduYW1lJywgJ2FzYycsIHRoaXMueFNjYWxlLmRvbWFpbigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9O1xyXG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlR3JhZGllbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzR3JhZGllbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50SWQgPSAnZ3JhZCcgKyBpZCgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRVcmwgPSBcInVybCgjXCIgKyB0aGlzLmdyYWRpZW50SWQgKyBcIilcIjtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZGF0YS5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcclxuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB0aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKG1heCQkMSwgbWluJCQxKTtcclxuICAgICAgICAgICAgdGhpcy5hcmVhR3JhZGllbnRTdG9wcyA9IHRoaXMuY29sb3JzLmdldExpbmVhckdyYWRpZW50U3RvcHMobWF4JCQxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzR3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLmFyZWFHcmFkaWVudFN0b3BzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuaXNJbmFjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzIHx8IHRoaXMuYWN0aXZlRW50cmllcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4U2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInlTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzY2FsZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlRmlsbE9wYWNpdHlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBMaW5lU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoYXNSYW5nZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIExpbmVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIExpbmVTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1saW5lLXNlcmllc10nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnPlxcbiAgICAgIDxkZWZzPlxcbiAgICAgICAgPHN2ZzpnIG5neC1jaGFydHMtc3ZnLWxpbmVhci1ncmFkaWVudCAqbmdJZj1cXFwiaGFzR3JhZGllbnRcXFwiXFxuICAgICAgICAgIG9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCJcXG4gICAgICAgICAgW25hbWVdPVxcXCJncmFkaWVudElkXFxcIlxcbiAgICAgICAgICBbc3RvcHNdPVxcXCJncmFkaWVudFN0b3BzXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L2RlZnM+XFxuICAgICAgPHN2ZzpnIG5neC1jaGFydHMtYXJlYVxcbiAgICAgICAgY2xhc3M9XFxcImxpbmUtaGlnaGxpZ2h0XFxcIlxcbiAgICAgICAgW2RhdGFdPVxcXCJkYXRhXFxcIlxcbiAgICAgICAgW3BhdGhdPVxcXCJhcmVhUGF0aFxcXCJcXG4gICAgICAgIFtmaWxsXT1cXFwiaGFzR3JhZGllbnQgPyBncmFkaWVudFVybCA6IGNvbG9ycy5nZXRDb2xvcihkYXRhLm5hbWUpXFxcIlxcbiAgICAgICAgW29wYWNpdHldPVxcXCIwLjI1XFxcIlxcbiAgICAgICAgW3N0YXJ0T3BhY2l0eV09XFxcIjBcXFwiXFxuICAgICAgICBbZ3JhZGllbnRdPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgW3N0b3BzXT1cXFwiYXJlYUdyYWRpZW50U3RvcHNcXFwiXFxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiaXNBY3RpdmUoZGF0YSlcXFwiXFxuICAgICAgICBbY2xhc3MuaW5hY3RpdmVdPVxcXCJpc0luYWN0aXZlKGRhdGEpXFxcIlxcbiAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIC8+XFxuICAgICAgPHN2ZzpnIG5neC1jaGFydHMtbGluZVxcbiAgICAgICAgY2xhc3M9XFxcImxpbmUtc2VyaWVzXFxcIlxcbiAgICAgICAgW2RhdGFdPVxcXCJkYXRhXFxcIlxcbiAgICAgICAgW3BhdGhdPVxcXCJwYXRoXFxcIlxcbiAgICAgICAgW3N0cm9rZV09XFxcInN0cm9rZVxcXCJcXG4gICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgIFtjbGFzcy5hY3RpdmVdPVxcXCJpc0FjdGl2ZShkYXRhKVxcXCJcXG4gICAgICAgIFtjbGFzcy5pbmFjdGl2ZV09XFxcImlzSW5hY3RpdmUoZGF0YSlcXFwiXFxuICAgICAgLz5cXG4gICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLWFyZWFcXG4gICAgICAgICpuZ0lmPVxcXCJoYXNSYW5nZVxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJsaW5lLXNlcmllcy1yYW5nZVxcXCJcXG4gICAgICAgIFtkYXRhXT1cXFwiZGF0YVxcXCJcXG4gICAgICAgIFtwYXRoXT1cXFwib3V0ZXJQYXRoXFxcIlxcbiAgICAgICAgW2ZpbGxdPVxcXCJoYXNHcmFkaWVudCA/IGdyYWRpZW50VXJsIDogY29sb3JzLmdldENvbG9yKGRhdGEubmFtZSlcXFwiXFxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiaXNBY3RpdmUoZGF0YSlcXFwiXFxuICAgICAgICBbY2xhc3MuaW5hY3RpdmVdPVxcXCJpc0luYWN0aXZlKGRhdGEpXFxcIlxcbiAgICAgICAgW29wYWNpdHldPVxcXCJyYW5nZUZpbGxPcGFjaXR5XFxcIlxcbiAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgTGluZVNlcmllc0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTGluZVNlcmllc0NvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBMaW5lQ2hhcnRNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMaW5lQ2hhcnRNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBMaW5lQ2hhcnRNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDaGFydENvbW1vbk1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgTGluZUNvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIExpbmVDaGFydENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIExpbmVTZXJpZXNDb21wb25lbnRcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZXhwb3J0czogW1xyXG4gICAgICAgICAgICAgICAgTGluZUNvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIExpbmVDaGFydENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIExpbmVTZXJpZXNDb21wb25lbnRcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBMaW5lQ2hhcnRNb2R1bGUpO1xyXG4gICAgcmV0dXJuIExpbmVDaGFydE1vZHVsZTtcclxufSgpKTtcclxuXHJcbnZhciB0d29QSSA9IDIgKiBNYXRoLlBJO1xyXG52YXIgUG9sYXJDaGFydENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQb2xhckNoYXJ0Q29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUG9sYXJDaGFydENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy5zaG93R3JpZExpbmVzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5jdXJ2ZSA9IGN1cnZlQ2FyZGluYWxDbG9zZWQ7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnJhbmdlRmlsbE9wYWNpdHkgPSAwLjE1O1xyXG4gICAgICAgIF90aGlzLnRyaW1ZQXhpc1RpY2tzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5tYXhZQXhpc1RpY2tMZW5ndGggPSAxNjtcclxuICAgICAgICBfdGhpcy5yb3VuZERvbWFpbnMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zaG93U2VyaWVzT25Ib3ZlciA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMuZ3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy55QXhpc01pblNjYWxlID0gMDtcclxuICAgICAgICBfdGhpcy5sYWJlbFRyaW0gPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmxhYmVsVHJpbVNpemUgPSAxMDtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgX3RoaXMueEF4aXNIZWlnaHQgPSAwO1xyXG4gICAgICAgIF90aGlzLnlBeGlzV2lkdGggPSAwO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0RGltcygpO1xyXG4gICAgICAgIHRoaXMuc2V0U2NhbGVzKCk7XHJcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZE9wdGlvbnMgPSB0aGlzLmdldExlZ2VuZE9wdGlvbnMoKTtcclxuICAgICAgICB0aGlzLnNldFRpY2tzKCk7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuc2V0RGltcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpbixcclxuICAgICAgICAgICAgc2hvd1hBeGlzOiB0aGlzLnhBeGlzLFxyXG4gICAgICAgICAgICBzaG93WUF4aXM6IHRoaXMueUF4aXMsXHJcbiAgICAgICAgICAgIHhBeGlzSGVpZ2h0OiB0aGlzLnhBeGlzSGVpZ2h0LFxyXG4gICAgICAgICAgICB5QXhpc1dpZHRoOiB0aGlzLnlBeGlzV2lkdGgsXHJcbiAgICAgICAgICAgIHNob3dYTGFiZWw6IHRoaXMuc2hvd1hBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dZTGFiZWw6IHRoaXMuc2hvd1lBeGlzTGFiZWwsXHJcbiAgICAgICAgICAgIHNob3dMZWdlbmQ6IHRoaXMubGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRUeXBlOiB0aGlzLnNjaGVtZVR5cGUsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGhhbGZXaWR0aCA9IE1hdGguZmxvb3IodGhpcy5kaW1zLndpZHRoIC8gMik7XHJcbiAgICAgICAgdmFyIGhhbGZIZWlnaHQgPSBNYXRoLmZsb29yKHRoaXMuZGltcy5oZWlnaHQgLyAyKTtcclxuICAgICAgICB2YXIgb3V0ZXJSYWRpdXMgPSAodGhpcy5vdXRlclJhZGl1cyA9IE1hdGgubWluKGhhbGZIZWlnaHQgLyAxLjUsIGhhbGZXaWR0aCAvIDEuNSkpO1xyXG4gICAgICAgIHZhciB5T2Zmc2V0ID0gTWF0aC5tYXgoMCwgaGFsZkhlaWdodCAtIG91dGVyUmFkaXVzKTtcclxuICAgICAgICB0aGlzLnlBeGlzRGltcyA9IF9fYXNzaWduKHt9LCB0aGlzLmRpbXMsIHsgd2lkdGg6IGhhbGZXaWR0aCB9KTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtWUF4aXMgPSBcInRyYW5zbGF0ZSgwLCBcIiArIHlPZmZzZXQgKyBcIilcIjtcclxuICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gdGhpcy5kaW1zLmhlaWdodCArIDQwO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtUGxvdCA9IFwidHJhbnNsYXRlKFwiICsgaGFsZldpZHRoICsgXCIsIFwiICsgaGFsZkhlaWdodCArIFwiKVwiO1xyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnNldFNjYWxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgeFZhbHVlcyA9IHRoaXMuZ2V0WFZhbHVlcygpO1xyXG4gICAgICAgIHRoaXMuc2NhbGVUeXBlID0gZ2V0U2NhbGVUeXBlKHhWYWx1ZXMpO1xyXG4gICAgICAgIHRoaXMueERvbWFpbiA9IHRoaXMuZmlsdGVyZWREb21haW4gfHwgdGhpcy5nZXRYRG9tYWluKHhWYWx1ZXMpO1xyXG4gICAgICAgIHRoaXMueURvbWFpbiA9IHRoaXMuZ2V0WURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzRG9tYWluID0gdGhpcy5nZXRTZXJpZXNEb21haW4oKTtcclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHRoaXMuZ2V0WFNjYWxlKHRoaXMueERvbWFpbiwgdHdvUEkpO1xyXG4gICAgICAgIHRoaXMueVNjYWxlID0gdGhpcy5nZXRZU2NhbGUodGhpcy55RG9tYWluLCB0aGlzLm91dGVyUmFkaXVzKTtcclxuICAgICAgICB0aGlzLnlBeGlzU2NhbGUgPSB0aGlzLmdldFlTY2FsZSh0aGlzLnlEb21haW4ucmV2ZXJzZSgpLCB0aGlzLm91dGVyUmFkaXVzKTtcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRUaWNrcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB0aWNrRm9ybWF0O1xyXG4gICAgICAgIGlmICh0aGlzLnhBeGlzVGlja0Zvcm1hdHRpbmcpIHtcclxuICAgICAgICAgICAgdGlja0Zvcm1hdCA9IHRoaXMueEF4aXNUaWNrRm9ybWF0dGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy54U2NhbGUudGlja0Zvcm1hdCkge1xyXG4gICAgICAgICAgICB0aWNrRm9ybWF0ID0gdGhpcy54U2NhbGUudGlja0Zvcm1hdC5hcHBseSh0aGlzLnhTY2FsZSwgWzVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRpY2tGb3JtYXQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGF0ZShkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG91dGVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cztcclxuICAgICAgICB2YXIgcyA9IDEuMTtcclxuICAgICAgICB0aGlzLnRoZXRhVGlja3MgPSB0aGlzLnhEb21haW4ubWFwKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gX3RoaXMueFNjYWxlKGQpO1xyXG4gICAgICAgICAgICB2YXIgZGQgPSBzICogb3V0ZXJSYWRpdXMgKiAoc3RhcnRBbmdsZSA+IE1hdGguUEkgPyAtMSA6IDEpO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSB0aWNrRm9ybWF0KGQpO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSBbb3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSwgLW91dGVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSldO1xyXG4gICAgICAgICAgICB2YXIgcG9zID0gW2RkLCBzICogc3RhcnRQb3NbMV1dO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaW5uZXJSYWRpdXM6IDAsXHJcbiAgICAgICAgICAgICAgICBvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3V0ZXJSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICBsYWJlbDogbGFiZWwsXHJcbiAgICAgICAgICAgICAgICBzdGFydFBvczogc3RhcnRQb3MsXHJcbiAgICAgICAgICAgICAgICBwb3M6IHBvc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBtaW5EaXN0YW5jZSA9IDEwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50aGV0YVRpY2tzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMudGhldGFUaWNrc1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgdGhpcy50aGV0YVRpY2tzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHRoaXMudGhldGFUaWNrc1tqXTtcclxuICAgICAgICAgICAgICAgIGlmIChiLnBvc1swXSAqIGEucG9zWzBdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gbWluRGlzdGFuY2UgLSBNYXRoLmFicyhiLnBvc1sxXSAtIGEucG9zWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5wb3NbMV0gKz0gTWF0aC5zaWduKGIucG9zWzBdKSAqIG87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmFkaXVzVGlja3MgPSB0aGlzLnlBeGlzU2NhbGUudGlja3MoTWF0aC5mbG9vcih0aGlzLmRpbXMuaGVpZ2h0IC8gNTApKS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLnlTY2FsZShkKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMucmVzdWx0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSByZXN1bHRzLnNlcmllczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZXMuaW5jbHVkZXMoZC5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGQubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRYRG9tYWluID0gZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSB0aGlzLmdldFhWYWx1ZXMoKTsgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICB2YXIgbWF4JCQxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBOdW1iZXIodik7IH0pO1xyXG4gICAgICAgICAgICB2YXIgbWluJCQxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBbbWluJCQxLCBtYXgkJDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnJlc3VsdHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gcmVzdWx0cy5zZXJpZXM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF9jW19iXTtcclxuICAgICAgICAgICAgICAgIGlmIChkb21haW4uaW5kZXhPZihkLnZhbHVlKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21haW4ucHVzaChkLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkLm1pbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbi5pbmRleE9mKGQubWluKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5taW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkLm1heCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbi5pbmRleE9mKGQubWF4KSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLnB1c2goZC5tYXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZG9tYWluO1xyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFlEb21haW4gPSBmdW5jdGlvbiAoZG9tYWluKSB7XHJcbiAgICAgICAgaWYgKGRvbWFpbiA9PT0gdm9pZCAwKSB7IGRvbWFpbiA9IHRoaXMuZ2V0WVZhbHVlcygpOyB9XHJcbiAgICAgICAgdmFyIG1pbiQkMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGRvbWFpbik7XHJcbiAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIFt0aGlzLnlBeGlzTWluU2NhbGVdLmNvbmNhdChkb21haW4pKTtcclxuICAgICAgICBtaW4kJDEgPSBNYXRoLm1heCgwLCBtaW4kJDEpO1xyXG4gICAgICAgIGlmICghdGhpcy5hdXRvU2NhbGUpIHtcclxuICAgICAgICAgICAgbWluJCQxID0gTWF0aC5taW4oMCwgbWluJCQxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFttaW4kJDEsIG1heCQkMV07XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2VyaWVzRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWU7IH0pO1xyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldFhTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIHdpZHRoKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnNjYWxlVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICd0aW1lJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZVRpbWUoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcclxuICAgICAgICAgICAgY2FzZSAnbGluZWFyJzpcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSlcclxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGRvbWFpbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY2FsZVBvaW50KClcclxuICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoIC0gdHdvUEkgLyBkb21haW4ubGVuZ3RoXSlcclxuICAgICAgICAgICAgICAgICAgICAucGFkZGluZygwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0WVNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzAsIGhlaWdodF0pXHJcbiAgICAgICAgICAgIC5kb21haW4oZG9tYWluKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3VuZERvbWFpbnMgPyBzY2FsZS5uaWNlKCkgOiBzY2FsZTtcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEsIHNlcmllcykge1xyXG4gICAgICAgIGlmIChzZXJpZXMpIHtcclxuICAgICAgICAgICAgZGF0YS5zZXJpZXMgPSBzZXJpZXMubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvbWFpbiA9IHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnID8gdGhpcy5zZXJpZXNEb21haW4gOiB0aGlzLnlEb21haW4ucmV2ZXJzZSgpO1xyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCB0aGlzLnNjaGVtZVR5cGUsIGRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lVHlwZSA9PT0gJ29yZGluYWwnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yczogdGhpcy5jb2xvcnMsXHJcbiAgICAgICAgICAgICAgICBkb21haW46IHRoaXMuc2VyaWVzRG9tYWluLFxyXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRoaXMubGVnZW5kVGl0bGUsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzY2FsZVR5cGU6IHRoaXMuc2NoZW1lVHlwZSxcclxuICAgICAgICAgICAgY29sb3JzOiB0aGlzLmNvbG9ycy5zY2FsZSxcclxuICAgICAgICAgICAgZG9tYWluOiB0aGlzLnlEb21haW4sXHJcbiAgICAgICAgICAgIHRpdGxlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVZQXhpc1dpZHRoID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGg7XHJcbiAgICAgICAgdGhpcy55QXhpc1dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVYQXhpc0hlaWdodCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy54QXhpc0hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuc2hvd1Nlcmllc09uSG92ZXIgPyBbaXRlbV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcykgOiB0aGlzLmFjdGl2ZUVudHJpZXM7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZGVhY3RpdmF0ZUFsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSB0aGlzLmFjdGl2ZUVudHJpZXMuc2xpY2UoKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5hY3RpdmVFbnRyaWVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGVudHJ5LCBlbnRyaWVzOiBbXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICB9O1xyXG4gICAgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRUaXRsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1hBeGlzTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93WUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieEF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImF1dG9TY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dHcmlkTGluZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImN1cnZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNjaGVtZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlRmlsbE9wYWNpdHlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltWUF4aXNUaWNrc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4WUF4aXNUaWNrTGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInhBeGlzVGlja0Zvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwieUF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJvdW5kRG9tYWluc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dTZXJpZXNPbkhvdmVyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInlBeGlzTWluU2NhbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFRyaW1cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVHJpbVNpemVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIFBvbGFyQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBQb2xhckNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBQb2xhckNoYXJ0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLXBvbGFyLWNoYXJ0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0XFxuICAgICAgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiXFxuICAgICAgW3Nob3dMZWdlbmRdPVxcXCJsZWdlbmRcXFwiXFxuICAgICAgW2xlZ2VuZE9wdGlvbnNdPVxcXCJsZWdlbmRPcHRpb25zXFxcIlxcbiAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsRGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICA+XFxuICAgICAgPHN2ZzpnIGNsYXNzPVxcXCJwb2xhci1jaGFydCBjaGFydFxcXCIgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtXFxcIj5cXG4gICAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1QbG90XFxcIj5cXG4gICAgICAgICAgPHN2ZzpjaXJjbGUgY2xhc3M9XFxcInBvbGFyLWNoYXJ0LWJhY2tncm91bmRcXFwiIGN4PVxcXCIwXFxcIiBjeT1cXFwiMFxcXCIgW2F0dHIucl09XFxcInRoaXMub3V0ZXJSYWRpdXNcXFwiIC8+XFxuICAgICAgICAgIDxzdmc6ZyAqbmdJZj1cXFwic2hvd0dyaWRMaW5lc1xcXCI+XFxuICAgICAgICAgICAgPHN2ZzpjaXJjbGVcXG4gICAgICAgICAgICAgICpuZ0Zvcj1cXFwibGV0IHIgb2YgcmFkaXVzVGlja3NcXFwiXFxuICAgICAgICAgICAgICBjbGFzcz1cXFwiZ3JpZGxpbmUtcGF0aCByYWRpYWwtZ3JpZGxpbmUtcGF0aFxcXCJcXG4gICAgICAgICAgICAgIGN4PVxcXCIwXFxcIlxcbiAgICAgICAgICAgICAgY3k9XFxcIjBcXFwiXFxuICAgICAgICAgICAgICBbYXR0ci5yXT1cXFwiclxcXCJcXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgICA8c3ZnOmcgKm5nSWY9XFxcInhBeGlzXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtcGllLWxhYmVsXFxuICAgICAgICAgICAgICAqbmdGb3I9XFxcImxldCB0aWNrIG9mIHRoZXRhVGlja3NcXFwiXFxuICAgICAgICAgICAgICBbZGF0YV09XFxcInRpY2tcXFwiXFxuICAgICAgICAgICAgICBbcmFkaXVzXT1cXFwib3V0ZXJSYWRpdXNcXFwiXFxuICAgICAgICAgICAgICBbbGFiZWxdPVxcXCJ0aWNrLmxhYmVsXFxcIlxcbiAgICAgICAgICAgICAgW21heF09XFxcIm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgICAgW3ZhbHVlXT1cXFwic2hvd0dyaWRMaW5lcyA/IDEgOiBvdXRlclJhZGl1c1xcXCJcXG4gICAgICAgICAgICAgIFtleHBsb2RlU2xpY2VzXT1cXFwidHJ1ZVxcXCJcXG4gICAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAgIFtsYWJlbFRyaW1dPVxcXCJsYWJlbFRyaW1cXFwiXFxuICAgICAgICAgICAgICBbbGFiZWxUcmltU2l6ZV09XFxcImxhYmVsVHJpbVNpemVcXFwiXFxuICAgICAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMteS1heGlzXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVlBeGlzXFxcIlxcbiAgICAgICAgICAqbmdJZj1cXFwieUF4aXNcXFwiXFxuICAgICAgICAgIFt5U2NhbGVdPVxcXCJ5QXhpc1NjYWxlXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcInlBeGlzRGltc1xcXCJcXG4gICAgICAgICAgW3Nob3dHcmlkTGluZXNdPVxcXCJzaG93R3JpZExpbmVzXFxcIlxcbiAgICAgICAgICBbc2hvd0xhYmVsXT1cXFwic2hvd1lBeGlzTGFiZWxcXFwiXFxuICAgICAgICAgIFtsYWJlbFRleHRdPVxcXCJ5QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbdHJpbVRpY2tzXT1cXFwidHJpbVlBeGlzVGlja3NcXFwiXFxuICAgICAgICAgIFttYXhUaWNrTGVuZ3RoXT1cXFwibWF4WUF4aXNUaWNrTGVuZ3RoXFxcIlxcbiAgICAgICAgICBbdGlja0Zvcm1hdHRpbmddPVxcXCJ5QXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVxcXCJ1cGRhdGVZQXhpc1dpZHRoKCRldmVudClcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWF4aXMtbGFiZWxcXG4gICAgICAgICAgKm5nSWY9XFxcInhBeGlzICYmIHNob3dYQXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbbGFiZWxdPVxcXCJ4QXhpc0xhYmVsXFxcIlxcbiAgICAgICAgICBbb2Zmc2V0XT1cXFwibGFiZWxPZmZzZXRcXFwiXFxuICAgICAgICAgIFtvcmllbnRdPVxcXCInYm90dG9tJ1xcXCJcXG4gICAgICAgICAgW2hlaWdodF09XFxcImRpbXMuaGVpZ2h0XFxcIlxcbiAgICAgICAgICBbd2lkdGhdPVxcXCJkaW1zLndpZHRoXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtUGxvdFxcXCI+XFxuICAgICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2YgcmVzdWx0czsgdHJhY2tCeTogdHJhY2tCeVxcXCIgW0BhbmltYXRpb25TdGF0ZV09XFxcIidhY3RpdmUnXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgICAgIG5neC1jaGFydHMtcG9sYXItc2VyaWVzXFxuICAgICAgICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgICAgICAgIFt4U2NhbGVdPVxcXCJ4U2NhbGVcXFwiXFxuICAgICAgICAgICAgICBbeVNjYWxlXT1cXFwieVNjYWxlXFxcIlxcbiAgICAgICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgICAgIFtkYXRhXT1cXFwic2VyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgICAgICAgICAgW3NjYWxlVHlwZV09XFxcInNjYWxlVHlwZVxcXCJcXG4gICAgICAgICAgICAgIFtjdXJ2ZV09XFxcImN1cnZlXFxcIlxcbiAgICAgICAgICAgICAgW3JhbmdlRmlsbE9wYWNpdHldPVxcXCJyYW5nZUZpbGxPcGFjaXR5XFxcIlxcbiAgICAgICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgKGFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXHJcbiAgICAgICAgICAgICAgICBcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCIsXHJcbiAgICAgICAgICAgICAgICBcIi5waWUtbGFiZWx7Zm9udC1zaXplOjExcHh9LnBpZS1sYWJlbC5hbmltYXRpb257YW5pbWF0aW9uOjc1MG1zIGVhc2UtaW4gZmFkZUlufUBrZXlmcmFtZXMgZmFkZUlue2Zyb217b3BhY2l0eTowfXRve29wYWNpdHk6MX19LnBpZS1sYWJlbC1saW5le3N0cm9rZS1kYXNoYXJyYXk6MTAwJX0ucGllLWxhYmVsLWxpbmUuYW5pbWF0aW9ue2FuaW1hdGlvbjozcyBsaW5lYXIgZHJhd091dDt0cmFuc2l0aW9uOmQgNzUwbXN9QGtleWZyYW1lcyBkcmF3T3V0e2Zyb217c3Ryb2tlLWRhc2hvZmZzZXQ6MTAwJX10b3tzdHJva2UtZGFzaG9mZnNldDowfX1cIixcclxuICAgICAgICAgICAgICAgIFwiLnBvbGFyLWNoYXJ0IC5wb2xhci1jaGFydC1iYWNrZ3JvdW5ke2ZpbGw6bm9uZX0ucG9sYXItY2hhcnQgLnJhZGlhbC1ncmlkbGluZS1wYXRoe3N0cm9rZS1kYXNoYXJyYXk6MTAgMTA7ZmlsbDpub25lfS5wb2xhci1jaGFydCAucGllLWxhYmVsLWxpbmV7c3Ryb2tlOiMyZjM2NDZ9LnBvbGFyLWNoYXJ0cy1zZXJpZXMgLnBvbGFyLXNlcmllcy1hcmVhe3BvaW50ZXItZXZlbnRzOm5vbmV9LnBvbGFyLXNlcmllcy1wYXRoe3BvaW50ZXItZXZlbnRzOm5vbmV9XCJcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIoJ2FuaW1hdGlvblN0YXRlJywgW1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgUG9sYXJDaGFydENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gUG9sYXJDaGFydENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBQb2xhclNlcmllc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvbGFyU2VyaWVzQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5jaXJjbGVSYWRpdXMgPSAzO1xyXG4gICAgfVxyXG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnVwZGF0ZUdyYWRpZW50cygpO1xyXG4gICAgICAgIHZhciBsaW5lJCQxID0gdGhpcy5nZXRMaW5lR2VuZXJhdG9yKCk7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnNvcnREYXRhKHRoaXMuZGF0YS5zZXJpZXMpO1xyXG4gICAgICAgIHZhciBzZXJpZXNOYW1lID0gdGhpcy5kYXRhLm5hbWU7XHJcbiAgICAgICAgdmFyIGxpbmVhclNjYWxlVHlwZSA9IHRoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcic7XHJcbiAgICAgICAgdmFyIG1pbiQkMSA9IHRoaXMueVNjYWxlLmRvbWFpbigpWzBdO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzQ29sb3IgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcihsaW5lYXJTY2FsZVR5cGUgPyBtaW4kJDEgOiBzZXJpZXNOYW1lKTtcclxuICAgICAgICB0aGlzLnBhdGggPSBsaW5lJCQxKGRhdGEpIHx8ICcnO1xyXG4gICAgICAgIHRoaXMuY2lyY2xlcyA9IGRhdGEubWFwKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gX3RoaXMuZ2V0QW5nbGUoZCk7XHJcbiAgICAgICAgICAgIHZhciByID0gX3RoaXMuZ2V0UmFkaXVzKGQpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkLnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IobGluZWFyU2NhbGVUeXBlID8gTWF0aC5hYnModmFsdWUpIDogc2VyaWVzTmFtZSk7XHJcbiAgICAgICAgICAgIHZhciBjRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGQsIHtcclxuICAgICAgICAgICAgICAgIHNlcmllczogc2VyaWVzTmFtZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIG5hbWU6IGQubmFtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGNEYXRhLFxyXG4gICAgICAgICAgICAgICAgY3g6IHIgKiBNYXRoLnNpbihhKSxcclxuICAgICAgICAgICAgICAgIGN5OiAtciAqIE1hdGguY29zKGEpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGQubmFtZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSh0aGlzLmRhdGEpO1xyXG4gICAgICAgIHRoaXMuaW5hY3RpdmUgPSB0aGlzLmlzSW5hY3RpdmUodGhpcy5kYXRhKTtcclxuICAgICAgICB0aGlzLnRvb2x0aXBUZXh0ID0gdGhpcy50b29sdGlwVGV4dCB8fCAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIF90aGlzLmRlZmF1bHRUb29sdGlwVGV4dChjKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldEFuZ2xlID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICB2YXIgbGFiZWwgPSBkLm5hbWU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAndGltZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueFNjYWxlKGxhYmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY2FsZVR5cGUgPT09ICdsaW5lYXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhTY2FsZShOdW1iZXIobGFiZWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueFNjYWxlKGxhYmVsKTtcclxuICAgIH07XHJcbiAgICBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0UmFkaXVzID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy55U2NhbGUoZC52YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldExpbmVHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbGluZVJhZGlhbCgpXHJcbiAgICAgICAgICAgIC5hbmdsZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMuZ2V0QW5nbGUoZCk7IH0pXHJcbiAgICAgICAgICAgIC5yYWRpdXMoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIF90aGlzLmdldFJhZGl1cyhkKTsgfSlcclxuICAgICAgICAgICAgLmN1cnZlKHRoaXMuY3VydmUpO1xyXG4gICAgfTtcclxuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5zb3J0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NhbGVUeXBlID09PSAnbGluZWFyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gc29ydExpbmVhcihkYXRhLCAnbmFtZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjYWxlVHlwZSA9PT0gJ3RpbWUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3J0QnlUaW1lKGRhdGEsICduYW1lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzb3J0QnlEb21haW4oZGF0YSwgJ25hbWUnLCAnYXNjJywgdGhpcy54U2NhbGUuZG9tYWluKCkpO1xyXG4gICAgfTtcclxuICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVtICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmlzSW5hY3RpdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRW50cmllcyB8fCB0aGlzLmFjdGl2ZUVudHJpZXMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpdGVtID09PSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmRlZmF1bHRUb29sdGlwVGV4dCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBsYWJlbCA9IF9hLmxhYmVsLCB2YWx1ZSA9IF9hLnZhbHVlO1xyXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIHRoaXMuZGF0YS5uYW1lICsgXCIgXFx1MjAyMiBcIiArIGxhYmVsICsgXCI8L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtdmFsXFxcIj5cIiArIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCkgKyBcIjwvc3Bhbj5cXG4gICAgXCI7XHJcbiAgICB9O1xyXG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZUdyYWRpZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhhc0dyYWRpZW50ID0gdGhpcy5ncmFkaWVudCB8fCB0aGlzLmNvbG9ycy5zY2FsZVR5cGUgPT09ICdsaW5lYXInO1xyXG4gICAgICAgIGlmICghdGhpcy5oYXNHcmFkaWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ3JhZGllbnRJZCA9ICdncmFkJyArIGlkKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmdyYWRpZW50VXJsID0gXCJ1cmwoI1wiICsgdGhpcy5ncmFkaWVudElkICsgXCIpXCI7XHJcbiAgICAgICAgaWYgKHRoaXMuY29sb3JzLnNjYWxlVHlwZSA9PT0gJ2xpbmVhcicpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZGF0YS5zZXJpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcclxuICAgICAgICAgICAgdmFyIG1heCQkMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XHJcbiAgICAgICAgICAgIHZhciBtaW4kJDEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50U3RvcHMgPSB0aGlzLmNvbG9ycy5nZXRMaW5lYXJHcmFkaWVudFN0b3BzKG1heCQkMSwgbWluJCQxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieFNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwieVNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2NhbGVUeXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VydmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZUVudHJpZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZUZpbGxPcGFjaXR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUG9sYXJTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBvbGFyU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgUG9sYXJTZXJpZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ2dbbmd4LWNoYXJ0cy1wb2xhci1zZXJpZXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBjbGFzcz1cXFwicG9sYXItY2hhcnRzLXNlcmllc1xcXCI+XFxuICAgICAgPGRlZnM+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1zdmctcmFkaWFsLWdyYWRpZW50XFxuICAgICAgICAgICpuZ0lmPVxcXCJoYXNHcmFkaWVudFxcXCJcXG4gICAgICAgICAgb3JpZW50YXRpb249XFxcInZlcnRpY2FsXFxcIlxcbiAgICAgICAgICBbY29sb3JdPVxcXCJzZXJpZXNDb2xvclxcXCJcXG4gICAgICAgICAgW25hbWVdPVxcXCJncmFkaWVudElkXFxcIlxcbiAgICAgICAgICBbc3RhcnRPcGFjaXR5XT1cXFwiMC4yNVxcXCJcXG4gICAgICAgICAgW2VuZE9wYWNpdHldPVxcXCIxXFxcIlxcbiAgICAgICAgICBbc3RvcHNdPVxcXCJncmFkaWVudFN0b3BzXFxcIlxcbiAgICAgICAgLz5cXG4gICAgICA8L2RlZnM+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLWxpbmVcXG4gICAgICAgIGNsYXNzPVxcXCJwb2xhci1zZXJpZXMtcGF0aFxcXCJcXG4gICAgICAgIFtwYXRoXT1cXFwicGF0aFxcXCJcXG4gICAgICAgIFtzdHJva2VdPVxcXCJoYXNHcmFkaWVudCA/IGdyYWRpZW50VXJsIDogc2VyaWVzQ29sb3JcXFwiXFxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiYWN0aXZlXFxcIlxcbiAgICAgICAgW2NsYXNzLmluYWN0aXZlXT1cXFwiaW5hY3RpdmVcXFwiXFxuICAgICAgICBbYXR0ci5maWxsLW9wYWNpdHldPVxcXCJyYW5nZUZpbGxPcGFjaXR5XFxcIlxcbiAgICAgICAgW2ZpbGxdPVxcXCJoYXNHcmFkaWVudCA/IGdyYWRpZW50VXJsIDogc2VyaWVzQ29sb3JcXFwiXFxuICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgLz5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtY2lyY2xlXFxuICAgICAgICAqbmdGb3I9XFxcImxldCBjaXJjbGUgb2YgY2lyY2xlc1xcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJjaXJjbGVcXFwiXFxuICAgICAgICBbY3hdPVxcXCJjaXJjbGUuY3hcXFwiXFxuICAgICAgICBbY3ldPVxcXCJjaXJjbGUuY3lcXFwiXFxuICAgICAgICBbcl09XFxcImNpcmNsZVJhZGl1c1xcXCJcXG4gICAgICAgIFtmaWxsXT1cXFwiY2lyY2xlLmNvbG9yXFxcIlxcbiAgICAgICAgW3N0eWxlLm9wYWNpdHldPVxcXCJpbmFjdGl2ZSA/IDAuMiA6IDFcXFwiXFxuICAgICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cXFwiJ3RvcCdcXFwiXFxuICAgICAgICB0b29sdGlwVHlwZT1cXFwidG9vbHRpcFxcXCJcXG4gICAgICAgIFt0b29sdGlwVGl0bGVdPVxcXCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiB0b29sdGlwVGV4dChjaXJjbGUpXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImNpcmNsZS5kYXRhXFxcIlxcbiAgICAgICAgKHNlbGVjdCk9XFxcInNlbGVjdC5lbWl0KGNpcmNsZS5kYXRhKVxcXCJcXG4gICAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlLmVtaXQoeyBuYW1lOiBjaXJjbGUuZGF0YS5zZXJpZXMgfSlcXFwiXFxuICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGUuZW1pdCh7IG5hbWU6IGNpcmNsZS5kYXRhLnNlcmllcyB9KVxcXCJcXG4gICAgICA+PC9zdmc6Zz5cXG4gICAgPC9zdmc6Zz5cXG4gIFwiLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBQb2xhclNlcmllc0NvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gUG9sYXJTZXJpZXNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5hY3RpdmVFbnRyaWVzID0gW107XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMubGFiZWwgPSAnVG90YWwnO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzIwLCAyMCwgMjAsIDIwXTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiAodGhpcy53aWR0aCAqIDQpIC8gMTIuMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW5cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmZvcm1hdERhdGVzKCk7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSB0aGlzLmdldERvbWFpbigpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdmFyIHhPZmZzZXQgPSB0aGlzLmRpbXMud2lkdGggLyAyO1xyXG4gICAgICAgIHZhciB5T2Zmc2V0ID0gdGhpcy5tYXJnaW5bMF0gKyB0aGlzLmRpbXMuaGVpZ2h0IC8gMjtcclxuICAgICAgICB0aGlzLmxlZ2VuZFdpZHRoID0gdGhpcy53aWR0aCAtIHRoaXMuZGltcy53aWR0aCAtIHRoaXMubWFyZ2luWzFdO1xyXG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBNYXRoLm1pbih0aGlzLmRpbXMud2lkdGgsIHRoaXMuZGltcy5oZWlnaHQpIC8gMi41O1xyXG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzICogMC43NTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgeE9mZnNldCArIFwiICwgXCIgKyB5T2Zmc2V0ICsgXCIpXCI7XHJcbiAgICB9O1xyXG4gICAgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUuZ2V0RG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmxhYmVsOyB9KTtcclxuICAgIH07XHJcbiAgICBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xyXG4gICAgfTtcclxuICAgIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgJ29yZGluYWwnLCB0aGlzLmRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgIGlmIChmcm9tTGVnZW5kID09PSB2b2lkIDApIHsgZnJvbUxlZ2VuZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0cy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbCA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kSW5kZXgoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZSA9PT0gaXRlbS5uYW1lICYmIGQudmFsdWUgPT09IGl0ZW0udmFsdWUgJiYgZC5zZXJpZXMgPT09IGl0ZW0uc2VyaWVzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpZHggPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IFtpdGVtXS5jb25jYXQodGhpcy5hY3RpdmVFbnRyaWVzKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uRGVhY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICBpdGVtID0gdGhpcy5yZXN1bHRzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZSAmJiBkLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlRW50cmllcyA9IHRoaXMuYWN0aXZlRW50cmllcy5zbGljZSgpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbiAgICBdLCBBZHZhbmNlZFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwZXJjZW50YWdlRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1hZHZhbmNlZC1waWUtY2hhcnQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdiBbc3R5bGUud2lkdGgucHhdPVxcXCJ3aWR0aFxcXCIgW3N0eWxlLmhlaWdodC5weF09XFxcImhlaWdodFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYWR2YW5jZWQtcGllIGNoYXJ0XFxcIiBbc3R5bGUud2lkdGgucHhdPVxcXCJkaW1zLndpZHRoXFxcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cXFwiZGltcy5oZWlnaHRcXFwiPlxcbiAgICAgICAgPG5neC1jaGFydHMtY2hhcnQgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiIFtzaG93TGVnZW5kXT1cXFwiZmFsc2VcXFwiIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCI+XFxuICAgICAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJwaWUgY2hhcnRcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgICAgbmd4LWNoYXJ0cy1waWUtc2VyaWVzXFxuICAgICAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICAgICAgW3Nlcmllc109XFxcInJlc3VsdHNcXFwiXFxuICAgICAgICAgICAgICBbaW5uZXJSYWRpdXNdPVxcXCJpbm5lclJhZGl1c1xcXCJcXG4gICAgICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgICAgIFtvdXRlclJhZGl1c109XFxcIm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICAgIFt0b29sdGlwVGV4dF09XFxcInRvb2x0aXBUZXh0XFxcIlxcbiAgICAgICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgIChkZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudClcXFwiXFxuICAgICAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYWR2YW5jZWQtcGllLWxlZ2VuZC13cmFwcGVyXFxcIiBbc3R5bGUud2lkdGgucHhdPVxcXCJ3aWR0aCAtIGRpbXMud2lkdGhcXFwiIFtzdHlsZS5oZWlnaHQucHhdPVxcXCJoZWlnaHRcXFwiPlxcbiAgICAgICAgPG5neC1jaGFydHMtYWR2YW5jZWQtbGVnZW5kXFxuICAgICAgICAgIFtkYXRhXT1cXFwicmVzdWx0c1xcXCJcXG4gICAgICAgICAgW2NvbG9yc109XFxcImNvbG9yc1xcXCJcXG4gICAgICAgICAgW3dpZHRoXT1cXFwid2lkdGggLSBkaW1zLndpZHRoIC0gbWFyZ2luWzFdXFxcIlxcbiAgICAgICAgICBbbGFiZWxdPVxcXCJsYWJlbFxcXCJcXG4gICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICBbbGFiZWxGb3JtYXR0aW5nXT1cXFwibmFtZUZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFtwZXJjZW50YWdlRm9ybWF0dGluZ109XFxcInBlcmNlbnRhZ2VGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAoYWN0aXZhdGUpPVxcXCJvbkFjdGl2YXRlKCRldmVudCwgdW5kZWZpbmVkLCB0cnVlKVxcXCJcXG4gICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50LCB1bmRlZmluZWQsIHRydWUpXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgPC9uZ3gtY2hhcnRzLWFkdmFuY2VkLWxlZ2VuZD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiLCBcIi5hZHZhbmNlZC1waWV7ZGlzcGxheTppbmxpbmUtYmxvY2s7ZmxvYXQ6bGVmdH0uYWR2YW5jZWQtcGllLWxlZ2VuZC13cmFwcGVye2Rpc3BsYXk6aW5saW5lLWJsb2NrfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBQaWVMYWJlbENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBpZUxhYmVsQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5sYWJlbFRyaW0gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFiZWxUcmltU2l6ZSA9IDEwO1xyXG4gICAgICAgIHRoaXMuaXNJRSA9IC8oZWRnZXxtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICAgICAgICB0aGlzLnRyaW1MYWJlbCA9IHRyaW1MYWJlbDtcclxuICAgIH1cclxuICAgIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzdGFydFJhZGl1cyA9IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIGlmICh0aGlzLmV4cGxvZGVTbGljZXMpIHtcclxuICAgICAgICAgICAgc3RhcnRSYWRpdXMgPSB0aGlzLnJhZGl1cyAqIHRoaXMudmFsdWUgLyB0aGlzLm1heDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlubmVyQXJjID0gYXJjKClcclxuICAgICAgICAgICAgLmlubmVyUmFkaXVzKHN0YXJ0UmFkaXVzKVxyXG4gICAgICAgICAgICAub3V0ZXJSYWRpdXMoc3RhcnRSYWRpdXMpO1xyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBpbm5lclBvcyB0aGVuIHNjYWxlIG91dGVyIHBvc2l0aW9uIHRvIG1hdGNoIGxhYmVsIHBvc2l0aW9uXHJcbiAgICAgICAgdmFyIGlubmVyUG9zID0gaW5uZXJBcmMuY2VudHJvaWQodGhpcy5kYXRhKTtcclxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmRhdGEucG9zWzFdIC8gaW5uZXJQb3NbMV07XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5wb3NbMV0gPT09IDAgfHwgaW5uZXJQb3NbMV0gPT09IDApIHtcclxuICAgICAgICAgICAgc2NhbGUgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3V0ZXJQb3MgPSBbc2NhbGUgKiBpbm5lclBvc1swXSwgc2NhbGUgKiBpbm5lclBvc1sxXV07XHJcbiAgICAgICAgdGhpcy5saW5lID0gXCJNXCIgKyBpbm5lclBvcyArIFwiTFwiICsgb3V0ZXJQb3MgKyBcIkxcIiArIHRoaXMuZGF0YS5wb3M7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0WFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEucG9zWzBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0WVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEucG9zWzFdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdHlsZVRyYW5zZm9ybVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzSUUgPyBudWxsIDogXCJ0cmFuc2xhdGUzZChcIiArIHRoaXMudGV4dFggKyBcInB4LFwiICsgdGhpcy50ZXh0WSArIFwicHgsIDApXCI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImF0dHJUcmFuc2Zvcm1cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuaXNJRSA/IG51bGwgOiBcInRyYW5zbGF0ZShcIiArIHRoaXMudGV4dFggKyBcIixcIiArIHRoaXMudGV4dFkgKyBcIilcIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwidGV4dFRyYW5zaXRpb25cIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0lFIHx8ICF0aGlzLmFuaW1hdGlvbnMgPyBudWxsIDogJ3RyYW5zZm9ybSAwLjc1cyc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUudGV4dEFuY2hvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taWRBbmdsZSh0aGlzLmRhdGEpIDwgTWF0aC5QSSA/ICdzdGFydCcgOiAnZW5kJztcclxuICAgIH07XHJcbiAgICBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUubWlkQW5nbGUgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwicmFkaXVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwbG9kZVNsaWNlc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZUxhYmVsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVHJpbVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgUGllTGFiZWxDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsVHJpbVNpemVcIiwgdm9pZCAwKTtcclxuICAgIFBpZUxhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtcGllLWxhYmVsXScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8dGl0bGU+e3tsYWJlbH19PC90aXRsZT5cXG4gICAgPHN2ZzpnXFxuICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwiYXR0clRyYW5zZm9ybVxcXCJcXG4gICAgICBbc3R5bGUudHJhbnNmb3JtXT1cXFwic3R5bGVUcmFuc2Zvcm1cXFwiXFxuICAgICAgW3N0eWxlLnRyYW5zaXRpb25dPVxcXCJ0ZXh0VHJhbnNpdGlvblxcXCI+XFxuICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICBjbGFzcz1cXFwicGllLWxhYmVsXFxcIlxcbiAgICAgICAgW2NsYXNzLmFuaW1hdGlvbl09XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICBkeT1cXFwiLjM1ZW1cXFwiXFxuICAgICAgICBbc3R5bGUudGV4dEFuY2hvcl09XFxcInRleHRBbmNob3IoKVxcXCJcXG4gICAgICAgIFtzdHlsZS5zaGFwZVJlbmRlcmluZ109XFxcIidjcmlzcEVkZ2VzJ1xcXCI+XFxuICAgICAgICB7e2xhYmVsVHJpbSA/IHRyaW1MYWJlbChsYWJlbCwgbGFiZWxUcmltU2l6ZSkgOiBsYWJlbH19XFxuICAgICAgPC9zdmc6dGV4dD5cXG4gICAgPC9zdmc6Zz5cXG4gICAgPHN2ZzpwYXRoXFxuICAgICAgW2F0dHIuZF09XFxcImxpbmVcXFwiXFxuICAgICAgW2F0dHIuc3Ryb2tlXT1cXFwiY29sb3JcXFwiXFxuICAgICAgZmlsbD1cXFwibm9uZVxcXCJcXG4gICAgICBjbGFzcz1cXFwicGllLWxhYmVsLWxpbmUgbGluZVxcXCJcXG4gICAgICBbY2xhc3MuYW5pbWF0aW9uXT1cXFwiYW5pbWF0aW9uc1xcXCI+XFxuICAgIDwvc3ZnOnBhdGg+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbiAgICBdLCBQaWVMYWJlbENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gUGllTGFiZWxDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgUGllQXJjQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGllQXJjQ29tcG9uZW50KGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0QW5nbGUgPSAwO1xyXG4gICAgICAgIHRoaXMuZW5kQW5nbGUgPSBNYXRoLlBJICogMjtcclxuICAgICAgICB0aGlzLmNvcm5lclJhZGl1cyA9IDA7XHJcbiAgICAgICAgdGhpcy5leHBsb2RlU2xpY2VzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wb2ludGVyRXZlbnRzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kYmxjbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudC5uYXRpdmVFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLmdldEdyYWRpZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdyYWRpZW50ID8gdGhpcy5ncmFkaWVudEZpbGwgOiB0aGlzLmZpbGw7XHJcbiAgICB9O1xyXG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS5nZXRQb2ludGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50ZXJFdmVudHMgPyAnYXV0bycgOiAnbm9uZSc7XHJcbiAgICB9O1xyXG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNhbGMgPSB0aGlzLmNhbGN1bGF0ZUFyYygpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRPcGFjaXR5ID0gMC41O1xyXG4gICAgICAgIHRoaXMucmFkaWFsR3JhZGllbnRJZCA9ICdsaW5lYXJHcmFkJyArIGlkKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmdyYWRpZW50RmlsbCA9IFwidXJsKCNcIiArIHRoaXMucmFkaWFsR3JhZGllbnRJZCArIFwiKVwiO1xyXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRBbmltYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBjYWxjLnN0YXJ0QW5nbGUodGhpcy5zdGFydEFuZ2xlKS5lbmRBbmdsZSh0aGlzLmVuZEFuZ2xlKSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLmNhbGN1bGF0ZUFyYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3V0ZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzO1xyXG4gICAgICAgIGlmICh0aGlzLmV4cGxvZGVTbGljZXMgJiYgdGhpcy5pbm5lclJhZGl1cyA9PT0gMCkge1xyXG4gICAgICAgICAgICBvdXRlclJhZGl1cyA9ICh0aGlzLm91dGVyUmFkaXVzICogdGhpcy52YWx1ZSkgLyB0aGlzLm1heDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyYygpXHJcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cyh0aGlzLmlubmVyUmFkaXVzKVxyXG4gICAgICAgICAgICAub3V0ZXJSYWRpdXMob3V0ZXJSYWRpdXMpXHJcbiAgICAgICAgICAgIC5jb3JuZXJSYWRpdXModGhpcy5jb3JuZXJSYWRpdXMpO1xyXG4gICAgfTtcclxuICAgIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUubG9hZEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5hcmMnKVxyXG4gICAgICAgICAgICAuZGF0YShbeyBzdGFydEFuZ2xlOiB0aGlzLnN0YXJ0QW5nbGUsIGVuZEFuZ2xlOiB0aGlzLmVuZEFuZ2xlIH1dKTtcclxuICAgICAgICB2YXIgY2FsYyA9IHRoaXMuY2FsY3VsYXRlQXJjKCk7XHJcbiAgICAgICAgbm9kZVxyXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgIC5hdHRyVHdlZW4oJ2QnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkO1xyXG4gICAgICAgICAgICB2YXIgY29weU9mRCA9IE9iamVjdC5hc3NpZ24oe30sIGQpO1xyXG4gICAgICAgICAgICBjb3B5T2ZELmVuZEFuZ2xlID0gY29weU9mRC5zdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGVyID0gaW50ZXJwb2xhdGUoY29weU9mRCwgY29weU9mRCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZXIoMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGMoaW50ZXJwb2xhdGVyKHQpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgIC5kdXJhdGlvbig3NTApXHJcbiAgICAgICAgICAgIC5hdHRyVHdlZW4oJ2QnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGVyID0gaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZXIoMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGMoaW50ZXJwb2xhdGVyKHQpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5hcmMnKVxyXG4gICAgICAgICAgICAuZGF0YShbeyBzdGFydEFuZ2xlOiB0aGlzLnN0YXJ0QW5nbGUsIGVuZEFuZ2xlOiB0aGlzLmVuZEFuZ2xlIH1dKTtcclxuICAgICAgICB2YXIgY2FsYyA9IHRoaXMuY2FsY3VsYXRlQXJjKCk7XHJcbiAgICAgICAgbm9kZVxyXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgIC5kdXJhdGlvbig3NTApXHJcbiAgICAgICAgICAgIC5hdHRyVHdlZW4oJ2QnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fY3VycmVudCB8fCBkO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGVyID0gaW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZXIoMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGMoaW50ZXJwb2xhdGVyKHQpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XHJcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2VsZWN0LmVtaXQoX3RoaXMuZGF0YSk7IH0sIDIwMCk7XHJcbiAgICB9O1xyXG4gICAgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZS5vbkRibENsaWNrID0gZnVuY3Rpb24gKGV2ZW50JCQxKSB7XHJcbiAgICAgICAgZXZlbnQkJDEucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudCQkMS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XHJcbiAgICAgICAgdGhpcy5kYmxjbGljay5lbWl0KHtcclxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxyXG4gICAgICAgICAgICBuYXRpdmVFdmVudDogZXZlbnQkJDFcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImZpbGxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlbmRBbmdsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvdXRlclJhZGl1c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb3JuZXJSYWRpdXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImV4cGxvZGVTbGljZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBQaWVBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb2ludGVyRXZlbnRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0FjdGl2ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUFyY0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGJsY2xpY2tcIiwgdm9pZCAwKTtcclxuICAgIFBpZUFyY0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXBpZS1hcmNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBjbGFzcz1cXFwiYXJjLWdyb3VwXFxcIj5cXG4gICAgICA8c3ZnOmRlZnMgKm5nSWY9XFxcImdyYWRpZW50XFxcIj5cXG4gICAgICAgIDxzdmc6ZyBuZ3gtY2hhcnRzLXN2Zy1yYWRpYWwtZ3JhZGllbnRcXG4gICAgICAgICAgW2NvbG9yXT1cXFwiZmlsbFxcXCJcXG4gICAgICAgICAgb3JpZW50YXRpb249XFxcInZlcnRpY2FsXFxcIlxcbiAgICAgICAgICBbbmFtZV09XFxcInJhZGlhbEdyYWRpZW50SWRcXFwiXFxuICAgICAgICAgIFtzdGFydE9wYWNpdHldPVxcXCJzdGFydE9wYWNpdHlcXFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvc3ZnOmRlZnM+XFxuICAgICAgPHN2ZzpwYXRoXFxuICAgICAgICBbYXR0ci5kXT1cXFwicGF0aFxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJhcmNcXFwiXFxuICAgICAgICBbY2xhc3MuYWN0aXZlXT1cXFwiaXNBY3RpdmVcXFwiXFxuICAgICAgICBbYXR0ci5maWxsXT1cXFwiZ2V0R3JhZGllbnQoKVxcXCJcXG4gICAgICAgIChjbGljayk9XFxcIm9uQ2xpY2soKVxcXCJcXG4gICAgICAgIChkYmxjbGljayk9XFxcIm9uRGJsQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgIChtb3VzZWVudGVyKT1cXFwiYWN0aXZhdGUuZW1pdChkYXRhKVxcXCJcXG4gICAgICAgIChtb3VzZWxlYXZlKT1cXFwiZGVhY3RpdmF0ZS5lbWl0KGRhdGEpXFxcIlxcbiAgICAgICAgW3N0eWxlLnBvaW50ZXItZXZlbnRzXT1cXFwiZ2V0UG9pbnRlckV2ZW50cygpXFxcIlxcbiAgICAgIC8+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW3R5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3RdKVxyXG4gICAgXSwgUGllQXJjQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBQaWVBcmNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgUGllQ2hhcnRDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUGllQ2hhcnRDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQaWVDaGFydENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sYWJlbHMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy5leHBsb2RlU2xpY2VzID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuZG91Z2hudXQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5hcmNXaWR0aCA9IDAuMjU7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnRyaW1MYWJlbHMgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLm1heExhYmVsTGVuZ3RoID0gMTA7XHJcbiAgICAgICAgX3RoaXMuZGJsY2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMubGFiZWxzICYmIHRoaXMuaGFzTm9PcHRpb25hbE1hcmdpbnNTZXQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1hcmdpbnMgPSBbMzAsIDgwLCAzMCwgODBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghdGhpcy5sYWJlbHMgJiYgdGhpcy5oYXNOb09wdGlvbmFsTWFyZ2luc1NldCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFyZ2lucyA9IFsyMCwgMjAsIDIwLCAyMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2lucyxcclxuICAgICAgICAgICAgc2hvd0xlZ2VuZDogdGhpcy5sZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB0aGlzLmxlZ2VuZFBvc2l0aW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5mb3JtYXREYXRlcygpO1xyXG4gICAgICAgIHZhciB4T2Zmc2V0ID0gdGhpcy5tYXJnaW5zWzNdICsgdGhpcy5kaW1zLndpZHRoIC8gMjtcclxuICAgICAgICB2YXIgeU9mZnNldCA9IHRoaXMubWFyZ2luc1swXSArIHRoaXMuZGltcy5oZWlnaHQgLyAyO1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRpb24gPSBcInRyYW5zbGF0ZShcIiArIHhPZmZzZXQgKyBcIiwgXCIgKyB5T2Zmc2V0ICsgXCIpXCI7XHJcbiAgICAgICAgdGhpcy5vdXRlclJhZGl1cyA9IE1hdGgubWluKHRoaXMuZGltcy53aWR0aCwgdGhpcy5kaW1zLmhlaWdodCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGFiZWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgLz0gMztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgLz0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuZG91Z2hudXQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgKiAoMSAtIHRoaXMuYXJjV2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5yZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRvbWFpbi5pbmRleE9mKGEubmFtZSkgLSBfdGhpcy5kb21haW4uaW5kZXhPZihiLm5hbWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICB9O1xyXG4gICAgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLmdldERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5sYWJlbDsgfSk7XHJcbiAgICB9O1xyXG4gICAgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgJ29yZGluYWwnLCB0aGlzLmRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5nZXRMZWdlbmRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNjYWxlVHlwZTogJ29yZGluYWwnLFxyXG4gICAgICAgICAgICBkb21haW46IHRoaXMuZG9tYWluLFxyXG4gICAgICAgICAgICBjb2xvcnM6IHRoaXMuY29sb3JzLFxyXG4gICAgICAgICAgICB0aXRsZTogdGhpcy5sZWdlbmRUaXRsZSxcclxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbaXRlbV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcyk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZS5oYXNOb09wdGlvbmFsTWFyZ2luc1NldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMubWFyZ2lucyB8fCB0aGlzLm1hcmdpbnMubGVuZ3RoIDw9IDA7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImV4cGxvZGVTbGljZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkb3VnaG51dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImFyY1dpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBEaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmltTGFiZWxzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4TGFiZWxMZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkYmxjbGlja1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibWFyZ2luc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9hID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIFBpZUNoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgUGllQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBQaWVDaGFydENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1waWUtY2hhcnQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnRcXG4gICAgICBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCJcXG4gICAgICBbc2hvd0xlZ2VuZF09XFxcImxlZ2VuZFxcXCJcXG4gICAgICBbbGVnZW5kT3B0aW9uc109XFxcImxlZ2VuZE9wdGlvbnNcXFwiXFxuICAgICAgW2FjdGl2ZUVudHJpZXNdPVxcXCJhY3RpdmVFbnRyaWVzXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAobGVnZW5kTGFiZWxBY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50LCB0cnVlKVxcXCJcXG4gICAgICAobGVnZW5kTGFiZWxEZWFjdGl2YXRlKT1cXFwib25EZWFjdGl2YXRlKCRldmVudCwgdHJ1ZSlcXFwiXFxuICAgICAgKGxlZ2VuZExhYmVsQ2xpY2spPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgID5cXG4gICAgICA8c3ZnOmcgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNsYXRpb25cXFwiIGNsYXNzPVxcXCJwaWUtY2hhcnQgY2hhcnRcXFwiPlxcbiAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgIG5neC1jaGFydHMtcGllLXNlcmllc1xcbiAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICBbc2VyaWVzXT1cXFwiZGF0YVxcXCJcXG4gICAgICAgICAgW3Nob3dMYWJlbHNdPVxcXCJsYWJlbHNcXFwiXFxuICAgICAgICAgIFtsYWJlbEZvcm1hdHRpbmddPVxcXCJsYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFt0cmltTGFiZWxzXT1cXFwidHJpbUxhYmVsc1xcXCJcXG4gICAgICAgICAgW21heExhYmVsTGVuZ3RoXT1cXFwibWF4TGFiZWxMZW5ndGhcXFwiXFxuICAgICAgICAgIFthY3RpdmVFbnRyaWVzXT1cXFwiYWN0aXZlRW50cmllc1xcXCJcXG4gICAgICAgICAgW2lubmVyUmFkaXVzXT1cXFwiaW5uZXJSYWRpdXNcXFwiXFxuICAgICAgICAgIFtvdXRlclJhZGl1c109XFxcIm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgICBbZXhwbG9kZVNsaWNlc109XFxcImV4cGxvZGVTbGljZXNcXFwiXFxuICAgICAgICAgIFtncmFkaWVudF09XFxcImdyYWRpZW50XFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgICAgIFt0b29sdGlwVGV4dF09XFxcInRvb2x0aXBUZXh0XFxcIlxcbiAgICAgICAgICAoZGJsY2xpY2spPVxcXCJkYmxjbGljay5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgKGRlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIiwgXCIucGllLWxhYmVse2ZvbnQtc2l6ZToxMXB4fS5waWUtbGFiZWwuYW5pbWF0aW9ue2FuaW1hdGlvbjo3NTBtcyBlYXNlLWluIGZhZGVJbn1Aa2V5ZnJhbWVzIGZhZGVJbntmcm9te29wYWNpdHk6MH10b3tvcGFjaXR5OjF9fS5waWUtbGFiZWwtbGluZXtzdHJva2UtZGFzaGFycmF5OjEwMCV9LnBpZS1sYWJlbC1saW5lLmFuaW1hdGlvbnthbmltYXRpb246M3MgbGluZWFyIGRyYXdPdXQ7dHJhbnNpdGlvbjpkIDc1MG1zfUBrZXlmcmFtZXMgZHJhd091dHtmcm9te3N0cm9rZS1kYXNob2Zmc2V0OjEwMCV9dG97c3Ryb2tlLWRhc2hvZmZzZXQ6MH19XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBQaWVDaGFydENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gUGllQ2hhcnRDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG5mdW5jdGlvbiBncmlkU2l6ZShkaW1zLCBsZW4sIG1pbldpZHRoKSB7XHJcbiAgICB2YXIgcm93cyA9IDE7XHJcbiAgICB2YXIgY29scyA9IGxlbjtcclxuICAgIHZhciB3aWR0aCA9IGRpbXMud2lkdGg7XHJcbiAgICBpZiAod2lkdGggPiBtaW5XaWR0aCkge1xyXG4gICAgICAgIHdoaWxlICh3aWR0aCAvIGNvbHMgPCBtaW5XaWR0aCkge1xyXG4gICAgICAgICAgICByb3dzICs9IDE7XHJcbiAgICAgICAgICAgIGNvbHMgPSBNYXRoLmNlaWwobGVuIC8gcm93cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtjb2xzLCByb3dzXTtcclxufVxyXG5mdW5jdGlvbiBncmlkTGF5b3V0KGRpbXMsIGRhdGEsIG1pbldpZHRoLCBkZXNpZ25hdGVkVG90YWwpIHtcclxuICAgIHZhciB4U2NhbGUgPSBzY2FsZUJhbmQoKTtcclxuICAgIHZhciB5U2NhbGUgPSBzY2FsZUJhbmQoKTtcclxuICAgIHZhciB3aWR0aCA9IGRpbXMud2lkdGg7XHJcbiAgICB2YXIgaGVpZ2h0ID0gZGltcy5oZWlnaHQ7XHJcbiAgICB2YXIgX2EgPSBncmlkU2l6ZShkaW1zLCBkYXRhLmxlbmd0aCwgbWluV2lkdGgpLCBjb2x1bW5zID0gX2FbMF0sIHJvd3MgPSBfYVsxXTtcclxuICAgIHZhciB4RG9tYWluID0gW107XHJcbiAgICB2YXIgeURvbWFpbiA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcclxuICAgICAgICB5RG9tYWluLnB1c2goaSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xyXG4gICAgICAgIHhEb21haW4ucHVzaChpKTtcclxuICAgIH1cclxuICAgIHhTY2FsZS5kb21haW4oeERvbWFpbik7XHJcbiAgICB5U2NhbGUuZG9tYWluKHlEb21haW4pO1xyXG4gICAgeFNjYWxlLnJhbmdlUm91bmQoWzAsIHdpZHRoXSwgMC4xKTtcclxuICAgIHlTY2FsZS5yYW5nZVJvdW5kKFswLCBoZWlnaHRdLCAwLjEpO1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgdmFyIHRvdGFsID0gZGVzaWduYXRlZFRvdGFsID8gZGVzaWduYXRlZFRvdGFsIDogZ2V0VG90YWwoZGF0YSk7XHJcbiAgICB2YXIgY2FyZFdpZHRoID0geFNjYWxlLmJhbmR3aWR0aCgpO1xyXG4gICAgdmFyIGNhcmRIZWlnaHQgPSB5U2NhbGUuYmFuZHdpZHRoKCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICByZXNbaV0gPSB7fTtcclxuICAgICAgICByZXNbaV0uZGF0YSA9IHtcclxuICAgICAgICAgICAgbmFtZTogZGF0YVtpXSA/IGRhdGFbaV0ubmFtZSA6ICcnLFxyXG4gICAgICAgICAgICB2YWx1ZTogZGF0YVtpXSA/IGRhdGFbaV0udmFsdWUgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGV4dHJhOiBkYXRhW2ldID8gZGF0YVtpXS5leHRyYSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgbGFiZWw6IGRhdGFbaV0gPyBkYXRhW2ldLmxhYmVsIDogJydcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlc1tpXS54ID0geFNjYWxlKGkgJSBjb2x1bW5zKTtcclxuICAgICAgICByZXNbaV0ueSA9IHlTY2FsZShNYXRoLmZsb29yKGkgLyBjb2x1bW5zKSk7XHJcbiAgICAgICAgcmVzW2ldLndpZHRoID0gY2FyZFdpZHRoO1xyXG4gICAgICAgIHJlc1tpXS5oZWlnaHQgPSBjYXJkSGVpZ2h0O1xyXG4gICAgICAgIHJlc1tpXS5kYXRhLnBlcmNlbnQgPSB0b3RhbCA+IDAgPyByZXNbaV0uZGF0YS52YWx1ZSAvIHRvdGFsIDogMDtcclxuICAgICAgICByZXNbaV0uZGF0YS50b3RhbCA9IHRvdGFsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBnZXRUb3RhbChyZXN1bHRzKSB7XHJcbiAgICByZXR1cm4gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIChkID8gZC52YWx1ZSA6IDApOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgdmFsKSB7IHJldHVybiBzdW0gKyB2YWw7IH0sIDApO1xyXG59XHJcblxyXG52YXIgUGllR3JpZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhQaWVHcmlkQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGllR3JpZENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50b29sdGlwRGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5sYWJlbCA9ICdUb3RhbCc7XHJcbiAgICAgICAgX3RoaXMubWluV2lkdGggPSAxNTA7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzIwLCAyMCwgMjAsIDIwXTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcclxuICAgICAgICB0aGlzLmRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZ3JpZExheW91dCh0aGlzLmRpbXMsIHRoaXMucmVzdWx0cywgdGhpcy5taW5XaWR0aCwgdGhpcy5kZXNpZ25hdGVkVG90YWwpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLm1hcmdpblszXSArIFwiICwgXCIgKyB0aGlzLm1hcmdpblswXSArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMuc2VyaWVzID0gdGhpcy5nZXRTZXJpZXMoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcFRleHQgPSB0aGlzLnRvb2x0aXBUZXh0IHx8IHRoaXMuZGVmYXVsdFRvb2x0aXBUZXh0O1xyXG4gICAgfTtcclxuICAgIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLmRlZmF1bHRUb29sdGlwVGV4dCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gX2EuZGF0YTtcclxuICAgICAgICB2YXIgbGFiZWwgPSB0cmltTGFiZWwoZm9ybWF0TGFiZWwoZGF0YS5uYW1lKSk7XHJcbiAgICAgICAgdmFyIHZhbCA9IGRhdGEudmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICByZXR1cm4gXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC1sYWJlbFxcXCI+XCIgKyBsYWJlbCArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWwgKyBcIjwvc3Bhbj5cXG4gICAgXCI7XHJcbiAgICB9O1xyXG4gICAgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0RG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmxhYmVsOyB9KTtcclxuICAgIH07XHJcbiAgICBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRTZXJpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmRlc2lnbmF0ZWRUb3RhbCA/IHRoaXMuZGVzaWduYXRlZFRvdGFsIDogdGhpcy5nZXRUb3RhbCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubWFwKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXNlbGluZUxhYmVsSGVpZ2h0ID0gMjA7XHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gMTA7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gZC5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGZvcm1hdExhYmVsKG5hbWUpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkLmRhdGEudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBtaW4oW2Qud2lkdGggLSBwYWRkaW5nLCBkLmhlaWdodCAtIGJhc2VsaW5lTGFiZWxIZWlnaHRdKSAvIDIgLSA1O1xyXG4gICAgICAgICAgICB2YXIgaW5uZXJSYWRpdXMgPSByYWRpdXMgKiAwLjk7XHJcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBjb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyZ2JhKDEwMCwxMDAsMTAwLDAuMyknO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbG9yU2NhbGUuZ2V0Q29sb3IobGFiZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgeFBvcyA9IGQueCArIChkLndpZHRoIC0gcGFkZGluZykgLyAyO1xyXG4gICAgICAgICAgICB2YXIgeVBvcyA9IGQueSArIChkLmhlaWdodCAtIGJhc2VsaW5lTGFiZWxIZWlnaHQpIC8gMjtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyB4UG9zICsgXCIsIFwiICsgeVBvcyArIFwiKVwiLFxyXG4gICAgICAgICAgICAgICAgY29sb3JzOiBjb2xvcnMsXHJcbiAgICAgICAgICAgICAgICBpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICBvdXRlclJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiB0cmltTGFiZWwobGFiZWwpLFxyXG4gICAgICAgICAgICAgICAgdG90YWw6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgcGVyY2VudDogZm9ybWF0KCcuMSUnKShkLmRhdGEucGVyY2VudCksXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgZCxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRvdGFsIC0gdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBkLmRhdGEubmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLmdldFRvdGFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgZCkgeyByZXR1cm4gc3VtICsgZDsgfSwgMCk7XHJcbiAgICB9O1xyXG4gICAgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvclNjYWxlID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCAnb3JkaW5hbCcsIHRoaXMuZG9tYWluLCB0aGlzLmN1c3RvbUNvbG9ycyk7XHJcbiAgICB9O1xyXG4gICAgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUub25BY3RpdmF0ZSA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tTGVnZW5kKSB7XHJcbiAgICAgICAgaWYgKGZyb21MZWdlbmQgPT09IHZvaWQgMCkgeyBmcm9tTGVnZW5kID0gZmFsc2U7IH1cclxuICAgICAgICBpdGVtID0gdGhpcy5yZXN1bHRzLmZpbmQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21MZWdlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZSAmJiBkLnNlcmllcyA9PT0gaXRlbS5zZXJpZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gW2l0ZW1dLmNvbmNhdCh0aGlzLmFjdGl2ZUVudHJpZXMpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUuZW1pdCh7IHZhbHVlOiBpdGVtLCBlbnRyaWVzOiB0aGlzLmFjdGl2ZUVudHJpZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21MZWdlbmQpIHtcclxuICAgICAgICBpZiAoZnJvbUxlZ2VuZCA9PT0gdm9pZCAwKSB7IGZyb21MZWdlbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIGl0ZW0gPSB0aGlzLnJlc3VsdHMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGFiZWwgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLm5hbWUgPT09IGl0ZW0ubmFtZSAmJiBkLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIGQuc2VyaWVzID09PSBpdGVtLnNlcmllcztcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVzaWduYXRlZFRvdGFsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluV2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRXZlbnRFbWl0dGVyICE9PSBcInVuZGVmaW5lZFwiICYmIEV2ZW50RW1pdHRlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgUGllR3JpZENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIFBpZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImRlYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbnRlbnRDaGlsZCgndG9vbHRpcFRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9jID0gdHlwZW9mIFRlbXBsYXRlUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIFRlbXBsYXRlUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QpXHJcbiAgICBdLCBQaWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIFBpZUdyaWRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtcGllLWdyaWQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnQgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiIFtzaG93TGVnZW5kXT1cXFwiZmFsc2VcXFwiIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCI+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcInBpZS1ncmlkIGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6ZyAqbmdGb3I9XFxcImxldCBzZXJpZXMgb2Ygc2VyaWVzXFxcIiBjbGFzcz1cXFwicGllLWdyaWQtaXRlbVxcXCIgW2F0dHIudHJhbnNmb3JtXT1cXFwic2VyaWVzLnRyYW5zZm9ybVxcXCI+XFxuICAgICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICAgIG5neC1jaGFydHMtcGllLWdyaWQtc2VyaWVzXFxuICAgICAgICAgICAgW2NvbG9yc109XFxcInNlcmllcy5jb2xvcnNcXFwiXFxuICAgICAgICAgICAgW2RhdGFdPVxcXCJzZXJpZXMuZGF0YVxcXCJcXG4gICAgICAgICAgICBbaW5uZXJSYWRpdXNdPVxcXCJzZXJpZXMuaW5uZXJSYWRpdXNcXFwiXFxuICAgICAgICAgICAgW291dGVyUmFkaXVzXT1cXFwic2VyaWVzLm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIG5neC10b29sdGlwXFxuICAgICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwVHlwZV09XFxcIid0b29sdGlwJ1xcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcFRpdGxlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogdG9vbHRpcFRleHQoeyBkYXRhOiBzZXJpZXMgfSlcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICBbdG9vbHRpcENvbnRleHRdPVxcXCJzZXJpZXMuZGF0YVswXS5kYXRhXFxcIlxcbiAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgICAqbmdJZj1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwibGFiZWwgcGVyY2VudC1sYWJlbFxcXCJcXG4gICAgICAgICAgICBkeT1cXFwiLTAuNWVtXFxcIlxcbiAgICAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgICAgeT1cXFwiNVxcXCJcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLWNvdW50LXVwXFxuICAgICAgICAgICAgW2NvdW50VG9dPVxcXCJzZXJpZXMucGVyY2VudFxcXCJcXG4gICAgICAgICAgICBbY291bnRTdWZmaXhdPVxcXCInJSdcXFwiXFxuICAgICAgICAgICAgdGV4dC1hbmNob3I9XFxcIm1pZGRsZVxcXCJcXG4gICAgICAgICAgPjwvc3ZnOnRleHQ+XFxuICAgICAgICAgIDxzdmc6dGV4dCAqbmdJZj1cXFwiIWFuaW1hdGlvbnNcXFwiIGNsYXNzPVxcXCJsYWJlbCBwZXJjZW50LWxhYmVsXFxcIiBkeT1cXFwiLTAuNWVtXFxcIiB4PVxcXCIwXFxcIiB5PVxcXCI1XFxcIiB0ZXh0LWFuY2hvcj1cXFwibWlkZGxlXFxcIj5cXG4gICAgICAgICAgICB7eyBzZXJpZXMucGVyY2VudC50b0xvY2FsZVN0cmluZygpIH19XFxuICAgICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgICAgIDxzdmc6dGV4dCBjbGFzcz1cXFwibGFiZWxcXFwiIGR5PVxcXCIwLjVlbVxcXCIgeD1cXFwiMFxcXCIgeT1cXFwiNVxcXCIgdGV4dC1hbmNob3I9XFxcIm1pZGRsZVxcXCI+XFxuICAgICAgICAgICAge3sgc2VyaWVzLmxhYmVsIH19XFxuICAgICAgICAgIDwvc3ZnOnRleHQ+XFxuICAgICAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgICAgICpuZ0lmPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJsYWJlbFxcXCJcXG4gICAgICAgICAgICBkeT1cXFwiMS4yM2VtXFxcIlxcbiAgICAgICAgICAgIHg9XFxcIjBcXFwiXFxuICAgICAgICAgICAgW2F0dHIueV09XFxcInNlcmllcy5vdXRlclJhZGl1c1xcXCJcXG4gICAgICAgICAgICB0ZXh0LWFuY2hvcj1cXFwibWlkZGxlXFxcIlxcbiAgICAgICAgICAgIG5neC1jaGFydHMtY291bnQtdXBcXG4gICAgICAgICAgICBbY291bnRUb109XFxcInNlcmllcy50b3RhbFxcXCJcXG4gICAgICAgICAgICBbY291bnRQcmVmaXhdPVxcXCJsYWJlbCArICc6ICdcXFwiXFxuICAgICAgICAgID48L3N2Zzp0ZXh0PlxcbiAgICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgICAqbmdJZj1cXFwiIWFuaW1hdGlvbnNcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcImxhYmVsXFxcIlxcbiAgICAgICAgICAgIGR5PVxcXCIxLjIzZW1cXFwiXFxuICAgICAgICAgICAgeD1cXFwiMFxcXCJcXG4gICAgICAgICAgICBbYXR0ci55XT1cXFwic2VyaWVzLm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgIHRleHQtYW5jaG9yPVxcXCJtaWRkbGVcXFwiXFxuICAgICAgICAgID5cXG4gICAgICAgICAgICB7eyBsYWJlbCB9fToge3sgc2VyaWVzLnRvdGFsLnRvTG9jYWxlU3RyaW5nKCkgfX1cXG4gICAgICAgICAgPC9zdmc6dGV4dD5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIiwgXCIucGllLWdyaWQgLmFyYzF7b3BhY2l0eTouNH0ucGllLWdyaWQgLnBlcmNlbnQtbGFiZWx7Zm9udC1zaXplOjE2cHg7Zm9udC13ZWlnaHQ6NDAwfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgUGllR3JpZENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gUGllR3JpZENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBQaWVHcmlkU2VyaWVzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGllR3JpZFNlcmllc0NvbXBvbmVudChlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IDcwO1xyXG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSA4MDtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcclxuICAgIH1cclxuICAgIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxheW91dCA9IHBpZSgpXHJcbiAgICAgICAgICAgIC52YWx1ZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5kYXRhLnZhbHVlOyB9KVxyXG4gICAgICAgICAgICAuc29ydChudWxsKTtcclxuICAgICAgICB0aGlzLmFyY3MgPSB0aGlzLmdldEFyY3MoKTtcclxuICAgIH07XHJcbiAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRBcmNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0KHRoaXMuZGF0YSkubWFwKGZ1bmN0aW9uIChhcmMkJDEsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGFyYyQkMS5kYXRhLmRhdGEubmFtZTtcclxuICAgICAgICAgICAgdmFyIG90aGVyID0gYXJjJCQxLmRhdGEuZGF0YS5vdGhlcjtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBhcmMkJDEuc3RhcnRBbmdsZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gX3RoaXMuY29sb3JzKGxhYmVsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGE6IGFyYyQkMS5kYXRhLmRhdGEsXHJcbiAgICAgICAgICAgICAgICBjbGFzczogJ2FyYyAnICsgJ2FyYycgKyBpbmRleCxcclxuICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogb3RoZXIgPyAwIDogYXJjJCQxLnN0YXJ0QW5nbGUsXHJcbiAgICAgICAgICAgICAgICBlbmRBbmdsZTogYXJjJCQxLmVuZEFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0ZTogX3RoaXMuYW5pbWF0aW9ucyAmJiAhb3RoZXIsXHJcbiAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAhb3RoZXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuZGF0YVswXS5kYXRhKTtcclxuICAgIH07XHJcbiAgICBQaWVHcmlkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YS5uYW1lO1xyXG4gICAgfTtcclxuICAgIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gKGFyYyQkMSkge1xyXG4gICAgICAgIHJldHVybiBhcmMkJDEuZGF0YS5uYW1lO1xyXG4gICAgfTtcclxuICAgIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmNvbG9yID0gZnVuY3Rpb24gKGFyYyQkMSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9ycyh0aGlzLmxhYmVsKGFyYyQkMSkpO1xyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllR3JpZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllR3JpZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5uZXJSYWRpdXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllR3JpZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZUdyaWRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllR3JpZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgUGllR3JpZFNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLXBpZS1ncmlkLXNlcmllc10nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIGNsYXNzPVxcXCJwaWUtZ3JpZC1hcmNzXFxcIj5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtcGllLWFyY1xcbiAgICAgICAgKm5nRm9yPVxcXCJsZXQgYXJjIG9mIGFyY3M7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgICBbYXR0ci5jbGFzc109XFxcImFyYy5jbGFzc1xcXCJcXG4gICAgICAgIFtzdGFydEFuZ2xlXT1cXFwiYXJjLnN0YXJ0QW5nbGVcXFwiXFxuICAgICAgICBbZW5kQW5nbGVdPVxcXCJhcmMuZW5kQW5nbGVcXFwiXFxuICAgICAgICBbaW5uZXJSYWRpdXNdPVxcXCJpbm5lclJhZGl1c1xcXCJcXG4gICAgICAgIFtvdXRlclJhZGl1c109XFxcIm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgW2ZpbGxdPVxcXCJjb2xvcihhcmMpXFxcIlxcbiAgICAgICAgW3ZhbHVlXT1cXFwiYXJjLmRhdGEudmFsdWVcXFwiXFxuICAgICAgICBbZGF0YV09XFxcImFyYy5kYXRhXFxcIlxcbiAgICAgICAgW2dyYWRpZW50XT1cXFwiZmFsc2VcXFwiXFxuICAgICAgICBbcG9pbnRlckV2ZW50c109XFxcImFyYy5wb2ludGVyRXZlbnRzXFxcIlxcbiAgICAgICAgW2FuaW1hdGVdPVxcXCJhcmMuYW5pbWF0ZVxcXCJcXG4gICAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICAoYWN0aXZhdGUpPVxcXCJhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgID48L3N2ZzpnPlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcclxuICAgIF0sIFBpZUdyaWRTZXJpZXNDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFBpZUdyaWRTZXJpZXNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgUGllU2VyaWVzQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUGllU2VyaWVzQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMuc2VyaWVzID0gW107XHJcbiAgICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IDYwO1xyXG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSA4MDtcclxuICAgICAgICB0aGlzLnRyaW1MYWJlbHMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubWF4TGFiZWxMZW5ndGggPSAxMDtcclxuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5kYmxjbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBpZUdlbmVyYXRvciA9IHBpZSgpXHJcbiAgICAgICAgICAgIC52YWx1ZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSlcclxuICAgICAgICAgICAgLnNvcnQobnVsbCk7XHJcbiAgICAgICAgdmFyIGFyY0RhdGEgPSBwaWVHZW5lcmF0b3IodGhpcy5zZXJpZXMpO1xyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4KGFyY0RhdGEsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuY2FsY3VsYXRlTGFiZWxQb3NpdGlvbnMoYXJjRGF0YSk7XHJcbiAgICAgICAgdGhpcy50b29sdGlwVGV4dCA9IHRoaXMudG9vbHRpcFRleHQgfHwgdGhpcy5kZWZhdWx0VG9vbHRpcFRleHQ7XHJcbiAgICB9O1xyXG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5taWRBbmdsZSA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGQuc3RhcnRBbmdsZSArIChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIDI7XHJcbiAgICB9O1xyXG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5vdXRlckFyYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZmFjdG9yID0gMS41O1xyXG4gICAgICAgIHJldHVybiBhcmMoKVxyXG4gICAgICAgICAgICAuaW5uZXJSYWRpdXModGhpcy5vdXRlclJhZGl1cyAqIGZhY3RvcilcclxuICAgICAgICAgICAgLm91dGVyUmFkaXVzKHRoaXMub3V0ZXJSYWRpdXMgKiBmYWN0b3IpO1xyXG4gICAgfTtcclxuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUuY2FsY3VsYXRlTGFiZWxQb3NpdGlvbnMgPSBmdW5jdGlvbiAocGllRGF0YSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGZhY3RvciA9IDEuNTtcclxuICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSAxMDtcclxuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbnMgPSBwaWVEYXRhO1xyXG4gICAgICAgIGxhYmVsUG9zaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgZC5wb3MgPSBfdGhpcy5vdXRlckFyYygpLmNlbnRyb2lkKGQpO1xyXG4gICAgICAgICAgICBkLnBvc1swXSA9IGZhY3RvciAqIF90aGlzLm91dGVyUmFkaXVzICogKF90aGlzLm1pZEFuZ2xlKGQpIDwgTWF0aC5QSSA/IDEgOiAtMSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbFBvc2l0aW9ucy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBsYWJlbFBvc2l0aW9uc1tpXTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmxhYmVsVmlzaWJsZShhKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbGFiZWxQb3NpdGlvbnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gbGFiZWxQb3NpdGlvbnNbal07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGFiZWxWaXNpYmxlKGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGV5J3JlIG9uIHRoZSBzYW1lIHNpZGVcclxuICAgICAgICAgICAgICAgIGlmIChiLnBvc1swXSAqIGEucG9zWzBdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXkncmUgb3ZlcmxhcHBpbmdcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG1pbkRpc3RhbmNlIC0gTWF0aC5hYnMoYi5wb3NbMV0gLSBhLnBvc1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdGhlIHNlY29uZCB1cCBvciBkb3duXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucG9zWzFdICs9IE1hdGguc2lnbihiLnBvc1swXSkgKiBvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGFiZWxQb3NpdGlvbnM7XHJcbiAgICB9O1xyXG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5sYWJlbFZpc2libGUgPSBmdW5jdGlvbiAobXlBcmMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaG93TGFiZWxzICYmIG15QXJjLmVuZEFuZ2xlIC0gbXlBcmMuc3RhcnRBbmdsZSA+IE1hdGguUEkgLyAzMDtcclxuICAgIH07XHJcbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFRvb2x0aXBUaXRsZSA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogdGhpcy50b29sdGlwVGV4dChhKTtcclxuICAgIH07XHJcbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmxhYmVsVGV4dCA9IGZ1bmN0aW9uIChteUFyYykge1xyXG4gICAgICAgIGlmICh0aGlzLmxhYmVsRm9ybWF0dGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbEZvcm1hdHRpbmcobXlBcmMuZGF0YS5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWwobXlBcmMpO1xyXG4gICAgfTtcclxuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubGFiZWwgPSBmdW5jdGlvbiAobXlBcmMpIHtcclxuICAgICAgICByZXR1cm4gZm9ybWF0TGFiZWwobXlBcmMuZGF0YS5uYW1lKTtcclxuICAgIH07XHJcbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmRlZmF1bHRUb29sdGlwVGV4dCA9IGZ1bmN0aW9uIChteUFyYykge1xyXG4gICAgICAgIHZhciBsYWJlbCA9IHRoaXMubGFiZWwobXlBcmMpO1xyXG4gICAgICAgIHZhciB2YWwgPSBmb3JtYXRMYWJlbChteUFyYy5kYXRhLnZhbHVlKTtcclxuICAgICAgICByZXR1cm4gXCJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC1sYWJlbFxcXCI+XCIgKyBsYWJlbCArIFwiPC9zcGFuPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLXZhbFxcXCI+XCIgKyB2YWwgKyBcIjwvc3Bhbj5cXG4gICAgXCI7XHJcbiAgICB9O1xyXG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5jb2xvciA9IGZ1bmN0aW9uIChteUFyYykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9ycy5nZXRDb2xvcih0aGlzLmxhYmVsKG15QXJjKSk7XHJcbiAgICB9O1xyXG4gICAgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS50cmFja0J5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YS5uYW1lO1xyXG4gICAgfTtcclxuICAgIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlRW50cmllcy5maW5kKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWUgJiYgZW50cnkuc2VyaWVzID09PSBkLnNlcmllcztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImlubmVyUmFkaXVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImV4cGxvZGVTbGljZXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0xhYmVsc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmVFbnRyaWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidHJpbUxhYmVsc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhMYWJlbExlbmd0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIFBpZVNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBQaWVTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYmxjbGlja1wiLCB2b2lkIDApO1xyXG4gICAgUGllU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtcGllLXNlcmllc10nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IGFyYyBvZiBkYXRhOyB0cmFja0J5OiB0cmFja0J5XFxcIj5cXG4gICAgICA8c3ZnOmdcXG4gICAgICAgIG5neC1jaGFydHMtcGllLWxhYmVsXFxuICAgICAgICAqbmdJZj1cXFwibGFiZWxWaXNpYmxlKGFyYylcXFwiXFxuICAgICAgICBbZGF0YV09XFxcImFyY1xcXCJcXG4gICAgICAgIFtyYWRpdXNdPVxcXCJvdXRlclJhZGl1c1xcXCJcXG4gICAgICAgIFtjb2xvcl09XFxcImNvbG9yKGFyYylcXFwiXFxuICAgICAgICBbbGFiZWxdPVxcXCJsYWJlbFRleHQoYXJjKVxcXCJcXG4gICAgICAgIFtsYWJlbFRyaW1dPVxcXCJ0cmltTGFiZWxzXFxcIlxcbiAgICAgICAgW2xhYmVsVHJpbVNpemVdPVxcXCJtYXhMYWJlbExlbmd0aFxcXCJcXG4gICAgICAgIFttYXhdPVxcXCJtYXhcXFwiXFxuICAgICAgICBbdmFsdWVdPVxcXCJhcmMudmFsdWVcXFwiXFxuICAgICAgICBbZXhwbG9kZVNsaWNlc109XFxcImV4cGxvZGVTbGljZXNcXFwiXFxuICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgPjwvc3ZnOmc+XFxuICAgICAgPHN2ZzpnXFxuICAgICAgICBuZ3gtY2hhcnRzLXBpZS1hcmNcXG4gICAgICAgIFtzdGFydEFuZ2xlXT1cXFwiYXJjLnN0YXJ0QW5nbGVcXFwiXFxuICAgICAgICBbZW5kQW5nbGVdPVxcXCJhcmMuZW5kQW5nbGVcXFwiXFxuICAgICAgICBbaW5uZXJSYWRpdXNdPVxcXCJpbm5lclJhZGl1c1xcXCJcXG4gICAgICAgIFtvdXRlclJhZGl1c109XFxcIm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgW2ZpbGxdPVxcXCJjb2xvcihhcmMpXFxcIlxcbiAgICAgICAgW3ZhbHVlXT1cXFwiYXJjLmRhdGEudmFsdWVcXFwiXFxuICAgICAgICBbZ3JhZGllbnRdPVxcXCJncmFkaWVudFxcXCJcXG4gICAgICAgIFtkYXRhXT1cXFwiYXJjLmRhdGFcXFwiXFxuICAgICAgICBbbWF4XT1cXFwibWF4XFxcIlxcbiAgICAgICAgW2V4cGxvZGVTbGljZXNdPVxcXCJleHBsb2RlU2xpY2VzXFxcIlxcbiAgICAgICAgW2lzQWN0aXZlXT1cXFwiaXNBY3RpdmUoYXJjLmRhdGEpXFxcIlxcbiAgICAgICAgW2FuaW1hdGVdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAgIChkZWFjdGl2YXRlKT1cXFwiZGVhY3RpdmF0ZS5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICAoZGJsY2xpY2spPVxcXCJkYmxjbGljay5lbWl0KCRldmVudClcXFwiXFxuICAgICAgICBuZ3gtdG9vbHRpcFxcbiAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cXFwiJ3RvcCdcXFwiXFxuICAgICAgICBbdG9vbHRpcFR5cGVdPVxcXCIndG9vbHRpcCdcXFwiXFxuICAgICAgICBbdG9vbHRpcFRpdGxlXT1cXFwiZ2V0VG9vbHRpcFRpdGxlKGFyYylcXFwiXFxuICAgICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgICAgW3Rvb2x0aXBDb250ZXh0XT1cXFwiYXJjLmRhdGFcXFwiXFxuICAgICAgPjwvc3ZnOmc+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgUGllU2VyaWVzQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBQaWVTZXJpZXNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgUGllQ2hhcnRNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQaWVDaGFydE1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIFBpZUNoYXJ0TW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBQaWVMYWJlbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFBpZUFyY0NvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFBpZUNoYXJ0Q29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgUGllR3JpZENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFBpZUdyaWRTZXJpZXNDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBQaWVTZXJpZXNDb21wb25lbnRcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZXhwb3J0czogW1xyXG4gICAgICAgICAgICAgICAgQWR2YW5jZWRQaWVDaGFydENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFBpZUxhYmVsQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgUGllQXJjQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgUGllQ2hhcnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBQaWVHcmlkQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgUGllR3JpZFNlcmllc0NvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFBpZVNlcmllc0NvbXBvbmVudFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFBpZUNoYXJ0TW9kdWxlKTtcclxuICAgIHJldHVybiBQaWVDaGFydE1vZHVsZTtcclxufSgpKTtcclxuXHJcbnZhciBQb2xhckNoYXJ0TW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG9sYXJDaGFydE1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIFBvbGFyQ2hhcnRNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDaGFydENvbW1vbk1vZHVsZSwgUGllQ2hhcnRNb2R1bGUsIExpbmVDaGFydE1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgUG9sYXJDaGFydENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFBvbGFyU2VyaWVzQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIFBvbGFyQ2hhcnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBQb2xhclNlcmllc0NvbXBvbmVudFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFBvbGFyQ2hhcnRNb2R1bGUpO1xyXG4gICAgcmV0dXJuIFBvbGFyQ2hhcnRNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG52YXIgQ2FyZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhcmRDb21wb25lbnQoZWxlbWVudCwgY2QsIHpvbmUpIHtcclxuICAgICAgICB0aGlzLmNkID0gY2Q7XHJcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSAnJztcclxuICAgICAgICB0aGlzLnRleHRGb250U2l6ZSA9IDEyO1xyXG4gICAgICAgIHRoaXMudGV4dFRyYW5zZm9ybSA9ICcnO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmJhbmRIZWlnaHQgPSAxMDtcclxuICAgICAgICB0aGlzLnRleHRQYWRkaW5nID0gWzEwLCAyMCwgNSwgMjBdO1xyXG4gICAgICAgIHRoaXMubGFiZWxGb250U2l6ZSA9IDE1O1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcclxuICAgIH1cclxuICAgIENhcmRDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIENhcmRDb21wb25lbnQucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uUmVxKTtcclxuICAgIH07XHJcbiAgICBDYXJkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGhhc1ZhbHVlID0gX3RoaXMuZGF0YSAmJiB0eXBlb2YgX3RoaXMuZGF0YS52YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZUZvcm1hdHRpbmcgPSBfdGhpcy52YWx1ZUZvcm1hdHRpbmcgfHwgKGZ1bmN0aW9uIChjYXJkKSB7IHJldHVybiBjYXJkLnZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7IH0pO1xyXG4gICAgICAgICAgICB2YXIgbGFiZWxGb3JtYXR0aW5nID0gX3RoaXMubGFiZWxGb3JtYXR0aW5nIHx8IChmdW5jdGlvbiAoY2FyZCkgeyByZXR1cm4gdHJpbUxhYmVsKGNhcmQubGFiZWwsIDU1KTsgfSk7XHJcbiAgICAgICAgICAgIF90aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgX3RoaXMueCArIFwiICwgXCIgKyBfdGhpcy55ICsgXCIpXCI7XHJcbiAgICAgICAgICAgIF90aGlzLnRleHRXaWR0aCA9IE1hdGgubWF4KDAsIF90aGlzLndpZHRoKSAtIF90aGlzLnRleHRQYWRkaW5nWzFdIC0gX3RoaXMudGV4dFBhZGRpbmdbM107XHJcbiAgICAgICAgICAgIF90aGlzLmNhcmRXaWR0aCA9IE1hdGgubWF4KDAsIF90aGlzLndpZHRoKTtcclxuICAgICAgICAgICAgX3RoaXMuY2FyZEhlaWdodCA9IE1hdGgubWF4KDAsIF90aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIF90aGlzLmxhYmVsID0gX3RoaXMubGFiZWwgPyBfdGhpcy5sYWJlbCA6IF90aGlzLmRhdGEubmFtZTtcclxuICAgICAgICAgICAgdmFyIGNhcmREYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgbGFiZWw6IF90aGlzLmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogX3RoaXMuZGF0YSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdGhpcy5kYXRhLnZhbHVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF90aGlzLmZvcm1hdHRlZExhYmVsID0gbGFiZWxGb3JtYXR0aW5nKGNhcmREYXRhKTtcclxuICAgICAgICAgICAgX3RoaXMudHJhbnNmb3JtQmFuZCA9IFwidHJhbnNsYXRlKDAgLCBcIiArIChfdGhpcy5jYXJkSGVpZ2h0IC0gX3RoaXMuYmFuZEhlaWdodCkgKyBcIilcIjtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gaGFzVmFsdWUgPyB2YWx1ZUZvcm1hdHRpbmcoY2FyZERhdGEpIDogJyc7XHJcbiAgICAgICAgICAgIF90aGlzLnZhbHVlID0gX3RoaXMucGFkZGVkVmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICBfdGhpcy5zZXRQYWRkaW5nKCk7XHJcbiAgICAgICAgICAgIF90aGlzLmJhbmRQYXRoID0gcm91bmRlZFJlY3QoMCwgMCwgX3RoaXMuY2FyZFdpZHRoLCBfdGhpcy5iYW5kSGVpZ2h0LCAzLCBbZmFsc2UsIGZhbHNlLCB0cnVlLCB0cnVlXSk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2NhbGVUZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1ZhbHVlICYmICFfdGhpcy5pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3RhcnRDb3VudCgpOyB9LCAyMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhcmRDb21wb25lbnQucHJvdG90eXBlLnBhZGRlZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWVkaWFuU2l6ZSAmJiB0aGlzLm1lZGlhblNpemUgPiB2YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFsdWUgKz0gJ1xcdTIwMDcnLnJlcGVhdCh0aGlzLm1lZGlhblNpemUgLSB2YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUuc3RhcnRDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCAmJiB0aGlzLmFuaW1hdGlvbnMpIHtcclxuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25SZXEpO1xyXG4gICAgICAgICAgICB2YXIgdmFsXzEgPSB0aGlzLmRhdGEudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBkZWNzID0gZGVjaW1hbENoZWNrZXIodmFsXzEpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVGb3JtYXR0aW5nXzEgPSB0aGlzLnZhbHVlRm9ybWF0dGluZyB8fCAoZnVuY3Rpb24gKGNhcmQpIHsgcmV0dXJuIGNhcmQudmFsdWUudG9Mb2NhbGVTdHJpbmcoKTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWUsIGZpbmlzaGVkID0gX2EuZmluaXNoZWQ7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmaW5pc2hlZCA/IHZhbF8xIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZUZvcm1hdHRpbmdfMSh7IGxhYmVsOiBfdGhpcy5sYWJlbCwgZGF0YTogX3RoaXMuZGF0YSwgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmluaXNoZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFsdWUgPSBfdGhpcy5wYWRkZWRWYWx1ZShfdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uUmVxID0gY291bnQoMCwgdmFsXzEsIGRlY3MsIDEsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhcmRDb21wb25lbnQucHJvdG90eXBlLnNjYWxlVGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuem9uZS5ydW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy50ZXh0RWwubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRleHRQYWRkaW5nID0gKF90aGlzLnRleHRQYWRkaW5nWzFdID0gX3RoaXMudGV4dFBhZGRpbmdbM10gPSBfdGhpcy5jYXJkV2lkdGggLyA4KTtcclxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gX3RoaXMuY2FyZFdpZHRoIC0gMiAqIHRleHRQYWRkaW5nO1xyXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gX3RoaXMuY2FyZEhlaWdodCAvIDM7XHJcbiAgICAgICAgICAgIHZhciByZXNpemVTY2FsZSA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoIC8gd2lkdGgsIGF2YWlsYWJsZUhlaWdodCAvIGhlaWdodCk7XHJcbiAgICAgICAgICAgIF90aGlzLnRleHRGb250U2l6ZSA9IE1hdGguZmxvb3IoX3RoaXMudGV4dEZvbnRTaXplICogcmVzaXplU2NhbGUpO1xyXG4gICAgICAgICAgICBfdGhpcy5sYWJlbEZvbnRTaXplID0gTWF0aC5taW4oX3RoaXMudGV4dEZvbnRTaXplLCAxNSk7XHJcbiAgICAgICAgICAgIF90aGlzLnNldFBhZGRpbmcoKTtcclxuICAgICAgICAgICAgX3RoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUuc2V0UGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRleHRQYWRkaW5nWzFdID0gdGhpcy50ZXh0UGFkZGluZ1szXSA9IHRoaXMuY2FyZFdpZHRoIC8gODtcclxuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuY2FyZEhlaWdodCAvIDI7XHJcbiAgICAgICAgdGhpcy50ZXh0UGFkZGluZ1swXSA9IHBhZGRpbmcgLSB0aGlzLnRleHRGb250U2l6ZSAtIHRoaXMubGFiZWxGb250U2l6ZSAvIDI7XHJcbiAgICAgICAgdGhpcy50ZXh0UGFkZGluZ1syXSA9IHBhZGRpbmcgLSB0aGlzLmxhYmVsRm9udFNpemU7XHJcbiAgICB9O1xyXG4gICAgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImJhbmRDb2xvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwidGV4dENvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwibWVkaWFuU2l6ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBWaWV3Q2hpbGQoJ3RleHRFbCcsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFbGVtZW50UmVmICE9PSBcInVuZGVmaW5lZFwiICYmIEVsZW1lbnRSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRFbFwiLCB2b2lkIDApO1xyXG4gICAgQ2FyZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWNhcmRdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJjZWxsXFxcIiAoY2xpY2spPVxcXCJvbkNsaWNrKClcXFwiPlxcbiAgICAgIDxzdmc6cmVjdCBjbGFzcz1cXFwiY2FyZFxcXCIgW3N0eWxlLmZpbGxdPVxcXCJjb2xvclxcXCIgW2F0dHIud2lkdGhdPVxcXCJjYXJkV2lkdGhcXFwiIFthdHRyLmhlaWdodF09XFxcImNhcmRIZWlnaHRcXFwiIHJ4PVxcXCIzXFxcIiByeT1cXFwiM1xcXCIgLz5cXG4gICAgICA8c3ZnOnBhdGhcXG4gICAgICAgICpuZ0lmPVxcXCJiYW5kQ29sb3IgJiYgYmFuZENvbG9yICE9PSBjb2xvclxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJjYXJkLWJhbmRcXFwiXFxuICAgICAgICBbYXR0ci5maWxsXT1cXFwiYmFuZENvbG9yXFxcIlxcbiAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtQmFuZFxcXCJcXG4gICAgICAgIHN0cm9rZT1cXFwibm9uZVxcXCJcXG4gICAgICAgIFthdHRyLmRdPVxcXCJiYW5kUGF0aFxcXCJcXG4gICAgICAvPlxcbiAgICAgIDx0aXRsZT57eyBsYWJlbCB9fTwvdGl0bGU+XFxuICAgICAgPHN2Zzpmb3JlaWduT2JqZWN0XFxuICAgICAgICBjbGFzcz1cXFwidHJpbW1lZC1sYWJlbFxcXCJcXG4gICAgICAgIHg9XFxcIjVcXFwiXFxuICAgICAgICBbYXR0ci54XT1cXFwidGV4dFBhZGRpbmdbM11cXFwiXFxuICAgICAgICBbYXR0ci55XT1cXFwiY2FyZEhlaWdodCAtIHRleHRQYWRkaW5nWzJdXFxcIlxcbiAgICAgICAgW2F0dHIud2lkdGhdPVxcXCJ0ZXh0V2lkdGhcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJsYWJlbEZvbnRTaXplICsgdGV4dFBhZGRpbmdbMl1cXFwiXFxuICAgICAgICBhbGlnbm1lbnQtYmFzZWxpbmU9XFxcImhhbmdpbmdcXFwiXFxuICAgICAgPlxcbiAgICAgICAgPHhodG1sOnBcXG4gICAgICAgICAgW3N0eWxlLmNvbG9yXT1cXFwidGV4dENvbG9yXFxcIlxcbiAgICAgICAgICBbc3R5bGUuZm9udFNpemUucHhdPVxcXCJsYWJlbEZvbnRTaXplXFxcIlxcbiAgICAgICAgICBbc3R5bGUubGluZUhlaWdodC5weF09XFxcImxhYmVsRm9udFNpemVcXFwiXFxuICAgICAgICAgIFtpbm5lckhUTUxdPVxcXCJmb3JtYXR0ZWRMYWJlbFxcXCJcXG4gICAgICAgID5cXG4gICAgICAgIDwveGh0bWw6cD5cXG4gICAgICA8L3N2Zzpmb3JlaWduT2JqZWN0PlxcbiAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgI3RleHRFbFxcbiAgICAgICAgY2xhc3M9XFxcInZhbHVlLXRleHRcXFwiXFxuICAgICAgICBbYXR0ci54XT1cXFwidGV4dFBhZGRpbmdbM11cXFwiXFxuICAgICAgICBbYXR0ci55XT1cXFwidGV4dFBhZGRpbmdbMF1cXFwiXFxuICAgICAgICBbc3R5bGUuZmlsbF09XFxcInRleHRDb2xvclxcXCJcXG4gICAgICAgIHRleHQtYW5jaG9yPVxcXCJzdGFydFxcXCJcXG4gICAgICAgIGFsaWdubWVudC1iYXNlbGluZT1cXFwiaGFuZ2luZ1xcXCJcXG4gICAgICAgIFtzdHlsZS5mb250LXNpemUucHRdPVxcXCJ0ZXh0Rm9udFNpemVcXFwiXFxuICAgICAgPlxcbiAgICAgICAge3sgdmFsdWUgfX1cXG4gICAgICA8L3N2Zzp0ZXh0PlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9iID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0LCB0eXBlb2YgKF9jID0gdHlwZW9mIENoYW5nZURldGVjdG9yUmVmICE9PSBcInVuZGVmaW5lZFwiICYmIENoYW5nZURldGVjdG9yUmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2MgOiBPYmplY3QsIHR5cGVvZiAoX2QgPSB0eXBlb2YgTmdab25lICE9PSBcInVuZGVmaW5lZFwiICYmIE5nWm9uZSkgPT09IFwiZnVuY3Rpb25cIiA/IF9kIDogT2JqZWN0XSlcclxuICAgIF0sIENhcmRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIENhcmRDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgQ2FyZFNlcmllc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENhcmRTZXJpZXNDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy5pbm5lclBhZGRpbmcgPSAxNTtcclxuICAgICAgICB0aGlzLmVtcHR5Q29sb3IgPSAncmdiYSgwLCAwLCAwLCAwKSc7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfTtcclxuICAgIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlRm9ybWF0dGluZ18xID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcgfHwgKGZ1bmN0aW9uIChjYXJkKSB7IHJldHVybiBjYXJkLnZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7IH0pO1xyXG4gICAgICAgICAgICB2YXIgc29ydGVkTGVuZ3RocyA9IHRoaXMuZGF0YVxyXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc1ZhbHVlID0gZCAmJiBkLmRhdGEgJiYgdHlwZW9mIGQuZGF0YS52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZC5kYXRhLnZhbHVlICE9PSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc1ZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZUZvcm1hdHRpbmdfMSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQuZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGQgPyBkLmRhdGEubmFtZSA6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZCAmJiBkLmRhdGEgPyBkLmRhdGEudmFsdWUgOiAnJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiIC0gYTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSBNYXRoLmNlaWwodGhpcy5kYXRhLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgICAgICB0aGlzLm1lZGlhblNpemUgPSBzb3J0ZWRMZW5ndGhzW2lkeF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYXJkcyA9IHRoaXMuZ2V0Q2FyZHMoKTtcclxuICAgICAgICB0aGlzLmNhcmRzID0gY2FyZHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmRhdGEudmFsdWUgIT09IG51bGw7IH0pO1xyXG4gICAgICAgIHRoaXMuZW1wdHlTbG90cyA9IGNhcmRzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5kYXRhLnZhbHVlID09PSBudWxsOyB9KTtcclxuICAgIH07XHJcbiAgICBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDYXJkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB5UGFkZGluZyA9IHR5cGVvZiB0aGlzLmlubmVyUGFkZGluZyA9PT0gJ251bWJlcicgPyB0aGlzLmlubmVyUGFkZGluZyA6IHRoaXMuaW5uZXJQYWRkaW5nWzBdICsgdGhpcy5pbm5lclBhZGRpbmdbMl07XHJcbiAgICAgICAgdmFyIHhQYWRkaW5nID0gdHlwZW9mIHRoaXMuaW5uZXJQYWRkaW5nID09PSAnbnVtYmVyJyA/IHRoaXMuaW5uZXJQYWRkaW5nIDogdGhpcy5pbm5lclBhZGRpbmdbMV0gKyB0aGlzLmlubmVyUGFkZGluZ1szXTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcChmdW5jdGlvbiAoZCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gZC5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbCAmJiBsYWJlbC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRGF0ZScpIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWwudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsID8gbGFiZWwudG9Mb2NhbGVTdHJpbmcoKSA6IGxhYmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGQuZGF0YS52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlQ29sb3IgPSBsYWJlbCA/IF90aGlzLmNvbG9ycy5nZXRDb2xvcihsYWJlbCkgOiBfdGhpcy5lbXB0eUNvbG9yO1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBfdGhpcy5jYXJkQ29sb3IgfHwgdmFsdWVDb2xvciB8fCAnIzAwMCc7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiBkLngsXHJcbiAgICAgICAgICAgICAgICB5OiBkLnksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogZC53aWR0aCAtIHhQYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBkLmhlaWdodCAtIHlQYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxyXG4gICAgICAgICAgICAgICAgYmFuZENvbG9yOiBfdGhpcy5iYW5kQ29sb3IgfHwgdmFsdWVDb2xvcixcclxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogX3RoaXMudGV4dENvbG9yIHx8IGludmVydENvbG9yKGNvbG9yKSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGQuZGF0YSxcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBUZXh0OiBsYWJlbCArIFwiOiBcIiArIHZhbHVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgY2FyZCkge1xyXG4gICAgICAgIHJldHVybiBjYXJkLmxhYmVsO1xyXG4gICAgfTtcclxuICAgIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInNsb3RzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaW1zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImlubmVyUGFkZGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2FyZENvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYW5kQ29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImVtcHR5Q29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRDb2xvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBDYXJkU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgQ2FyZFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBDYXJkU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtY2FyZC1zZXJpZXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6cmVjdFxcbiAgICAgICpuZ0Zvcj1cXFwibGV0IGMgb2YgZW1wdHlTbG90czsgdHJhY2tCeTogdHJhY2tCeVxcXCJcXG4gICAgICBjbGFzcz1cXFwiY2FyZC1lbXB0eVxcXCJcXG4gICAgICBbYXR0ci54XT1cXFwiYy54XFxcIlxcbiAgICAgIFthdHRyLnldPVxcXCJjLnlcXFwiXFxuICAgICAgW3N0eWxlLmZpbGxdPVxcXCJlbXB0eUNvbG9yXFxcIlxcbiAgICAgIFthdHRyLndpZHRoXT1cXFwiYy53aWR0aFxcXCJcXG4gICAgICBbYXR0ci5oZWlnaHRdPVxcXCJjLmhlaWdodFxcXCJcXG4gICAgICByeD1cXFwiM1xcXCJcXG4gICAgICByeT1cXFwiM1xcXCJcXG4gICAgLz5cXG4gICAgPHN2ZzpnXFxuICAgICAgbmd4LWNoYXJ0cy1jYXJkXFxuICAgICAgKm5nRm9yPVxcXCJsZXQgYyBvZiBjYXJkczsgdHJhY2tCeTogdHJhY2tCeVxcXCJcXG4gICAgICBbeF09XFxcImMueFxcXCJcXG4gICAgICBbeV09XFxcImMueVxcXCJcXG4gICAgICBbd2lkdGhdPVxcXCJjLndpZHRoXFxcIlxcbiAgICAgIFtoZWlnaHRdPVxcXCJjLmhlaWdodFxcXCJcXG4gICAgICBbY29sb3JdPVxcXCJjLmNvbG9yXFxcIlxcbiAgICAgIFtiYW5kQ29sb3JdPVxcXCJjLmJhbmRDb2xvclxcXCJcXG4gICAgICBbdGV4dENvbG9yXT1cXFwiYy50ZXh0Q29sb3JcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJjLmRhdGFcXFwiXFxuICAgICAgW2xhYmVsXT1cXFwiYy5sYWJlbFxcXCJcXG4gICAgICBbbWVkaWFuU2l6ZV09XFxcIm1lZGlhblNpemVcXFwiXFxuICAgICAgW3ZhbHVlRm9ybWF0dGluZ109XFxcInZhbHVlRm9ybWF0dGluZ1xcXCJcXG4gICAgICBbbGFiZWxGb3JtYXR0aW5nXT1cXFwibGFiZWxGb3JtYXR0aW5nXFxcIlxcbiAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAvPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSlcclxuICAgIF0sIENhcmRTZXJpZXNDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIENhcmRTZXJpZXNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgTnVtYmVyQ2FyZENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOdW1iZXJDYXJkQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTnVtYmVyQ2FyZENvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5lbXB0eUNvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMCknO1xyXG4gICAgICAgIF90aGlzLmlubmVyUGFkZGluZyA9IDE1O1xyXG4gICAgICAgIF90aGlzLm1hcmdpbiA9IFsxMCwgMTAsIDEwLCAxMF07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE51bWJlckNhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImNsaWNrYWJsZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuc2VsZWN0Lm9ic2VydmVycy5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0RGF0ZXMoKTtcclxuICAgICAgICB0aGlzLmRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiAsIFwiICsgdGhpcy5tYXJnaW5bMF0gKyBcIilcIjtcclxuICAgICAgICB2YXIgc2l6ZSA9IGdyaWRTaXplKHRoaXMuZGltcywgdGhpcy5yZXN1bHRzLmxlbmd0aCwgMTUwKTtcclxuICAgICAgICB2YXIgTiA9IHNpemVbMF0gKiBzaXplWzFdO1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5yZXN1bHRzLnNsaWNlKCk7XHJcbiAgICAgICAgd2hpbGUgKGRhdGEubGVuZ3RoIDwgTikge1xyXG4gICAgICAgICAgICBkYXRhLnB1c2goeyB2YWx1ZTogbnVsbCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZ3JpZExheW91dCh0aGlzLmRpbXMsIGRhdGEsIDE1MCwgdGhpcy5kZXNpZ25hdGVkVG90YWwpO1xyXG4gICAgfTtcclxuICAgIE51bWJlckNhcmRDb21wb25lbnQucHJvdG90eXBlLmdldERvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5sYWJlbDsgfSk7XHJcbiAgICB9O1xyXG4gICAgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsICdvcmRpbmFsJywgdGhpcy5kb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjYXJkQ29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE51bWJlckNhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImJhbmRDb2xvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZW1wdHlDb2xvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5uZXJQYWRkaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZXh0Q29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE51bWJlckNhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFiZWxGb3JtYXR0aW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBOdW1iZXJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZXNpZ25hdGVkVG90YWxcIiwgdm9pZCAwKTtcclxuICAgIE51bWJlckNhcmRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ25neC1jaGFydHMtbnVtYmVyLWNhcmQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPG5neC1jaGFydHMtY2hhcnQgW3ZpZXddPVxcXCJbd2lkdGgsIGhlaWdodF1cXFwiIFtzaG93TGVnZW5kXT1cXFwiZmFsc2VcXFwiIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCI+XFxuICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCIgY2xhc3M9XFxcIm51bWJlci1jYXJkIGNoYXJ0XFxcIiBbY2xhc3MuY2xpY2thYmxlXT1cXFwiY2xpY2thYmxlXFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWNhcmQtc2VyaWVzXFxuICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgIFtjYXJkQ29sb3JdPVxcXCJjYXJkQ29sb3JcXFwiXFxuICAgICAgICAgIFtiYW5kQ29sb3JdPVxcXCJiYW5kQ29sb3JcXFwiXFxuICAgICAgICAgIFt0ZXh0Q29sb3JdPVxcXCJ0ZXh0Q29sb3JcXFwiXFxuICAgICAgICAgIFtlbXB0eUNvbG9yXT1cXFwiZW1wdHlDb2xvclxcXCJcXG4gICAgICAgICAgW2RhdGFdPVxcXCJkYXRhXFxcIlxcbiAgICAgICAgICBbZGltc109XFxcImRpbXNcXFwiXFxuICAgICAgICAgIFtpbm5lclBhZGRpbmddPVxcXCJpbm5lclBhZGRpbmdcXFwiXFxuICAgICAgICAgIFt2YWx1ZUZvcm1hdHRpbmddPVxcXCJ2YWx1ZUZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFtsYWJlbEZvcm1hdHRpbmddPVxcXCJsYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLm5neC1jaGFydHN7ZmxvYXQ6bGVmdDtvdmVyZmxvdzp2aXNpYmxlfS5uZ3gtY2hhcnRzIC5hcmMsLm5neC1jaGFydHMgLmJhciwubmd4LWNoYXJ0cyAuY2lyY2xle2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5hcmMuYWN0aXZlLC5uZ3gtY2hhcnRzIC5hcmM6aG92ZXIsLm5neC1jaGFydHMgLmJhci5hY3RpdmUsLm5neC1jaGFydHMgLmJhcjpob3Zlciwubmd4LWNoYXJ0cyAuY2FyZC5hY3RpdmUsLm5neC1jaGFydHMgLmNhcmQ6aG92ZXIsLm5neC1jaGFydHMgLmNlbGwuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jZWxsOmhvdmVye29wYWNpdHk6Ljg7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dH0ubmd4LWNoYXJ0cyAuYXJjOmZvY3VzLC5uZ3gtY2hhcnRzIC5iYXI6Zm9jdXMsLm5neC1jaGFydHMgLmNhcmQ6Zm9jdXMsLm5neC1jaGFydHMgLmNlbGw6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmMuaGlkZGVuLC5uZ3gtY2hhcnRzIC5iYXIuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jYXJkLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2VsbC5oaWRkZW57ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIGc6Zm9jdXN7b3V0bGluZTowfS5uZ3gtY2hhcnRzIC5hcmVhLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMtcmFuZ2UuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtYXJlYS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLXBhdGguaW5hY3RpdmV7dHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBlYXNlLWluLW91dDtvcGFjaXR5Oi4yfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodHtkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0LmFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5uZ3gtY2hhcnRzIC5hcmVhe29wYWNpdHk6LjZ9Lm5neC1jaGFydHMgLmNpcmNsZTpob3ZlcntjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAubGFiZWx7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NDAwfS5uZ3gtY2hhcnRzIC50b29sdGlwLWFuY2hvcntmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGh7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5yZWZsaW5lLXBhdGh7c3Ryb2tlOiNhOGIyYzc7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheTo1O3N0cm9rZS1kYXNob2Zmc2V0OjV9Lm5neC1jaGFydHMgLnJlZmxpbmUtbGFiZWx7Zm9udC1zaXplOjlweH0ubmd4LWNoYXJ0cyAucmVmZXJlbmNlLWFyZWF7ZmlsbC1vcGFjaXR5Oi4wNTtmaWxsOiMwMDB9Lm5neC1jaGFydHMgLmdyaWRsaW5lLXBhdGgtZG90dGVke3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZTtzdHJva2UtZGFzaGFycmF5OjEsMjA7c3Ryb2tlLWRhc2hvZmZzZXQ6M30ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbCByZWN0e2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAuZ3JpZC1wYW5lbC5vZGQgcmVjdHtmaWxsOnJnYmEoMCwwLDAsLjA1KX1cIiwgXCJuZ3gtY2hhcnRzLW51bWJlci1jYXJkIC5jZWxsIC50cmltbWVkLWxhYmVse2ZvbnQtc2l6ZToxMnB4O3BvaW50ZXItZXZlbnRzOm5vbmU7b3ZlcmZsb3c6aGlkZGVuO3RleHQtYWxpZ246bGVmdDtsaW5lLWhlaWdodDoxZW19bmd4LWNoYXJ0cy1udW1iZXItY2FyZCAuY2VsbCAudHJpbW1lZC1sYWJlbCBwe292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXA7dGV4dC1vdmVyZmxvdzplbGxpcHNpczt3aWR0aDoxMDAlO3BhZGRpbmc6MDttYXJnaW46MH1uZ3gtY2hhcnRzLW51bWJlci1jYXJkIC5jZWxsIC52YWx1ZS10ZXh0e3BvaW50ZXItZXZlbnRzOm5vbmV9bmd4LWNoYXJ0cy1udW1iZXItY2FyZCAubnVtYmVyLWNhcmQuY2xpY2thYmxlIC5jZWxsIC5jYXJkLG5neC1jaGFydHMtbnVtYmVyLWNhcmQgLm51bWJlci1jYXJkLmNsaWNrYWJsZSAuY2VsbCAuY2FyZC1iYW5ke2N1cnNvcjpwb2ludGVyfVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgTnVtYmVyQ2FyZENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTnVtYmVyQ2FyZENvbXBvbmVudDtcclxufShCYXNlQ2hhcnRDb21wb25lbnQpKTtcclxuXHJcbnZhciBOdW1iZXJDYXJkTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTnVtYmVyQ2FyZE1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIE51bWJlckNhcmRNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDaGFydENvbW1vbk1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgQ2FyZENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIENhcmRTZXJpZXNDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBOdW1iZXJDYXJkQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIENhcmRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBDYXJkU2VyaWVzQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyQ2FyZENvbXBvbmVudFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE51bWJlckNhcmRNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE51bWJlckNhcmRNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG52YXIgVHJlZU1hcENlbGxDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUcmVlTWFwQ2VsbENvbXBvbmVudChlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQubmF0aXZlRWxlbWVudDtcclxuICAgIH1cclxuICAgIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMudmFsdWVGb3JtYXR0aW5nID0gdGhpcy52YWx1ZUZvcm1hdHRpbmcgfHwgKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTsgfSk7XHJcbiAgICAgICAgdmFyIGxhYmVsRm9ybWF0dGluZyA9IHRoaXMubGFiZWxGb3JtYXR0aW5nIHx8IChmdW5jdGlvbiAoY2VsbCkgeyByZXR1cm4gdHJpbUxhYmVsKGNlbGwubGFiZWwsIDU1KTsgfSk7XHJcbiAgICAgICAgdmFyIGNlbGxEYXRhID0ge1xyXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXHJcbiAgICAgICAgICAgIGxhYmVsOiB0aGlzLmxhYmVsLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWRWYWx1ZSA9IHRoaXMudmFsdWVGb3JtYXR0aW5nKGNlbGxEYXRhLnZhbHVlKTtcclxuICAgICAgICB0aGlzLmZvcm1hdHRlZExhYmVsID0gbGFiZWxGb3JtYXR0aW5nKGNlbGxEYXRhKTtcclxuICAgICAgICB0aGlzLmdyYWRpZW50SWQgPSAnZ3JhZCcgKyBpZCgpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5ncmFkaWVudFVybCA9IFwidXJsKCNcIiArIHRoaXMuZ3JhZGllbnRJZCArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IHRoaXMuZ2V0R3JhZGllbnRTdG9wcygpO1xyXG4gICAgfTtcclxuICAgIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRlVG9DdXJyZW50Rm9ybSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5sb2FkQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub2RlID0gc2VsZWN0KHRoaXMuZWxlbWVudCkuc2VsZWN0KCcuY2VsbCcpO1xyXG4gICAgICAgIG5vZGVcclxuICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAwKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHRoaXMueClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCB0aGlzLnkpO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0ZVRvQ3VycmVudEZvcm0oKTtcclxuICAgIH07XHJcbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VGV4dENvbG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBpbnZlcnRDb2xvcih0aGlzLmZpbGwpO1xyXG4gICAgfTtcclxuICAgIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5hbmltYXRlVG9DdXJyZW50Rm9ybSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHNlbGVjdCh0aGlzLmVsZW1lbnQpLnNlbGVjdCgnLmNlbGwnKTtcclxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25zKSB7XHJcbiAgICAgICAgICAgIG5vZGVcclxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbig3NTApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDEpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHRoaXMueClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgdGhpcy55KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy53aWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDEpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHRoaXMueClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgdGhpcy55KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy53aWR0aClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZS5vbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQodGhpcy5kYXRhKTtcclxuICAgIH07XHJcbiAgICBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUuZ2V0R3JhZGllbnRTdG9wcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5maWxsLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC4zXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMTAwLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuZmlsbCxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwieFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ3JhZGllbnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBUcmVlTWFwQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIFRyZWVNYXBDZWxsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtdHJlZS1tYXAtY2VsbF0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnPlxcbiAgICAgIDxkZWZzICpuZ0lmPVxcXCJncmFkaWVudFxcXCI+XFxuICAgICAgICA8c3ZnOmcgbmd4LWNoYXJ0cy1zdmctbGluZWFyLWdyYWRpZW50IG9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCIgW25hbWVdPVxcXCJncmFkaWVudElkXFxcIiBbc3RvcHNdPVxcXCJncmFkaWVudFN0b3BzXFxcIiAvPlxcbiAgICAgIDwvZGVmcz5cXG4gICAgICA8c3ZnOnJlY3RcXG4gICAgICAgIFthdHRyLmZpbGxdPVxcXCJncmFkaWVudCA/IGdyYWRpZW50VXJsIDogZmlsbFxcXCJcXG4gICAgICAgIFthdHRyLndpZHRoXT1cXFwid2lkdGhcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJoZWlnaHRcXFwiXFxuICAgICAgICBbYXR0ci54XT1cXFwieFxcXCJcXG4gICAgICAgIFthdHRyLnldPVxcXCJ5XFxcIlxcbiAgICAgICAgW3N0eWxlLmN1cnNvcl09XFxcIidwb2ludGVyJ1xcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJjZWxsXFxcIlxcbiAgICAgICAgKGNsaWNrKT1cXFwib25DbGljaygpXFxcIlxcbiAgICAgIC8+XFxuICAgICAgPHN2Zzpmb3JlaWduT2JqZWN0XFxuICAgICAgICAqbmdJZj1cXFwid2lkdGggPj0gNzAgJiYgaGVpZ2h0ID49IDM1XFxcIlxcbiAgICAgICAgW2F0dHIueF09XFxcInhcXFwiXFxuICAgICAgICBbYXR0ci55XT1cXFwieVxcXCJcXG4gICAgICAgIFthdHRyLndpZHRoXT1cXFwid2lkdGhcXFwiXFxuICAgICAgICBbYXR0ci5oZWlnaHRdPVxcXCJoZWlnaHRcXFwiXFxuICAgICAgICBjbGFzcz1cXFwidHJlZW1hcC1sYWJlbFxcXCJcXG4gICAgICAgIFtzdHlsZS5wb2ludGVyLWV2ZW50c109XFxcIidub25lJ1xcXCJcXG4gICAgICA+XFxuICAgICAgICA8eGh0bWw6cCBbc3R5bGUuY29sb3JdPVxcXCJnZXRUZXh0Q29sb3IoKVxcXCIgW3N0eWxlLmhlaWdodF09XFxcImhlaWdodCArICdweCdcXFwiIFtzdHlsZS53aWR0aF09XFxcIndpZHRoICsgJ3B4J1xcXCI+XFxuICAgICAgICAgIDx4aHRtbDpzcGFuIGNsYXNzPVxcXCJ0cmVlbWFwLWxhYmVsXFxcIiBbaW5uZXJIVE1MXT1cXFwiZm9ybWF0dGVkTGFiZWxcXFwiPiA8L3hodG1sOnNwYW4+XFxuICAgICAgICAgIDx4aHRtbDpiciAvPlxcbiAgICAgICAgICA8eGh0bWw6c3BhblxcbiAgICAgICAgICAgICpuZ0lmPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJ0cmVlbWFwLXZhbFxcXCJcXG4gICAgICAgICAgICBuZ3gtY2hhcnRzLWNvdW50LXVwXFxuICAgICAgICAgICAgW2NvdW50VG9dPVxcXCJ2YWx1ZVxcXCJcXG4gICAgICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgIDwveGh0bWw6c3Bhbj5cXG4gICAgICAgICAgPHhodG1sOnNwYW4gKm5nSWY9XFxcIiFhbmltYXRpb25zXFxcIiBjbGFzcz1cXFwidHJlZW1hcC12YWxcXFwiPlxcbiAgICAgICAgICAgIHt7IGZvcm1hdHRlZFZhbHVlIH19XFxuICAgICAgICAgIDwveGh0bWw6c3Bhbj5cXG4gICAgICAgIDwveGh0bWw6cD5cXG4gICAgICA8L3N2Zzpmb3JlaWduT2JqZWN0PlxcbiAgICA8L3N2ZzpnPlxcbiAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFt0eXBlb2YgKF9hID0gdHlwZW9mIEVsZW1lbnRSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgRWxlbWVudFJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0XSlcclxuICAgIF0sIFRyZWVNYXBDZWxsQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBUcmVlTWFwQ2VsbENvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMuY2VsbHMgPSB0aGlzLmdldENlbGxzKCk7XHJcbiAgICB9O1xyXG4gICAgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldENlbGxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5jaGlsZHJlblxyXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLmRlcHRoID09PSAxO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGQsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQuaWQ7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkLmRhdGEsXHJcbiAgICAgICAgICAgICAgICB4OiBkLngwLFxyXG4gICAgICAgICAgICAgICAgeTogZC55MCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBkLngxIC0gZC54MCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogZC55MSAtIGQueTAsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiBfdGhpcy5jb2xvcnMuZ2V0Q29sb3IobGFiZWwpLFxyXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGU6IGQudmFsdWVUeXBlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLmdldFRvb2x0aXBUZXh0ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsID0gX2EubGFiZWwsIHZhbHVlID0gX2EudmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtbGFiZWxcXFwiPlwiICsgbGFiZWwgKyBcIjwvc3Bhbj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidG9vbHRpcC12YWxcXFwiPlwiICsgdmFsdWUudG9Mb2NhbGVTdHJpbmcoKSArIFwiPC9zcGFuPlxcbiAgICBcIjtcclxuICAgIH07XHJcbiAgICBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xyXG4gICAgfTtcclxuICAgIHZhciBfYTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGltc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJncmFkaWVudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgVGVtcGxhdGVSZWYgIT09IFwidW5kZWZpbmVkXCIgJiYgVGVtcGxhdGVSZWYpID09PSBcImZ1bmN0aW9uXCIgPyBfYSA6IE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtdHJlZS1tYXAtY2VsbC1zZXJpZXNdJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxzdmc6Z1xcbiAgICAgIG5neC1jaGFydHMtdHJlZS1tYXAtY2VsbFxcbiAgICAgICpuZ0Zvcj1cXFwibGV0IGMgb2YgY2VsbHM7IHRyYWNrQnk6IHRyYWNrQnlcXFwiXFxuICAgICAgW2RhdGFdPVxcXCJjLmRhdGFcXFwiXFxuICAgICAgW3hdPVxcXCJjLnhcXFwiXFxuICAgICAgW3ldPVxcXCJjLnlcXFwiXFxuICAgICAgW3dpZHRoXT1cXFwiYy53aWR0aFxcXCJcXG4gICAgICBbaGVpZ2h0XT1cXFwiYy5oZWlnaHRcXFwiXFxuICAgICAgW2ZpbGxdPVxcXCJjLmZpbGxcXFwiXFxuICAgICAgW2xhYmVsXT1cXFwiYy5sYWJlbFxcXCJcXG4gICAgICBbdmFsdWVdPVxcXCJjLnZhbHVlXFxcIlxcbiAgICAgIFt2YWx1ZVR5cGVdPVxcXCJjLnZhbHVlVHlwZVxcXCJcXG4gICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgIFtsYWJlbEZvcm1hdHRpbmddPVxcXCJsYWJlbEZvcm1hdHRpbmdcXFwiXFxuICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChzZWxlY3QpPVxcXCJvbkNsaWNrKCRldmVudClcXFwiXFxuICAgICAgbmd4LXRvb2x0aXBcXG4gICAgICBbdG9vbHRpcERpc2FibGVkXT1cXFwidG9vbHRpcERpc2FibGVkXFxcIlxcbiAgICAgIFt0b29sdGlwUGxhY2VtZW50XT1cXFwiJ3RvcCdcXFwiXFxuICAgICAgW3Rvb2x0aXBUeXBlXT1cXFwiJ3Rvb2x0aXAnXFxcIlxcbiAgICAgIFt0b29sdGlwVGl0bGVdPVxcXCJ0b29sdGlwVGVtcGxhdGUgPyB1bmRlZmluZWQgOiBnZXRUb29sdGlwVGV4dChjKVxcXCJcXG4gICAgICBbdG9vbHRpcFRlbXBsYXRlXT1cXFwidG9vbHRpcFRlbXBsYXRlXFxcIlxcbiAgICAgIFt0b29sdGlwQ29udGV4dF09XFxcImMuZGF0YVxcXCJcXG4gICAgPjwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgVHJlZU1hcENlbGxTZXJpZXNDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50O1xyXG59KCkpO1xyXG5cclxudmFyIFRyZWVNYXBDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVHJlZU1hcENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRyZWVNYXBDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuZ3JhZGllbnQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAxMCwgMTAsIDEwXTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRpbXMgPSBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtYXJnaW5zOiB0aGlzLm1hcmdpblxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gdGhpcy5nZXREb21haW4oKTtcclxuICAgICAgICB0aGlzLnRyZWVtYXAgPSB0cmVlbWFwKCkuc2l6ZShbdGhpcy5kaW1zLndpZHRoLCB0aGlzLmRpbXMuaGVpZ2h0XSk7XHJcbiAgICAgICAgdmFyIHJvb3ROb2RlID0ge1xyXG4gICAgICAgICAgICBuYW1lOiAncm9vdCcsXHJcbiAgICAgICAgICAgIHZhbHVlOiAwLFxyXG4gICAgICAgICAgICBpc1Jvb3Q6IHRydWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByb290ID0gc3RyYXRpZnkoKVxyXG4gICAgICAgICAgICAuaWQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gZC5uYW1lO1xyXG4gICAgICAgICAgICBpZiAobGFiZWwuY29uc3RydWN0b3IubmFtZSA9PT0gJ0RhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbC50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbDtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAucGFyZW50SWQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIChkLmlzUm9vdCA/IG51bGwgOiAncm9vdCcpOyB9KShbcm9vdE5vZGVdLmNvbmNhdCh0aGlzLnJlc3VsdHMpKVxyXG4gICAgICAgICAgICAuc3VtKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLnRyZWVtYXAocm9vdCk7XHJcbiAgICAgICAgdGhpcy5zZXRDb2xvcnMoKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgdGhpcy5kaW1zLnhPZmZzZXQgKyBcIiAsIFwiICsgdGhpcy5tYXJnaW5bMF0gKyBcIilcIjtcclxuICAgIH07XHJcbiAgICBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZS5nZXREb21haW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZTsgfSk7XHJcbiAgICB9O1xyXG4gICAgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdChkYXRhKTtcclxuICAgIH07XHJcbiAgICBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBuZXcgQ29sb3JIZWxwZXIodGhpcy5zY2hlbWUsICdvcmRpbmFsJywgdGhpcy5kb21haW4sIHRoaXMuY3VzdG9tQ29sb3JzKTtcclxuICAgIH07XHJcbiAgICB2YXIgX2E7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXN1bHRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcERpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBUcmVlTWFwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFRyZWVNYXBDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIFRyZWVNYXBDb21wb25lbnQucHJvdG90eXBlLCBcImdyYWRpZW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgVHJlZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBUcmVlTWFwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLXRyZWUtbWFwJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxuZ3gtY2hhcnRzLWNoYXJ0IFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIiBbc2hvd0xlZ2VuZF09XFxcImZhbHNlXFxcIiBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJ0cmVlLW1hcCBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy10cmVlLW1hcC1jZWxsLXNlcmllc1xcbiAgICAgICAgICBbY29sb3JzXT1cXFwiY29sb3JzXFxcIlxcbiAgICAgICAgICBbZGF0YV09XFxcImRhdGFcXFwiXFxuICAgICAgICAgIFtkaW1zXT1cXFwiZGltc1xcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgW3ZhbHVlRm9ybWF0dGluZ109XFxcInZhbHVlRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW2xhYmVsRm9ybWF0dGluZ109XFxcImxhYmVsRm9ybWF0dGluZ1xcXCJcXG4gICAgICAgICAgW2dyYWRpZW50XT1cXFwiZ3JhZGllbnRcXFwiXFxuICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgKHNlbGVjdCk9XFxcIm9uQ2xpY2soJGV2ZW50KVxcXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9zdmc6Zz5cXG4gICAgPC9uZ3gtY2hhcnRzLWNoYXJ0PlxcbiAgXCIsXHJcbiAgICAgICAgICAgIHN0eWxlczogW1wiLnRyZWUtbWFwIC50cmVlbWFwLXZhbHtmb250LXNpemU6MS4zZW07cGFkZGluZy10b3A6NXB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrfS50cmVlLW1hcCAudHJlZW1hcC1sYWJlbCBwe2Rpc3BsYXk6dGFibGUtY2VsbDt0ZXh0LWFsaWduOmNlbnRlcjtsaW5lLWhlaWdodDoxLjJlbTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBUcmVlTWFwQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBUcmVlTWFwQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIFRyZWVNYXBNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUcmVlTWFwTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgVHJlZU1hcE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NoYXJ0Q29tbW9uTW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICBUcmVlTWFwQ2VsbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgVHJlZU1hcENvbXBvbmVudFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgICAgICAgICBUcmVlTWFwQ2VsbENvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIFRyZWVNYXBDZWxsU2VyaWVzQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgVHJlZU1hcENvbXBvbmVudFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIFRyZWVNYXBNb2R1bGUpO1xyXG4gICAgcmV0dXJuIFRyZWVNYXBNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG52YXIgTGluZWFyR2F1Z2VDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTGluZWFyR2F1Z2VDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMaW5lYXJHYXVnZUNvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5taW4gPSAwO1xyXG4gICAgICAgIF90aGlzLm1heCA9IDEwMDtcclxuICAgICAgICBfdGhpcy52YWx1ZSA9IDA7XHJcbiAgICAgICAgX3RoaXMubWFyZ2luID0gWzEwLCAyMCwgMTAsIDIwXTtcclxuICAgICAgICBfdGhpcy52YWx1ZVJlc2l6ZVNjYWxlID0gMTtcclxuICAgICAgICBfdGhpcy51bml0c1Jlc2l6ZVNjYWxlID0gMTtcclxuICAgICAgICBfdGhpcy52YWx1ZVRleHRUcmFuc2Zvcm0gPSAnJztcclxuICAgICAgICBfdGhpcy52YWx1ZVRyYW5zbGF0ZSA9ICcnO1xyXG4gICAgICAgIF90aGlzLnVuaXRzVGV4dFRyYW5zZm9ybSA9ICcnO1xyXG4gICAgICAgIF90aGlzLnVuaXRzVHJhbnNsYXRlID0gJyc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnNjYWxlVGV4dCgndmFsdWUnKTtcclxuICAgICAgICAgICAgX3RoaXMuc2NhbGVUZXh0KCd1bml0cycpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFzUHJldmlvdXNWYWx1ZSA9IHRoaXMucHJldmlvdXNWYWx1ZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5tYXgsIHRoaXMudmFsdWUpO1xyXG4gICAgICAgIHRoaXMubWluID0gTWF0aC5taW4odGhpcy5taW4sIHRoaXMudmFsdWUpO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1ByZXZpb3VzVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgdGhpcy5wcmV2aW91c1ZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5taW4gPSBNYXRoLm1pbih0aGlzLm1pbiwgdGhpcy5wcmV2aW91c1ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaW1zID0gY2FsY3VsYXRlVmlld0RpbWVuc2lvbnMoe1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWFyZ2luczogdGhpcy5tYXJnaW5cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnZhbHVlRG9tYWluID0gdGhpcy5nZXRWYWx1ZURvbWFpbigpO1xyXG4gICAgICAgIHRoaXMudmFsdWVTY2FsZSA9IHRoaXMuZ2V0VmFsdWVTY2FsZSgpO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5nZXREaXNwbGF5VmFsdWUoKTtcclxuICAgICAgICB0aGlzLnNldENvbG9ycygpO1xyXG4gICAgICAgIHZhciB4T2Zmc2V0ID0gdGhpcy5tYXJnaW5bM10gKyB0aGlzLmRpbXMud2lkdGggLyAyO1xyXG4gICAgICAgIHZhciB5T2Zmc2V0ID0gdGhpcy5tYXJnaW5bMF0gKyB0aGlzLmRpbXMuaGVpZ2h0IC8gMjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgeE9mZnNldCArIFwiLCBcIiArIHlPZmZzZXQgKyBcIilcIjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybUxpbmUgPSBcInRyYW5zbGF0ZShcIiArICh0aGlzLm1hcmdpblszXSArIHRoaXMudmFsdWVTY2FsZSh0aGlzLnByZXZpb3VzVmFsdWUpKSArIFwiLCBcIiArIHlPZmZzZXQgKyBcIilcIjtcclxuICAgICAgICB0aGlzLnZhbHVlVHJhbnNsYXRlID0gXCJ0cmFuc2xhdGUoMCwgLTE1KVwiO1xyXG4gICAgICAgIHRoaXMudW5pdHNUcmFuc2xhdGUgPSBcInRyYW5zbGF0ZSgwLCAxNSlcIjtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNjYWxlVGV4dCgndmFsdWUnKTsgfSwgNTApO1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2NhbGVUZXh0KCd1bml0cycpOyB9LCA1MCk7XHJcbiAgICB9O1xyXG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLmdldFZhbHVlRG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy5taW4sIHRoaXMubWF4XTtcclxuICAgIH07XHJcbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuZGltcy53aWR0aF0pXHJcbiAgICAgICAgICAgIC5kb21haW4odGhpcy52YWx1ZURvbWFpbik7XHJcbiAgICB9O1xyXG4gICAgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLmdldERpc3BsYXlWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZUZvcm1hdHRpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVGb3JtYXR0aW5nKHRoaXMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgfTtcclxuICAgIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5zY2FsZVRleHQgPSBmdW5jdGlvbiAoZWxlbWVudCwgcmVwZWF0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAocmVwZWF0ID09PSB2b2lkIDApIHsgcmVwZWF0ID0gdHJ1ZTsgfVxyXG4gICAgICAgIHZhciBlbDtcclxuICAgICAgICB2YXIgcmVzaXplU2NhbGU7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgZWwgPSB0aGlzLnZhbHVlVGV4dEVsO1xyXG4gICAgICAgICAgICByZXNpemVTY2FsZSA9IHRoaXMudmFsdWVSZXNpemVTY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsID0gdGhpcy51bml0c1RleHRFbDtcclxuICAgICAgICAgICAgcmVzaXplU2NhbGUgPSB0aGlzLnVuaXRzUmVzaXplU2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYSA9IGVsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIG9sZFNjYWxlID0gcmVzaXplU2NhbGU7XHJcbiAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gdGhpcy5kaW1zLndpZHRoO1xyXG4gICAgICAgIHZhciBhdmFpbGFibGVIZWlnaHQgPSBNYXRoLm1heCh0aGlzLmRpbXMuaGVpZ2h0IC8gMiAtIDE1LCAwKTtcclxuICAgICAgICB2YXIgcmVzaXplU2NhbGVXaWR0aCA9IE1hdGguZmxvb3IoKGF2YWlsYWJsZVdpZHRoIC8gKHdpZHRoIC8gcmVzaXplU2NhbGUpKSAqIDEwMCkgLyAxMDA7XHJcbiAgICAgICAgdmFyIHJlc2l6ZVNjYWxlSGVpZ2h0ID0gTWF0aC5mbG9vcigoYXZhaWxhYmxlSGVpZ2h0IC8gKGhlaWdodCAvIHJlc2l6ZVNjYWxlKSkgKiAxMDApIC8gMTAwO1xyXG4gICAgICAgIHJlc2l6ZVNjYWxlID0gTWF0aC5taW4ocmVzaXplU2NhbGVIZWlnaHQsIHJlc2l6ZVNjYWxlV2lkdGgpO1xyXG4gICAgICAgIGlmIChyZXNpemVTY2FsZSAhPT0gb2xkU2NhbGUpIHtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVSZXNpemVTY2FsZSA9IHJlc2l6ZVNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZVRleHRUcmFuc2Zvcm0gPSBcInNjYWxlKFwiICsgcmVzaXplU2NhbGUgKyBcIiwgXCIgKyByZXNpemVTY2FsZSArIFwiKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bml0c1Jlc2l6ZVNjYWxlID0gcmVzaXplU2NhbGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuaXRzVGV4dFRyYW5zZm9ybSA9IFwic2NhbGUoXCIgKyByZXNpemVTY2FsZSArIFwiLCBcIiArIHJlc2l6ZVNjYWxlICsgXCIpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcclxuICAgICAgICAgICAgaWYgKHJlcGVhdCkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2NhbGVUZXh0KGVsZW1lbnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0sIDUwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHtcclxuICAgICAgICAgICAgbmFtZTogJ1ZhbHVlJyxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbmV3IENvbG9ySGVscGVyKHRoaXMuc2NoZW1lLCAnb3JkaW5hbCcsIFt0aGlzLnZhbHVlXSwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ1bml0c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTGluZWFyR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInByZXZpb3VzVmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIExpbmVhckdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUZvcm1hdHRpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFZpZXdDaGlsZCgndmFsdWVUZXh0RWwnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2EgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVUZXh0RWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFZpZXdDaGlsZCgndW5pdHNUZXh0RWwnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2IgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2IgOiBPYmplY3QpXHJcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidW5pdHNUZXh0RWxcIiwgdm9pZCAwKTtcclxuICAgIExpbmVhckdhdWdlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICduZ3gtY2hhcnRzLWxpbmVhci1nYXVnZScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydCBbdmlld109XFxcIlt3aWR0aCwgaGVpZ2h0XVxcXCIgW3Nob3dMZWdlbmRdPVxcXCJmYWxzZVxcXCIgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIiAoY2xpY2spPVxcXCJvbkNsaWNrKClcXFwiPlxcbiAgICAgIDxzdmc6ZyBjbGFzcz1cXFwibGluZWFyLWdhdWdlIGNoYXJ0XFxcIj5cXG4gICAgICAgIDxzdmc6Z1xcbiAgICAgICAgICBuZ3gtY2hhcnRzLWJhclxcbiAgICAgICAgICBjbGFzcz1cXFwiYmFja2dyb3VuZC1iYXJcXFwiXFxuICAgICAgICAgIFt3aWR0aF09XFxcImRpbXMud2lkdGhcXFwiXFxuICAgICAgICAgIFtoZWlnaHRdPVxcXCIzXFxcIlxcbiAgICAgICAgICBbeF09XFxcIm1hcmdpblszXVxcXCJcXG4gICAgICAgICAgW3ldPVxcXCJkaW1zLmhlaWdodCAvIDIgKyBtYXJnaW5bMF0gLSAyXFxcIlxcbiAgICAgICAgICBbZGF0YV09XFxcInt9XFxcIlxcbiAgICAgICAgICBbb3JpZW50YXRpb25dPVxcXCInaG9yaXpvbnRhbCdcXFwiXFxuICAgICAgICAgIFtyb3VuZEVkZ2VzXT1cXFwidHJ1ZVxcXCJcXG4gICAgICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1iYXJcXG4gICAgICAgICAgW3dpZHRoXT1cXFwidmFsdWVTY2FsZSh2YWx1ZSlcXFwiXFxuICAgICAgICAgIFtoZWlnaHRdPVxcXCIzXFxcIlxcbiAgICAgICAgICBbeF09XFxcIm1hcmdpblszXVxcXCJcXG4gICAgICAgICAgW3ldPVxcXCJkaW1zLmhlaWdodCAvIDIgKyBtYXJnaW5bMF0gLSAyXFxcIlxcbiAgICAgICAgICBbZmlsbF09XFxcImNvbG9ycy5nZXRDb2xvcih1bml0cylcXFwiXFxuICAgICAgICAgIFtkYXRhXT1cXFwie31cXFwiXFxuICAgICAgICAgIFtvcmllbnRhdGlvbl09XFxcIidob3Jpem9udGFsJ1xcXCJcXG4gICAgICAgICAgW3JvdW5kRWRnZXNdPVxcXCJ0cnVlXFxcIlxcbiAgICAgICAgICBbYW5pbWF0aW9uc109XFxcImFuaW1hdGlvbnNcXFwiXFxuICAgICAgICA+PC9zdmc6Zz5cXG5cXG4gICAgICAgIDxzdmc6bGluZVxcbiAgICAgICAgICAqbmdJZj1cXFwiaGFzUHJldmlvdXNWYWx1ZVxcXCJcXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtTGluZVxcXCJcXG4gICAgICAgICAgeDE9XFxcIjBcXFwiXFxuICAgICAgICAgIHkxPVxcXCI1XFxcIlxcbiAgICAgICAgICB4Mj1cXFwiMFxcXCJcXG4gICAgICAgICAgeTI9XFxcIjE1XFxcIlxcbiAgICAgICAgICBbYXR0ci5zdHJva2VdPVxcXCJjb2xvcnMuZ2V0Q29sb3IodW5pdHMpXFxcIlxcbiAgICAgICAgLz5cXG5cXG4gICAgICAgIDxzdmc6bGluZVxcbiAgICAgICAgICAqbmdJZj1cXFwiaGFzUHJldmlvdXNWYWx1ZVxcXCJcXG4gICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidHJhbnNmb3JtTGluZVxcXCJcXG4gICAgICAgICAgeDE9XFxcIjBcXFwiXFxuICAgICAgICAgIHkxPVxcXCItNVxcXCJcXG4gICAgICAgICAgeDI9XFxcIjBcXFwiXFxuICAgICAgICAgIHkyPVxcXCItMTVcXFwiXFxuICAgICAgICAgIFthdHRyLnN0cm9rZV09XFxcImNvbG9ycy5nZXRDb2xvcih1bml0cylcXFwiXFxuICAgICAgICAvPlxcblxcbiAgICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInRyYW5zZm9ybVxcXCI+XFxuICAgICAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ2YWx1ZVRyYW5zbGF0ZVxcXCI+XFxuICAgICAgICAgICAgPHN2Zzp0ZXh0XFxuICAgICAgICAgICAgICAjdmFsdWVUZXh0RWxcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJ2YWx1ZVxcXCJcXG4gICAgICAgICAgICAgIFtzdHlsZS50ZXh0QW5jaG9yXT1cXFwiJ21pZGRsZSdcXFwiXFxuICAgICAgICAgICAgICBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ2YWx1ZVRleHRUcmFuc2Zvcm1cXFwiXFxuICAgICAgICAgICAgICBhbGlnbm1lbnQtYmFzZWxpbmU9XFxcImFmdGVyLWVkZ2VcXFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAge3sgZGlzcGxheVZhbHVlIH19XFxuICAgICAgICAgICAgPC9zdmc6dGV4dD5cXG4gICAgICAgICAgPC9zdmc6Zz5cXG5cXG4gICAgICAgICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInVuaXRzVHJhbnNsYXRlXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgICAgICN1bml0c1RleHRFbFxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcInVuaXRzXFxcIlxcbiAgICAgICAgICAgICAgW3N0eWxlLnRleHRBbmNob3JdPVxcXCInbWlkZGxlJ1xcXCJcXG4gICAgICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInVuaXRzVGV4dFRyYW5zZm9ybVxcXCJcXG4gICAgICAgICAgICAgIGFsaWdubWVudC1iYXNlbGluZT1cXFwiYmVmb3JlLWVkZ2VcXFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAge3sgdW5pdHMgfX1cXG4gICAgICAgICAgICA8L3N2Zzp0ZXh0PlxcbiAgICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPC9zdmc6Zz5cXG4gICAgICA8L3N2ZzpnPlxcbiAgICA8L25neC1jaGFydHMtY2hhcnQ+XFxuICBcIixcclxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubmd4LWNoYXJ0c3tmbG9hdDpsZWZ0O292ZXJmbG93OnZpc2libGV9Lm5neC1jaGFydHMgLmFyYywubmd4LWNoYXJ0cyAuYmFyLC5uZ3gtY2hhcnRzIC5jaXJjbGV7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmFyYy5hY3RpdmUsLm5neC1jaGFydHMgLmFyYzpob3Zlciwubmd4LWNoYXJ0cyAuYmFyLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYmFyOmhvdmVyLC5uZ3gtY2hhcnRzIC5jYXJkLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2FyZDpob3Zlciwubmd4LWNoYXJ0cyAuY2VsbC5hY3RpdmUsLm5neC1jaGFydHMgLmNlbGw6aG92ZXJ7b3BhY2l0eTouODt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0fS5uZ3gtY2hhcnRzIC5hcmM6Zm9jdXMsLm5neC1jaGFydHMgLmJhcjpmb2N1cywubmd4LWNoYXJ0cyAuY2FyZDpmb2N1cywubmd4LWNoYXJ0cyAuY2VsbDpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyYy5oaWRkZW4sLm5neC1jaGFydHMgLmJhci5oaWRkZW4sLm5neC1jaGFydHMgLmNhcmQuaGlkZGVuLC5uZ3gtY2hhcnRzIC5jZWxsLmhpZGRlbntkaXNwbGF5Om5vbmV9Lm5neC1jaGFydHMgZzpmb2N1c3tvdXRsaW5lOjB9Lm5neC1jaGFydHMgLmFyZWEtc2VyaWVzLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy1yYW5nZS5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAubGluZS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1hcmVhLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5wb2xhci1zZXJpZXMtcGF0aC5pbmFjdGl2ZXt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGVhc2UtaW4tb3V0O29wYWNpdHk6LjJ9Lm5neC1jaGFydHMgLmxpbmUtaGlnaGxpZ2h0e2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHQuYWN0aXZle2Rpc3BsYXk6YmxvY2t9Lm5neC1jaGFydHMgLmFyZWF7b3BhY2l0eTouNn0ubmd4LWNoYXJ0cyAuY2lyY2xlOmhvdmVye2N1cnNvcjpwb2ludGVyfS5uZ3gtY2hhcnRzIC5sYWJlbHtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo0MDB9Lm5neC1jaGFydHMgLnRvb2x0aXAtYW5jaG9ye2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLnJlZmxpbmUtcGF0aHtzdHJva2U6I2E4YjJjNztzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjU7c3Ryb2tlLWRhc2hvZmZzZXQ6NX0ubmd4LWNoYXJ0cyAucmVmbGluZS1sYWJlbHtmb250LXNpemU6OXB4fS5uZ3gtY2hhcnRzIC5yZWZlcmVuY2UtYXJlYXtmaWxsLW9wYWNpdHk6LjA1O2ZpbGw6IzAwMH0ubmd4LWNoYXJ0cyAuZ3JpZGxpbmUtcGF0aC1kb3R0ZWR7c3Ryb2tlOiNkZGQ7c3Ryb2tlLXdpZHRoOjE7ZmlsbDpub25lO3N0cm9rZS1kYXNoYXJyYXk6MSwyMDtzdHJva2UtZGFzaG9mZnNldDozfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsIHJlY3R7ZmlsbDpub25lfS5uZ3gtY2hhcnRzIC5ncmlkLXBhbmVsLm9kZCByZWN0e2ZpbGw6cmdiYSgwLDAsMCwuMDUpfVwiLCBcIi5saW5lYXItZ2F1Z2V7Y3Vyc29yOnBvaW50ZXJ9LmxpbmVhci1nYXVnZSAuYmFja2dyb3VuZC1iYXIgcGF0aHtmaWxsOnJnYmEoMCwwLDAsLjA1KX0ubGluZWFyLWdhdWdlIC51bml0c3tmaWxsOiM2NjZ9XCJdLFxyXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBMaW5lYXJHYXVnZUNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTGluZWFyR2F1Z2VDb21wb25lbnQ7XHJcbn0oQmFzZUNoYXJ0Q29tcG9uZW50KSk7XHJcblxyXG52YXIgR2F1Z2VDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoR2F1Z2VDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBHYXVnZUNvbXBvbmVudCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5sZWdlbmQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5sZWdlbmRUaXRsZSA9ICdMZWdlbmQnO1xyXG4gICAgICAgIF90aGlzLmxlZ2VuZFBvc2l0aW9uID0gJ3JpZ2h0JztcclxuICAgICAgICBfdGhpcy5taW4gPSAwO1xyXG4gICAgICAgIF90aGlzLm1heCA9IDEwMDtcclxuICAgICAgICBfdGhpcy5iaWdTZWdtZW50cyA9IDEwO1xyXG4gICAgICAgIF90aGlzLnNtYWxsU2VnbWVudHMgPSA1O1xyXG4gICAgICAgIF90aGlzLnNob3dBeGlzID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5zdGFydEFuZ2xlID0gLTEyMDtcclxuICAgICAgICBfdGhpcy5hbmdsZVNwYW4gPSAyNDA7XHJcbiAgICAgICAgX3RoaXMuYWN0aXZlRW50cmllcyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnRvb2x0aXBEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnNob3dUZXh0ID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5hY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5kZWFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLnJlc2l6ZVNjYWxlID0gMTtcclxuICAgICAgICBfdGhpcy5yb3RhdGlvbiA9ICcnO1xyXG4gICAgICAgIF90aGlzLnRleHRUcmFuc2Zvcm0gPSAnc2NhbGUoMSwgMSknO1xyXG4gICAgICAgIF90aGlzLmNvcm5lclJhZGl1cyA9IDEwO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2NhbGVUZXh0KCk7IH0pO1xyXG4gICAgfTtcclxuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICghdGhpcy5zaG93QXhpcykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWFyZ2luKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmdpbiA9IFsxMCwgMjAsIDEwLCAyMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5tYXJnaW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFyZ2luID0gWzYwLCAxMDAsIDYwLCAxMDBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0QW5nbGUgPCAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRBbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgJSAzNjApICsgMzYwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFuZ2xlU3BhbiA9IE1hdGgubWluKHRoaXMuYW5nbGVTcGFuLCAzNjApO1xyXG4gICAgICAgIHRoaXMuZGltcyA9IGNhbGN1bGF0ZVZpZXdEaW1lbnNpb25zKHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgIG1hcmdpbnM6IHRoaXMubWFyZ2luLFxyXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB0aGlzLmxlZ2VuZCxcclxuICAgICAgICAgICAgbGVnZW5kUG9zaXRpb246IHRoaXMubGVnZW5kUG9zaXRpb25cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmRvbWFpbiA9IHRoaXMuZ2V0RG9tYWluKCk7XHJcbiAgICAgICAgdGhpcy52YWx1ZURvbWFpbiA9IHRoaXMuZ2V0VmFsdWVEb21haW4oKTtcclxuICAgICAgICB0aGlzLnZhbHVlU2NhbGUgPSB0aGlzLmdldFZhbHVlU2NhbGUoKTtcclxuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZ2V0RGlzcGxheVZhbHVlKCk7XHJcbiAgICAgICAgdGhpcy5vdXRlclJhZGl1cyA9IE1hdGgubWluKHRoaXMuZGltcy53aWR0aCwgdGhpcy5kaW1zLmhlaWdodCkgLyAyO1xyXG4gICAgICAgIHRoaXMuYXJjcyA9IHRoaXMuZ2V0QXJjcygpO1xyXG4gICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRPcHRpb25zID0gdGhpcy5nZXRMZWdlbmRPcHRpb25zKCk7XHJcbiAgICAgICAgdmFyIHhPZmZzZXQgPSB0aGlzLm1hcmdpblszXSArIHRoaXMuZGltcy53aWR0aCAvIDI7XHJcbiAgICAgICAgdmFyIHlPZmZzZXQgPSB0aGlzLm1hcmdpblswXSArIHRoaXMuZGltcy5oZWlnaHQgLyAyO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB4T2Zmc2V0ICsgXCIsIFwiICsgeU9mZnNldCArIFwiKVwiO1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSBcInJvdGF0ZShcIiArIHRoaXMuc3RhcnRBbmdsZSArIFwiKVwiO1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2NhbGVUZXh0KCk7IH0sIDUwKTtcclxuICAgIH07XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0QXJjcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJjcyA9IFtdO1xyXG4gICAgICAgIHZhciBhdmFpbGFibGVSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzICogMC43O1xyXG4gICAgICAgIHZhciByYWRpdXNQZXJBcmMgPSBNYXRoLm1pbihhdmFpbGFibGVSYWRpdXMgLyB0aGlzLnJlc3VsdHMubGVuZ3RoLCAxMCk7XHJcbiAgICAgICAgdmFyIGFyY1dpZHRoID0gcmFkaXVzUGVyQXJjICogMC43O1xyXG4gICAgICAgIHRoaXMudGV4dFJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSB0aGlzLnJlc3VsdHMubGVuZ3RoICogcmFkaXVzUGVyQXJjO1xyXG4gICAgICAgIHRoaXMuY29ybmVyUmFkaXVzID0gTWF0aC5mbG9vcihhcmNXaWR0aCAvIDIpO1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5yZXN1bHRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZCA9IF9hW19pXTtcclxuICAgICAgICAgICAgdmFyIG91dGVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cyAtIGkgKiByYWRpdXNQZXJBcmM7XHJcbiAgICAgICAgICAgIHZhciBpbm5lclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gYXJjV2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBiYWNrZ3JvdW5kQXJjID0ge1xyXG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6ICh0aGlzLmFuZ2xlU3BhbiAqIE1hdGguUEkpIC8gMTgwLFxyXG4gICAgICAgICAgICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLm1heCxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkLm5hbWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlQXJjID0ge1xyXG4gICAgICAgICAgICAgICAgZW5kQW5nbGU6IChNYXRoLm1pbih0aGlzLnZhbHVlU2NhbGUoZC52YWx1ZSksIHRoaXMuYW5nbGVTcGFuKSAqIE1hdGguUEkpIC8gMTgwLFxyXG4gICAgICAgICAgICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGQubmFtZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgYXJjJCQxID0ge1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZEFyYzogYmFja2dyb3VuZEFyYyxcclxuICAgICAgICAgICAgICAgIHZhbHVlQXJjOiB2YWx1ZUFyY1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhcmNzLnB1c2goYXJjJCQxKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJjcztcclxuICAgIH07XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0RG9tYWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWU7IH0pO1xyXG4gICAgfTtcclxuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWx1ZURvbWFpbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSk7XHJcbiAgICAgICAgdmFyIGRhdGFNaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpO1xyXG4gICAgICAgIHZhciBkYXRhTWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzKTtcclxuICAgICAgICBpZiAodGhpcy5taW4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1pbiA9IE1hdGgubWluKHRoaXMubWluLCBkYXRhTWluKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWluID0gZGF0YU1pbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWF4ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgZGF0YU1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IGRhdGFNYXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbdGhpcy5taW4sIHRoaXMubWF4XTtcclxuICAgIH07XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsdWVTY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMuYW5nbGVTcGFuXSlcclxuICAgICAgICAgICAgLm5pY2UoKVxyXG4gICAgICAgICAgICAuZG9tYWluKHRoaXMudmFsdWVEb21haW4pO1xyXG4gICAgfTtcclxuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5nZXREaXNwbGF5VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSkucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYjsgfSwgMCk7XHJcbiAgICAgICAgaWYgKHRoaXMudGV4dFZhbHVlICYmIDAgIT09IHRoaXMudGV4dFZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0VmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVGb3JtYXR0aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlRm9ybWF0dGluZyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvY2FsZVN0cmluZygpO1xyXG4gICAgfTtcclxuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5zY2FsZVRleHQgPSBmdW5jdGlvbiAocmVwZWF0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAocmVwZWF0ID09PSB2b2lkIDApIHsgcmVwZWF0ID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmICghdGhpcy5zaG93VGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMudGV4dEVsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XHJcbiAgICAgICAgdmFyIG9sZFNjYWxlID0gdGhpcy5yZXNpemVTY2FsZTtcclxuICAgICAgICBpZiAod2lkdGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemVTY2FsZSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlU3BhY2UgPSB0aGlzLnRleHRSYWRpdXM7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2NhbGUgPSBNYXRoLmZsb29yKChhdmFpbGFibGVTcGFjZSAvICh3aWR0aCAvIHRoaXMucmVzaXplU2NhbGUpKSAqIDEwMCkgLyAxMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZVNjYWxlICE9PSBvbGRTY2FsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRleHRUcmFuc2Zvcm0gPSBcInNjYWxlKFwiICsgdGhpcy5yZXNpemVTY2FsZSArIFwiLCBcIiArIHRoaXMucmVzaXplU2NhbGUgKyBcIilcIjtcclxuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcclxuICAgICAgICAgICAgaWYgKHJlcGVhdCkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY2FsZVRleHQoZmFsc2UpOyB9LCA1MCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQoZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLmdldExlZ2VuZE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2NhbGVUeXBlOiAnb3JkaW5hbCcsXHJcbiAgICAgICAgICAgIGNvbG9yczogdGhpcy5jb2xvcnMsXHJcbiAgICAgICAgICAgIGRvbWFpbjogdGhpcy5kb21haW4sXHJcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLmxlZ2VuZFRpdGxlLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5sZWdlbmRQb3NpdGlvblxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5ldyBDb2xvckhlbHBlcih0aGlzLnNjaGVtZSwgJ29yZGluYWwnLCB0aGlzLmRvbWFpbiwgdGhpcy5jdXN0b21Db2xvcnMpO1xyXG4gICAgfTtcclxuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5vbkFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMgPSBbaXRlbV0uY29uY2F0KHRoaXMuYWN0aXZlRW50cmllcyk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZS5lbWl0KHsgdmFsdWU6IGl0ZW0sIGVudHJpZXM6IHRoaXMuYWN0aXZlRW50cmllcyB9KTtcclxuICAgIH07XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5uYW1lID09PSBpdGVtLm5hbWUgJiYgZC52YWx1ZSA9PT0gaXRlbS52YWx1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUVudHJpZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFbnRyaWVzID0gdGhpcy5hY3RpdmVFbnRyaWVzLnNsaWNlKCk7XHJcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlLmVtaXQoeyB2YWx1ZTogaXRlbSwgZW50cmllczogdGhpcy5hY3RpdmVFbnRyaWVzIH0pO1xyXG4gICAgfTtcclxuICAgIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVFbnRyaWVzKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZUVudHJpZXMuZmluZChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkubmFtZSA9PT0gZC5uYW1lICYmIGVudHJ5LnNlcmllcyA9PT0gZC5zZXJpZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUudHJhY2tCeSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLnZhbHVlQXJjLmRhdGEubmFtZTtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kVGl0bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWdlbmRQb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRWYWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInVuaXRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYmlnU2VnbWVudHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzbWFsbFNlZ21lbnRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXN1bHRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dBeGlzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImFuZ2xlU3BhblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlRW50cmllc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcImF4aXNUaWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93VGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyKSA9PT0gXCJmdW5jdGlvblwiID8gX2EgOiBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB0eXBlb2YgKF9iID0gdHlwZW9mIEV2ZW50RW1pdHRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudEVtaXR0ZXIpID09PSBcImZ1bmN0aW9uXCIgPyBfYiA6IE9iamVjdClcclxuICAgIF0sIEdhdWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGQoJ3Rvb2x0aXBUZW1wbGF0ZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYyA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9jIDogT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVmlld0NoaWxkKCd0ZXh0RWwnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGVvZiAoX2QgPSB0eXBlb2YgRWxlbWVudFJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFbGVtZW50UmVmKSA9PT0gXCJmdW5jdGlvblwiID8gX2QgOiBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidGV4dEVsXCIsIHZvaWQgMCk7XHJcbiAgICBHYXVnZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbmd4LWNoYXJ0cy1nYXVnZScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8bmd4LWNoYXJ0cy1jaGFydFxcbiAgICAgIFt2aWV3XT1cXFwiW3dpZHRoLCBoZWlnaHRdXFxcIlxcbiAgICAgIFtzaG93TGVnZW5kXT1cXFwibGVnZW5kXFxcIlxcbiAgICAgIFtsZWdlbmRPcHRpb25zXT1cXFwibGVnZW5kT3B0aW9uc1xcXCJcXG4gICAgICBbYWN0aXZlRW50cmllc109XFxcImFjdGl2ZUVudHJpZXNcXFwiXFxuICAgICAgW2FuaW1hdGlvbnNdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbENsaWNrKT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbEFjdGl2YXRlKT1cXFwib25BY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgIChsZWdlbmRMYWJlbERlYWN0aXZhdGUpPVxcXCJvbkRlYWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgPlxcbiAgICAgIDxzdmc6ZyBbYXR0ci50cmFuc2Zvcm1dPVxcXCJ0cmFuc2Zvcm1cXFwiIGNsYXNzPVxcXCJnYXVnZSBjaGFydFxcXCI+XFxuICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgYXJjIG9mIGFyY3M7IHRyYWNrQnk6IHRyYWNrQnlcXFwiIFthdHRyLnRyYW5zZm9ybV09XFxcInJvdGF0aW9uXFxcIj5cXG4gICAgICAgICAgPHN2ZzpnXFxuICAgICAgICAgICAgbmd4LWNoYXJ0cy1nYXVnZS1hcmNcXG4gICAgICAgICAgICBbYmFja2dyb3VuZEFyY109XFxcImFyYy5iYWNrZ3JvdW5kQXJjXFxcIlxcbiAgICAgICAgICAgIFt2YWx1ZUFyY109XFxcImFyYy52YWx1ZUFyY1xcXCJcXG4gICAgICAgICAgICBbY29ybmVyUmFkaXVzXT1cXFwiY29ybmVyUmFkaXVzXFxcIlxcbiAgICAgICAgICAgIFtjb2xvcnNdPVxcXCJjb2xvcnNcXFwiXFxuICAgICAgICAgICAgW2lzQWN0aXZlXT1cXFwiaXNBY3RpdmUoYXJjLnZhbHVlQXJjLmRhdGEpXFxcIlxcbiAgICAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVxcXCJ0b29sdGlwRGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgW3Rvb2x0aXBUZW1wbGF0ZV09XFxcInRvb2x0aXBUZW1wbGF0ZVxcXCJcXG4gICAgICAgICAgICBbdmFsdWVGb3JtYXR0aW5nXT1cXFwidmFsdWVGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgICAgIFthbmltYXRpb25zXT1cXFwiYW5pbWF0aW9uc1xcXCJcXG4gICAgICAgICAgICAoc2VsZWN0KT1cXFwib25DbGljaygkZXZlbnQpXFxcIlxcbiAgICAgICAgICAgIChhY3RpdmF0ZSk9XFxcIm9uQWN0aXZhdGUoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAoZGVhY3RpdmF0ZSk9XFxcIm9uRGVhY3RpdmF0ZSgkZXZlbnQpXFxcIlxcbiAgICAgICAgICA+PC9zdmc6Zz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuXFxuICAgICAgICA8c3ZnOmdcXG4gICAgICAgICAgbmd4LWNoYXJ0cy1nYXVnZS1heGlzXFxuICAgICAgICAgICpuZ0lmPVxcXCJzaG93QXhpc1xcXCJcXG4gICAgICAgICAgW2JpZ1NlZ21lbnRzXT1cXFwiYmlnU2VnbWVudHNcXFwiXFxuICAgICAgICAgIFtzbWFsbFNlZ21lbnRzXT1cXFwic21hbGxTZWdtZW50c1xcXCJcXG4gICAgICAgICAgW21pbl09XFxcIm1pblxcXCJcXG4gICAgICAgICAgW21heF09XFxcIm1heFxcXCJcXG4gICAgICAgICAgW3JhZGl1c109XFxcIm91dGVyUmFkaXVzXFxcIlxcbiAgICAgICAgICBbYW5nbGVTcGFuXT1cXFwiYW5nbGVTcGFuXFxcIlxcbiAgICAgICAgICBbdmFsdWVTY2FsZV09XFxcInZhbHVlU2NhbGVcXFwiXFxuICAgICAgICAgIFtzdGFydEFuZ2xlXT1cXFwic3RhcnRBbmdsZVxcXCJcXG4gICAgICAgICAgW3RpY2tGb3JtYXR0aW5nXT1cXFwiYXhpc1RpY2tGb3JtYXR0aW5nXFxcIlxcbiAgICAgICAgPjwvc3ZnOmc+XFxuXFxuICAgICAgICA8c3ZnOnRleHRcXG4gICAgICAgICAgI3RleHRFbFxcbiAgICAgICAgICAqbmdJZj1cXFwic2hvd1RleHRcXFwiXFxuICAgICAgICAgIFtzdHlsZS50ZXh0QW5jaG9yXT1cXFwiJ21pZGRsZSdcXFwiXFxuICAgICAgICAgIFthdHRyLnRyYW5zZm9ybV09XFxcInRleHRUcmFuc2Zvcm1cXFwiXFxuICAgICAgICAgIGFsaWdubWVudC1iYXNlbGluZT1cXFwiY2VudHJhbFxcXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPHRzcGFuIHg9XFxcIjBcXFwiIGR5PVxcXCIwXFxcIj57eyBkaXNwbGF5VmFsdWUgfX08L3RzcGFuPlxcbiAgICAgICAgICA8dHNwYW4geD1cXFwiMFxcXCIgZHk9XFxcIjEuMmVtXFxcIj57eyB1bml0cyB9fTwvdHNwYW4+XFxuICAgICAgICA8L3N2Zzp0ZXh0PlxcbiAgICAgIDwvc3ZnOmc+XFxuICAgIDwvbmd4LWNoYXJ0cy1jaGFydD5cXG4gIFwiLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFtcIi5uZ3gtY2hhcnRze2Zsb2F0OmxlZnQ7b3ZlcmZsb3c6dmlzaWJsZX0ubmd4LWNoYXJ0cyAuYXJjLC5uZ3gtY2hhcnRzIC5iYXIsLm5neC1jaGFydHMgLmNpcmNsZXtjdXJzb3I6cG9pbnRlcn0ubmd4LWNoYXJ0cyAuYXJjLmFjdGl2ZSwubmd4LWNoYXJ0cyAuYXJjOmhvdmVyLC5uZ3gtY2hhcnRzIC5iYXIuYWN0aXZlLC5uZ3gtY2hhcnRzIC5iYXI6aG92ZXIsLm5neC1jaGFydHMgLmNhcmQuYWN0aXZlLC5uZ3gtY2hhcnRzIC5jYXJkOmhvdmVyLC5uZ3gtY2hhcnRzIC5jZWxsLmFjdGl2ZSwubmd4LWNoYXJ0cyAuY2VsbDpob3ZlcntvcGFjaXR5Oi44O3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXR9Lm5neC1jaGFydHMgLmFyYzpmb2N1cywubmd4LWNoYXJ0cyAuYmFyOmZvY3VzLC5uZ3gtY2hhcnRzIC5jYXJkOmZvY3VzLC5uZ3gtY2hhcnRzIC5jZWxsOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJjLmhpZGRlbiwubmd4LWNoYXJ0cyAuYmFyLmhpZGRlbiwubmd4LWNoYXJ0cyAuY2FyZC5oaWRkZW4sLm5neC1jaGFydHMgLmNlbGwuaGlkZGVue2Rpc3BsYXk6bm9uZX0ubmd4LWNoYXJ0cyBnOmZvY3Vze291dGxpbmU6MH0ubmd4LWNoYXJ0cyAuYXJlYS1zZXJpZXMuaW5hY3RpdmUsLm5neC1jaGFydHMgLmxpbmUtc2VyaWVzLXJhbmdlLmluYWN0aXZlLC5uZ3gtY2hhcnRzIC5saW5lLXNlcmllcy5pbmFjdGl2ZSwubmd4LWNoYXJ0cyAucG9sYXItc2VyaWVzLWFyZWEuaW5hY3RpdmUsLm5neC1jaGFydHMgLnBvbGFyLXNlcmllcy1wYXRoLmluYWN0aXZle3RyYW5zaXRpb246b3BhY2l0eSAuMXMgZWFzZS1pbi1vdXQ7b3BhY2l0eTouMn0ubmd4LWNoYXJ0cyAubGluZS1oaWdobGlnaHR7ZGlzcGxheTpub25lfS5uZ3gtY2hhcnRzIC5saW5lLWhpZ2hsaWdodC5hY3RpdmV7ZGlzcGxheTpibG9ja30ubmd4LWNoYXJ0cyAuYXJlYXtvcGFjaXR5Oi42fS5uZ3gtY2hhcnRzIC5jaXJjbGU6aG92ZXJ7Y3Vyc29yOnBvaW50ZXJ9Lm5neC1jaGFydHMgLmxhYmVse2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjQwMH0ubmd4LWNoYXJ0cyAudG9vbHRpcC1hbmNob3J7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoe3N0cm9rZTojZGRkO3N0cm9rZS13aWR0aDoxO2ZpbGw6bm9uZX0ubmd4LWNoYXJ0cyAucmVmbGluZS1wYXRoe3N0cm9rZTojYThiMmM3O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6NTtzdHJva2UtZGFzaG9mZnNldDo1fS5uZ3gtY2hhcnRzIC5yZWZsaW5lLWxhYmVse2ZvbnQtc2l6ZTo5cHh9Lm5neC1jaGFydHMgLnJlZmVyZW5jZS1hcmVhe2ZpbGwtb3BhY2l0eTouMDU7ZmlsbDojMDAwfS5uZ3gtY2hhcnRzIC5ncmlkbGluZS1wYXRoLWRvdHRlZHtzdHJva2U6I2RkZDtzdHJva2Utd2lkdGg6MTtmaWxsOm5vbmU7c3Ryb2tlLWRhc2hhcnJheToxLDIwO3N0cm9rZS1kYXNob2Zmc2V0OjN9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwgcmVjdHtmaWxsOm5vbmV9Lm5neC1jaGFydHMgLmdyaWQtcGFuZWwub2RkIHJlY3R7ZmlsbDpyZ2JhKDAsMCwwLC4wNSl9XCIsIFwiLmdhdWdlIC5iYWNrZ3JvdW5kLWFyYyBwYXRoe2ZpbGw6cmdiYSgwLDAsMCwuMDUpfS5nYXVnZSAuZ2F1Z2UtdGljayBwYXRoe3N0cm9rZTojNjY2fS5nYXVnZSAuZ2F1Z2UtdGljayB0ZXh0e2ZvbnQtc2l6ZToxMnB4O2ZpbGw6IzY2Njtmb250LXdlaWdodDo3MDB9LmdhdWdlIC5nYXVnZS10aWNrLWxhcmdlIHBhdGh7c3Ryb2tlLXdpZHRoOjJweH0uZ2F1Z2UgLmdhdWdlLXRpY2stc21hbGwgcGF0aHtzdHJva2Utd2lkdGg6MXB4fVwiXSxcclxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgR2F1Z2VDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIEdhdWdlQ29tcG9uZW50O1xyXG59KEJhc2VDaGFydENvbXBvbmVudCkpO1xyXG5cclxudmFyIEdhdWdlQXJjQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR2F1Z2VBcmNDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcERpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZS50b29sdGlwVGV4dCA9IGZ1bmN0aW9uIChhcmMkJDEpIHtcclxuICAgICAgICB2YXIgbGFiZWwgPSBmb3JtYXRMYWJlbChhcmMkJDEuZGF0YS5uYW1lKTtcclxuICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlRm9ybWF0dGluZykge1xyXG4gICAgICAgICAgICB2YWwgPSB0aGlzLnZhbHVlRm9ybWF0dGluZyhhcmMkJDEuZGF0YS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YWwgPSBmb3JtYXRMYWJlbChhcmMkJDEuZGF0YS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0b29sdGlwLWxhYmVsXFxcIj5cIiArIGxhYmVsICsgXCI8L3NwYW4+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInRvb2x0aXAtdmFsXFxcIj5cIiArIHZhbCArIFwiPC9zcGFuPlxcbiAgICBcIjtcclxuICAgIH07XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImJhY2tncm91bmRBcmNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZUFyY1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYSA9IHR5cGVvZiBDb2xvckhlbHBlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBDb2xvckhlbHBlcikgPT09IFwiZnVuY3Rpb25cIiA/IF9hIDogT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VBcmNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0FjdGl2ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b29sdGlwRGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgR2F1Z2VBcmNDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZW9mIChfYiA9IHR5cGVvZiBUZW1wbGF0ZVJlZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBUZW1wbGF0ZVJlZikgPT09IFwiZnVuY3Rpb25cIiA/IF9iIDogT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VBcmNDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmltYXRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VBcmNDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY3RpdmF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWFjdGl2YXRlXCIsIHZvaWQgMCk7XHJcbiAgICBHYXVnZUFyY0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnZ1tuZ3gtY2hhcnRzLWdhdWdlLWFyY10nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIG5neC1jaGFydHMtcGllLWFyY1xcbiAgICAgIGNsYXNzPVxcXCJiYWNrZ3JvdW5kLWFyY1xcXCJcXG4gICAgICBbc3RhcnRBbmdsZV09XFxcIjBcXFwiXFxuICAgICAgW2VuZEFuZ2xlXT1cXFwiYmFja2dyb3VuZEFyYy5lbmRBbmdsZVxcXCJcXG4gICAgICBbaW5uZXJSYWRpdXNdPVxcXCJiYWNrZ3JvdW5kQXJjLmlubmVyUmFkaXVzXFxcIlxcbiAgICAgIFtvdXRlclJhZGl1c109XFxcImJhY2tncm91bmRBcmMub3V0ZXJSYWRpdXNcXFwiXFxuICAgICAgW2Nvcm5lclJhZGl1c109XFxcImNvcm5lclJhZGl1c1xcXCJcXG4gICAgICBbZGF0YV09XFxcImJhY2tncm91bmRBcmMuZGF0YVxcXCJcXG4gICAgICBbYW5pbWF0ZV09XFxcImZhbHNlXFxcIlxcbiAgICAgIFtwb2ludGVyRXZlbnRzXT1cXFwiZmFsc2VcXFwiPlxcbiAgICA8L3N2ZzpnPlxcbiAgICA8c3ZnOmcgbmd4LWNoYXJ0cy1waWUtYXJjXFxuICAgICAgW3N0YXJ0QW5nbGVdPVxcXCIwXFxcIlxcbiAgICAgIFtlbmRBbmdsZV09XFxcInZhbHVlQXJjLmVuZEFuZ2xlXFxcIlxcbiAgICAgIFtpbm5lclJhZGl1c109XFxcInZhbHVlQXJjLmlubmVyUmFkaXVzXFxcIlxcbiAgICAgIFtvdXRlclJhZGl1c109XFxcInZhbHVlQXJjLm91dGVyUmFkaXVzXFxcIlxcbiAgICAgIFtjb3JuZXJSYWRpdXNdPVxcXCJjb3JuZXJSYWRpdXNcXFwiXFxuICAgICAgW2ZpbGxdPVxcXCJjb2xvcnMuZ2V0Q29sb3IodmFsdWVBcmMuZGF0YS5uYW1lKVxcXCJcXG4gICAgICBbZGF0YV09XFxcInZhbHVlQXJjLmRhdGFcXFwiXFxuICAgICAgW2FuaW1hdGVdPVxcXCJhbmltYXRpb25zXFxcIlxcbiAgICAgIFtpc0FjdGl2ZV09XFxcImlzQWN0aXZlXFxcIlxcbiAgICAgIChzZWxlY3QpPVxcXCJzZWxlY3QuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgIChhY3RpdmF0ZSk9XFxcImFjdGl2YXRlLmVtaXQoJGV2ZW50KVxcXCJcXG4gICAgICAoZGVhY3RpdmF0ZSk9XFxcImRlYWN0aXZhdGUuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgIG5neC10b29sdGlwXFxuICAgICAgW3Rvb2x0aXBEaXNhYmxlZF09XFxcInRvb2x0aXBEaXNhYmxlZFxcXCJcXG4gICAgICBbdG9vbHRpcFBsYWNlbWVudF09XFxcIid0b3AnXFxcIlxcbiAgICAgIFt0b29sdGlwVHlwZV09XFxcIid0b29sdGlwJ1xcXCJcXG4gICAgICBbdG9vbHRpcFRpdGxlXT1cXFwidG9vbHRpcFRlbXBsYXRlID8gdW5kZWZpbmVkIDogdG9vbHRpcFRleHQodmFsdWVBcmMpXFxcIlxcbiAgICAgIFt0b29sdGlwVGVtcGxhdGVdPVxcXCJ0b29sdGlwVGVtcGxhdGVcXFwiXFxuICAgICAgW3Rvb2x0aXBDb250ZXh0XT1cXFwidmFsdWVBcmMuZGF0YVxcXCI+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEdhdWdlQXJjQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBHYXVnZUFyY0NvbXBvbmVudDtcclxufSgpKTtcclxuXHJcbnZhciBHYXVnZUF4aXNDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHYXVnZUF4aXNDb21wb25lbnQoKSB7XHJcbiAgICAgICAgdGhpcy5yb3RhdGUgPSAnJztcclxuICAgIH1cclxuICAgIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbkFuZ2xlID0gLTkwICsgdGhpcy5zdGFydEFuZ2xlO1xyXG4gICAgICAgIHRoaXMucm90YXRlID0gXCJyb3RhdGUoXCIgKyB0aGlzLnJvdGF0aW9uQW5nbGUgKyBcIilcIjtcclxuICAgICAgICB0aGlzLnRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xyXG4gICAgfTtcclxuICAgIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUuZ2V0VGlja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJpZ1RpY2tTZWdtZW50ID0gdGhpcy5hbmdsZVNwYW4gLyB0aGlzLmJpZ1NlZ21lbnRzO1xyXG4gICAgICAgIHZhciBzbWFsbFRpY2tTZWdtZW50ID0gYmlnVGlja1NlZ21lbnQgLyAodGhpcy5zbWFsbFNlZ21lbnRzKTtcclxuICAgICAgICB2YXIgdGlja0xlbmd0aCA9IDIwO1xyXG4gICAgICAgIHZhciB0aWNrcyA9IHtcclxuICAgICAgICAgICAgYmlnOiBbXSxcclxuICAgICAgICAgICAgc21hbGw6IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc3RhcnREaXN0YW5jZSA9IHRoaXMucmFkaXVzICsgMTA7XHJcbiAgICAgICAgdmFyIHRleHREaXN0ID0gc3RhcnREaXN0YW5jZSArIHRpY2tMZW5ndGggKyAxMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB0aGlzLmJpZ1NlZ21lbnRzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlRGVnID0gaSAqIGJpZ1RpY2tTZWdtZW50O1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBhbmdsZURlZyAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0QW5jaG9yID0gdGhpcy5nZXRUZXh0QW5jaG9yKGFuZ2xlRGVnKTtcclxuICAgICAgICAgICAgdmFyIHNraXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgdGhpcy5hbmdsZVNwYW4gPT09IDM2MCkge1xyXG4gICAgICAgICAgICAgICAgc2tpcCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFza2lwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IE51bWJlci5wYXJzZUZsb2F0KHRoaXMudmFsdWVTY2FsZS5pbnZlcnQoYW5nbGVEZWcpLnRvU3RyaW5nKCkpLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50aWNrRm9ybWF0dGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLnRpY2tGb3JtYXR0aW5nKHRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGlja3MuYmlnLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMuZ2V0VGlja1BhdGgoc3RhcnREaXN0YW5jZSwgdGlja0xlbmd0aCwgYW5nbGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I6IHRleHRBbmNob3IsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0VHJhbnNmb3JtOiBcIlxcbiAgICAgICAgICAgIHRyYW5zbGF0ZShcIiArIHRleHREaXN0ICogTWF0aC5jb3MoYW5nbGUpICsgXCIsIFwiICsgdGV4dERpc3QgKiBNYXRoLnNpbihhbmdsZSkgKyBcIikgcm90YXRlKFwiICsgLXRoaXMucm90YXRpb25BbmdsZSArIFwiKVxcbiAgICAgICAgICBcIlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMuYmlnU2VnbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IHRoaXMuc21hbGxTZWdtZW50czsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc21hbGxBbmdsZURlZyA9IGFuZ2xlRGVnICsgaiAqIHNtYWxsVGlja1NlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgc21hbGxBbmdsZSA9IHNtYWxsQW5nbGVEZWcgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICAgICAgICAgICAgdGlja3Muc21hbGwucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5nZXRUaWNrUGF0aChzdGFydERpc3RhbmNlLCB0aWNrTGVuZ3RoIC8gMiwgc21hbGxBbmdsZSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aWNrcztcclxuICAgIH07XHJcbiAgICBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLmdldFRleHRBbmNob3IgPSBmdW5jdGlvbiAoYW5nbGUpIHtcclxuICAgICAgICAvLyBbMCwgNDVdID0gJ21pZGRsZSc7XHJcbiAgICAgICAgLy8gWzQ2LCAxMzVdID0gJ3N0YXJ0JztcclxuICAgICAgICAvLyBbMTM2LCAyMjVdID0gJ21pZGRsZSc7XHJcbiAgICAgICAgLy8gWzIyNiwgMzE1XSA9ICdlbmQnO1xyXG4gICAgICAgIGFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIGFuZ2xlKSAlIDM2MDtcclxuICAgICAgICB2YXIgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xyXG4gICAgICAgIGlmIChhbmdsZSA+IDQ1ICYmIGFuZ2xlIDw9IDEzNSkge1xyXG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYW5nbGUgPiAyMjUgJiYgYW5nbGUgPD0gMzE1KSB7XHJcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnZW5kJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRleHRBbmNob3I7XHJcbiAgICB9O1xyXG4gICAgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZS5nZXRUaWNrUGF0aCA9IGZ1bmN0aW9uIChzdGFydERpc3RhbmNlLCB0aWNrTGVuZ3RoLCBhbmdsZSkge1xyXG4gICAgICAgIHZhciB5MSA9IHN0YXJ0RGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgdmFyIHkyID0gKHN0YXJ0RGlzdGFuY2UgKyB0aWNrTGVuZ3RoKSAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICB2YXIgeDEgPSBzdGFydERpc3RhbmNlICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIHZhciB4MiA9IChzdGFydERpc3RhbmNlICsgdGlja0xlbmd0aCkgKiBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFt7IHg6IHgxLCB5OiB5MSB9LCB7IHg6IHgyLCB5OiB5MiB9XTtcclxuICAgICAgICB2YXIgbGluZUdlbmVyYXRvciA9IGxpbmUoKS54KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLng7IH0pLnkoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQueTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmVHZW5lcmF0b3IocG9pbnRzKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcImJpZ1NlZ21lbnRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcInNtYWxsU2VnbWVudHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBHYXVnZUF4aXNDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhbmdsZVNwYW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYWRpdXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIEdhdWdlQXhpc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aWNrRm9ybWF0dGluZ1wiLCB2b2lkIDApO1xyXG4gICAgR2F1Z2VBeGlzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtZ2F1Z2UtYXhpc10nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPHN2ZzpnIFthdHRyLnRyYW5zZm9ybV09XFxcInJvdGF0ZVxcXCI+XFxuICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aWNrcy5iaWdcXFwiXFxuICAgICAgICAgICAgY2xhc3M9XFxcImdhdWdlLXRpY2sgZ2F1Z2UtdGljay1sYXJnZVxcXCI+XFxuICAgICAgICAgICAgPHN2ZzpwYXRoIFthdHRyLmRdPVxcXCJ0aWNrLmxpbmVcXFwiIC8+XFxuICAgICAgICA8L3N2ZzpnPlxcbiAgICAgICAgPHN2ZzpnICpuZ0Zvcj1cXFwibGV0IHRpY2sgb2YgdGlja3MuYmlnXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJnYXVnZS10aWNrIGdhdWdlLXRpY2stbGFyZ2VcXFwiPlxcbiAgICAgICAgICAgIDxzdmc6dGV4dFxcbiAgICAgICAgICAgICAgICBbc3R5bGUudGV4dEFuY2hvcl09XFxcInRpY2sudGV4dEFuY2hvclxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIudHJhbnNmb3JtXT1cXFwidGljay50ZXh0VHJhbnNmb3JtXFxcIlxcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQtYmFzZWxpbmU9XFxcImNlbnRyYWxcXFwiPlxcbiAgICAgICAgICAgICAgICB7e3RpY2sudGV4dH19XFxuICAgICAgICAgICAgPC9zdmc6dGV4dD5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgICAgICA8c3ZnOmcgKm5nRm9yPVxcXCJsZXQgdGljayBvZiB0aWNrcy5zbWFsbFxcXCJcXG4gICAgICAgICAgICBjbGFzcz1cXFwiZ2F1Z2UtdGljayBnYXVnZS10aWNrLXNtYWxsXFxcIj5cXG4gICAgICAgICAgICA8c3ZnOnBhdGggW2F0dHIuZF09XFxcInRpY2subGluZVxcXCIgLz5cXG4gICAgICAgIDwvc3ZnOmc+XFxuICAgIDwvc3ZnOmc+XFxuICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KVxyXG4gICAgXSwgR2F1Z2VBeGlzQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBHYXVnZUF4aXNDb21wb25lbnQ7XHJcbn0oKSk7XHJcblxyXG52YXIgR2F1Z2VNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHYXVnZU1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIEdhdWdlTW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ2hhcnRDb21tb25Nb2R1bGUsIFBpZUNoYXJ0TW9kdWxlLCBCYXJDaGFydE1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgTGluZWFyR2F1Z2VDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBHYXVnZUNvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEdhdWdlQXJjQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgR2F1Z2VBeGlzQ29tcG9uZW50XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIExpbmVhckdhdWdlQ29tcG9uZW50LFxyXG4gICAgICAgICAgICAgICAgR2F1Z2VDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBHYXVnZUFyY0NvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIEdhdWdlQXhpc0NvbXBvbmVudFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEdhdWdlTW9kdWxlKTtcclxuICAgIHJldHVybiBHYXVnZU1vZHVsZTtcclxufSgpKTtcclxuXHJcbnZhciBOZ3hDaGFydHNNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZ3hDaGFydHNNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBOZ3hDaGFydHNNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtcclxuICAgICAgICAgICAgICAgIENoYXJ0Q29tbW9uTW9kdWxlLFxyXG4gICAgICAgICAgICAgICAgQXJlYUNoYXJ0TW9kdWxlLFxyXG4gICAgICAgICAgICAgICAgQmFyQ2hhcnRNb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBCdWJibGVDaGFydE1vZHVsZSxcclxuICAgICAgICAgICAgICAgIEZvcmNlRGlyZWN0ZWRHcmFwaE1vZHVsZSxcclxuICAgICAgICAgICAgICAgIEhlYXRNYXBNb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBMaW5lQ2hhcnRNb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBQb2xhckNoYXJ0TW9kdWxlLFxyXG4gICAgICAgICAgICAgICAgTnVtYmVyQ2FyZE1vZHVsZSxcclxuICAgICAgICAgICAgICAgIFBpZUNoYXJ0TW9kdWxlLFxyXG4gICAgICAgICAgICAgICAgVHJlZU1hcE1vZHVsZSxcclxuICAgICAgICAgICAgICAgIEdhdWdlTW9kdWxlXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgTmd4Q2hhcnRzTW9kdWxlKTtcclxuICAgIHJldHVybiBOZ3hDaGFydHNNb2R1bGU7XHJcbn0oKSk7XHJcblxyXG5mdW5jdGlvbiB0aWNrRm9ybWF0KGZpZWxkVHlwZSwgZ3JvdXBCeVR5cGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICBpZiAobGFiZWwgPT09ICdObyBWYWx1ZScgfHwgbGFiZWwgPT09ICdPdGhlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmllbGRUeXBlID09PSAnZGF0ZScgJiYgZ3JvdXBCeVR5cGUgPT09ICdncm91cEJ5Jykge1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gdGltZUZvcm1hdCgnTU0vREQvWVlZWScpO1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyKGxhYmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsLnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgeyBOZ3hDaGFydHNNb2R1bGUsIENoYXJ0Q29tbW9uTW9kdWxlLCBMZWdlbmRDb21wb25lbnQsIFNjYWxlTGVnZW5kQ29tcG9uZW50LCBMZWdlbmRFbnRyeUNvbXBvbmVudCwgQWR2YW5jZWRMZWdlbmRDb21wb25lbnQsIFRvb2x0aXBNb2R1bGUsIFRvb2x0aXBTZXJ2aWNlLCBUb29sdGlwQ29udGVudENvbXBvbmVudCwgVG9vbHRpcERpcmVjdGl2ZSwgU3R5bGVUeXBlcywgQWxpZ25tZW50VHlwZXMsIFNob3dUeXBlcywgQXhlc01vZHVsZSwgQXhpc0xhYmVsQ29tcG9uZW50LCBYQXhpc0NvbXBvbmVudCwgWEF4aXNUaWNrc0NvbXBvbmVudCwgWUF4aXNDb21wb25lbnQsIFlBeGlzVGlja3NDb21wb25lbnQsIHJlZHVjZVRpY2tzLCBDb3VudFVwRGlyZWN0aXZlLCBjb3VudCwgZGVjaW1hbENoZWNrZXIsIFRpbWVsaW5lLCBDb2xvckhlbHBlciwgQ2hhcnRDb21wb25lbnQsIEFyZWFDb21wb25lbnQsIEJhc2VDaGFydENvbXBvbmVudCwgQ2lyY2xlQ29tcG9uZW50LCBDaXJjbGVTZXJpZXNDb21wb25lbnQsIGdyaWRTaXplLCBncmlkTGF5b3V0LCBHcmlkUGFuZWxDb21wb25lbnQsIEdyaWRQYW5lbFNlcmllc0NvbXBvbmVudCwgU3ZnTGluZWFyR3JhZGllbnRDb21wb25lbnQsIFN2Z1JhZGlhbEdyYWRpZW50Q29tcG9uZW50LCBUb29sdGlwQXJlYSwgdGlja0Zvcm1hdCwgdHJpbUxhYmVsLCBjYWxjdWxhdGVWaWV3RGltZW5zaW9ucywgZm9ybWF0TGFiZWwsIGdldFVuaXF1ZVhEb21haW5WYWx1ZXMsIGdldFNjYWxlVHlwZSwgQXJlYUNoYXJ0TW9kdWxlLCBBcmVhQ2hhcnRDb21wb25lbnQsIEFyZWFDaGFydE5vcm1hbGl6ZWRDb21wb25lbnQsIEFyZWFDaGFydFN0YWNrZWRDb21wb25lbnQsIEFyZWFTZXJpZXNDb21wb25lbnQsIEJhckNoYXJ0TW9kdWxlLCBCYXJDb21wb25lbnQsIEJhckhvcml6b250YWxDb21wb25lbnQsIEJhckhvcml6b250YWwyRENvbXBvbmVudCwgQmFySG9yaXpvbnRhbE5vcm1hbGl6ZWRDb21wb25lbnQsIEJhckhvcml6b250YWxTdGFja2VkQ29tcG9uZW50LCBTZXJpZXNIb3Jpem9udGFsLCBCYXJMYWJlbENvbXBvbmVudCwgQmFyVmVydGljYWxDb21wb25lbnQsIEJhclZlcnRpY2FsMkRDb21wb25lbnQsIEJhclZlcnRpY2FsTm9ybWFsaXplZENvbXBvbmVudCwgQmFyVmVydGljYWxTdGFja2VkQ29tcG9uZW50LCBEMFR5cGVzLCBTZXJpZXNWZXJ0aWNhbENvbXBvbmVudCwgQnViYmxlQ2hhcnRNb2R1bGUsIEJ1YmJsZUNoYXJ0Q29tcG9uZW50LCBnZXREb21haW4sIGdldFNjYWxlLCBCdWJibGVTZXJpZXNDb21wb25lbnQsIEZvcmNlRGlyZWN0ZWRHcmFwaE1vZHVsZSwgRm9yY2VEaXJlY3RlZEdyYXBoQ29tcG9uZW50LCBIZWF0TWFwTW9kdWxlLCBIZWF0TWFwQ29tcG9uZW50LCBIZWF0TWFwQ2VsbENvbXBvbmVudCwgSGVhdENlbGxTZXJpZXNDb21wb25lbnQsIExpbmVDaGFydE1vZHVsZSwgTGluZUNoYXJ0Q29tcG9uZW50LCBMaW5lQ29tcG9uZW50LCBMaW5lU2VyaWVzQ29tcG9uZW50LCBQb2xhckNoYXJ0TW9kdWxlLCBQb2xhckNoYXJ0Q29tcG9uZW50LCBQb2xhclNlcmllc0NvbXBvbmVudCwgTnVtYmVyQ2FyZE1vZHVsZSwgTnVtYmVyQ2FyZENvbXBvbmVudCwgQ2FyZENvbXBvbmVudCwgQ2FyZFNlcmllc0NvbXBvbmVudCwgUGllQ2hhcnRNb2R1bGUsIEFkdmFuY2VkUGllQ2hhcnRDb21wb25lbnQsIFBpZUNoYXJ0Q29tcG9uZW50LCBQaWVBcmNDb21wb25lbnQsIFBpZUdyaWRDb21wb25lbnQsIFBpZUdyaWRTZXJpZXNDb21wb25lbnQsIFBpZVNlcmllc0NvbXBvbmVudCwgUGllTGFiZWxDb21wb25lbnQsIFRyZWVNYXBNb2R1bGUsIFRyZWVNYXBDb21wb25lbnQsIFRyZWVNYXBDZWxsQ29tcG9uZW50LCBUcmVlTWFwQ2VsbFNlcmllc0NvbXBvbmVudCwgR2F1Z2VNb2R1bGUsIEdhdWdlQXJjQ29tcG9uZW50LCBHYXVnZUF4aXNDb21wb25lbnQsIEdhdWdlQ29tcG9uZW50LCBMaW5lYXJHYXVnZUNvbXBvbmVudCB9O1xyXG4iXX0=